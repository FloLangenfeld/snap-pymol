diff -upNr pymol-open-source-2.3.0/contrib/champ/champ.c pymol-open-source-2.3.3/contrib/champ/champ.c
--- pymol-open-source-2.3.0/contrib/champ/champ.c	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/contrib/champ/champ.c	2019-08-22 10:24:47.658585920 +0200
@@ -34,10 +34,10 @@ Z* -------------------------------------
 #define _RINGDEBUG
 #define _AROMDEBUG
 
-char *ChampParseAliphaticAtom(CChamp *I,char *c,int atom,int mask,int len,int imp_hyd);
-char *ChampParseAromaticAtom(CChamp *I,char *c,int atom,int mask,int len,int imp_hyd);
-char *ChampParseStringAtom(CChamp *I,char *c,int atom,int len);
-int ChampParseAtomBlock(CChamp *I,char **c_ptr,int cur_atom);
+char *ChampParseAliphaticAtom(CChamp *I,const char *c,int atom,int mask,int len,int imp_hyd);
+char *ChampParseAromaticAtom(CChamp *I,const char *c,int atom,int mask,int len,int imp_hyd);
+char *ChampParseStringAtom(CChamp *I,const char *c,int atom,int len);
+int ChampParseAtomBlock(CChamp *I,const char **c_ptr,int cur_atom);
 
 void ChampAtomDump(CChamp *I,int index);
 void ChampAtomFlagDump(CChamp *I,int index);
@@ -61,10 +61,10 @@ void ChampMatchFreeChain(CChamp *I,int m
 void ChampCountRings(CChamp *I,int index);
 void ChampPrepareTarget(CChamp *I,int index);
 void ChampPreparePattern(CChamp *I,int index);
-char *ChampParseBlockAtom(CChamp *I,char *c,int atom,int mask,int len,int not_flag);
+char *ChampParseBlockAtom(CChamp *I,const char *c,int atom,int mask,int len,int not_flag);
 void ChampCountBondsEtc(CChamp *I,int index);
 void ChampCheckCharge(CChamp *I,int index);
-char *ChampParseTag(CChamp *I,char *c,unsigned int *map,unsigned int *not_map,int *ok);
+char *ChampParseTag(CChamp *I,const char *c,unsigned int *map,unsigned int *not_map,int *ok);
 
 
 static int num_to_ring[12] = { 
@@ -108,7 +108,7 @@ static int num_to_degree[9] = {
 
 #ifdef _HAPPY_UT
 
-static void diff(char *p,char *q)
+static void diff(const char *p,const char *q)
 {
   int same=true;
   char *s1,*s2;
@@ -370,7 +370,7 @@ int main(int argc, char *argv[])
 
 #endif
 
-char *ChampParseTag(CChamp *I,char *c,unsigned int *map,unsigned int *not_map,int *ok)
+char *ChampParseTag(CChamp *I,const char *c,unsigned int *map,unsigned int *not_map,int *ok)
 {
   /* parse bit masks like <1> <1,2,3> <12,3,1> etc... */
 
@@ -414,7 +414,7 @@ char *ChampParseTag(CChamp *I,char *c,un
     } else 
       c++;
   }
-  return(c);
+  return (char*)c;
 }
 
 static void merge_lineages(CChamp *I,int *src,int *src_mask,int *dst,int *dst_mask)
@@ -1180,11 +1180,11 @@ void ChampPreparePattern(CChamp *I,int i
     pat->unique_atom = ChampUniqueListNew(I,pat->atom,0);
 }
 
-static int PTruthCallStr(PyObject *object,char *method,char *argument)
+static int PTruthCallStr(PyObject *object,const char *method,const char *argument)
 {
   int result = false;
   PyObject *tmp;
-  tmp = PyObject_CallMethod(object,method,"s",argument);
+  tmp = PyObject_CallMethod(object,(char*)method,"s",argument);
   if(tmp) {
     if(PyObject_IsTrue(tmp))
       result = 1;
@@ -1241,7 +1241,7 @@ static void UtilCleanStr(char *s) /*remo
 
 static int PConvPyObjectToStrMaxClean(PyObject *object,char *value,int ln)
 {
-  char *st;
+  const char *st;
   PyObject *tmp;
   int result=true;
   if(!object)
@@ -2772,7 +2772,7 @@ int ChampMatch2(CChamp *I,int template,i
  * Smiles
  * =============================================================== */
 
-char *ChampParseBlockAtom(CChamp *I,char *c,int atom,int mask,int len,int not_flag)
+char *ChampParseBlockAtom(CChamp *I,const char *c,int atom,int mask,int len,int not_flag)
 {
   ListAtom *at;
   at=I->Atom+atom;
@@ -2798,10 +2798,10 @@ char *ChampParseBlockAtom(CChamp *I,char
     }
   }
   /* need to include code for loading symbol */
-  return c+len;
+  return (char*)c+len;
 }
 
-char *ChampParseAliphaticAtom(CChamp *I,char *c,int atom,int mask,int len,int imp_hyd) 
+char *ChampParseAliphaticAtom(CChamp *I,const char *c,int atom,int mask,int len,int imp_hyd) 
 {
   ListAtom *at;
   at=I->Atom+atom;
@@ -2812,10 +2812,10 @@ char *ChampParseAliphaticAtom(CChamp *I,
     " ChampParseAliphaticAtom: called.\n"
     ENDFD;
   /* need to include code for loading symbol */
-  return c+len;
+  return (char*)c+len;
 }
 
-char *ChampParseAromaticAtom(CChamp *I,char *c,int atom,int mask,int len,int imp_hyd) 
+char *ChampParseAromaticAtom(CChamp *I,const char *c,int atom,int mask,int len,int imp_hyd) 
 {
   ListAtom *at;
   at=I->Atom+atom;
@@ -2826,10 +2826,10 @@ char *ChampParseAromaticAtom(CChamp *I,c
   PRINTFD(FB_smiles_parsing) 
     " ChampParseAromaticAtom: called.\n"
     ENDFD;
-  return c+len;
+  return (char*)c+len;
 }
 
-char *ChampParseStringAtom(CChamp *I,char *c,int atom,int len) 
+char *ChampParseStringAtom(CChamp *I,const char *c,int atom,int len) 
 {
   ListAtom *at;
   at=I->Atom+atom;
@@ -2840,12 +2840,12 @@ char *ChampParseStringAtom(CChamp *I,cha
   PRINTFD(FB_smiles_parsing) 
     " ChampParseStringAtom: called.\n"
     ENDFD;
-  return c+len;
+  return (char*)c+len;
 }
 
-int ChampParseNumeral(char *c);
+int ChampParseNumeral(const char *c);
 
-int ChampParseNumeral(char *c) {
+int ChampParseNumeral(const char *c) {
   switch(*c) {
   case '0':
   case '1':
@@ -2864,11 +2864,11 @@ int ChampParseNumeral(char *c) {
   }
 }
 
-int ChampParseAtomBlock(CChamp *I,char **c_ptr,int cur_atom) 
+int ChampParseAtomBlock(CChamp *I,const char **c_ptr,int cur_atom) 
 {
   int ok = true;
   ListAtom *at;
-  char *c;
+  const char *c;
   int not_flag = false;
   int num;
   int done=false;
@@ -4739,7 +4739,7 @@ int ChampAddBondToAtom(CChamp *I,int ato
   return(ok);
 }
 
-int ChampSmiToPat(CChamp *I,char *c) 
+int ChampSmiToPat(CChamp *I, const char *c) 
 { /* returns root atom of list */
   int mark[MAX_RING]; /* ring marks 0-9 */
   int mark_pri[MAX_RING]; /* lexical priority of mark */
@@ -4761,7 +4761,7 @@ int ChampSmiToPat(CChamp *I,char *c)
   int a;
   int not_bond = false;
   int lex_pri = 0;
-  char *orig_c=c;
+  const char *orig_c=c;
 
 #define save_bond() { if(last_bond) {I->Bond[last_bond].link=cur_bond;}\
           else {bond_list=cur_bond;}\
diff -upNr pymol-open-source-2.3.0/contrib/champ/champ.h pymol-open-source-2.3.3/contrib/champ/champ.h
--- pymol-open-source-2.3.0/contrib/champ/champ.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/contrib/champ/champ.h	2019-08-22 10:24:47.658585920 +0200
@@ -282,7 +282,7 @@ int ChampPatIdentical(ListAtom *p,ListAt
 int ChampAtomMatch(ListAtom *p,ListAtom *a);
 int ChampBondMatch(ListBond *p,ListBond *a);
 
-int ChampSmiToPat(CChamp *I,char *c);
+int ChampSmiToPat(CChamp *I, const char *c);
 void ChampMemoryDump(CChamp *I);
 int ChampMemoryUsage(CChamp *I);
 int ChampMatch_1V1_B(CChamp *I,int pattern,int target);
diff -upNr pymol-open-source-2.3.0/contrib/champ/strblock.c pymol-open-source-2.3.3/contrib/champ/strblock.c
--- pymol-open-source-2.3.0/contrib/champ/strblock.c	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/contrib/champ/strblock.c	2019-08-22 10:24:47.658585920 +0200
@@ -49,11 +49,12 @@ int main(int argc, char *argv[])
 
 /* right now just a braindead, memory-leaky system */
 
-int StrBlockNewStr(char **list_ptr,char *st,int len)
+int StrBlockNewStr(char **list_ptr,const char *st,int len)
 {
   StrBlock *I;
   register int a;
-  register char *p,*q;
+  register char *q;
+  const char *p;
   char *str;
   int result, new_extent;
   I=*((StrBlock**)list_ptr);
diff -upNr pymol-open-source-2.3.0/contrib/champ/strblock.h pymol-open-source-2.3.3/contrib/champ/strblock.h
--- pymol-open-source-2.3.0/contrib/champ/strblock.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/contrib/champ/strblock.h	2019-08-22 10:24:47.658585920 +0200
@@ -23,7 +23,7 @@ typedef struct {
 } StrBlock;
 
 char  *StrBlockNew(int init_size);
-int   StrBlockNewStr(char **block,char *st,int len);
+int   StrBlockNewStr(char **block,const char *st,int len);
 void  StrBlockFree(char *block);
 void  StrBlockFreeStr(char *block,int elem);
 
diff -upNr pymol-open-source-2.3.0/contrib/mmtf-c/mmtf_parser.cpp pymol-open-source-2.3.3/contrib/mmtf-c/mmtf_parser.cpp
--- pymol-open-source-2.3.0/contrib/mmtf-c/mmtf_parser.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/contrib/mmtf-c/mmtf_parser.cpp	2019-08-22 12:53:36.304823965 +0200
@@ -28,7 +28,21 @@
 #define __STDC_LIMIT_MACROS
 
 #include "mmtf_parser.h"
-#include "mmtf_parser_private.h"
+
+//*** Standard libs
+#include <stdbool.h>
+
+//*** MsgPack lib
+#ifdef MMTF_MSGPACK_USE_CPP11
+#include <msgpack.hpp>
+#define msgpack_object msgpack::object
+#define msgpack_object_kv msgpack::object_kv
+#define msgpack_object_str msgpack::object_str
+#define MMTF_MSGPACK_TYPE(T) msgpack::type::T
+#else
+#include <msgpack.h>
+#define MMTF_MSGPACK_TYPE(T) MSGPACK_OBJECT_##T
+#endif
 
 #if MSGPACK_VERSION_MAJOR < 1
 #error "msgpack-c >= 1.0 required (https://github.com/msgpack/msgpack-c)"
@@ -251,7 +265,7 @@ enum {
     }
 
 #define CODEGEN_MMTF_parser_fetch_List(type_, suffix) \
-    type_* MMTF_parser_fetch_##suffix##List( \
+    static type_* MMTF_parser_fetch_##suffix##List( \
             const msgpack_object* object, size_t* length) { \
         CODEGEN_BODY_fetch_OBJECT_ARRAY(type_, { \
             MMTF_parser_put_##suffix(iter, result + i); \
@@ -365,6 +379,7 @@ void array_copy_bigendian_2(void* dst, c
     }
 }
 
+static
 float* MMTF_parser_float_from_bytes(const char* input, uint32_t input_length, uint32_t* output_length) {
     IF_NOT_MULTIPLE_ERROR_RETURN(input_length, 4, NULL);
 
@@ -378,6 +393,7 @@ float* MMTF_parser_float_from_bytes(cons
     return output;
 }
 
+static
 int8_t* MMTF_parser_int8_from_bytes(const char* input, uint32_t input_length, uint32_t* output_length) {
     (*output_length) = input_length;
 
@@ -389,6 +405,7 @@ int8_t* MMTF_parser_int8_from_bytes(cons
     return output;
 }
 
+static
 int16_t* MMTF_parser_int16_from_bytes(const char* input, uint32_t input_length, uint32_t* output_length) {
     IF_NOT_MULTIPLE_ERROR_RETURN(input_length, 2, NULL);
 
@@ -402,6 +419,7 @@ int16_t* MMTF_parser_int16_from_bytes(co
     return output;
 }
 
+static
 int32_t* MMTF_parser_int32_from_bytes(const char* input, const uint32_t input_length, uint32_t* output_length) {
     IF_NOT_MULTIPLE_ERROR_RETURN(input_length, 4, NULL);
 
@@ -415,6 +433,7 @@ int32_t* MMTF_parser_int32_from_bytes(co
     return output;
 }
 
+static
 char** MMTF_parser_strings_from_bytes(const char* input, uint32_t input_length, uint32_t parameter, uint32_t* output_length) {
     IF_NOT_MULTIPLE_ERROR_RETURN(input_length, parameter, NULL);
 
@@ -436,6 +455,7 @@ char** MMTF_parser_strings_from_bytes(co
 
 //*** Array decoders
 // Run-length decode
+static
 int32_t* MMTF_parser_run_length_decode(const int32_t* input, uint32_t input_length, uint32_t* output_length) {
     (*output_length) = 0;
 
@@ -468,6 +488,7 @@ int32_t* MMTF_parser_run_length_decode(c
 }
 
 // Delta decode
+static
 int32_t* MMTF_parser_delta_decode(const int32_t* input, uint32_t input_length, uint32_t* output_length) {
     (*output_length) = input_length;
     int32_t* output = MALLOC_ARRAY(int32_t, (*output_length)); // The output needs to be freed by the calling process
@@ -486,6 +507,7 @@ int32_t* MMTF_parser_delta_decode(const
 }
 
 // Recursive indexing decode
+static
 int32_t* MMTF_parser_recursive_indexing_decode_from_16(const int16_t* input, uint32_t input_length, uint32_t* output_length) {
     (*output_length) = 0;
     uint32_t i;
@@ -517,6 +539,7 @@ int32_t* MMTF_parser_recursive_indexing_
     return output;
 }
 
+static
 int32_t* MMTF_parser_recursive_indexing_decode_from_8(const int8_t* input, uint32_t input_length, uint32_t* output_length) {
     (*output_length) = 0;
     uint32_t i;
@@ -545,6 +568,7 @@ int32_t* MMTF_parser_recursive_indexing_
 }
 
 // Integer decoding
+static
 float* MMTF_parser_integer_decode_from_16(const int16_t* input, uint32_t input_length, int32_t parameter, uint32_t* output_length) {
     (*output_length) = input_length;
     float* output = (float*)MALLOC_ARRAY(float, (*output_length));
@@ -559,6 +583,7 @@ float* MMTF_parser_integer_decode_from_1
     return output;
 }
 
+static
 float* MMTF_parser_integer_decode_from_32(const int32_t* input, uint32_t input_length, int32_t parameter, uint32_t* output_length) {
     (*output_length) = input_length;
     float* output = (float*)MALLOC_ARRAY(float, (*output_length));
@@ -744,6 +769,7 @@ void MMTF_parser_put_string(const msgpac
 }
 
 //*** Unpacking from MsgPack and applying strategy
+static
 char* MMTF_parser_fetch_string(const msgpack_object* object) {
     switch (object->type) {
 #ifdef MMTF_ACCEPT_MSGPACK_BIN_AS_STR
@@ -781,6 +807,7 @@ char MMTF_parser_fetch_char(const msgpac
     return *(object->via.str.ptr);
 }
 
+static
 int64_t MMTF_parser_fetch_int(const msgpack_object* object) {
     int64_t result;
 
@@ -796,6 +823,7 @@ int64_t MMTF_parser_fetch_int(const msgp
     return result;
 }
 
+static
 float MMTF_parser_fetch_float(const msgpack_object* object) {
     switch (object->type) {
     case /* FLOAT64 */ MMTF_MSGPACK_TYPE(FLOAT):
@@ -867,6 +895,7 @@ bool MMTF_parser_compare_msgpack_string_
 
 static
 void MMTF_parser_put_entity(const msgpack_object* object, MMTF_Entity* entity) {
+    MMTF_Entity_init(entity);
     MAP_ITERATE_BEGIN(object);
     FETCH_AND_ASSIGN(entity, string, description);
     FETCH_AND_ASSIGN(entity, string, type);
@@ -877,6 +906,7 @@ void MMTF_parser_put_entity(const msgpac
 
 static
 void MMTF_parser_put_group(const msgpack_object* object, MMTF_GroupType* group_type) {
+    MMTF_GroupType_init(group_type);
     MAP_ITERATE_BEGIN(object);
     FETCH_AND_ASSIGN_DUMMYCOUNT(group_type, int32_array, formalChargeList);
     FETCH_AND_ASSIGN_WITHCOUNT(group_type, string_array, atomNameList);
@@ -890,7 +920,11 @@ void MMTF_parser_put_group(const msgpack
 }
 
 static
+MMTF_Transform* MMTF_parser_fetch_transformList(const msgpack_object*, size_t*);
+
+static
 void MMTF_parser_put_bioAssembly(const msgpack_object* object, MMTF_BioAssembly* bio_assembly) {
+    MMTF_BioAssembly_init(bio_assembly);
     MAP_ITERATE_BEGIN(object);
     FETCH_AND_ASSIGN(bio_assembly, string, name);
     FETCH_AND_ASSIGN_WITHCOUNT(bio_assembly, transformList, transformList);
diff -upNr pymol-open-source-2.3.0/contrib/mmtf-c/mmtf_parser_private.h pymol-open-source-2.3.3/contrib/mmtf-c/mmtf_parser_private.h
--- pymol-open-source-2.3.0/contrib/mmtf-c/mmtf_parser_private.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/contrib/mmtf-c/mmtf_parser_private.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,84 +0,0 @@
-// *************************************************************************
-// Copyright [2016] [RCSB]
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-//
-// This is a private header file for mmtf_parser.c and must not be included
-// by other files.
-//
-// The authors of this code are: Julien Ferte (http://www.julienferte.com/),
-// Anthony Bradley, Thomas Holder.
-//
-//
-// Other contributors: Yana Valasatava, Alexander Rose.
-//
-// *************************************************************************
-
-#ifndef MMTF_PRIVATE_H
-#define MMTF_PRIVATE_H
-
-#include "mmtf_parser.h"
-
-//*** Standard libs
-#include <stdbool.h>
-
-//*** MsgPack lib
-#ifdef MMTF_MSGPACK_USE_CPP11
-#include <msgpack.hpp>
-#define msgpack_object msgpack::object
-#define msgpack_object_kv msgpack::object_kv
-#define msgpack_object_str msgpack::object_str
-#define MMTF_MSGPACK_TYPE(T) msgpack::type::T
-#else
-#include <msgpack.h>
-#define MMTF_MSGPACK_TYPE(T) MSGPACK_OBJECT_##T
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-//*** Array converters
-float* MMTF_parser_float_from_bytes(const char*, uint32_t, uint32_t*);
-int8_t* MMTF_parser_int8_from_bytes(const char*, uint32_t, uint32_t*);
-int16_t* MMTF_parser_int16_from_bytes(const char*, uint32_t, uint32_t*);
-int32_t* MMTF_parser_int32_from_bytes(const char*, const uint32_t, uint32_t*);
-char** MMTF_parser_strings_from_bytes(const char*, uint32_t, uint32_t, uint32_t*);
-
-//*** Array decoders
-int32_t* MMTF_parser_run_length_decode(const int32_t*, uint32_t, uint32_t*);
-int32_t* MMTF_parser_delta_decode(const int32_t*, uint32_t, uint32_t*);
-int32_t* MMTF_parser_recursive_indexing_decode_from_16(const int16_t*, uint32_t, uint32_t*);
-int32_t* MMTF_parser_recursive_indexing_decode_from_8(const int8_t*, uint32_t, uint32_t*);
-float* MMTF_parser_integer_decode_from_16(const int16_t*, uint32_t, int32_t, uint32_t*);
-float* MMTF_parser_integer_decode_from_32(const int32_t*, uint32_t, int32_t, uint32_t*);
-
-//*** Unpacking from MsgPack and applying strategy
-char* MMTF_parser_fetch_string(const msgpack_object*);
-int64_t MMTF_parser_fetch_int(const msgpack_object*);
-float MMTF_parser_fetch_float(const msgpack_object*);
-
-MMTF_Entity* MMTF_parser_fetch_entityList(const msgpack_object*, size_t*);
-
-MMTF_GroupType* MMTF_parser_fetch_groupList(const msgpack_object*, size_t*);
-
-MMTF_BioAssembly* MMTF_parser_fetch_bioAssemblyList(const msgpack_object*, size_t*);
-MMTF_Transform* MMTF_parser_fetch_transformList(const msgpack_object*, size_t*);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
-
-// vi:sw=4:expandtab
diff -upNr pymol-open-source-2.3.0/create_shadertext.py pymol-open-source-2.3.3/create_shadertext.py
--- pymol-open-source-2.3.0/create_shadertext.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/create_shadertext.py	2019-08-22 10:24:47.658585920 +0200
@@ -128,20 +128,11 @@ def create_buildinfo(outputdir, pymoldir
     except OSError:
         sha = ''
 
-    rev = 0
-    try:
-        for line in Popen(['svn', 'info'], cwd=pymoldir, stdout=PIPE).stdout:
-            if line.startswith(b'Last Changed Rev'):
-                rev = int(line.split()[3])
-    except OSError:
-        pass
-
     with openw(os.path.join(outputdir, 'PyMOLBuildInfo.h')) as out:
         print('''
 #define _PyMOL_BUILD_DATE %d
 #define _PYMOL_BUILD_GIT_SHA "%s"
-#define _PyMOL_BUILD_SVN_REV %d
-        ''' % (time.time(), sha, rev), file=out)
+        ''' % (time.time(), sha), file=out)
 
 if __name__ == "__main__":
     create_shadertext(*sys.argv[1:6])
diff -upNr pymol-open-source-2.3.0/examples/devel/cgo_label_hack.py pymol-open-source-2.3.3/examples/devel/cgo_label_hack.py
--- pymol-open-source-2.3.0/examples/devel/cgo_label_hack.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/examples/devel/cgo_label_hack.py	2019-08-22 10:24:47.658585920 +0200
@@ -1,4 +1,3 @@
-import string
 import math
 from pymol.cgo import *
 from pymol import cmd
@@ -41,7 +40,7 @@ for a in range(0,63):
    pdb_list = [
       "HETATM%5d  C   UNK     1    %8.3f%8.3f%8.3f  1.00 10.00\n"%(c,2.0,0,2.0),
       ]
-   cmd.read_pdbstr(string.join(pdb_list,''),'lab1',c,discrete=1)
+   cmd.read_pdbstr(''.join(pdb_list),'lab1',c,discrete=1)
    cmd.label("(lab1 and id %d)"%c,"'frame %d %6.3f'"%(c,math.sin(a/10.0)))
 
 
@@ -54,7 +53,7 @@ pdb_list = [
 "HETATM    1  X   UNK     1    %8.3f%8.3f%8.3f  1.00 10.00\n"%(3.2,0,0),
 "HETATM    2  Y   UNK     2    %8.3f%8.3f%8.3f  1.00 10.00\n"%(0,3.2,0),
 "HETATM    3  Z   UNK     3    %8.3f%8.3f%8.3f  1.00 10.00\n"%(0,0,3.2),]
-cmd.read_pdbstr(string.join(pdb_list,''),'lab2')
+cmd.read_pdbstr(''.join(pdb_list),'lab2')
 cmd.hide('(lab2)')
 cmd.label('lab2','name')
 cmd.color('white','lab2')
diff -upNr pymol-open-source-2.3.0/examples/devel/mutate02.py pymol-open-source-2.3.3/examples/devel/mutate02.py
--- pymol-open-source-2.3.0/examples/devel/mutate02.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/examples/devel/mutate02.py	2019-08-22 10:24:47.658585920 +0200
@@ -18,7 +18,7 @@ stored.list = []
 # generate our list of residues (CA-atoms) to mutate
 
 cmd.iterate("1hpv//A//CA",
-"stored.list.append(string.join([model,segi,chain,resi,name],'/'))")
+"stored.list.append('/'.join([model,segi,chain,resi,name]))")
 
 # now iterate through each residue
 
diff -upNr pymol-open-source-2.3.0/examples/devel/webgui02.py pymol-open-source-2.3.3/examples/devel/webgui02.py
--- pymol-open-source-2.3.0/examples/devel/webgui02.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/examples/devel/webgui02.py	2019-08-22 10:24:47.658585920 +0200
@@ -277,7 +277,7 @@ def data_from_sdf(sdf_file_path):
         mol_id = mol[0].strip()
 
         # store the MOL record
-        mol_dict[mol_id] = string.join(mol,'')
+        mol_dict[mol_id] = ''.join(mol)
         
         # add row (assuming mol_id is unique)
         row_id_list.append(mol_id)
diff -upNr pymol-open-source-2.3.0/.gitignore pymol-open-source-2.3.3/.gitignore
--- pymol-open-source-2.3.0/.gitignore	1970-01-01 01:00:00.000000000 +0100
+++ pymol-open-source-2.3.3/.gitignore	2019-08-22 10:24:47.654585268 +0200
@@ -0,0 +1,4 @@
+*.pyc
+*.d
+generated
+build
diff -upNr pymol-open-source-2.3.0/INSTALL pymol-open-source-2.3.3/INSTALL
--- pymol-open-source-2.3.0/INSTALL	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/INSTALL	2019-08-22 10:24:47.654585268 +0200
@@ -13,14 +13,15 @@ REQUIREMENTS
       https://github.com/schrodinger/pmw-patched
     - OpenGL
     - GLEW
-    - GLUT (freeglut) (optional, disable with --no-glut)
+    - GLUT (freeglut) (optional, enable with --glut)
     - libpng
     - freetype
     - libxml2 (optional, for COLLADA export, disable with --no-libxml)
     - msgpack-c 2.1.5+ (optional, for fast MMTF loading and export,
         disable with --use-msgpackc=no)
     - mmtf-cpp (for fast MMTF export, disable with --use-msgpackc=no)
-    - PyQt5, PyQt4, or PySide (optional, will fall back to Tk interface)
+    - PyQt5, PyQt4, PySide2 or PySide (optional, will fall back to Tk
+        interface if compiled with --glut)
     - glm
     - catch2 (optional, enable with --testing)
 
diff -upNr pymol-open-source-2.3.0/layer0/Base.h pymol-open-source-2.3.3/layer0/Base.h
--- pymol-open-source-2.3.0/layer0/Base.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Base.h	2019-08-22 10:24:47.658585920 +0200
@@ -32,10 +32,6 @@ typedef unsigned int uint;
 
 #define MAX_VDW 2.5F            /* this has to go */
 
-#ifndef MAXFLOAT
-#define MAXFLOAT FLT_MAX
-#endif
-
 #ifndef R_SMALL4
 #define R_SMALL4 0.0001F
 #endif
diff -upNr pymol-open-source-2.3.0/layer0/Block.cpp pymol-open-source-2.3.3/layer0/Block.cpp
--- pymol-open-source-2.3.0/layer0/Block.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Block.cpp	2019-08-22 10:24:47.658585920 +0200
@@ -123,46 +123,28 @@ void Block::translate(int dx, int dy)
 
 
 /*========================================================================*/
-void Block::recursiveDraw(CGO *orthoCGO)
+void Block::recursiveDraw(CGO* orthoCGO)
 {
-  if (this->next)
-    next->recursiveDraw(orthoCGO);
   if (active) {
-      draw(orthoCGO);
-    if (inside)
-      inside->recursiveDraw(orthoCGO);
+    draw(orthoCGO);
   }
 }
 
-/*========================================================================*/
-bool Block::recursiveFastDraw(CGO *orthoCGO)
+bool Block::recursiveFastDraw(CGO* orthoCGO)
 {
   bool ret = false;
-  if (next)
-    ret |= next->recursiveFastDraw(orthoCGO);
   if (active) {
-      ret |= this->fastDraw(orthoCGO);
-    if (inside)
-      ret |= inside->recursiveFastDraw(orthoCGO);
+    ret |= fastDraw(orthoCGO);
   }
   return ret;
 }
 
-/*========================================================================*/
-Block *Block::recursiveFind(int x, int y)
+Block* Block::recursiveFind(int x, int y)
 {
-  Block *check;
-  Block *block = this;
-  if(block) {
-    if(!block->active)
-      block = block->next->recursiveFind(x, y);
-    else if(!rectXYInside(x, y))
-      block = block->next->recursiveFind(x, y);
-    else if(block->inside)
-      if((check = block->inside->recursiveFind(x, y)))
-        block = check;
+  if (!active || !rectXYInside(x, y)) {
+    return nullptr;
   }
-  return (block);
+  return this;
 }
 
 bool Block::rectXYInside(int x, int y) const
diff -upNr pymol-open-source-2.3.0/layer0/Block.h pymol-open-source-2.3.3/layer0/Block.h
--- pymol-open-source-2.3.0/layer0/Block.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Block.h	2019-08-22 10:24:47.658585920 +0200
@@ -18,6 +18,7 @@ Z* -------------------------------------
 #ifndef _H_Block
 #define _H_Block
 
+#include <vector>
 #include<utility>
 
 #include "PyMOLGlobals.h"
@@ -31,14 +32,22 @@ struct BlockRect{
 
 struct Block {
   PyMOLGlobals * m_G;
-  Block *next = nullptr, *inside = nullptr, *parent = nullptr;
   void *reference = nullptr;
   BlockRect rect {}, margin {};
   bool active = false;
   float BackColor[3] = {0.2F, 0.2F, 0.2F };
   float TextColor[3] = {1.0F, 1.0F, 1.0F };
 
+  /**
+   * Draws this block
+   * @param orthoCGO CGO to append to
+   */
   virtual void draw(CGO *orthoCGO) {};
+
+  /**
+   * Draws this block (uses overidden fastDraw implementation)
+   * @param orthoCGO CGO to append to
+   */
   virtual bool fastDraw(CGO *orthoCGO) { return false; }
   virtual void reshape(int width, int height);
   virtual int click(int button, int x, int y, int mod) { return 0; }
@@ -48,8 +57,29 @@ struct Block {
   Block(PyMOLGlobals * _G) : m_G(_G){}
 
   void globalToLocal(int x, int y, int *lx, int *ly);
+
+  /**
+   * Draws this block
+   * @param orthoCGO CGO to append to
+   * @Note: Implementation no longer recursive.
+   */
   void recursiveDraw(CGO *orthoCGO);
+
+  /**
+   * Draws this block (uses overridden fastDraw implementation)
+   * @param orthoCGO CGO to append to
+   * @Note: Implementation no longer recursive.
+   */
   bool recursiveFastDraw(CGO *orthoCGO);
+
+  /**
+   * Determines whether this block is located at (x, y)
+   * @param x cursor X location
+   * @param y cursor Y location
+   * @return pointer to this block if (x, y) is in this block; nullptr otherwise
+   * Note: Implementation is no longer recursive. This is essentially now
+   * just a evalutation to bool.
+   */
   Block *recursiveFind(int x, int y);
   void setMargin(int t, int l, int b, int r);
   void fill(CGO *orthoCGO);
diff -upNr pymol-open-source-2.3.0/layer0/Feedback.cpp pymol-open-source-2.3.3/layer0/Feedback.cpp
--- pymol-open-source-2.3.0/layer0/Feedback.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Feedback.cpp	2019-08-22 10:24:47.658585920 +0200
@@ -16,34 +16,23 @@ I* Additional authors of this source fil
 Z* -------------------------------------------------------------------
 */
 
+#include <algorithm>
+
 #include"os_predef.h"
 #include"os_std.h"
 #include"MemoryDebug.h"
 #include"Feedback.h"
 #include"Ortho.h"
 
-int FeedbackInit(PyMOLGlobals * G, int quiet)
+CFeedback::CFeedback(PyMOLGlobals* G, int quiet) : m_G{G}
 {
-  int a;
-
-  CFeedback *I;
-  I = (G->Feedback = Calloc(CFeedback, 1));
-
-  I->Stack = VLAlloc(char, FB_Total);
-  I->Depth = 0;
-  G->Feedback->Mask = I->Stack;
-
-  if(quiet) {
-    for(a = 0; a < FB_Total; a++) {
-      G->Feedback->Mask[a] = 0;
-    }
-  } else {
-    for(a = 0; a < FB_Total; a++) {
-      G->Feedback->Mask[a] =
-        FB_Output | FB_Results | FB_Errors | FB_Warnings | FB_Actions | FB_Details;
+  if(!quiet) {
+    for(auto& mask : currentLayer()) {
+      mask = FB_Output | FB_Results | FB_Errors | FB_Warnings | FB_Actions |
+             FB_Details;
     }
 
-    G->Feedback->Mask[FB_Main] &= ~(FB_Errors); /* suppress opengl errors in main */
+    currentMask(FB_Main) &= ~(FB_Errors); /* suppress opengl errors in main */
 
   }
 
@@ -51,108 +40,94 @@ int FeedbackInit(PyMOLGlobals * G, int q
   if(fb_env) {
     int n, sysmod, mask;
     while(sscanf(fb_env, "%i:%i%n", &sysmod, &mask, &n) > 1) {
-      FeedbackSetMask(G, sysmod, mask);
+      setMask(sysmod, mask);
       fb_env += n;
     }
   }
-
-  return 1;
-}
-
-void FeedbackFree(PyMOLGlobals * G)
-{
-  CFeedback *I = G->Feedback;
-
-  VLAFreeP(I->Stack);
-  FreeP(G->Feedback);
-
 }
 
-
 /* below we'll presume that any standard feedback on the feedback
 module itself will be effected at the Python level, since feedback
 levels will be changed as a matter of course inside of PyMOL in order
 to quietly perform complex actions.  */
 
-void FeedbackPush(PyMOLGlobals * G)
+void CFeedback::push()
 {
-  CFeedback *I = G->Feedback;
-  int a;
-  I->Depth++;
-  VLACheck(I->Stack, char, (I->Depth + 1) * FB_Total);
-  G->Feedback->Mask = I->Stack + (I->Depth * FB_Total);
-  for(a = 0; a < FB_Total; a++) {
-    G->Feedback->Mask[a] = G->Feedback->Mask[a - FB_Total];
-  }
-  PRINTFD(G, FB_Feedback) " Feedback: push\n" ENDFD;
+  m_stack.push_back(m_stack.back());
+  PRINTFD(m_G, FB_Feedback) " Feedback: push\n" ENDFD;
 }
 
-void FeedbackPop(PyMOLGlobals * G)
+void CFeedback::pop()
 {
-  CFeedback *I = G->Feedback;
-  if(I->Depth) {
-    I->Depth--;
-    G->Feedback->Mask = I->Stack + (I->Depth * FB_Total);
+  if(m_stack.size() > 1) {
+    m_stack.pop_back();
   }
-  PRINTFD(G, FB_Feedback) " Feedback: pop\n" ENDFD;
+  PRINTFD(m_G, FB_Feedback) " Feedback: pop\n" ENDFD;
 }
 
-void FeedbackSetMask(PyMOLGlobals * G, unsigned int sysmod, unsigned char mask)
+void CFeedback::setMask(unsigned int sysmod, unsigned char mask)
 {
-  int a;
   if((sysmod > 0) && (sysmod < FB_Total)) {
-    G->Feedback->Mask[sysmod] = mask;
+    currentMask(sysmod) = mask;
   } else if(!sysmod) {
-    for(a = 0; a < FB_Total; a++) {
-      G->Feedback->Mask[a] = mask;
-    }
+    std::fill(currentLayer().begin(), currentLayer().end(), mask);
   }
-  PRINTFD(G, FB_Feedback)
+  PRINTFD(m_G, FB_Feedback)
     " FeedbackSetMask: sysmod %d, mask 0x%02X\n", sysmod, mask ENDFD;
 }
 
-void FeedbackDisable(PyMOLGlobals * G, unsigned int sysmod, unsigned char mask)
+unsigned char& CFeedback::currentMask(unsigned int sysmod)
+{
+  return m_stack.back()[sysmod];
+}
+
+bool CFeedback::testMask(unsigned int sysmod, unsigned char mask)
+{
+  return currentMask(sysmod) & mask;
+}
+
+void CFeedback::disable(unsigned int sysmod, unsigned char mask)
 {
-  int a;
   if((sysmod > 0) && (sysmod < FB_Total)) {
-    G->Feedback->Mask[sysmod] = G->Feedback->Mask[sysmod] & (0xFF - mask);
+    auto& targetMask = currentMask(sysmod);
+    targetMask &= 0xFF - mask;
   } else if(!sysmod) {
-    for(a = 0; a < FB_Total; a++) {
-      G->Feedback->Mask[a] = G->Feedback->Mask[a] & (0xFF - mask);
+    for(auto& obj_mask : currentLayer()) {
+      obj_mask &=  0xFF - mask;
     }
   }
-  PRINTFD(G, FB_Feedback)
+  PRINTFD(m_G, FB_Feedback)
     " FeedbackDisable: sysmod %d, mask 0x%02X\n", sysmod, mask ENDFD;
 
 }
 
-void FeedbackEnable(PyMOLGlobals * G, unsigned int sysmod, unsigned char mask)
+void CFeedback::enable(unsigned int sysmod, unsigned char mask)
 {
-  int a;
   if((sysmod > 0) && (sysmod < FB_Total)) {
-    G->Feedback->Mask[sysmod] = G->Feedback->Mask[sysmod] | mask;
+    auto& targetMask = currentMask(sysmod);
+    targetMask |= mask;
   } else if(!sysmod) {
-    for(a = 0; a < FB_Total; a++) {
-      G->Feedback->Mask[a] = G->Feedback->Mask[a] | mask;
+    for(auto& obj_mask : currentLayer()) {
+      obj_mask |= mask;
     }
   }
-  PRINTFD(G, FB_Feedback)
+  PRINTFD(m_G, FB_Feedback)
     " FeedbackEnable: sysmod %d, mask 0x%02X\n", sysmod, mask ENDFD;
 
 }
 
-void FeedbackAutoAdd(PyMOLGlobals * G, unsigned int sysmod, unsigned char mask, const char *str)
+void CFeedback::autoAdd(unsigned int sysmod, unsigned char mask, const char *str)
 {
-  if(Feedback(G, sysmod, mask))
-    FeedbackAddColored(G, str, mask);
+  if(testMask(sysmod, mask))
+    addColored(str, mask);
 }
 
-void FeedbackAdd(PyMOLGlobals * G, const char *str)
+void CFeedback::add(const char *str)
 {
-  OrthoAddOutput(G, str);
+  OrthoAddOutput(m_G, str);
 }
 
-void FeedbackAddColored(PyMOLGlobals * G, const char *str, unsigned char mask)
+void CFeedback::addColored(const char *str, unsigned char mask)
 {
-  FeedbackAdd(G, str);
+  add(str);
 }
diff -upNr pymol-open-source-2.3.0/layer0/Feedback.h pymol-open-source-2.3.3/layer0/Feedback.h
--- pymol-open-source-2.3.0/layer0/Feedback.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Feedback.h	2019-08-22 10:24:47.662586571 +0200
@@ -20,12 +20,8 @@ Z* -------------------------------------
 #define _H_Feedback
 
 #include"PyMOLGlobals.h"
-
-struct _CFeedback {
-  char *Mask;
-  char *Stack;
-  int Depth;
-};
+#include <vector>
+#include <array>
 
 
 /* 
@@ -221,28 +217,36 @@ function name.
 
 #define FB_Everything      0xFF
 
-int FeedbackInit(PyMOLGlobals * G, int quiet);
-void FeedbackFree(PyMOLGlobals * G);
-void FeedbackPush(PyMOLGlobals * G);
-void FeedbackPop(PyMOLGlobals * G);
-
-void FeedbackAutoAdd(PyMOLGlobals * G, unsigned int sysmod, unsigned char mask,
-                     const char *str);
-void FeedbackAdd(PyMOLGlobals * G, const char *str);
-void FeedbackAddColored(PyMOLGlobals * G, const char *str, unsigned char mask);
-
-void FeedbackSetMask(PyMOLGlobals * G, unsigned int sysmod, unsigned char mask);
-void FeedbackDisable(PyMOLGlobals * G, unsigned int sysmod, unsigned char mask);
-void FeedbackEnable(PyMOLGlobals * G, unsigned int sysmod, unsigned char mask);
-
+class CFeedback
+{
+  std::vector<std::array<unsigned char, FB_Total>> m_stack{{}};
+  PyMOLGlobals* m_G;
+
+public:
+  CFeedback(PyMOLGlobals* G, int quiet);
+  decltype(m_stack)::value_type& currentLayer() { return m_stack.back(); };
+  void push();
+  void pop();
+  void autoAdd(unsigned int sysmod, unsigned char mask, const char* str);
+  void add(const char* str);
+  void addColored(const char* str, unsigned char mask);
+  void setMask(unsigned int sysmod, unsigned char mask);
+  unsigned char& currentMask(unsigned int sysmod);
+  bool testMask(unsigned int sysmod, unsigned char mask);
+  void disable(unsigned int sysmod, unsigned char mask);
+  void enable(unsigned int sysmod, unsigned char mask);
+};
 
 /* Mechanism: a high-speed bit test, with no range checking 
  * in order to avoid penalizing performance-senstive code
  * modules which may contain live debugging code.  
  */
 
-#define Feedback(G,sysmod,mask) (G->Feedback->Mask[sysmod]&(mask))
-
+inline
+bool Feedback(PyMOLGlobals* G, unsigned int sysmod, unsigned char mask)
+{
+  return G->Feedback->testMask(sysmod, mask);
+}
 
 /* FEEDBACK_MAX_OUTPUT should be as small as is reasonable
  * since this much space gets consumed on the stack
@@ -259,16 +263,30 @@ typedef char FeedbackLineType[FEEDBACK_M
  * variable arguments.
 */
 
-#define PRINTFB(G,sysmod,mask) { FeedbackLineType _FBstr; if(Feedback(G,sysmod,mask)) {(snprintf)( _FBstr, FEEDBACK_MAX_OUTPUT,
-#define ENDFB(G) );  FeedbackAdd(G,_FBstr);}}
+#ifdef _WEBGL
+#else
+
+#define PRINTFB(G,sysmod,mask) \
+{ \
+  FeedbackLineType _FBstr; \
+  if(G->Feedback->testMask(sysmod,mask)) {\
+    const unsigned char _mask = mask; \
+    (snprintf)( _FBstr, FEEDBACK_MAX_OUTPUT,
+
+#define ENDFB(G) \
+    ); \
+    G->Feedback->addColored(_FBstr,_mask); \
+  } \
+}
 
 #define PRINTF { FeedbackLineType _FBstr; (snprintf)( _FBstr, FEEDBACK_MAX_OUTPUT,
-#define ENDF(G)  ); FeedbackAdd(G,_FBstr);}
+#define ENDF(G)  ); G->Feedback->add(_FBstr);}
+#endif
 
 
 /* debugging: goes to stderr */
 
-#define PRINTFD(G,sysmod) {if(Feedback(G,sysmod,FB_Debugging)) { fprintf(stderr,
+#define PRINTFD(G,sysmod) {if(G->Feedback->testMask(sysmod, FB_Debugging)) { fprintf(stderr,
 #define ENDFD   );fflush(stderr);}}
 
 
diff -upNr pymol-open-source-2.3.0/layer0/Field.cpp pymol-open-source-2.3.3/layer0/Field.cpp
--- pymol-open-source-2.3.0/layer0/Field.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Field.cpp	2019-08-22 10:24:47.662586571 +0200
@@ -69,7 +69,7 @@ PyObject *FieldAsNumPyArray(CField * fie
     return NULL;
   }
 
-  ok_assert(1, dims = Alloc(npy_intp, field->n_dim));
+  ok_assert(1, dims = pymol::malloc<npy_intp>(field->n_dim));
   copyN(field->dim, dims, field->n_dim);
 
   if(copy) {
@@ -133,8 +133,8 @@ CField *FieldNewCopy(PyMOLGlobals * G, c
 
   {
     int a;
-    I->dim = Alloc(unsigned int, src->n_dim);
-    I->stride = Alloc(unsigned int, src->n_dim);
+    I->dim = pymol::malloc<unsigned int>(src->n_dim);
+    I->stride = pymol::malloc<unsigned int>(src->n_dim);
     ok = I->dim && I->stride;
     if(ok)
       for(a = 0; a < src->n_dim; a++) {
@@ -144,24 +144,9 @@ CField *FieldNewCopy(PyMOLGlobals * G, c
   }
 
   if(ok) {
-    unsigned int n_elem = I->size / I->base_size;
-    switch (I->type) {
-    case cFieldInt:
-      ok = ((I->data = (char *) Alloc(char, n_elem * sizeof(int))) != NULL);
-      if(ok)
-        memcpy(I->data, src->data, sizeof(int) * n_elem);
-      break;
-    case cFieldFloat:
-      ok = ((I->data = (char *) Alloc(char, n_elem * sizeof(float))) != NULL);
-      if(ok)
-        memcpy(I->data, src->data, sizeof(float) * n_elem);
-      break;
-    default:
-      ok = ((I->data = (char *) Alloc(char, I->size)) != NULL);
+      ok = ((I->data = pymol::malloc<char>(I->size)) != nullptr);
       if(ok)
         memcpy(I->data, src->data, I->size);
-      break;
-    }
   }
   if(!ok) {
     if(I) {
@@ -224,7 +209,7 @@ CField *FieldNewFromPyList(PyMOLGlobals
       }
       break;
     default:
-      I->data = (char *) mmalloc(I->size);
+      I->data = pymol::malloc<char>(I->size);
       break;
     }
   }
@@ -375,7 +360,7 @@ int FieldSmooth3f(CField * I)
   int a, b, c;
   int na = I->dim[0], nb = I->dim[1], nc = I->dim[2];
   int n_pts = na * nb * nc;
-  char *data = (char *) mmalloc(sizeof(float) * n_pts);
+  auto data = (char*) pymol::malloc<float>(n_pts);
   int x, y, z;
   int da, db, dc;
   double tot;
@@ -466,8 +451,8 @@ CField *FieldNew(PyMOLGlobals * G, int *
   OOAlloc(G, CField);
   I->type = type;
   I->base_size = base_size;
-  I->stride = (unsigned int *) Alloc(unsigned int, n_dim);
-  I->dim = (unsigned int *) Alloc(unsigned int, n_dim);
+  I->stride = pymol::malloc<unsigned int>(n_dim);
+  I->dim = pymol::malloc<unsigned int>(n_dim);
 
   stride = base_size;
   for(a = n_dim - 1; a >= 0; a--) {
@@ -475,7 +460,7 @@ CField *FieldNew(PyMOLGlobals * G, int *
     I->dim[a] = dim[a];
     stride *= dim[a];
   }
-  I->data = (char *) mmalloc(stride);
+  I->data = pymol::malloc<char>(stride);
   I->n_dim = n_dim;
   I->size = stride;
   return (I);
diff -upNr pymol-open-source-2.3.0/layer0/File.cpp pymol-open-source-2.3.3/layer0/File.cpp
--- pymol-open-source-2.3.0/layer0/File.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/File.cpp	2019-08-22 10:24:47.662586571 +0200
@@ -33,7 +33,7 @@ static long fgetsize(FILE *fp) {
 static char * fgetcontents(FILE *fp, long *size) {
   long filesize = fgetsize(fp);
 
-  char *contents = (char*) mmalloc(filesize + 255);
+  char *contents = pymol::malloc<char>(filesize + 255);
   if (!contents)
     return nullptr;
 
diff -upNr pymol-open-source-2.3.0/layer0/Isosurf.cpp pymol-open-source-2.3.3/layer0/Isosurf.cpp
--- pymol-open-source-2.3.0/layer0/Isosurf.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Isosurf.cpp	2019-08-22 10:24:47.662586571 +0200
@@ -83,8 +83,6 @@ static int IsosurfAlloc(PyMOLGlobals * G
 static void IsosurfPurge(CIsosurf * II);
 static int IsosurfCurrent(CIsosurf * II);
 static int IsosurfCodeVertices(CIsosurf * II);
-static void IsosurfInterpolate(CIsosurf * II, float *v1, float *l1, float *v2, float *l2,
-                               float *pt);
 static int IsosurfFindActiveEdges(CIsosurf * II);
 static int IsosurfFindLines(CIsosurf * II);
 static int IsosurfDrawLines(CIsosurf * II);
@@ -128,9 +126,7 @@ PyObject *IsosurfAsPyList(PyMOLGlobals *
 
 
 /*===========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
+inline
 static void IsosurfInterpolate(CIsosurf * I, float *v1, float *l1, float *v2, float *l2,
                                float *pt)
 {
@@ -157,7 +153,7 @@ Isofield *IsosurfNewFromPyList(PyMOLGlob
   /* TO ENABLE BACKWARDS COMPATIBILITY...
      Always check ll when adding new PyList_GetItem's */
   if(ok)
-    ok = ((result = Alloc(Isofield, 1)) != NULL);
+    ok = ((result = pymol::malloc<Isofield>(1)) != nullptr);
   if(ok) {
     result->data = NULL;
     result->points = NULL;
@@ -196,7 +192,7 @@ Isofield *IsosurfNewCopy(PyMOLGlobals *
 {
   int ok = true;
 
-  Isofield *result = Calloc(Isofield, 1);
+  Isofield *result = pymol::calloc<Isofield>(1);
 
   copy3f(src->dimensions, result->dimensions);
   result->save_points = src->save_points;
@@ -389,7 +385,7 @@ Isofield *IsosurfFieldAlloc(PyMOLGlobals
 
   /* Warning: ...FromPyList also allocs and inits from the heap */
 
-  result = Alloc(Isofield, 1);
+  result = pymol::malloc<Isofield>(1);
   ErrChkPtr(G, result);
   result->data = FieldNew(G, dims, 3, sizeof(float), cFieldFloat);
   ErrChkPtr(G, result->data);
@@ -460,7 +456,7 @@ static void IsosurfCode(CIsosurf * II, c
 static CIsosurf *IsosurfNew(PyMOLGlobals * G)
 {
   int c;
-  CIsosurf *I = Calloc(CIsosurf, 1);
+  CIsosurf *I = pymol::calloc<CIsosurf>(1);
   I->G = G;
   I->VertexCodes = NULL;
   I->ActiveEdges = NULL;
@@ -1143,15 +1139,16 @@ static int IsosurfGradients(PyMOLGlobals
     range_dim[2] = (range[5] - range[2]);
 
     range_size = range_dim[0] * range_dim[1] * range_dim[2];
-
-    flag = Calloc(int, range_size);
-
+    if (ok)
+      flag = pymol::calloc<int>(range_size);
+    CHECKOK(ok, flag);
     flag_stride[0] = 1;
     flag_stride[1] = range_dim[0];
     flag_stride[2] = range_dim[0] * range_dim[1];
 
-    order = Calloc(int, 3 * range_size);
-
+    if (ok)
+      order = pymol::calloc<int>(3 * range_size);
+    CHECKOK(ok, order);
     if(order && flag && (range_dim[0] > 1) && (range_dim[1] > 1) && (range_dim[2] > 1)) {
 
       {
diff -upNr pymol-open-source-2.3.0/layer0/ListMacros.h pymol-open-source-2.3.3/layer0/ListMacros.h
--- pymol-open-source-2.3.0/layer0/ListMacros.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/ListMacros.h	2019-08-22 10:24:47.662586571 +0200
@@ -125,7 +125,7 @@ Z* -------------------------------------
 {						\
     if(!(Elem))					\
       {							\
-	(Elem) = (ElemType*)mmalloc(sizeof(ElemType));	\
+	(Elem) = pymol::malloc<ElemType>(1);		\
 	ErrChkPtr(G,Elem);				\
       }							\
 }
@@ -134,7 +134,7 @@ Z* -------------------------------------
 {						\
   if(!(Elem))						  \
     {							  \
-      (Elem) = (ElemType*)mcalloc(sizeof(ElemType),1);	  \
+      (Elem) = pymol::calloc<ElemType>(1);		  \
       ErrChkPtr(G,Elem);				  \
     }							  \
 }
@@ -210,7 +210,7 @@ do { \
 do {						\
  if(!(Elem))						\
    {							\
-     (Elem) = (ElemType*)mmalloc(sizeof(ElemType));	\
+     (Elem) = pymol::malloc<ElemType>(1);		\
      ErrChkPtr(G,Elem);					\
    }							\
  } while (0)
@@ -219,7 +219,7 @@ do {						\
 do {							  \
   if(!(Elem))						  \
     {							  \
-      (Elem) = (ElemType*)mcalloc(sizeof(ElemType),1);	  \
+      (Elem) = pymol::calloc<ElemType>(1);		  \
       ErrChkPtr(G,Elem);				  \
     }							  \
 } while (0)
diff -upNr pymol-open-source-2.3.0/layer0/Match.cpp pymol-open-source-2.3.3/layer0/Match.cpp
--- pymol-open-source-2.3.0/layer0/Match.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Match.cpp	2019-08-22 10:24:47.662586571 +0200
@@ -286,7 +286,7 @@ int MatchMatrixFromFile(CMatch * I, cons
       ok = false;
     }
   } else {
-    buffer = Alloc(char, BLOSUM62_ROWS * BLOSUM62_COLS);
+    buffer = pymol::malloc<char>(BLOSUM62_ROWS * BLOSUM62_COLS);
     if(buffer) {
       p = buffer;
       a = 0;
@@ -321,7 +321,7 @@ int MatchMatrixFromFile(CMatch * I, cons
     if(!n_entry)
       ok = false;
     else {
-      code = (char *) Calloc(char, n_entry * sizeof(int));
+      code = (char*) pymol::calloc<int>(n_entry);
 
       /* read codes */
 
diff -upNr pymol-open-source-2.3.0/layer0/Matrix.cpp pymol-open-source-2.3.3/layer0/Matrix.cpp
--- pymol-open-source-2.3.0/layer0/Matrix.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Matrix.cpp	2019-08-22 10:24:47.662586571 +0200
@@ -28,8 +28,8 @@ Z* -------------------------------------
 
 /* Jenarix owned types, aliases, and defines */
 
-#define xx_os_malloc mmalloc
-#define xx_os_free mfree
+#define xx_os_malloc malloc
+#define xx_os_free free
 #define xx_os_memcpy memcpy
 #define xx_os_memset memset
 #define xx_fabs fabs
@@ -660,8 +660,8 @@ int *MatrixFilter(float cutoff, int wind
   int start, finish;
   int cnt;
 
-  flag = Alloc(int, nv);        /* allocate flag matrix */
-  dev = Alloc(float, nv);       /* allocate matrix for storing deviations */
+  flag = pymol::malloc<int>(nv);        /* allocate flag matrix */
+  dev = pymol::malloc<float>(nv);       /* allocate matrix for storing deviations */
 
   for(a = 0; a < nv; a++) {
     flag[a] = true;
diff -upNr pymol-open-source-2.3.0/layer0/MemoryCache.h pymol-open-source-2.3.3/layer0/MemoryCache.h
--- pymol-open-source-2.3.0/layer0/MemoryCache.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/MemoryCache.h	2019-08-22 10:24:47.662586571 +0200
@@ -81,9 +81,9 @@ Z* -------------------------------------
 #define VLACacheMalloc(G,a,b,c,d,t,i) VLAMalloc(a,b,c,d)
 #define VLACacheFree(G,p,t,i,f) VLAFree(p)
 
-#define CacheAlloc(G,type,size,thread,id) (type*)mmalloc(sizeof(type)*(size))
-#define CacheCalloc(G,type,size,thread,id) (type*)mcalloc(sizeof(type),size)
-#define CacheRealloc(G,ptr,type,size,thread,id) (type*)mrealloc(sizeof(type)*(size))
+#define CacheAlloc(G,type,size,thread,id) pymol::malloc<type>(size)
+#define CacheCalloc(G,type,size,thread,id) pymol::calloc<type>(size)
+#define CacheRealloc(G,ptr,type,size,thread,id) pymol::realloc<type>(size)
 #define CacheFreeP(G,ptr,thread,id,force) {if(ptr) {mfree(ptr);ptr=NULL;}}
 
 #endif
diff -upNr pymol-open-source-2.3.0/layer0/MemoryDebug.cpp pymol-open-source-2.3.3/layer0/MemoryDebug.cpp
--- pymol-open-source-2.3.0/layer0/MemoryDebug.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/MemoryDebug.cpp	2019-08-22 10:24:47.666587222 +0200
@@ -14,9 +14,6 @@ I* Additional authors of this source fil
 Z* -------------------------------------------------------------------
 */
 
-
-/* This file can be compiled under C as a .c file, or under C++ as a .cc file*/
-
 #include"os_predef.h"
 #include"ov_port.h"
 
@@ -28,20 +25,20 @@ Z* -------------------------------------
 void *MemoryReallocForSureSafe(void *ptr, unsigned int new_size, unsigned int old_size)
 {
   if(new_size < old_size) {
-    float *tmp = (float*) mmalloc(new_size);
+    auto tmp = pymol::malloc<char>(new_size);
     if(tmp && new_size && old_size) {
       memcpy(tmp, ptr, new_size);
     }
     FreeP(ptr);
     return tmp;
   } else {
-    return mrealloc(ptr, new_size);
+    return pymol::realloc((char*) ptr, new_size);
   }
 }
 
 void *MemoryReallocForSure(void *ptr, unsigned int new_size)
 {                               /* unsafe -- replace with above */
-  float *tmp = (float*) mmalloc(new_size);
+  auto tmp = pymol::malloc<char>(new_size);
   if(tmp)
     memcpy(tmp, ptr, new_size);
   FreeP(ptr);
@@ -60,6 +57,12 @@ static void DieOutOfMemory(void)
     ("*** that you are viewing or rendering.    Sorry for the inconvenience... ***\n");
   printf
     ("****************************************************************************\n");
+
+#if defined(_PYMOL_IOS) && !defined(_WEBGL)
+  fireMemoryWarning();
+  return;
+#endif
+
 #ifdef GDB_ENTRY
   abort();
 #endif
@@ -73,6 +76,19 @@ void MemoryZero(char *p, char *q)
     memset(p, 0, q - p);
 }
 
+/**
+ * Update `size` and reallocate this vla
+ *
+ * @param size number of elements
+ * @return reallocated pointer or NULL if realloc failed
+ */
+static VLARec* VLARec_resize(VLARec* vla, ov_size size)
+{
+  vla->size = size;
+  return (VLARec*) pymol::realloc(
+      (char*) (void*) vla, (vla->unit_size * size) + sizeof(VLARec));
+}
+
 void *VLAExpand(void *ptr, ov_size rec)
 {
   VLARec *vla;
@@ -82,25 +98,22 @@ void *VLAExpand(void *ptr, ov_size rec)
   if(rec >= vla->size) {
     if(vla->auto_zero)
       soffset = sizeof(VLARec) + (vla->unit_size * vla->size);
-    vla->size = ((unsigned int) (rec * vla->grow_factor)) + 1;
-#if 0
-    if(vla->size <= rec)
-      vla->size = rec + 1;
-#endif
-    {
-      VLARec *old_vla = vla;
-      vla = (VLARec *) mrealloc(vla, (vla->unit_size * vla->size) + sizeof(VLARec));
-      while(!vla) {             /* back off on the request size until it actually fits */
-        vla = old_vla;
-        vla->grow_factor = (vla->grow_factor - 1.0F) / 2.0F + 1.0F;
-        vla->size = ((unsigned int) (rec * vla->grow_factor)) + 1;
-        vla = (VLARec *) mrealloc(vla, (vla->unit_size * vla->size) + sizeof(VLARec));
-        if(!vla) {
-          if(old_vla->grow_factor < 1.001F) {
-            printf("VLAExpand-ERR: realloc failed.\n");
-            DieOutOfMemory();
-          }
-        }
+
+    // back off on the request size until it actually fits
+    while (true) {
+      auto resized_vla = VLARec_resize(vla, rec * vla->grow_factor + 1);
+      if (resized_vla) {
+        vla = resized_vla;
+        break;
+      }
+
+      vla->grow_factor = (vla->grow_factor - 1.0F) / 2.0F + 1.0F;
+
+      if (vla->grow_factor < 1.001F) {
+        mfree(vla);
+        printf("VLAExpand-ERR: realloc failed.\n");
+        DieOutOfMemory();
+        return nullptr;
       }
     }
     if(vla->auto_zero) {
@@ -117,11 +130,12 @@ void *VLAMalloc(ov_size init_size, ov_si
 {
   VLARec *vla;
   char *start, *stop;
-  vla = (VLARec*) mmalloc((init_size * unit_size) + sizeof(VLARec));
+  vla = (VLARec*) pymol::malloc<char>((init_size * unit_size) + sizeof(VLARec));
 
   if(!vla) {
     printf("VLAMalloc-ERR: malloc failed\n");
     DieOutOfMemory();
+    return nullptr;
   }
   vla->size = init_size;
   vla->unit_size = unit_size;
@@ -161,7 +175,7 @@ void *VLANewCopy(const void *ptr)
     unsigned int size;
     vla = &((VLARec *) ptr)[-1];
     size = (vla->unit_size * vla->size) + sizeof(VLARec);
-    new_vla = (VLARec*) mmalloc(size);
+    new_vla = (VLARec*) pymol::malloc<char>(size);
     if(!new_vla) {
       printf("VLACopy-ERR: mmalloc failed\n");
       exit(EXIT_FAILURE);
@@ -184,8 +198,7 @@ void *VLASetSize(void *ptr, unsigned int
   if(vla->auto_zero) {
     soffset = sizeof(VLARec) + (vla->unit_size * vla->size);
   }
-  vla->size = new_size;
-  vla = (VLARec*) mrealloc(vla, (vla->unit_size * vla->size) + sizeof(VLARec));
+  vla = VLARec_resize(vla, new_size);
   if(!vla) {
     printf("VLASetSize-ERR: realloc failed.\n");
     DieOutOfMemory();
@@ -284,8 +297,7 @@ void *VLASetSizeForSure(void *ptr, unsig
                                    (vla->unit_size * vla->size) + sizeof(VLARec));
     vla->size = new_size;
   } else {
-    vla->size = new_size;
-    vla = (VLARec*) mrealloc(vla, (vla->unit_size * vla->size) + sizeof(VLARec));
+    vla = VLARec_resize(vla, new_size);
   }
   if(!vla) {
     printf("VLASetSize-ERR: realloc failed.\n");
diff -upNr pymol-open-source-2.3.0/layer0/MemoryDebug.h pymol-open-source-2.3.3/layer0/MemoryDebug.h
--- pymol-open-source-2.3.0/layer0/MemoryDebug.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/MemoryDebug.h	2019-08-22 10:24:47.666587222 +0200
@@ -46,9 +46,25 @@ typedef struct VLARec {
 #define VLAInsert(ptr,type,index,count) {ptr=(type*)VLAInsertRaw(ptr,index,count);}
 #define VLADelete(ptr,type,index,count) {ptr=(type*)VLADeleteRaw(ptr,index,count);}
 
-#define Alloc(type,size) (type*)mmalloc(sizeof(type)*(size))
-#define Calloc(type,size) (type*)mcalloc(sizeof(type),size)
-#define Realloc(ptr,type,size) (type*)mrealloc(ptr,sizeof(type)*(size))
+namespace pymol
+{
+using ::free;
+
+template <typename T> T* malloc(size_t num)
+{
+  return (T*) ::malloc(num * sizeof(T));
+}
+
+template <typename T> T* calloc(size_t num)
+{
+  return (T*) ::calloc(num, sizeof(T));
+}
+
+template <typename T> T* realloc(T* ptr, size_t num)
+{
+  return (T*) ::realloc(ptr, num * sizeof(T));
+}
+} // namespace pymol
 
 #define FreeP(ptr) {if(ptr) {mfree(ptr);ptr=NULL;}}
 #define DeleteP(ptr) {if(ptr) {delete ptr;ptr=NULL;}}
@@ -72,22 +88,9 @@ void *VLANewCopy(const void *ptr);
 void MemoryZero(char *p, char *q);
 
 
-#define mcalloc calloc
-#define mmalloc malloc
-#define mrealloc realloc
-#define mfree free
+#define mfree pymol::free
 #define mstrdup strdup
 #define ReallocForSure(ptr,type,size) (type*)MemoryReallocForSure(ptr,sizeof(type)*(size))
-#define ReallocForSureSafe(ptr,type,size,old_size) (type*)MemoryReallocForSure(ptr,sizeof(type)*(size),sizeof(type)*(old_size))
-
-#ifdef __cplusplus
-#define mnew new
-#endif
-
-#define MD_FILE_LINE_Call
-#define MD_FILE_LINE_Decl
-#define MD_FILE_LINE_Nest
-#define MD_FILE_LINE_PTR_Call
 
 
 inline unsigned int VLAGetByteSize(const void *ptr) {
diff -upNr pymol-open-source-2.3.0/layer0/MyPNG.cpp pymol-open-source-2.3.3/layer0/MyPNG.cpp
--- pymol-open-source-2.3.0/layer0/MyPNG.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/MyPNG.cpp	2019-08-22 10:24:47.666587222 +0200
@@ -84,7 +84,7 @@ static unsigned char *base64_decode(cons
   if (input_length < 1)
     input_length = strlen(data);
 
-  ok_assert(1, decoded_data = (unsigned char*) mmalloc(input_length / 4 * 3));
+  ok_assert(1, decoded_data = pymol::malloc<unsigned char>(input_length / 4 * 3));
 
   while (i < input_length) {
     triple = 0;
@@ -192,7 +192,7 @@ int MyPNGWrite(const char* file_name, co
       png_bytep *row_pointers;
       int fd = 0;
 
-      row_pointers = Alloc(png_bytep, height);
+      row_pointers = pymol::malloc<png_bytep>(height);
 
       /* open the file, allowing use of an encoded file descriptor, with
          approach adapted from TJO: chr(1) followed by ascii-format integer */
@@ -327,7 +327,7 @@ int MyPNGWrite(const char* file_name, co
   case cMyPNG_FormatPPM:
     {
       FILE *fil = pymol_fopen(file_name, "wb");
-      unsigned char *buffer = Alloc(unsigned char, 3 * width * height);
+      unsigned char *buffer = pymol::malloc<unsigned char>(3 * width * height);
 
       if(fil && buffer) {
         fprintf(fil, "P6\n");
diff -upNr pymol-open-source-2.3.0/layer0/OOMac.h pymol-open-source-2.3.3/layer0/OOMac.h
--- pymol-open-source-2.3.0/layer0/OOMac.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/OOMac.h	2019-08-22 10:24:47.666587222 +0200
@@ -22,13 +22,11 @@ Z* -------------------------------------
 #include"MemoryDebug.h"
 
 #define OOAlloc(G,type) \
-type *I;					\
-I = (type*)mmalloc(sizeof(type));		\
+auto* I = pymol::malloc<type>(1); \
 ErrChkPtr(G,I);
 
 #define OOCalloc(G,type) \
-type *I;					 \
-I = (type*)mcalloc(sizeof(type),1);		 \
+auto* I = pymol::calloc<type>(1); \
 ErrChkPtr(G,I);
 
 #define OOFreeP(ptr) \
diff -upNr pymol-open-source-2.3.0/layer0/os_gl.cpp pymol-open-source-2.3.3/layer0/os_gl.cpp
--- pymol-open-source-2.3.0/layer0/os_gl.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/os_gl.cpp	2019-08-22 10:24:47.670587874 +0200
@@ -104,13 +104,11 @@ int PyMOLCheckOpenGLErr(const char *pos)
 }
 
 #ifdef _PYMOL_NO_GLUT
-#ifndef _MACPYMOL_XCODE
 int p_glutGet(GLenum type)
 {
   return 0;
 }
 #endif
-#endif
 
 #ifndef _PYMOL_NO_GLUT
 
diff -upNr pymol-open-source-2.3.0/layer0/os_predef.h pymol-open-source-2.3.3/layer0/os_predef.h
--- pymol-open-source-2.3.0/layer0/os_predef.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/os_predef.h	2019-08-22 10:24:47.670587874 +0200
@@ -49,10 +49,6 @@ typedef float aliased_float;
 
 /* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in "os_proprietary.h") */
 
-#if defined(_MSC_VER)
-#define __inline__ __inline
-#endif
-
 #ifdef WIN32
 #define PATH_SEP "\\"
 #else
diff -upNr pymol-open-source-2.3.0/layer0/Pixmap.cpp pymol-open-source-2.3.3/layer0/Pixmap.cpp
--- pymol-open-source-2.3.0/layer0/Pixmap.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Pixmap.cpp	2019-08-22 10:24:47.666587222 +0200
@@ -27,7 +27,7 @@ void PixmapInit(PyMOLGlobals * G, CPixma
   I->height = height;
   I->width = width;
   if((height >= 0) && (width >= 0)) {
-    I->buffer = Alloc(unsigned char, 4 * height * width);
+    I->buffer = pymol::malloc<unsigned char>(4 * height * width);
   }
 }
 
diff -upNr pymol-open-source-2.3.0/layer0/PyMOLGlobals.h pymol-open-source-2.3.3/layer0/PyMOLGlobals.h
--- pymol-open-source-2.3.0/layer0/PyMOLGlobals.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/PyMOLGlobals.h	2019-08-22 10:24:47.666587222 +0200
@@ -36,13 +36,13 @@ typedef struct _CMemoryCache CMemoryCach
 typedef struct _CIsosurf CIsosurf;
 typedef struct _CTetsurf CTetsurf;
 typedef struct _CSphere CSphere;
-typedef struct _CFeedback CFeedback;
+struct CFeedback;
 typedef struct _CUtil CUtil;
 struct CColor;
 struct CMovie;
 struct CControl;
 struct CButMode;
-typedef struct _COrtho COrtho;
+class COrtho;
 typedef struct _CWord CWord;
 typedef struct _CCGORenderer CCGORenderer;
 typedef struct _CCharacter CCharacter;
@@ -64,6 +64,7 @@ typedef struct _CTexture CTexture;
 typedef struct _CType CType;
 typedef struct _CMain CMain;
 typedef struct _CPlugIOManager CPlugIOManager;
+struct ObjectMolecule;
 
 class CShaderMgr;
 class CMovieScenes;
diff -upNr pymol-open-source-2.3.0/layer0/PyMOLOptions.h pymol-open-source-2.3.3/layer0/PyMOLOptions.h
--- pymol-open-source-2.3.0/layer0/PyMOLOptions.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/PyMOLOptions.h	2019-08-22 10:24:47.666587222 +0200
@@ -48,7 +48,6 @@ struct _CPyMOLOptions {
       launch_status,
       no_quit;        // prevent any action from quitting or killing PyMOL
 
-  bool retina;        // enables 4K Retina support, if available
   bool gldebug;       // enables GL debugging
 
   /* WARNING: for the sake of forward compability, never delete or
diff -upNr pymol-open-source-2.3.0/layer0/ShaderMgr.cpp pymol-open-source-2.3.3/layer0/ShaderMgr.cpp
--- pymol-open-source-2.3.0/layer0/ShaderMgr.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/ShaderMgr.cpp	2019-08-22 10:24:47.666587222 +0200
@@ -695,17 +695,17 @@ void CShaderMgr::Config() {
       " Detected OpenGL version %d.%d.", gl_major, gl_minor ENDFB(G);
 
     if (GLEW_VERSION_2_0) {
-      FeedbackAdd(G, " Shaders available.\n");
+      G->Feedback->add(" Shaders available.\n");
     }
     else { 
-      FeedbackAdd(G, " Shaders and volumes unavailable.\n");
+      G->Feedback->add(" Shaders and volumes unavailable.\n");
       disableShaders(G);
       return;
     }
   } 
   else {
     /* print info on glew error? */
-    FeedbackAdd(G, " There was an error intializing GLEW.  Basic graphics, including\n shaders and volumes may be unavailable.\n");
+    G->Feedback->add(" There was an error intializing GLEW.  Basic graphics, including\n shaders and volumes may be unavailable.\n");
     disableShaders(G);
     fprintf(stderr, " GLEW-Error: %s\n", glewGetErrorString(err));
     return;
@@ -808,7 +808,7 @@ void CShaderMgr::Config() {
     int major, minor;
     getGLSLVersion(G, &major, &minor);
     sprintf(buf, " Detected GLSL version %d.%d.\n", major, minor);
-    FeedbackAdd(G, buf);
+    G->Feedback->add(buf);
   }
 #endif
   shaders_present |= 0x1;
diff -upNr pymol-open-source-2.3.0/layer0/ShaderPrg.cpp pymol-open-source-2.3.3/layer0/ShaderPrg.cpp
--- pymol-open-source-2.3.0/layer0/ShaderPrg.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/ShaderPrg.cpp	2019-08-22 10:24:47.666587222 +0200
@@ -34,7 +34,6 @@ Z* -------------------------------------
 #include "File.h"
 #include "Matrix.h"
 #include "Scene.h"
-#include "MacPyMOL.h"
 #include "Parse.h"
 #ifdef _WEBGL
 #include "Matrix.h"
@@ -193,7 +192,7 @@ int CShaderPrg::Link() {
 	ENDFB(G);
       glGetProgramiv(id, GL_INFO_LOG_LENGTH, &infoLogLength);
       if (!glGetError() && infoLogLength>0){
-	char *infoLog = Alloc(char, infoLogLength);
+	char *infoLog = pymol::malloc<char>(infoLogLength);
 	glGetProgramInfoLog(id, infoLogLength, &howLong, infoLog);
 	PRINTFB(G, FB_ShaderMgr, FB_Errors)
 	  "%s\n", infoLog
diff -upNr pymol-open-source-2.3.0/layer0/Sphere.cpp pymol-open-source-2.3.3/layer0/Sphere.cpp
--- pymol-open-source-2.3.0/layer0/Sphere.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Sphere.cpp	2019-08-22 10:24:47.666587222 +0200
@@ -263,10 +263,10 @@ static void SphereDumpAll(CSphere *I)
 
 void SphereInit(PyMOLGlobals * G)
 {
-  CSphere *I = (G->Sphere = Calloc(CSphere, 1));
+  CSphere *I = (G->Sphere = pymol::calloc<CSphere>(1));
 
 #ifdef FAST_SPHERE_INIT
-  I->Array = Alloc(SphereRec, Sphere_NSpheres);
+  I->Array = pymol::malloc<SphereRec>(Sphere_NSpheres);
 
   {
     int i;
@@ -400,13 +400,13 @@ static SphereRec *MakeDotSphere(PyMOLGlo
   SphereBuilderRec SBuild, *S;
   S = &SBuild;
 
-  S->Dot = (float *) mmalloc(sizeof(float) * 3 * MAXDOT);
+  S->Dot = pymol::malloc<float>(3 * MAXDOT);
   ErrChkPtr(G, S->Dot);
-  S->EdgeRef = (EdgeArray *) mmalloc(sizeof(EdgeArray));
+  S->EdgeRef = pymol::malloc<EdgeArray>(1);
   ErrChkPtr(G, S->EdgeRef);
-  S->Tri = Alloc(Triangle, MAXTRI);
+  S->Tri = pymol::malloc<Triangle>(MAXTRI);
   ErrChkPtr(G, S->Tri);
-  TriFlag = Alloc(int, MAXTRI);
+  TriFlag = pymol::malloc<int>(MAXTRI);
   ErrChkPtr(G, TriFlag);
 
   S->NDot = 12;
@@ -464,15 +464,15 @@ static SphereRec *MakeDotSphere(PyMOLGlo
     //    printf( "MakeDotSphere: Level: %i  S->NTri: %i\n",c, S->NTri); 
   }
   //  printf(" MakeDotSphere: NDot %i S->NTri %i\n",S->NDot,S->NTri);
-  result = Alloc(SphereRec, 1);
+  result = pymol::malloc<SphereRec>(1);
   ErrChkPtr(G, result);
-  result->dot = Alloc(Vector3f, S->NDot);
+  result->dot = pymol::malloc<Vector3f>(S->NDot);
   ErrChkPtr(G, result->dot);
-  result->area = Alloc(float, S->NDot);
+  result->area = pymol::malloc<float>(S->NDot);
   ErrChkPtr(G, result->area);
-  result->StripLen = Alloc(int, S->NTri * 3);
+  result->StripLen = pymol::malloc<int>(S->NTri * 3);
   ErrChkPtr(G, result->StripLen);
-  result->Sequence = Alloc(int, S->NTri * 3);
+  result->Sequence = pymol::malloc<int>(S->NTri * 3);
   ErrChkPtr(G, result->Sequence);
 
   for(a = 0; a < S->NDot; a++) {
@@ -632,12 +632,12 @@ static SphereRec *MakeDotSphere(PyMOLGlo
   mfree(S->EdgeRef);
   mfree(TriFlag);
   result->Tri = (int *) S->Tri;
-  result->Tri = Realloc(result->Tri, int, S->NTri * 3);
+  result->Tri = pymol::realloc(result->Tri, S->NTri * 3);
   result->NTri = S->NTri;
-  result->StripLen = Realloc(result->StripLen, int, nStrip);
-  result->Sequence = Realloc(result->Sequence, int, nVertTot);
-  result->dot = Realloc(result->dot, Vector3f, S->NDot);
-  result->area = Realloc(result->area, float, S->NDot);
+  result->StripLen = pymol::realloc(result->StripLen, nStrip);
+  result->Sequence = pymol::realloc(result->Sequence, nVertTot);
+  result->dot = pymol::realloc(result->dot, S->NDot);
+  result->area = pymol::realloc(result->area, S->NDot);
   result->nDot = S->NDot;
   result->NStrip = nStrip;
   result->NVertTot = nVertTot;
diff -upNr pymol-open-source-2.3.0/layer0/Tetsurf.cpp pymol-open-source-2.3.3/layer0/Tetsurf.cpp
--- pymol-open-source-2.3.0/layer0/Tetsurf.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Tetsurf.cpp	2019-08-22 10:24:47.670587874 +0200
@@ -309,7 +309,7 @@ static CTetsurf *TetsurfNew(PyMOLGlobals
 #define cM_101_111 0x20000
 #define cM_110_111 0x40000
 
-  CTetsurf *I = Calloc(CTetsurf, 1);
+  CTetsurf *I = pymol::calloc<CTetsurf>(1);
   int c;
   int nv = 1;
   int last_nv;
@@ -690,9 +690,7 @@ static void TetsurfPurge(CTetsurf * II)
 
 
 /*===========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
+inline
 static void TetsurfInterpolate2(float *pt, float *v0, float l0, float *v1, float l1,
                                 float level)
 {
@@ -705,9 +703,6 @@ static void TetsurfInterpolate2(float *p
 
 
 /*===========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static void TetsurfInterpolate4(float *pt, float *v0, float l0, float *v1, float l1,
                                 float l2, float l3, float level)
 {
@@ -730,9 +725,6 @@ static void TetsurfInterpolate4(float *p
 
 
 /*===========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static void TetsurfInterpolate8(float *pt, float *v0, float l0, float *v1, float l1,
                                 float l2, float l3, float l4,
                                 float l5, float l6, float l7, float level)
diff -upNr pymol-open-source-2.3.0/layer0/Texture.cpp pymol-open-source-2.3.3/layer0/Texture.cpp
--- pymol-open-source-2.3.0/layer0/Texture.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Texture.cpp	2019-08-22 10:24:47.670587874 +0200
@@ -116,7 +116,7 @@ void TextureInitTextTextureImpl(PyMOLGlo
     if (is_new){
       int tex_dim = textureSize;
       int buff_total = tex_dim * tex_dim;
-      unsigned char *temp_buffer = Alloc(unsigned char, buff_total * 4);
+      unsigned char *temp_buffer = pymol::malloc<unsigned char>(buff_total * 4);
       UtilZeroMem(temp_buffer, buff_total * 4);
       glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
 		   tex_dim, tex_dim, 0, GL_RGBA, GL_UNSIGNED_BYTE, (GLvoid*)temp_buffer);
@@ -156,7 +156,7 @@ int TextureGetFromChar(PyMOLGlobals * G,
         GLuint texture_id = 0;
         int buff_incr = is_new ? tex_dim : w;
         int buff_total = is_new ? tex_dim * tex_dim : w * h;
-        unsigned char *temp_buffer = Alloc(unsigned char, buff_total * 4);
+        unsigned char *temp_buffer = pymol::malloc<unsigned char>(buff_total * 4);
 
         {
           int a, b;
diff -upNr pymol-open-source-2.3.0/layer0/Triangle.cpp pymol-open-source-2.3.3/layer0/Triangle.cpp
--- pymol-open-source-2.3.0/layer0/Triangle.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Triangle.cpp	2019-08-22 10:24:47.670587874 +0200
@@ -123,7 +123,7 @@ static int *TriangleMakeStripVLA(Triangl
   float *v0, *v1, *v2, vt1[3], vt2[3], *tn0, *tn1, *tn2, tn[3], xtn[3];
 
   strip = VLAlloc(int, I->nTri * 4);    /* strip VLA is count,vert,vert,...count,vert,vert...zero */
-  tFlag = Alloc(int, I->nTri);
+  tFlag = pymol::malloc<int>(I->nTri);
   for(a = 0; a < I->nTri; a++)
     tFlag[a] = 0;
   s = strip;
@@ -318,9 +318,9 @@ static int TriangleAdjustNormals(Triangl
   float *v0, *v1, *v2, *tn, vt1[3], vt2[3], *vn0, *tn0, *tn1, *tn2, *tw;
   int a, *t, i0, i1, i2;
   float tmp[3];
-  tNorm = Alloc(float, 3 * I->nTri);
-  tWght = Alloc(float, I->nTri);
-  vFlag = Alloc(int, n);
+  tNorm = pymol::malloc<float>(3 * I->nTri);
+  tWght = pymol::malloc<float>(I->nTri);
+  vFlag = pymol::malloc<int>(n);
   for(a = 0; a < n; a++) {
     vFlag[a] = 0;
   }
@@ -381,7 +381,7 @@ static int TriangleAdjustNormals(Triangl
   if(final_pass) {
     int repeat = true;
     int max_cyc = 5;
-    float *va = Alloc(float, 3 * n), *va0, *va1, *va2;
+    float *va = pymol::malloc<float>(3 * n), *va0, *va1, *va2;
     float vt[3];
     while(repeat && max_cyc) {
       repeat = false;
@@ -784,7 +784,7 @@ static int TriangleBuildObvious(Triangle
   if(s12 > 0)
     used = I->edge[s12].vert3;
   if(s12 >= 0) {
-    float minDist2 = MAXFLOAT;
+    float minDist2 = FLT_MAX;
     maxDot = _plus;
     i0 = -1;
     v1 = v + i1 * 3;
@@ -2015,8 +2015,8 @@ static int TriangleFixProblems(TriangleS
   int *vFlag = NULL;
   problemFlag = false;
 
-  pFlag = Alloc(int, n);
-  vFlag = Alloc(int, n);
+  pFlag = pymol::malloc<int>(n);
+  vFlag = pymol::malloc<int>(n);
   for(a = 0; a < n; a++) {
     vFlag[a] = 0;
     if(I->vertActive[a]) {
@@ -2159,11 +2159,11 @@ static int TriangleBruteForceClosure(Tri
   int p1, p2;
   float dp;
 
-  active = Alloc(int, n);
+  active = pymol::malloc<int>(n);
   ac = 0;
-  pair = Alloc(int, n * 2);
+  pair = pymol::malloc<int>(n * 2);
   pc = 0;
-  pFlag = Alloc(int, n);
+  pFlag = pymol::malloc<int>(n);
   for(a = 0; a < n; a++) {
     if(I->vertActive[a]) {
       pFlag[a] = 1;
@@ -2288,8 +2288,9 @@ int *TrianglePointsToSurface(PyMOLGlobal
   int a;
 
   if(n >= 3) {
-    I = Alloc(TriangleSurfaceRec, 1);
-    if(I) {
+    I = pymol::malloc<TriangleSurfaceRec>(1);
+    CHECKOK(ok, I);
+    if(ok) {
       float maxEdgeLen = 0.0F;
   
       I->G = G;
@@ -2313,7 +2314,7 @@ int *TrianglePointsToSurface(PyMOLGlobal
         maxEdgeLen = (cutoff*1.414F);
         I->maxEdgeLenSq = maxEdgeLen * maxEdgeLen;
       } else {
-        I->maxEdgeLenSq = MAXFLOAT;
+        I->maxEdgeLenSq = FLT_MAX;
       }
 
       I->map = MapNew(I->G, cutoff, v, n, extent);
@@ -2325,21 +2326,30 @@ int *TrianglePointsToSurface(PyMOLGlobal
         ok = false;
 
       if(ok) {
-        I->edgeStatus = Alloc(int, n);
+        I->edgeStatus = pymol::malloc<int>(n);
+	CHECKOK(ok, I->edgeStatus);
+	if (ok){
         for(a = 0; a < n; a++) {
           I->edgeStatus[a] = 0;
         }
-
-        I->vertActive = Alloc(int, n);
+	}
+	if (ok)
+	  I->vertActive = pymol::malloc<int>(n);
+	CHECKOK(ok, I->vertActive);
+	if (ok){
         for(a = 0; a < n; a++) {
           I->vertActive[a] = -1;
         }
-
-        I->vertWeight = Alloc(int, n);
+	}
+	if (ok)
+	  I->vertWeight = pymol::malloc<int>(n);
+	CHECKOK(ok, I->vertWeight);
+	if (ok){
         for(a = 0; a < n; a++) {
           I->vertWeight[a] = 2;
         }
       }
+      }
 
       if(ok) {
         ok = TriangleFill(I, v, vn, n, true);
diff -upNr pymol-open-source-2.3.0/layer0/Util.cpp pymol-open-source-2.3.3/layer0/Util.cpp
--- pymol-open-source-2.3.0/layer0/Util.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Util.cpp	2019-08-22 10:24:47.670587874 +0200
@@ -29,8 +29,8 @@ struct _CUtil {
 
 int UtilInit(PyMOLGlobals *G) 
 {
-  G->Util = Calloc(CUtil,1);
-  G->Util->StartSec = UtilGetSeconds(G);
+  G->Util = pymol::calloc<CUtil>(1);
+  G->Util->StartSec = UtilGetSecondsEpoch();
   return 1;
 }
 
@@ -66,18 +66,27 @@ int UtilCountStringVLA(char *vla)
   return(result);
 }
 
+/**
+ * Get a timestamp in seconds since PyMOL was started
+ */
 double UtilGetSeconds(PyMOLGlobals *G)
 {
+  return UtilGetSecondsEpoch() - G->Util->StartSec;
+}
+
+/**
+ * Get a timestamp in seconds since 1970-01-01
+ */
+double UtilGetSecondsEpoch()
+{
 #ifndef _WIN32
-  /* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in "os_proprietary.h") */
   struct timeval tv;
   gettimeofday(&tv,NULL);
-  return((tv.tv_sec+(tv.tv_usec/((double)1000000.0)))-G->Util->StartSec);
-  /* END PROPRIETARY CODE SEGMENT */
+  return tv.tv_sec + (tv.tv_usec / 1e6);
 #else
    struct __timeb64 timebuffer;
    _ftime64( &timebuffer );
-   return((timebuffer.time+(timebuffer.millitm/((double)1000.0)))-G->Util->StartSec);
+   return timebuffer.time + (timebuffer.millitm / 1e3);
 #endif
 }
 
@@ -281,7 +290,7 @@ void *UtilArrayCalloc(unsigned int *dim,
   for(a=0;a<ndim;a++)
 	 size = size * dim[a];
   size = size + sum;
-  result = (void*)mcalloc(size*2,1); /* what is this *2 for ??? */
+  result = pymol::calloc<char>(size);
 
   if(result) {
     chunk = 1;
@@ -405,7 +414,7 @@ int UtilSemiSortFloatIndex(int n,float *
 
 int UtilSemiSortFloatIndexWithNBins(int n, int nbins, float *array, int *destx, int forward)
 {
-  int *start1 = Calloc(int,n + nbins);
+  int *start1 = pymol::calloc<int>(n + nbins);
   int ret = UtilSemiSortFloatIndexWithNBinsImpl(start1, n, nbins, array, destx, forward);
   mfree(start1);
   return ret;
@@ -509,8 +518,8 @@ void UtilSortInPlace(PyMOLGlobals *G,voi
   int a;
   if(nItem>0)
 	 {
-	   tmp = Alloc(char,(itemSize*nItem));
-	   index = Alloc(int,nItem+1);
+	   tmp = pymol::malloc<char>((itemSize*nItem));
+	   index = pymol::malloc<int>(nItem+1);
 	   ErrChkPtr(G,tmp);
 	   ErrChkPtr(G,index);
 	   UtilSortIndex(nItem,array,index,fOrdered);
diff -upNr pymol-open-source-2.3.0/layer0/Util.h pymol-open-source-2.3.3/layer0/Util.h
--- pymol-open-source-2.3.0/layer0/Util.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Util.h	2019-08-22 10:24:47.670587874 +0200
@@ -39,6 +39,7 @@ void UtilStripANSIEscapes(char *s);
 void UtilStripANSIEscapes(std::string& str);
 int UtilCountStringVLA(char *vla);
 
+double UtilGetSecondsEpoch();
 double UtilGetSeconds(PyMOLGlobals * G);
 int UtilInit(PyMOLGlobals * G);
 void UtilFree(PyMOLGlobals * G);
diff -upNr pymol-open-source-2.3.0/layer0/Vector.cpp pymol-open-source-2.3.3/layer0/Vector.cpp
--- pymol-open-source-2.3.0/layer0/Vector.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Vector.cpp	2019-08-22 10:24:47.670587874 +0200
@@ -1780,7 +1780,7 @@ double distance_halfline2point3f(const f
     else
       return (sqrt1d(result));
   } else {
-    return (MAXFLOAT);
+    return FLT_MAX;
   }
 }
 
diff -upNr pymol-open-source-2.3.0/layer0/Vector.h pymol-open-source-2.3.3/layer0/Vector.h
--- pymol-open-source-2.3.0/layer0/Vector.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Vector.h	2019-08-22 10:24:47.670587874 +0200
@@ -398,7 +398,7 @@ inline void cross_product3f(const float
   cross[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);
 }
 
-__inline__ static double inline_sqrt1f(float f)
+inline double inline_sqrt1f(float f)
 {                               /* no good as a macro because f is used twice */
   if(f > _0f_inline)
     return (sqrt(f));
@@ -406,7 +406,7 @@ __inline__ static double inline_sqrt1f(f
     return (_0d_inline);
 }
 
-__inline__ static double inline_sqrt1d(double f)
+inline double inline_sqrt1d(double f)
 {                               /* no good as a macro because f is used twice */
   if(f > _0d_inline)
     return (sqrt(f));
@@ -422,7 +422,7 @@ inline float length2f(const float * v1)
   return sqrt1f((v1[0] * v1[0]) + (v1[1] * v1[1]));
 }
 
-__inline__ static void inline_normalize3f(float *v1)
+inline void inline_normalize3f(float *v1)
 {
   double vlen = length3f(v1);
   if(vlen > R_SMALLd_inline) {
@@ -435,7 +435,7 @@ __inline__ static void inline_normalize3
   }
 }
 
-__inline__ static double inline_diff3f(const float *v1, const float *v2)
+inline double inline_diff3f(const float *v1, const float *v2)
 {
   float dx, dy, dz;
   dx = (v1[0] - v2[0]);
@@ -444,7 +444,7 @@ __inline__ static double inline_diff3f(c
   return (sqrt1d(dx * dx + dy * dy + dz * dz));
 }
 
-__inline__ static float inline_diffsq3f(const float *v1, const float *v2)
+inline float inline_diffsq3f(const float *v1, const float *v2)
 {
   float dx, dy, dz;
   dx = (v1[0] - v2[0]);
@@ -455,7 +455,7 @@ __inline__ static float inline_diffsq3f(
   return (dz * dz + (dx + dy));
 }
 
-__inline__ static int inline_within3f(const float *v1, const float *v2, float dist)
+inline int inline_within3f(const float *v1, const float *v2, float dist)
 {
   float dx, dy, dz, dist2;
   dx = (float) fabs(v1[0] - v2[0]);
@@ -473,7 +473,7 @@ __inline__ static int inline_within3f(co
   return (((dx + dy) + dz * dz) <= dist2);
 }
 
-__inline__ static int inline_within3fsq(const float *v1, const float *v2, float dist, float dist2)
+inline int inline_within3fsq(const float *v1, const float *v2, float dist, float dist2)
 {
   /* manually optimized to take advantage of parallel execution units */
   float dx, dy, dz;
@@ -498,7 +498,7 @@ __inline__ static int inline_within3fsq(
   return ((dx + dz) <= (dist2));
 }
 
-__inline__ static int inline_within3fret(const float *v1, const float *v2, float cutoff,
+inline int inline_within3fret(const float *v1, const float *v2, float cutoff,
                                          const float cutoff2, float *diff, float *dist)
 {
   float dx, dy, dz, dist2;
@@ -519,7 +519,7 @@ __inline__ static int inline_within3fret
   return 1;
 }
 
-__inline__ static void inline_remove_component3f(const float *v1, const float *unit, float *result)
+inline void inline_remove_component3f(const float *v1, const float *unit, float *result)
 {
   float dot;
 
@@ -529,7 +529,7 @@ __inline__ static void inline_remove_com
   result[2] = v1[2] - unit[2] * dot;
 }
 
-__inline__ static float inline_project3f(const float *v1, const float *v2, float *proj)
+inline float inline_project3f(const float *v1, const float *v2, float *proj)
 {
   float dot;
 
diff -upNr pymol-open-source-2.3.0/layer0/Version.h pymol-open-source-2.3.3/layer0/Version.h
--- pymol-open-source-2.3.0/layer0/Version.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Version.h	2019-08-22 10:24:47.670587874 +0200
@@ -1,5 +1,5 @@
 #ifndef _PyMOL_VERSION
-#define _PyMOL_VERSION "2.3.0"
+#define _PyMOL_VERSION "2.4.0a0"
 #endif
 
 /* for session file compatibility */
diff -upNr pymol-open-source-2.3.0/layer0/Word.cpp pymol-open-source-2.3.3/layer0/Word.cpp
--- pymol-open-source-2.3.0/layer0/Word.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Word.cpp	2019-08-22 10:24:47.670587874 +0200
@@ -52,7 +52,6 @@ struct _CWordMatcher {
 #define cMatchAlphaRange  cWordMatchOptionAlphaRanges
 #define cMatchWildcard 3
 
-#ifndef _PYMOL_INLINE
 int WordCompare(PyMOLGlobals * G, const char *p, const char *q, int ignCase)
 
 
@@ -93,7 +92,6 @@ int WordCompare(PyMOLGlobals * G, const
     return 1;
   return 0;
 }
-#endif
 
 void WordMatchOptionsConfigInteger(CWordMatchOptions * I)
 {
@@ -591,8 +589,8 @@ CWordList *WordListNew(PyMOLGlobals * G,
     }
     /* allocate the storage we'll need to hold the words */
     {
-      I->word = Alloc(char, len);
-      I->start = Alloc(char *, n_word);
+      I->word = pymol::malloc<char>(len);
+      I->start = pymol::malloc<char *>(n_word);
 
       /* and copy the words */
 
@@ -670,7 +668,7 @@ int WordInit(PyMOLGlobals * G)
 {
   CWord *I = NULL;
 
-  I = (G->Word = Calloc(CWord, 1));
+  I = (G->Word = pymol::calloc<CWord>(1));
   if(I) {
     return 1;
   } else
diff -upNr pymol-open-source-2.3.0/layer0/Word.h pymol-open-source-2.3.3/layer0/Word.h
--- pymol-open-source-2.3.0/layer0/Word.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer0/Word.h	2019-08-22 10:24:47.670587874 +0200
@@ -91,52 +91,8 @@ int WordIndex(PyMOLGlobals * G, WordType
 int WordKey(PyMOLGlobals * G, WordKeyValue * list, const char *word, int minMatch, int ignCase,
             int *exact);
 
-#ifdef _PYMOL_INLINE
-__inline__ static int WordCompare(PyMOLGlobals * G, const char *p, const char *q, int ignCase)
-
-
-/* all things equal, shorter is smaller */
-{
-  int result = 0;
-  char cp, cq, tlp, tlq;
-  if(ignCase) {
-    while((cp = *p) && (cq = *q)) {
-      p++;
-      q++;
-      if(cp != cq) {
-        (tlp = tolower(cp));
-        (tlq = tolower(cq));
-        if(tlp < tlq)
-          return -1;
-        else if(tlp > tlq) {
-          return 1;
-        }
-      }
-    }
-  } else {
-    while((cp = *p) && (cq = *q)) {
-      p++;
-      q++;
-      if(cp != cq) {
-        if(cp < cq) {
-          return -1;
-        } else if(cp > cq) {
-          return 1;
-        }
-      }
-    }
-  }
-  if((!result) && (!*p) && (*q))
-    return -1;
-  else if((!result) && (*p) && (!*q))
-    return 1;
-  return 0;
-}
-#else
 int WordCompare(PyMOLGlobals * G, const char *p, const char *q, int ignCase);
 
-#endif
-
 inline int WordCompare(PyMOLGlobals * G, const lexidx_t& s1, const lexidx_t& s2, int ignCase) {
   if (s1 == s2)
     return 0;
diff -upNr pymol-open-source-2.3.0/layer1/Basis.cpp pymol-open-source-2.3.3/layer1/Basis.cpp
--- pymol-open-source-2.3.0/layer1/Basis.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/Basis.cpp	2019-08-22 10:24:47.674588525 +0200
@@ -15,8 +15,6 @@ I* Additional authors of this source fil
 Z* -------------------------------------------------------------------
 */
 
-#ifndef _PYMOL_INLINE
-
 #include"os_predef.h"
 #include"os_std.h"
 
@@ -34,9 +32,6 @@ static const float kR_SMALL5 = 0.0001F;
 #define EPSILON 0.000001F
 
 /*========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int ZLineToSphere(float *base, float *point, float *dir, float radius,
                          float maxial, float *sphere, float *asum, float *pre)
 {
@@ -90,7 +85,7 @@ static int ZLineToSphere(float *base, fl
   if(ab_dangle > kR_SMALL4)
     tan_acos_dangle = (float) (sqrt1d(1.0 - dangle * dangle) / dangle);
   else
-    tan_acos_dangle = MAXFLOAT;
+    tan_acos_dangle = FLT_MAX;
 
   /* now we need to define the triangle in the perp-plane  
      to figure out where the projected line intersection point is */
@@ -159,9 +154,6 @@ static int ZLineToSphere(float *base, fl
   return (1);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int LineToSphere(float *base, float *ray, float *point, float *dir, float radius,
                         float maxial, float *sphere, float *asum)
 {
@@ -244,7 +236,7 @@ static int LineToSphere(float *base, flo
   if(ab_dangle > kR_SMALL4)
     tan_acos_dangle = (float) (sqrt1d(1.0 - dangle * dangle) / dangle);
   else
-    tan_acos_dangle = MAXFLOAT;
+    tan_acos_dangle = FLT_MAX;
 
   /* now we need to define the triangle in the perp-plane  
      to figure out where the projected line intersection point is */
@@ -315,9 +307,6 @@ static int LineToSphere(float *base, flo
   return (1);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int FrontToInteriorSphere(float *front,
                                  float *point,
                                  float *dir, float radius, float radius2, float maxial)
@@ -347,9 +336,6 @@ static int FrontToInteriorSphere(float *
 
 
 /*========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int ZLineToSphereCapped(float *base, float *point,
                                float *dir, float radius, float maxial,
                                float *sphere, float *asum, int cap1, int cap2, float *pre)
@@ -572,9 +558,6 @@ static int ZLineToSphereCapped(float *ba
   return (1);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int LineToSphereCapped(float *base, float *ray,
                               float *point, float *dir, float radius, float maxial,
                               float *sphere, float *asum, int cap1, int cap2)
@@ -1073,9 +1056,6 @@ static int ConeLineToSphereCapped(float
   return 0;
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int FrontToInteriorSphereCapped(float *front,
                                        float *point,
                                        float *dir,
@@ -1108,13 +1088,10 @@ static int FrontToInteriorSphereCapped(f
 
 
 /*========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static float ZLineClipPoint(float *base, float *point, float *alongNormalSq, float cutoff)
 {
   float hyp0, hyp1, hyp2;
-  float result = MAXFLOAT;
+  float result = FLT_MAX;
 
   /* this routine determines whether or not a vector starting at "base"
      heading in the direction "normal" intersects a sphere located at "point".
@@ -1143,14 +1120,11 @@ static float ZLineClipPoint(float *base,
   return result;
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static float ZLineClipPointNoZCheck(float *base, float *point, float *alongNormalSq,
                                     float cutoff)
 {
   float hyp0, hyp1, hyp2;
-  float result = MAXFLOAT;
+  float result = FLT_MAX;
 
   /* this routine determines whether or not a vector starting at "base"
      heading in the direction "normal" intersects a sphere located at "point".
@@ -1178,9 +1152,6 @@ static float ZLineClipPointNoZCheck(floa
   return result;
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int LineClipPoint(float *base, float *ray,
                          float *point, float *dist, float cutoff, float cutoff2)
 {
@@ -1524,9 +1495,6 @@ int n_sausages = 0;
 int n_skipped = 0;
 #endif
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 int BasisHitPerspective(BasisCallRec * BC)
 {
   CBasis *BI = BC->Basis;
@@ -1617,7 +1585,7 @@ int BasisHitPerspective(BasisCallRec * B
 
     elist = map->EList;
 
-    r_dist = MAXFLOAT;
+    r_dist = FLT_MAX;
 
     excl_trans_flag = (excl_trans != _0);
 
@@ -2021,9 +1989,6 @@ int BasisHitPerspective(BasisCallRec * B
   }
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 int BasisHitOrthoscopic(BasisCallRec * BC)
 {
   const float _0 = 0.0F, _1 = 1.0F;
@@ -2073,7 +2038,7 @@ int BasisHitOrthoscopic(BasisCallRec * B
 
     excl_trans_flag = (excl_trans != _0);
 
-    r_dist = MAXFLOAT;
+    r_dist = FLT_MAX;
 
     xxtmp = BI->Map->EHead + (a * BI->Map->D1D2) + (b * BI->Map->Dim[2]) + c;
 
@@ -2345,9 +2310,6 @@ int BasisHitOrthoscopic(BasisCallRec * B
   return (-1);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 int BasisHitShadow(BasisCallRec * BC)
 {
   const float _0 = 0.0F;
@@ -2398,7 +2360,7 @@ int BasisHitShadow(BasisCallRec * BC)
       except2 = vert2prim[except2];
 
     r_trans = _1;
-    r_dist = MAXFLOAT;
+    r_dist = FLT_MAX;
 
     xxtmp = BI->Map->EHead + (a * BI->Map->D1D2) + (b * BI->Map->Dim[2]) + c;
 
@@ -3283,10 +3245,10 @@ int BasisMakeMap(CBasis * I, int *vert2p
       int prm_index;
       MapType *map = I->Map;
 
-      prm_spanner = Calloc(int, n_prim);
+      prm_spanner = pymol::calloc<int>(n_prim);
       CHECKOK(ok, prm_spanner);
       if (ok)
-	spanner = Calloc(int, n);
+	spanner = pymol::calloc<int>(n);
       CHECKOK(ok, spanner);
 
       /* figure out which primitives span more than one voxel */
@@ -3681,8 +3643,3 @@ void BasisCylinderSausagePrecompute(floa
   pre[0] = dir[1] * ln;
   pre[1] = -dir[0] * ln;
 }
-
-#else
-typedef int this_file_is_no_longer_empty;
-
-#endif
diff -upNr pymol-open-source-2.3.0/layer1/CGO.cpp pymol-open-source-2.3.3/layer1/CGO.cpp
--- pymol-open-source-2.3.0/layer1/CGO.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/CGO.cpp	2019-08-22 10:24:47.678589177 +0200
@@ -184,7 +184,7 @@ int CGORendererInit(PyMOLGlobals * G)
 {
   CCGORenderer *I = NULL;
 
-  I = (G->CGORenderer = Calloc(CCGORenderer, 1));
+  I = (G->CGORenderer = pymol::calloc<CCGORenderer>(1));
   if(I) {
     I->G = G;
     I->isPicking = false;
@@ -2209,7 +2209,7 @@ static int OptimizePointsToVBO(const CGO
   //    tot = num_total_indexes * (3 * 3 + 2) ;
   /* NOTE/TODO: Not sure why 3*5 needs to be used, but 3*3+2, which is the 
      correct length, crashes in glBufferData */
-  vertexVals = Alloc(float, tot);
+  vertexVals = pymol::malloc<float>(tot);
   CHECKOK(ok, vertexVals);
   if (!ok){
     PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: OptimizePointsToVBO() vertexVals could not be allocated\n" ENDFB(I->G);	
@@ -2786,7 +2786,7 @@ CGO *CGOOptimizeToVBONotIndexed(const CG
   int num_total_vertices = 0, num_total_indexes = 0, num_total_vertices_lines = 0, num_total_indexes_lines = 0,
     num_total_vertices_points = 0;
   short has_draw_buffer = false;
-  float min[3] = { MAXFLOAT, MAXFLOAT, MAXFLOAT }, max[3] = { -MAXFLOAT, -MAXFLOAT, -MAXFLOAT };
+  float min[3] = { FLT_MAX, FLT_MAX, FLT_MAX }, max[3] = { -FLT_MAX, -FLT_MAX, -FLT_MAX };
   int ambient_occlusion = 0;
   int ok = true;
   cgo = CGONewSized(I->G, 0);
@@ -2817,7 +2817,7 @@ CGO *CGOOptimizeToVBONotIndexed(const CG
        correct length, crashes in glBufferData */
     /* before allocating anything, we should check to make sure that we have enough memory on IOS,
        otherwise we should just fail */
-    vertexVals = Alloc(float, tot);
+    vertexVals = pymol::malloc<float>(tot);
     if (!vertexVals){
       PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeToVBONotIndexed() vertexVals could not be allocated\n" ENDFB(I->G);	
       CGOFree(cgo);
@@ -2942,7 +2942,7 @@ CGO *CGOOptimizeToVBONotIndexed(const CG
     //    tot = num_total_indexes * (3 * 3 + 2) ;
     /* NOTE/TODO: Not sure why 3*5 needs to be used, but 3*3+2, which is the 
        correct length, crashes in glBufferData */
-    vertexVals = Alloc(float, tot);
+    vertexVals = pymol::malloc<float>(tot);
     if (!vertexVals){
       PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeToVBONotIndexed() vertexVals could not be allocated\n" ENDFB(I->G);	
       CGOFree(cgo);
@@ -3206,7 +3206,7 @@ CGO *CGOOptimizeToVBOIndexed(CGO * I, in
   int num_total_vertices = 0, num_total_indexes = 0, num_total_vertices_lines = 0, num_total_indexes_lines = 0,
     num_total_vertices_points = 0;
   short has_draw_buffer = false;
-  float min[3] = { MAXFLOAT, MAXFLOAT, MAXFLOAT }, max[3] = { -MAXFLOAT, -MAXFLOAT, -MAXFLOAT };
+  float min[3] = { FLT_MAX, FLT_MAX, FLT_MAX }, max[3] = { -FLT_MAX, -FLT_MAX, -FLT_MAX };
   int ok = true;
 
   CGOCountNumVertices(I, &num_total_vertices, &num_total_indexes,
@@ -3264,7 +3264,7 @@ CGO *CGOOptimizeToVBOIndexed(CGO * I, in
       // round to 4 byte words for the length of the CGO
       n_data = bytes_to_allocate / 4 + (((bytes_to_allocate % 4) == 0) ? 0 : 1) ;
     }
-    vertexIndices = Calloc(GL_C_INT_TYPE, num_total_indexes);
+    vertexIndices = pymol::calloc<GL_C_INT_TYPE>(num_total_indexes);
     vertexIndicesAllocated = 1;
     if (!vertexIndices){
       PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeToVBOIndexed() vertexIndices could not be allocated\n" ENDFB(I->G);	
@@ -3275,7 +3275,7 @@ CGO *CGOOptimizeToVBOIndexed(CGO * I, in
     //    tot = num_total_vertices * (3 * 3 + 2) ;
     /* NOTE/TODO: Not sure why 3*5 needs to be used, but 3*3+2, which is the 
        correct length, crashes in glBufferData */
-    vertexVals = Alloc(float, tot);
+    vertexVals = pymol::malloc<float>(tot);
     if (!vertexVals){
       PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeToVBOIndexed() vertexVals could not be allocated\n" ENDFB(I->G);	
       CGOFree(cgo);
@@ -3577,7 +3577,7 @@ CGO *CGOOptimizeToVBOIndexed(CGO * I, in
 
     pc = I->op;
     hasNormals = !CGOHasAnyLineVerticesWithoutNormals(I);
-    vertexIndexes = Alloc(GL_C_INT_TYPE, num_total_indexes_lines);
+    vertexIndexes = pymol::malloc<GL_C_INT_TYPE>(num_total_indexes_lines);
     if (!vertexIndexes){
       PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeToVBOIndexed() vertexIndexes could not be allocated\n" ENDFB(I->G);	
       CGOFree(cgo);
@@ -3587,7 +3587,7 @@ CGO *CGOOptimizeToVBOIndexed(CGO * I, in
     //    tot = num_total_vertices * (3 * 3 + 2) ;
     /* NOTE/TODO: Not sure why 3*5 needs to be used, but 3*3+2, which is the 
        correct length, crashes in glBufferData */
-    vertexVals = Alloc(float, tot);
+    vertexVals = pymol::malloc<float>(tot);
     if (!vertexVals){
       PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeToVBOIndexed() vertexVals could not be allocated\n" ENDFB(I->G);	
       CGOFree(cgo);
@@ -3853,7 +3853,7 @@ CGO *CGOOptimizeSpheresToVBONonIndexed(c
   float *save_pc;
   int num_total_spheres = 0;
   short has_draw_buffer = false;
-  float min[3] = { MAXFLOAT, MAXFLOAT, MAXFLOAT }, max[3] = { -MAXFLOAT, -MAXFLOAT, -MAXFLOAT };
+  float min[3] = { FLT_MAX, FLT_MAX, FLT_MAX }, max[3] = { -FLT_MAX, -FLT_MAX, -FLT_MAX };
   int vv, total_vert = 0, total_spheres = 0;
   int ok = true;
 
@@ -3878,14 +3878,14 @@ CGO *CGOOptimizeSpheresToVBONonIndexed(c
 
     cgo_shader_ub_flags = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_flags);
   
-    org_vertVals = vertVals = Alloc(float, tot);
+    org_vertVals = vertVals = pymol::malloc<float>(tot);
     if (!org_vertVals){
       PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeSpheresToVBONonIndexed() org_vertVals could not be allocated\n" ENDFB(I->G);	
       CGOFree(cgo);
       return (NULL);
     }
 
-    org_colorValsUB = colorValsUB = Alloc(GLubyte, tot);
+    org_colorValsUB = colorValsUB = pymol::malloc<GLubyte>(tot);
     if (!org_colorValsUB){
       PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeSpheresToVBONonIndexed() org_colorValsUB could not be allocated\n" ENDFB(I->G);	
       FreeP(org_vertVals);
@@ -3894,7 +3894,7 @@ CGO *CGOOptimizeSpheresToVBONonIndexed(c
     }
 
     if (cgo_shader_ub_flags){
-      org_rightUpFlagValsUB = rightUpFlagValsUB = Alloc(GLubyte, VALUES_PER_IMPOSTER_SPACE_COORD * VERTICES_PER_SPHERE * num_total_spheres);
+      org_rightUpFlagValsUB = rightUpFlagValsUB = pymol::malloc<GLubyte>(VALUES_PER_IMPOSTER_SPACE_COORD * VERTICES_PER_SPHERE * num_total_spheres);
       if (!org_rightUpFlagValsUB){
 	PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeSpheresToVBONonIndexed() org_rightUpFlagValsUB could not be allocated\n" ENDFB(I->G);	
 	FreeP(org_colorValsUB);	FreeP(org_vertVals);
@@ -3902,7 +3902,7 @@ CGO *CGOOptimizeSpheresToVBONonIndexed(c
 	return (NULL);
       }
     } else {
-      org_rightUpFlagVals = rightUpFlagVals = Alloc(float, VALUES_PER_IMPOSTER_SPACE_COORD * VERTICES_PER_SPHERE * num_total_spheres);
+      org_rightUpFlagVals = rightUpFlagVals = pymol::malloc<float>(VALUES_PER_IMPOSTER_SPACE_COORD * VERTICES_PER_SPHERE * num_total_spheres);
       if (!org_rightUpFlagVals){
 	PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeSpheresToVBONonIndexed() org_rightUpFlagVals could not be allocated\n" ENDFB(I->G);	
 	FreeP(org_colorValsUB);	FreeP(org_vertVals);
@@ -3912,7 +3912,7 @@ CGO *CGOOptimizeSpheresToVBONonIndexed(c
     }
     if (has_picking){
       // atom/bond info for picking, 2 ints for each sphere
-      org_pickcolorVals = pickcolorVals = Alloc(int, num_total_spheres * 2 * 4);
+      org_pickcolorVals = pickcolorVals = pymol::malloc<int>(num_total_spheres * 2 * 4);
     }
 
     pc = I->op;
@@ -4162,14 +4162,15 @@ CGO *CGOSimplify(const CGO * I, int est,
         float mid[3];
         mult3f(cyl->axis, .5f, mid);
         add3f(cyl->origin, mid, mid);
+        float alpha2 = cyl->alpha >= 0.f ? cyl->alpha : cgo->alpha;
         if (cap & cCylShaderInterpColor){
-          ok &= CGOSimpleCylinder(cgo, cyl->origin, v1, cyl->tube_size, color1, cyl->color2, cyl->alpha, cyl->alpha, true, bcap, fcap, &pickcolor2, stick_round_nub);
+          ok &= CGOSimpleCylinder(cgo, cyl->origin, v1, cyl->tube_size, color1, cyl->color2, cgo->alpha, alpha2, true, bcap, fcap, &pickcolor2, stick_round_nub);
         } else {
           ok &= CGOColorv(cgo, color1);
-          ok &= CGOSimpleCylinder(cgo, cyl->origin, mid, cyl->tube_size, color1, NULL, cyl->alpha, cyl->alpha, false, fcap, 0, nullptr, stick_round_nub);
+          ok &= CGOSimpleCylinder(cgo, cyl->origin, mid, cyl->tube_size, color1, NULL, cgo->alpha, alpha2, false, fcap, 0, nullptr, stick_round_nub);
           ok &= CGOColorv(cgo, cyl->color2);
           ok &= CGOPickColor(cgo, pickcolor2.index, pickcolor2.bond);
-          ok &= CGOSimpleCylinder(cgo, mid, v1, cyl->tube_size, cyl->color2, NULL, cyl->alpha, cyl->alpha, false, 0, bcap, nullptr, stick_round_nub);
+          ok &= CGOSimpleCylinder(cgo, mid, v1, cyl->tube_size, cyl->color2, NULL, cgo->alpha, alpha2, false, 0, bcap, nullptr, stick_round_nub);
         }
       }
       break;
@@ -4471,14 +4472,15 @@ CGO *CGOSimplifyNoCompress(const CGO * I
         float mid[3];
         mult3f(cyl->axis, .5f, mid);
         add3f(cyl->origin, mid, mid);
+        float alpha2 = cyl->alpha >= 0.f ? cyl->alpha : cgo->alpha;
         if (cap & cCylShaderInterpColor){
-          ok &= CGOSimpleCylinder(cgo, cyl->origin, v1, cyl->tube_size, color1, cyl->color2, cyl->alpha, cyl->alpha, true, bcap, fcap, &pickcolor2, stick_round_nub);
+          ok &= CGOSimpleCylinder(cgo, cyl->origin, v1, cyl->tube_size, color1, cyl->color2, cgo->alpha, alpha2, true, bcap, fcap, &pickcolor2, stick_round_nub);
         } else {
           ok &= CGOColorv(cgo, color1);
-          ok &= CGOSimpleCylinder(cgo, cyl->origin, mid, cyl->tube_size, color1, NULL, cyl->alpha, cyl->alpha, false, fcap, 0, NULL, stick_round_nub);
+          ok &= CGOSimpleCylinder(cgo, cyl->origin, mid, cyl->tube_size, color1, NULL, cgo->alpha, alpha2, false, fcap, 0, NULL, stick_round_nub);
           ok &= CGOColorv(cgo, cyl->color2);
           ok &= CGOPickColor(cgo, pickcolor2.index, pickcolor2.bond);
-          ok &= CGOSimpleCylinder(cgo, mid, v1, cyl->tube_size, cyl->color2, NULL, cyl->alpha, cyl->alpha, false, 0, bcap, NULL, stick_round_nub);
+          ok &= CGOSimpleCylinder(cgo, mid, v1, cyl->tube_size, cyl->color2, NULL, cgo->alpha, alpha2, false, 0, bcap, NULL, stick_round_nub);
         }
       }
       break;
@@ -4565,25 +4567,25 @@ CGO *CGOOptimizeTextures(CGO * I, int es
   if (num_total_textures){
     float *worldPos, *screenValues, *textExtents, *pickColorVals;
     int place3 = 0, place2 = 0;
-    worldPos = Alloc(float, num_total_textures * 18);
+    worldPos = pymol::malloc<float>(num_total_textures * 18);
     if (!worldPos){
       PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeTextures() worldPos could not be allocated\n" ENDFB(I->G);
       return NULL;
     }
-    screenValues = Alloc(float, num_total_textures * 18);
+    screenValues = pymol::malloc<float>(num_total_textures * 18);
     if (!screenValues){
       PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeTextures() screenValues could not be allocated\n" ENDFB(I->G);
       FreeP(worldPos);
       return NULL;
     }
-    textExtents = Alloc(float, num_total_textures * 12);
+    textExtents = pymol::malloc<float>(num_total_textures * 12);
     if (!textExtents){
       PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeTextures() textExtents could not be allocated\n" ENDFB(I->G);
       FreeP(screenValues);
       FreeP(worldPos);
       return NULL;
     }
-    pickColorVals = Alloc(float, num_total_textures * 12); /* pick index and bond */
+    pickColorVals = pymol::malloc<float>(num_total_textures * 12); /* pick index and bond */
     if (!pickColorVals){
       PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeTextures() pickColorVals could not be allocated\n" ENDFB(I->G);
       FreeP(textExtents);
@@ -4776,7 +4778,7 @@ CGO *CGOOptimizeLabels(CGO * I, int est,
     float *targetPos, *worldPos, *screenValues, *screenWorldValues, *textExtents, *pickColorVals;
     float *relativeMode;
     int place3 = 0, place2 = 0, place = 0;
-    worldPos = Alloc(float, num_total_labels * 6 * 17); 
+    worldPos = pymol::malloc<float>(num_total_labels * 6 * 17); 
     if (!worldPos){
       PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeLabels() worldPos could not be allocated\n" ENDFB(I->G);
       return NULL;
@@ -4939,7 +4941,7 @@ CGO *CGOOptimizeConnectors(CGO * I, int
     uchar *relativeMode, *drawBkgrd;
     uchar *isCenterPt = NULL;
     int place3 = 0, place2 = 0, place = 0;
-    targetPt3d = Calloc(float, num_total_connectors * 20 * factor); /* too much, relativeMode only needs 1 byte per vertex, instead of 1 float */
+    targetPt3d = pymol::calloc<float>(num_total_connectors * 20 * factor); /* too much, relativeMode only needs 1 byte per vertex, instead of 1 float */
     if (!targetPt3d){
       PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeConnectors() could not be allocated\n" ENDFB(I->G);
       return NULL;
@@ -5687,17 +5689,19 @@ int CGORenderRay(CGO * I, CRay * ray, Re
         const float *color1 = c0;
         const float *color2 = cyl->color2;
         add3f(cyl->origin, cyl->axis, v1);
+        float alpha1 = I->G->CGORenderer->alpha;
+        float alpha2 = cyl->alpha >= 0.f ? cyl->alpha : alpha1;
         if (colorinterp || equal3f(color1, color2)) {
-          ok &= ray->customCylinder3fv(pc, v1, cyl->tube_size, color1, color2, fcap, bcap, cyl->alpha, cyl->alpha);
+          ok &= ray->customCylinder3fv(pc, v1, cyl->tube_size, color1, color2, fcap, bcap, alpha1, alpha2);
         } else {
           float mid[3];
           mult3f(cyl->axis, .5f, mid);
           add3f(cyl->origin, mid, mid);
 
           ray->color3fv(c0);
-          ok &= ray->customCylinder3fv(cyl->origin, mid, cyl->tube_size, color1, color1, fcap, 0, cyl->alpha, cyl->alpha);
+          ok &= ray->customCylinder3fv(cyl->origin, mid, cyl->tube_size, color1, color1, fcap, 0, alpha1, alpha2);
           ray->color3fv(cyl->color2);
-          ok &= ray->customCylinder3fv(mid, v1, cyl->tube_size, color2, color2, 0, bcap, cyl->alpha, cyl->alpha);
+          ok &= ray->customCylinder3fv(mid, v1, cyl->tube_size, color2, color2, 0, bcap, alpha1, alpha2);
         }
       }
       break;
@@ -8148,7 +8152,7 @@ void CGORenderGLAlpha(CGO * I, RenderInf
     if(I->z_flag) {
       if(!I->i_start) {
         I->i_size = 256;
-        I->i_start = Calloc(int, I->i_size);
+        I->i_start = pymol::calloc<int>(I->i_size);
       } else {
         UtilZeroMem(I->i_start, sizeof(int) * I->i_size);
       }
@@ -9541,7 +9545,7 @@ CGO *CGOOptimizeScreenTexturesAndPolygon
 	}*/
       tot = num_total_indices * mul ;
     }
-    vertexVals = Alloc(float, tot);
+    vertexVals = pymol::malloc<float>(tot);
     if (!vertexVals){
       PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeScreenTexturesAndPolygons() vertexVals could not be allocated\n" ENDFB(I->G);	
       CGOFree(cgo);
@@ -11258,7 +11262,7 @@ CGO *CGOConvertToShader(const CGO *I, At
     int nfrags = nfragspergroup * ntotalverts/vertsperpickinfo;
     int nvertsperindivfrag = vertsperpickinfo/nfragspergroup;
     num_total_indexes = nfrags * nvertsperfrag;
-    vertexIndices = Calloc(GL_C_INT_TYPE, num_total_indexes);
+    vertexIndices = pymol::calloc<GL_C_INT_TYPE>(num_total_indexes);
     int idxpl=0;
     // using vertsperpickinfo as verts per frag
     for (int cnt = 0, vpl = 0; cnt < nfrags; ++cnt){
diff -upNr pymol-open-source-2.3.0/layer1/CGO.h pymol-open-source-2.3.3/layer1/CGO.h
--- pymol-open-source-2.3.0/layer1/CGO.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/CGO.h	2019-08-22 10:24:47.678589177 +0200
@@ -585,7 +585,7 @@ namespace cgo {
       static const int op_code = CGO_SHADER_CYLINDER_WITH_2ND_COLOR;
       shadercylinder2ndcolor(CGO *I, const float *_origin, const float *_axis, const float _radius,
                              int _cap, const float *_color2, Pickable *pickcolor2 = NULL,
-                             const float alpha = 1.0f);
+                             const float alpha = -1.f);
       float origin[3], axis[3], tube_size;
       int cap;
       float color2[3];
diff -upNr pymol-open-source-2.3.0/layer1/Character.cpp pymol-open-source-2.3.3/layer1/Character.cpp
--- pymol-open-source-2.3.0/layer1/Character.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/Character.cpp	2019-08-22 10:24:47.678589177 +0200
@@ -401,7 +401,7 @@ int CharacterGetGeometry(PyMOLGlobals *
 int CharacterInit(PyMOLGlobals * G)
 {
   CCharacter *I = NULL;
-  if((I = (G->Character = Calloc(CCharacter, 1)))) {
+  if((I = (G->Character = pymol::calloc<CCharacter>(1)))) {
     I->MaxAlloc = 5;
     I->Char = VLACalloc(CharRec, I->MaxAlloc + 1);
     {
@@ -410,7 +410,7 @@ int CharacterInit(PyMOLGlobals * G)
         I->Char[a].Prev = a - 1;
       I->LastFree = I->MaxAlloc;
     }
-    I->Hash = Calloc(int, (HASH_MASK + 1));
+    I->Hash = pymol::calloc<int>((HASH_MASK + 1));
     I->TargetMaxUsage = 25000;
     return 1;
   } else
diff -upNr pymol-open-source-2.3.0/layer1/Color.cpp pymol-open-source-2.3.3/layer1/Color.cpp
--- pymol-open-source-2.3.0/layer1/Color.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/Color.cpp	2019-08-22 10:24:47.678589177 +0200
@@ -182,7 +182,7 @@ ObjectGadgetRamp *ColorGetRamp(PyMOLGlob
     if(index < I->NExt) {
       if(!I->Ext[index].Ptr) {
         if(I->Ext[index].Name) {
-          char *name = OVLexicon_FetchCString(I->Lex, I->Ext[index].Name);
+          const char *name = I->Ext[index].Name;
           I->Ext[index].Ptr = (void *) ExecutiveFindObjectByName(G, name);
         }
       }
@@ -202,7 +202,7 @@ int ColorGetRamped(PyMOLGlobals * G, int
     if(index < I->NExt) {
       if(!I->Ext[index].Ptr) {
         if(I->Ext[index].Name) {
-          char *name = OVLexicon_FetchCString(I->Lex, I->Ext[index].Name);
+          const char *name = I->Ext[index].Name;
           I->Ext[index].Ptr = (void *) ExecutiveFindObjectByName(G, name);
         }
       }
@@ -261,9 +261,8 @@ static int ColorFindExtByName(PyMOLGloba
     best = &mybest;
   *best = 0;
   for(a = 0; a < I->NExt; a++) {
-    int color_lex = I->Ext[a].Name;
-    if(color_lex) {
-      char *color_name = OVLexicon_FetchCString(I->Lex, color_lex);
+    const char *color_name = I->Ext[a].Name;
+    if(color_name) {
       wm = WordMatch(G, name, color_name, true);
       if(wm < 0) {
         if(null_okay || (I->Ext[a].Ptr)) {
@@ -282,6 +281,24 @@ static int ColorFindExtByName(PyMOLGloba
   return (result);
 }
 
+/**
+ * Map name to index (idx[name] = index)
+ *
+ * @return pointer to stored name string
+ */
+static const char* reg_name(
+    std::unordered_map<std::string, CColor::ColorIdx>& idx, int index,
+    const char* name)
+{
+  auto handle = idx.emplace(name, index);
+
+  if (!handle.second) {
+    handle.first->second = index;
+  }
+
+  return handle.first->first.c_str();
+}
+
 void ColorRegisterExt(PyMOLGlobals * G, const char *name, void *ptr, int type)
 {
   CColor *I = G->Color;
@@ -292,15 +309,7 @@ void ColorRegisterExt(PyMOLGlobals * G,
     VLACheck(I->Ext, ExtRec, I->NExt);
     a = I->NExt;
     I->NExt++;
-    {
-      OVreturn_word result = OVLexicon_GetFromCString(I->Lex, name);
-      if(OVreturn_IS_OK(result)) {
-        OVOneToOne_Set(I->Idx, result.word, cColorExtCutoff - a);
-        I->Ext[a].Name = result.word;
-      } else {
-        I->Ext[a].Name = 0;
-      }
-    }
+    I->Ext[a].Name = reg_name(I->Idx, cColorExtCutoff - a, name);
   }
   if(a >= 0) {
     I->Ext[a].Ptr = ptr;
@@ -316,8 +325,7 @@ void ColorForgetExt(PyMOLGlobals * G, co
 
   if(a >= 0) {                  /* currently leaks memory in I->Ext array -- TODO fix */
     if(I->Ext[a].Name) {
-      OVLexicon_DecRef(I->Lex, I->Ext[a].Name);
-      OVOneToOne_DelForward(I->Idx, I->Ext[a].Name);
+      I->Idx.erase(I->Ext[a].Name);
     }
     I->Ext[a].Name = 0;
     I->Ext[a].Ptr = NULL;
@@ -336,7 +344,7 @@ PyObject *ColorExtAsPyList(PyMOLGlobals
   for(a = 0; a < I->NExt; a++) {
     list = PyList_New(2);
     {
-      const char *name = ext->Name ? OVLexicon_FetchCString(I->Lex, ext->Name) : "";
+      const char *name = ext->Name ? ext->Name : "";
       PyList_SetItem(list, 0, PyString_FromString(name));
     }
     PyList_SetItem(list, 1, PyInt_FromLong(ext->Type));
@@ -368,7 +376,7 @@ PyObject *ColorAsPyList(PyMOLGlobals * G
     if(color->Custom || color->LutColorFlag) {
       list = PyList_New(7);
       {
-        char *name = OVLexicon_FetchCString(I->Lex, color->Name);
+        const char *name = color->Name;
         PyList_SetItem(list, 0, PyString_FromString(name));
       }
       PyList_SetItem(list, 1, PyInt_FromLong(a));
@@ -462,12 +470,7 @@ int ColorExtFromPyList(PyMOLGlobals * G,
         WordType name;
         OVreturn_word result;
         ok = PConvPyStrToStr(PyList_GetItem(rec, 0), name, sizeof(WordType));
-        if(OVreturn_IS_OK(result = OVLexicon_GetFromCString(I->Lex, name))) {
-          OVOneToOne_Set(I->Idx, result.word, cColorExtCutoff - a);
-          ext->Name = result.word;
-        } else {
-          ext->Name = 0;
-        }
+        ext->Name = reg_name(I->Idx, cColorExtCutoff - a, name);
       }
       if(ok)
         ok = PConvPyIntToInt(PyList_GetItem(rec, 1), &ext->Type);
@@ -539,12 +542,7 @@ int ColorFromPyList(PyMOLGlobals * G, Py
           WordType name;
           OVreturn_word result;
           ok = PConvPyStrToStr(PyList_GetItem(rec, 0), name, sizeof(WordType));
-          if(OVreturn_IS_OK(result = OVLexicon_GetFromCString(I->Lex, name))) {
-            OVOneToOne_Set(I->Idx, result.word, index);
-            color->Name = result.word;
-          } else {
-            color->Name = 0;
-          }
+          color->Name = reg_name(I->Idx, index, name);
         }
         if(ok)
           ok = PConvPyListToFloatArrayInPlace(PyList_GetItem(rec, 2), color->Color, 3);
@@ -584,18 +582,16 @@ void ColorDef(PyMOLGlobals * G, const ch
   int wm;
 
   {
-    OVreturn_word result;
-    if(OVreturn_IS_OK(result = OVLexicon_BorrowFromCString(I->Lex, name)))
-      if(OVreturn_IS_OK(result = OVOneToOne_GetForward(I->Idx, result.word))) {
-        color = result.word;
+      auto it = I->Idx.find(name);
+      if(it != I->Idx.end()){
+        color = it->second;
       }
   }
 
   if(color < 0) {
     for(a = 0; a < I->NColor; a++) {
-      int color_ext = I->Color[a].Name;
-      if(color_ext) {
-        char *color_name = OVLexicon_FetchCString(I->Lex, color_ext);
+      auto* color_name = I->Color[a].Name;
+      if(color_name) {
         wm = WordMatch(G, name, color_name, true);
         if(wm < 0) {
           color = a;
@@ -610,13 +606,7 @@ void ColorDef(PyMOLGlobals * G, const ch
     color = I->NColor;
     VLACheck(I->Color, ColorRec, I->NColor);
     I->NColor++;
-
-    if(OVreturn_IS_OK(result = OVLexicon_GetFromCString(I->Lex, name))) {
-      OVOneToOne_Set(I->Idx, result.word, color);
-      I->Color[color].Name = result.word;
-    } else {
-      I->Color[color].Name = 0;
-    }
+    I->Color[color].Name = reg_name(I->Idx, color, name);
   }
 
   I->Color[color].Color[0] = v[0];
@@ -717,19 +707,17 @@ int ColorGetIndex(PyMOLGlobals * G, cons
   if(WordMatch(G, name, "back", true))
     return (cColorBack);
 
-  if(I->Lex) {                  /* search for a perfect match (fast!) */
-    OVreturn_word result;
-    if(OVreturn_IS_OK(result = OVLexicon_BorrowFromCString(I->Lex, name)))
-      if(OVreturn_IS_OK(result = OVOneToOne_GetForward(I->Idx, result.word))) {
+  {                  /* search for a perfect match (fast!) */
+      auto it = I->Idx.find(name);
+      if(it != I->Idx.end()){
         found = true;
-        color = result.word;
+        color = it->second;
       }
   }
   if(!found) {                  /* search for an imperfect match */
     for(a = 0; a < I->NColor; a++) {
-      int color_ext = I->Color[a].Name;
-      if(color_ext) {
-        char *color_name = OVLexicon_FetchCString(I->Lex, color_ext);
+      auto* color_name = I->Color[a].Name;
+      if(color_name) {
         wm = WordMatch(G, name, color_name, true);
         if(wm < 0) {
           color = a;
@@ -766,7 +754,7 @@ const char *ColorGetName(PyMOLGlobals *
 {
   CColor *I = G->Color;
   if((index >= 0) && (index < I->NColor)) {
-    return OVLexicon_FetchCString(I->Lex, I->Color[index].Name);
+    return I->Color[index].Name;
   } else if((index & cColor_TRGB_Mask) == cColor_TRGB_Bits) {
     index = (((index & 0xFFFFFF) | ((index << 2) & 0xFC000000) |        /* convert 6 bits of trans into 8 */
               ((index >> 4) & 0x03000000)));
@@ -778,7 +766,7 @@ const char *ColorGetName(PyMOLGlobals *
   } else if(index <= cColorExtCutoff) {
     int a = cColorExtCutoff - index;
     if(a < I->NExt) {
-      return OVLexicon_FetchCString(I->Lex, I->Ext[a].Name);
+      return I->Ext[a].Name;
     } else
       return NULL;
   }
@@ -794,9 +782,9 @@ int ColorGetStatus(PyMOLGlobals * G, int
      1 otherwise */
   int result = 0;
   if((index >= 0) && (index < I->NColor)) {
-    int color_ext = I->Color[index].Name;
-    if(color_ext) {
-      char *c = OVLexicon_FetchCString(I->Lex, color_ext);
+    auto* color_name = I->Color[index].Name;
+    if(color_name) {
+      const char* c = color_name;
       result = 1;
       while(*c) {
         if(((*c) >= '0') && ((*c) <= '9')) {
@@ -825,27 +813,12 @@ void ColorFree(PyMOLGlobals * G)
   CColor *I = G->Color;
   VLAFreeP(I->Color);
   VLAFreeP(I->Ext);
-  if(I->Lex)
-    OVLexicon_Del(I->Lex);
-  if(I->Idx)
-    OVOneToOne_Del(I->Idx);
   DeleteP(I);
 }
 
 
 /*========================================================================*/
 
-static int reg_name(OVLexicon * lex, OVOneToOne * o2o, int index, const char *name)
-{
-  OVreturn_word result;
-  if(OVreturn_IS_OK(result = OVLexicon_GetFromCString(lex, name))) {
-    OVOneToOne_Set(o2o, result.word, index);
-    return result.word;
-  } else {
-    return 0;
-  }
-}
-
 void ColorReset(PyMOLGlobals * G)
 {
 
@@ -1029,391 +1002,384 @@ void ColorReset(PyMOLGlobals * G)
     {1.0, 0.0, 1.0},            /* violet */
   };
 
-  if(I->Lex)
-    OVLexicon_Del(I->Lex);
-  I->Lex = OVLexicon_New(G->Context->heap);
-
-  if(I->Idx)
-    OVOneToOne_Del(I->Idx);
-
-  I->Idx = OVOneToOne_New(G->Context->heap);
+  I->Idx.clear();
 
   /* BLUE->VIOLET->RED r546 to r909 */
   /* BLUE->CYAN->GREEN->YELLOW->RED s182 to s909 */
   /* BLUE->WHITE->RED w00 to */
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "white");
+  color->Name = reg_name(I->Idx, n_color, "white");
   color->Color[0] = 1.0F;
   color->Color[1] = 1.0F;
   color->Color[2] = 1.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "black");
+  color->Name = reg_name(I->Idx, n_color, "black");
   color->Color[0] = 0.0F;
   color->Color[1] = 0.0F;
   color->Color[2] = 0.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "blue");
+  color->Name = reg_name(I->Idx, n_color, "blue");
   color->Color[0] = 0.0F;
   color->Color[1] = 0.0F;
   color->Color[2] = 1.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "green");
+  color->Name = reg_name(I->Idx, n_color, "green");
   color->Color[0] = 0.0F;
   color->Color[1] = 1.0F;
   color->Color[2] = 0.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "red");
+  color->Name = reg_name(I->Idx, n_color, "red");
   color->Color[0] = 1.0F;
   color->Color[1] = 0.0F;
   color->Color[2] = 0.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "cyan");
+  color->Name = reg_name(I->Idx, n_color, "cyan");
   color->Color[0] = 0.0F;
   color->Color[1] = 1.0F;
   color->Color[2] = 1.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "yellow");
+  color->Name = reg_name(I->Idx, n_color, "yellow");
   color->Color[0] = 1.0F;
   color->Color[1] = 1.0F;
   color->Color[2] = 0.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "dash");
+  color->Name = reg_name(I->Idx, n_color, "dash");
   color->Color[0] = 1.0F;
   color->Color[1] = 1.0F;
   color->Color[2] = 0.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "magenta");
+  color->Name = reg_name(I->Idx, n_color, "magenta");
   color->Color[0] = 1.0F;
   color->Color[1] = 0.0F;
   color->Color[2] = 1.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "salmon");
+  color->Name = reg_name(I->Idx, n_color, "salmon");
   color->Color[0] = 1.0F;
   color->Color[1] = 0.6F;       /* was 0.5 */
   color->Color[2] = 0.6F;       /* wat 0.5 */
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "lime");
+  color->Name = reg_name(I->Idx, n_color, "lime");
   color->Color[0] = 0.5F;
   color->Color[1] = 1.0F;
   color->Color[2] = 0.5F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "slate");
+  color->Name = reg_name(I->Idx, n_color, "slate");
   color->Color[0] = 0.5F;
   color->Color[1] = 0.5F;
   color->Color[2] = 1.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "hotpink");
+  color->Name = reg_name(I->Idx, n_color, "hotpink");
   color->Color[0] = 1.0F;
   color->Color[1] = 0.0F;
   color->Color[2] = 0.5F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "orange");
+  color->Name = reg_name(I->Idx, n_color, "orange");
   color->Color[0] = 1.0F;
   color->Color[1] = 0.5F;
   color->Color[2] = 0.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "chartreuse");        /* AKA puke green */
+  color->Name = reg_name(I->Idx, n_color, "chartreuse");        /* AKA puke green */
   color->Color[0] = 0.5F;
   color->Color[1] = 1.0F;
   color->Color[2] = 0.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "limegreen");
+  color->Name = reg_name(I->Idx, n_color, "limegreen");
   color->Color[0] = 0.0F;
   color->Color[1] = 1.0F;
   color->Color[2] = 0.5F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "purpleblue");        /* legacy name */
+  color->Name = reg_name(I->Idx, n_color, "purpleblue");        /* legacy name */
   color->Color[0] = 0.5F;
   color->Color[1] = 0.0F;
   color->Color[2] = 1.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "marine");
+  color->Name = reg_name(I->Idx, n_color, "marine");
   color->Color[0] = 0.0F;
   color->Color[1] = 0.5F;
   color->Color[2] = 1.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "olive");
+  color->Name = reg_name(I->Idx, n_color, "olive");
   color->Color[0] = 0.77F;
   color->Color[1] = 0.70F;
   color->Color[2] = 0.00F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "purple");
+  color->Name = reg_name(I->Idx, n_color, "purple");
   color->Color[0] = 0.75F;
   color->Color[1] = 0.00F;
   color->Color[2] = 0.75F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "teal");
+  color->Name = reg_name(I->Idx, n_color, "teal");
   color->Color[0] = 0.00F;
   color->Color[1] = 0.75F;
   color->Color[2] = 0.75F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "ruby");
+  color->Name = reg_name(I->Idx, n_color, "ruby");
   color->Color[0] = 0.6F;
   color->Color[1] = 0.2F;
   color->Color[2] = 0.2F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "forest");
+  color->Name = reg_name(I->Idx, n_color, "forest");
   color->Color[0] = 0.2F;
   color->Color[1] = 0.6F;
   color->Color[2] = 0.2F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "deepblue");  /* was "deep" */
+  color->Name = reg_name(I->Idx, n_color, "deepblue");  /* was "deep" */
   color->Color[0] = 0.25F;
   color->Color[1] = 0.25F;
   color->Color[2] = 0.65F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "grey");      /* english spelling */
+  color->Name = reg_name(I->Idx, n_color, "grey");      /* english spelling */
   color->Color[0] = 0.5F;
   color->Color[1] = 0.5F;
   color->Color[2] = 0.5F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "gray");      /* american spelling */
+  color->Name = reg_name(I->Idx, n_color, "gray");      /* american spelling */
   color->Color[0] = 0.5F;
   color->Color[1] = 0.5F;
   color->Color[2] = 0.5F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "carbon");
+  color->Name = reg_name(I->Idx, n_color, "carbon");
   color->Color[0] = 0.2F;
   color->Color[1] = 1.0F;
   color->Color[2] = 0.2F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "nitrogen");
+  color->Name = reg_name(I->Idx, n_color, "nitrogen");
   color->Color[0] = 0.2F;
   color->Color[1] = 0.2F;
   color->Color[2] = 1.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "oxygen");
+  color->Name = reg_name(I->Idx, n_color, "oxygen");
   color->Color[0] = 1.0F;
   color->Color[1] = 0.3F;
   color->Color[2] = 0.3F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "hydrogen");
+  color->Name = reg_name(I->Idx, n_color, "hydrogen");
   color->Color[0] = 0.9F;
   color->Color[1] = 0.9F;
   color->Color[2] = 0.9F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "brightorange");
+  color->Name = reg_name(I->Idx, n_color, "brightorange");
   color->Color[0] = 1.0F;
   color->Color[1] = 0.7F;
   color->Color[2] = 0.2F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "sulfur");
+  color->Name = reg_name(I->Idx, n_color, "sulfur");
   color->Color[0] = 0.9F;       /* needs to be far enough from "yellow" */
   color->Color[1] = 0.775F;     /* to be resolved, while still slightly on */
   color->Color[2] = 0.25F;      /* the yellow side of yelloworange */
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "tv_red");
+  color->Name = reg_name(I->Idx, n_color, "tv_red");
   color->Color[0] = 1.0F;
   color->Color[1] = 0.2F;
   color->Color[2] = 0.2F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "tv_green");
+  color->Name = reg_name(I->Idx, n_color, "tv_green");
   color->Color[0] = 0.2F;
   color->Color[1] = 1.0F;
   color->Color[2] = 0.2F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "tv_blue");
+  color->Name = reg_name(I->Idx, n_color, "tv_blue");
   color->Color[0] = 0.3F;
   color->Color[1] = 0.3F;
   color->Color[2] = 1.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "tv_yellow");
+  color->Name = reg_name(I->Idx, n_color, "tv_yellow");
   color->Color[0] = 1.0F;
   color->Color[1] = 1.0F;
   color->Color[2] = 0.2F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "yelloworange");
+  color->Name = reg_name(I->Idx, n_color, "yelloworange");
   color->Color[0] = 1.0F;
   color->Color[1] = 0.87F;
   color->Color[2] = 0.37F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "tv_orange");
+  color->Name = reg_name(I->Idx, n_color, "tv_orange");
   color->Color[0] = 1.0F;
   color->Color[1] = 0.55F;
   color->Color[2] = 0.15F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "br0");
+  color->Name = reg_name(I->Idx, n_color, "br0");
   color->Color[0] = 0.1F;
   color->Color[1] = 0.1F;
   color->Color[2] = 1.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "br1");
+  color->Name = reg_name(I->Idx, n_color, "br1");
   color->Color[0] = 0.2F;
   color->Color[1] = 0.1F;
   color->Color[2] = 0.9F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "br2");
+  color->Name = reg_name(I->Idx, n_color, "br2");
   color->Color[0] = 0.3F;
   color->Color[1] = 0.1F;
   color->Color[2] = 0.8F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "br3");
+  color->Name = reg_name(I->Idx, n_color, "br3");
   color->Color[0] = 0.4F;
   color->Color[1] = 0.1F;
   color->Color[2] = 0.7F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "br4");
+  color->Name = reg_name(I->Idx, n_color, "br4");
   color->Color[0] = 0.5F;
   color->Color[1] = 0.1F;
   color->Color[2] = 0.6F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "br5");
+  color->Name = reg_name(I->Idx, n_color, "br5");
   color->Color[0] = 0.6F;
   color->Color[1] = 0.1F;
   color->Color[2] = 0.5F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "br6");
+  color->Name = reg_name(I->Idx, n_color, "br6");
   color->Color[0] = 0.7F;
   color->Color[1] = 0.1F;
   color->Color[2] = 0.4F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "br7");
+  color->Name = reg_name(I->Idx, n_color, "br7");
   color->Color[0] = 0.8F;
   color->Color[1] = 0.1F;
   color->Color[2] = 0.3F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "br8");
+  color->Name = reg_name(I->Idx, n_color, "br8");
   color->Color[0] = 0.9F;
   color->Color[1] = 0.1F;
   color->Color[2] = 0.2F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "br9");
+  color->Name = reg_name(I->Idx, n_color, "br9");
   color->Color[0] = 1.0F;
   color->Color[1] = 0.1F;
   color->Color[2] = 0.1F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "pink");
+  color->Name = reg_name(I->Idx, n_color, "pink");
   color->Color[0] = 1.0F;
   color->Color[1] = 0.65F;
   color->Color[2] = 0.85F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "firebrick");
+  color->Name = reg_name(I->Idx, n_color, "firebrick");
   color->Color[0] = 0.698F;
   color->Color[1] = 0.13F;
   color->Color[2] = 0.13F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "chocolate");
+  color->Name = reg_name(I->Idx, n_color, "chocolate");
   color->Color[0] = 0.555F;
   color->Color[1] = 0.222F;
   color->Color[2] = 0.111F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "brown");
+  color->Name = reg_name(I->Idx, n_color, "brown");
   color->Color[0] = 0.65F;
   color->Color[1] = 0.32F;
   color->Color[2] = 0.17F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "wheat");
+  color->Name = reg_name(I->Idx, n_color, "wheat");
   color->Color[0] = 0.99F;
   color->Color[1] = 0.82F;
   color->Color[2] = 0.65F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "violet");
+  color->Name = reg_name(I->Idx, n_color, "violet");
   color->Color[0] = 1.0F;
   color->Color[1] = 0.5F;
   color->Color[2] = 1.0F;
@@ -1427,7 +1393,7 @@ void ColorReset(PyMOLGlobals * G)
     name[5] = (a % 10) + '0';
     name[4] = ((a % 100) / 10) + '0';
     /* sprintf(color->Name,"grey%02d",a); */
-    color->Name = reg_name(I->Lex, I->Idx, n_color, name);
+    color->Name = reg_name(I->Idx, n_color, name);
     color->Color[0] = a / 99.0F;
     color->Color[1] = a / 99.0F;
     color->Color[2] = a / 99.0F;
@@ -1435,7 +1401,7 @@ void ColorReset(PyMOLGlobals * G)
     color++;
   }
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "lightmagenta");
+  color->Name = reg_name(I->Idx, n_color, "lightmagenta");
   color->Color[0] = 1.0F;
   color->Color[1] = 0.2F;
   color->Color[2] = 0.8F;
@@ -1454,7 +1420,7 @@ void ColorReset(PyMOLGlobals * G)
     name[1] = ((a % 1000) / 100) + '0';
     /* sprintf(color->Name,"s%03d",a); */
     f = 1.0F - (a - (set1 * A_DIV)) / A_DIV;
-    color->Name = reg_name(I->Lex, I->Idx, n_color, name);
+    color->Name = reg_name(I->Idx, n_color, name);
     color->Color[0] = f * spectrumS[set1][0] + (1.0F - f) * spectrumS[set1 + 1][0];
     color->Color[1] = f * spectrumS[set1][1] + (1.0F - f) * spectrumS[set1 + 1][1];
     color->Color[2] = f * spectrumS[set1][2] + (1.0F - f) * spectrumS[set1 + 1][2];
@@ -1472,7 +1438,7 @@ void ColorReset(PyMOLGlobals * G)
     name[2] = ((a % 100) / 10) + '0';
     name[1] = ((a % 1000) / 100) + '0';
     f = 1.0F - (a - (set1 * A_DIV)) / A_DIV;
-    color->Name = reg_name(I->Lex, I->Idx, n_color, name);
+    color->Name = reg_name(I->Idx, n_color, name);
     color->Color[0] = f * spectrumR[set1][0] + (1.0F - f) * spectrumR[set1 + 1][0];
     color->Color[1] = f * spectrumR[set1][1] + (1.0F - f) * spectrumR[set1 + 1][1];
     color->Color[2] = f * spectrumR[set1][2] + (1.0F - f) * spectrumR[set1 + 1][2];
@@ -1490,7 +1456,7 @@ void ColorReset(PyMOLGlobals * G)
     name[2] = ((a % 100) / 10) + '0';
     name[1] = ((a % 1000) / 100) + '0';
     f = 1.0F - (a - (set1 * A_DIV)) / A_DIV;
-    color->Name = reg_name(I->Lex, I->Idx, n_color, name);
+    color->Name = reg_name(I->Idx, n_color, name);
     color->Color[0] = f * spectrumC[set1][0] + (1.0F - f) * spectrumC[set1 + 1][0];
     color->Color[1] = f * spectrumC[set1][1] + (1.0F - f) * spectrumC[set1 + 1][1];
     color->Color[2] = f * spectrumC[set1][2] + (1.0F - f) * spectrumC[set1 + 1][2];
@@ -1510,7 +1476,7 @@ void ColorReset(PyMOLGlobals * G)
     name[2] = ((a % 100) / 10) + '0';
     name[1] = ((a % 1000) / 100) + '0';
     f = 1.0F - (a - (set1 * W_DIV)) / W_DIV;
-    color->Name = reg_name(I->Lex, I->Idx, n_color, name);
+    color->Name = reg_name(I->Idx, n_color, name);
     color->Color[0] = f * spectrumW[set1][0] + (1.0F - f) * spectrumW[set1 + 1][0];
     color->Color[1] = f * spectrumW[set1][1] + (1.0F - f) * spectrumW[set1 + 1][1];
     color->Color[2] = f * spectrumW[set1][2] + (1.0F - f) * spectrumW[set1 + 1][2];
@@ -1518,7 +1484,7 @@ void ColorReset(PyMOLGlobals * G)
     color++;
   }
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "density");
+  color->Name = reg_name(I->Idx, n_color, "density");
   color->Color[0] = 0.1F;
   color->Color[1] = 0.1F;
   color->Color[2] = 0.6F;
@@ -1530,7 +1496,7 @@ void ColorReset(PyMOLGlobals * G)
     name[5] = (a % 10) + '0';
     name[4] = ((a % 100) / 10) + '0';
     /* sprintf(color->Name,"gray%02d",a); */
-    color->Name = reg_name(I->Lex, I->Idx, n_color, name);
+    color->Name = reg_name(I->Idx, n_color, name);
     color->Color[0] = a / 99.0F;
     color->Color[1] = a / 99.0F;
     color->Color[2] = a / 99.0F;
@@ -1550,7 +1516,7 @@ void ColorReset(PyMOLGlobals * G)
     name[1] = ((a % 1000) / 100) + '0';
     /* sprintf(color->Name,"o%03d",a); */
     f = 1.0F - (a - (set1 * B_DIV)) / B_DIV;
-    color->Name = reg_name(I->Lex, I->Idx, n_color, name);
+    color->Name = reg_name(I->Idx, n_color, name);
     color->Color[0] = f * spectrumO[set1][0] + (1.0F - f) * spectrumO[set1 + 1][0];
     color->Color[1] = f * spectrumO[set1][1] + (1.0F - f) * spectrumO[set1 + 1][1];
     color->Color[2] = f * spectrumO[set1][2] + (1.0F - f) * spectrumO[set1 + 1][2];
@@ -1558,924 +1524,924 @@ void ColorReset(PyMOLGlobals * G)
     color++;
   }
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "paleyellow");
+  color->Name = reg_name(I->Idx, n_color, "paleyellow");
   color->Color[0] = 1.0F;
   color->Color[1] = 1.0F;
   color->Color[2] = 0.5F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "aquamarine");
+  color->Name = reg_name(I->Idx, n_color, "aquamarine");
   color->Color[0] = 0.5F;
   color->Color[1] = 1.0F;
   color->Color[2] = 1.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "deepsalmon");
+  color->Name = reg_name(I->Idx, n_color, "deepsalmon");
   color->Color[0] = 1.0F;
   color->Color[1] = 0.5F;
   color->Color[2] = 0.5F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "palegreen");
+  color->Name = reg_name(I->Idx, n_color, "palegreen");
   color->Color[0] = 0.65F;
   color->Color[1] = 0.9F;
   color->Color[2] = 0.65F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "deepolive");
+  color->Name = reg_name(I->Idx, n_color, "deepolive");
   color->Color[0] = 0.6F;
   color->Color[1] = 0.6F;
   color->Color[2] = 0.1F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "deeppurple");
+  color->Name = reg_name(I->Idx, n_color, "deeppurple");
   color->Color[0] = 0.6F;
   color->Color[1] = 0.1F;
   color->Color[2] = 0.6F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "deepteal");
+  color->Name = reg_name(I->Idx, n_color, "deepteal");
   color->Color[0] = 0.1F;
   color->Color[1] = 0.6F;
   color->Color[2] = 0.6F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "lightblue");
+  color->Name = reg_name(I->Idx, n_color, "lightblue");
   color->Color[0] = 0.75F;
   color->Color[1] = 0.75;
   color->Color[2] = 1.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "lightorange");
+  color->Name = reg_name(I->Idx, n_color, "lightorange");
   color->Color[0] = 1.0F;
   color->Color[1] = 0.8F;
   color->Color[2] = 0.5F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "palecyan");
+  color->Name = reg_name(I->Idx, n_color, "palecyan");
   color->Color[0] = 0.8F;
   color->Color[1] = 1.0F;
   color->Color[2] = 1.0F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "lightteal");
+  color->Name = reg_name(I->Idx, n_color, "lightteal");
   color->Color[0] = 0.4F;
   color->Color[1] = 0.7F;
   color->Color[2] = 0.7F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "splitpea");
+  color->Name = reg_name(I->Idx, n_color, "splitpea");
   color->Color[0] = 0.52F;
   color->Color[1] = 0.75F;
   color->Color[2] = 0.00F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "raspberry");
+  color->Name = reg_name(I->Idx, n_color, "raspberry");
   color->Color[0] = 0.70F;
   color->Color[1] = 0.30F;
   color->Color[2] = 0.40F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "sand");
+  color->Name = reg_name(I->Idx, n_color, "sand");
   color->Color[0] = 0.72F;
   color->Color[1] = 0.55F;
   color->Color[2] = 0.30F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "smudge");
+  color->Name = reg_name(I->Idx, n_color, "smudge");
   color->Color[0] = 0.55F;
   color->Color[1] = 0.70F;
   color->Color[2] = 0.40F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "violetpurple");
+  color->Name = reg_name(I->Idx, n_color, "violetpurple");
   color->Color[0] = 0.55F;
   color->Color[1] = 0.25F;
   color->Color[2] = 0.60F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "dirtyviolet");
+  color->Name = reg_name(I->Idx, n_color, "dirtyviolet");
   color->Color[0] = 0.70F;
   color->Color[1] = 0.50F;
   color->Color[2] = 0.50F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "deepsalmon");
+  color->Name = reg_name(I->Idx, n_color, "deepsalmon");
   color->Color[0] = 1.00F;
   color->Color[1] = 0.42F;
   color->Color[2] = 0.42F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "lightpink");
+  color->Name = reg_name(I->Idx, n_color, "lightpink");
   color->Color[0] = 1.00F;
   color->Color[1] = 0.75F;
   color->Color[2] = 0.87F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "greencyan");
+  color->Name = reg_name(I->Idx, n_color, "greencyan");
   color->Color[0] = 0.25F;
   color->Color[1] = 1.00F;
   color->Color[2] = 0.75F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "limon");
+  color->Name = reg_name(I->Idx, n_color, "limon");
   color->Color[0] = 0.75F;
   color->Color[1] = 1.00F;
   color->Color[2] = 0.25F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "skyblue");
+  color->Name = reg_name(I->Idx, n_color, "skyblue");
   color->Color[0] = 0.20F;
   color->Color[1] = 0.50F;
   color->Color[2] = 0.80F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "bluewhite");
+  color->Name = reg_name(I->Idx, n_color, "bluewhite");
   color->Color[0] = 0.85F;
   color->Color[1] = 0.85F;
   color->Color[2] = 1.00F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "warmpink");
+  color->Name = reg_name(I->Idx, n_color, "warmpink");
   color->Color[0] = 0.85F;
   color->Color[1] = 0.20F;
   color->Color[2] = 0.50F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "darksalmon");
+  color->Name = reg_name(I->Idx, n_color, "darksalmon");
   color->Color[0] = 0.73F;
   color->Color[1] = 0.55F;
   color->Color[2] = 0.52F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "helium");
+  color->Name = reg_name(I->Idx, n_color, "helium");
   color->Color[0] = 0.850980392F;
   color->Color[1] = 1.000000000F;
   color->Color[2] = 1.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "lithium");
+  color->Name = reg_name(I->Idx, n_color, "lithium");
   color->Color[0] = 0.800000000F;
   color->Color[1] = 0.501960784F;
   color->Color[2] = 1.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "beryllium");
+  color->Name = reg_name(I->Idx, n_color, "beryllium");
   color->Color[0] = 0.760784314F;
   color->Color[1] = 1.000000000F;
   color->Color[2] = 0.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "boron");
+  color->Name = reg_name(I->Idx, n_color, "boron");
   color->Color[0] = 1.000000000F;
   color->Color[1] = 0.709803922F;
   color->Color[2] = 0.709803922F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "fluorine");
+  color->Name = reg_name(I->Idx, n_color, "fluorine");
   color->Color[0] = 0.701960784F;
   color->Color[1] = 1.000000000F;
   color->Color[2] = 1.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "neon");
+  color->Name = reg_name(I->Idx, n_color, "neon");
   color->Color[0] = 0.701960784F;
   color->Color[1] = 0.890196078F;
   color->Color[2] = 0.960784314F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "sodium");
+  color->Name = reg_name(I->Idx, n_color, "sodium");
   color->Color[0] = 0.670588235F;
   color->Color[1] = 0.360784314F;
   color->Color[2] = 0.949019608F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "magnesium");
+  color->Name = reg_name(I->Idx, n_color, "magnesium");
   color->Color[0] = 0.541176471F;
   color->Color[1] = 1.000000000F;
   color->Color[2] = 0.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "aluminum");
+  color->Name = reg_name(I->Idx, n_color, "aluminum");
   color->Color[0] = 0.749019608F;
   color->Color[1] = 0.650980392F;
   color->Color[2] = 0.650980392F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "silicon");
+  color->Name = reg_name(I->Idx, n_color, "silicon");
   color->Color[0] = 0.941176471F;
   color->Color[1] = 0.784313725F;
   color->Color[2] = 0.627450980F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "phosphorus");
+  color->Name = reg_name(I->Idx, n_color, "phosphorus");
   color->Color[0] = 1.000000000F;
   color->Color[1] = 0.501960784F;
   color->Color[2] = 0.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "chlorine");
+  color->Name = reg_name(I->Idx, n_color, "chlorine");
   color->Color[0] = 0.121568627F;
   color->Color[1] = 0.941176471F;
   color->Color[2] = 0.121568627F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "argon");
+  color->Name = reg_name(I->Idx, n_color, "argon");
   color->Color[0] = 0.501960784F;
   color->Color[1] = 0.819607843F;
   color->Color[2] = 0.890196078F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "potassium");
+  color->Name = reg_name(I->Idx, n_color, "potassium");
   color->Color[0] = 0.560784314F;
   color->Color[1] = 0.250980392F;
   color->Color[2] = 0.831372549F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "calcium");
+  color->Name = reg_name(I->Idx, n_color, "calcium");
   color->Color[0] = 0.239215686F;
   color->Color[1] = 1.000000000F;
   color->Color[2] = 0.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "scandium");
+  color->Name = reg_name(I->Idx, n_color, "scandium");
   color->Color[0] = 0.901960784F;
   color->Color[1] = 0.901960784F;
   color->Color[2] = 0.901960784F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "titanium");
+  color->Name = reg_name(I->Idx, n_color, "titanium");
   color->Color[0] = 0.749019608F;
   color->Color[1] = 0.760784314F;
   color->Color[2] = 0.780392157F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "vanadium");
+  color->Name = reg_name(I->Idx, n_color, "vanadium");
   color->Color[0] = 0.650980392F;
   color->Color[1] = 0.650980392F;
   color->Color[2] = 0.670588235F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "chromium");
+  color->Name = reg_name(I->Idx, n_color, "chromium");
   color->Color[0] = 0.541176471F;
   color->Color[1] = 0.600000000F;
   color->Color[2] = 0.780392157F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "manganese");
+  color->Name = reg_name(I->Idx, n_color, "manganese");
   color->Color[0] = 0.611764706F;
   color->Color[1] = 0.478431373F;
   color->Color[2] = 0.780392157F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "iron");
+  color->Name = reg_name(I->Idx, n_color, "iron");
   color->Color[0] = 0.878431373F;
   color->Color[1] = 0.400000000F;
   color->Color[2] = 0.200000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "cobalt");
+  color->Name = reg_name(I->Idx, n_color, "cobalt");
   color->Color[0] = 0.941176471F;
   color->Color[1] = 0.564705882F;
   color->Color[2] = 0.627450980F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "nickel");
+  color->Name = reg_name(I->Idx, n_color, "nickel");
   color->Color[0] = 0.313725490F;
   color->Color[1] = 0.815686275F;
   color->Color[2] = 0.313725490F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "copper");
+  color->Name = reg_name(I->Idx, n_color, "copper");
   color->Color[0] = 0.784313725F;
   color->Color[1] = 0.501960784F;
   color->Color[2] = 0.200000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "zinc");
+  color->Name = reg_name(I->Idx, n_color, "zinc");
   color->Color[0] = 0.490196078F;
   color->Color[1] = 0.501960784F;
   color->Color[2] = 0.690196078F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "gallium");
+  color->Name = reg_name(I->Idx, n_color, "gallium");
   color->Color[0] = 0.760784314F;
   color->Color[1] = 0.560784314F;
   color->Color[2] = 0.560784314F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "germanium");
+  color->Name = reg_name(I->Idx, n_color, "germanium");
   color->Color[0] = 0.400000000F;
   color->Color[1] = 0.560784314F;
   color->Color[2] = 0.560784314F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "arsenic");
+  color->Name = reg_name(I->Idx, n_color, "arsenic");
   color->Color[0] = 0.741176471F;
   color->Color[1] = 0.501960784F;
   color->Color[2] = 0.890196078F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "selenium");
+  color->Name = reg_name(I->Idx, n_color, "selenium");
   color->Color[0] = 1.000000000F;
   color->Color[1] = 0.631372549F;
   color->Color[2] = 0.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "bromine");
+  color->Name = reg_name(I->Idx, n_color, "bromine");
   color->Color[0] = 0.650980392F;
   color->Color[1] = 0.160784314F;
   color->Color[2] = 0.160784314F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "krypton");
+  color->Name = reg_name(I->Idx, n_color, "krypton");
   color->Color[0] = 0.360784314F;
   color->Color[1] = 0.721568627F;
   color->Color[2] = 0.819607843F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "rubidium");
+  color->Name = reg_name(I->Idx, n_color, "rubidium");
   color->Color[0] = 0.439215686F;
   color->Color[1] = 0.180392157F;
   color->Color[2] = 0.690196078F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "strontium");
+  color->Name = reg_name(I->Idx, n_color, "strontium");
   color->Color[0] = 0.000000000F;
   color->Color[1] = 1.000000000F;
   color->Color[2] = 0.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "yttrium");
+  color->Name = reg_name(I->Idx, n_color, "yttrium");
   color->Color[0] = 0.580392157F;
   color->Color[1] = 1.000000000F;
   color->Color[2] = 1.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "zirconium");
+  color->Name = reg_name(I->Idx, n_color, "zirconium");
   color->Color[0] = 0.580392157F;
   color->Color[1] = 0.878431373F;
   color->Color[2] = 0.878431373F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "niobium");
+  color->Name = reg_name(I->Idx, n_color, "niobium");
   color->Color[0] = 0.450980392F;
   color->Color[1] = 0.760784314F;
   color->Color[2] = 0.788235294F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "molybdenum");
+  color->Name = reg_name(I->Idx, n_color, "molybdenum");
   color->Color[0] = 0.329411765F;
   color->Color[1] = 0.709803922F;
   color->Color[2] = 0.709803922F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "technetium");
+  color->Name = reg_name(I->Idx, n_color, "technetium");
   color->Color[0] = 0.231372549F;
   color->Color[1] = 0.619607843F;
   color->Color[2] = 0.619607843F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "ruthenium");
+  color->Name = reg_name(I->Idx, n_color, "ruthenium");
   color->Color[0] = 0.141176471F;
   color->Color[1] = 0.560784314F;
   color->Color[2] = 0.560784314F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "rhodium");
+  color->Name = reg_name(I->Idx, n_color, "rhodium");
   color->Color[0] = 0.039215686F;
   color->Color[1] = 0.490196078F;
   color->Color[2] = 0.549019608F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "palladium");
+  color->Name = reg_name(I->Idx, n_color, "palladium");
   color->Color[0] = 0.000000000F;
   color->Color[1] = 0.411764706F;
   color->Color[2] = 0.521568627F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "silver");
+  color->Name = reg_name(I->Idx, n_color, "silver");
   color->Color[0] = 0.752941176F;
   color->Color[1] = 0.752941176F;
   color->Color[2] = 0.752941176F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "cadmium");
+  color->Name = reg_name(I->Idx, n_color, "cadmium");
   color->Color[0] = 1.000000000F;
   color->Color[1] = 0.850980392F;
   color->Color[2] = 0.560784314F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "indium");
+  color->Name = reg_name(I->Idx, n_color, "indium");
   color->Color[0] = 0.650980392F;
   color->Color[1] = 0.458823529F;
   color->Color[2] = 0.450980392F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "tin");
+  color->Name = reg_name(I->Idx, n_color, "tin");
   color->Color[0] = 0.400000000F;
   color->Color[1] = 0.501960784F;
   color->Color[2] = 0.501960784F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "antimony");
+  color->Name = reg_name(I->Idx, n_color, "antimony");
   color->Color[0] = 0.619607843F;
   color->Color[1] = 0.388235294F;
   color->Color[2] = 0.709803922F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "tellurium");
+  color->Name = reg_name(I->Idx, n_color, "tellurium");
   color->Color[0] = 0.831372549F;
   color->Color[1] = 0.478431373F;
   color->Color[2] = 0.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "iodine");
+  color->Name = reg_name(I->Idx, n_color, "iodine");
   color->Color[0] = 0.580392157F;
   color->Color[1] = 0.000000000F;
   color->Color[2] = 0.580392157F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "xenon");
+  color->Name = reg_name(I->Idx, n_color, "xenon");
   color->Color[0] = 0.258823529F;
   color->Color[1] = 0.619607843F;
   color->Color[2] = 0.690196078F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "cesium");
+  color->Name = reg_name(I->Idx, n_color, "cesium");
   color->Color[0] = 0.341176471F;
   color->Color[1] = 0.090196078F;
   color->Color[2] = 0.560784314F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "barium");
+  color->Name = reg_name(I->Idx, n_color, "barium");
   color->Color[0] = 0.000000000F;
   color->Color[1] = 0.788235294F;
   color->Color[2] = 0.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "lanthanum");
+  color->Name = reg_name(I->Idx, n_color, "lanthanum");
   color->Color[0] = 0.439215686F;
   color->Color[1] = 0.831372549F;
   color->Color[2] = 1.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "cerium");
+  color->Name = reg_name(I->Idx, n_color, "cerium");
   color->Color[0] = 1.000000000F;
   color->Color[1] = 1.000000000F;
   color->Color[2] = 0.780392157F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "praseodymium");
+  color->Name = reg_name(I->Idx, n_color, "praseodymium");
   color->Color[0] = 0.850980392F;
   color->Color[1] = 1.000000000F;
   color->Color[2] = 0.780392157F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "neodymium");
+  color->Name = reg_name(I->Idx, n_color, "neodymium");
   color->Color[0] = 0.780392157F;
   color->Color[1] = 1.000000000F;
   color->Color[2] = 0.780392157F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "promethium");
+  color->Name = reg_name(I->Idx, n_color, "promethium");
   color->Color[0] = 0.639215686F;
   color->Color[1] = 1.000000000F;
   color->Color[2] = 0.780392157F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "samarium");
+  color->Name = reg_name(I->Idx, n_color, "samarium");
   color->Color[0] = 0.560784314F;
   color->Color[1] = 1.000000000F;
   color->Color[2] = 0.780392157F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "europium");
+  color->Name = reg_name(I->Idx, n_color, "europium");
   color->Color[0] = 0.380392157F;
   color->Color[1] = 1.000000000F;
   color->Color[2] = 0.780392157F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "gadolinium");
+  color->Name = reg_name(I->Idx, n_color, "gadolinium");
   color->Color[0] = 0.270588235F;
   color->Color[1] = 1.000000000F;
   color->Color[2] = 0.780392157F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "terbium");
+  color->Name = reg_name(I->Idx, n_color, "terbium");
   color->Color[0] = 0.188235294F;
   color->Color[1] = 1.000000000F;
   color->Color[2] = 0.780392157F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "dysprosium");
+  color->Name = reg_name(I->Idx, n_color, "dysprosium");
   color->Color[0] = 0.121568627F;
   color->Color[1] = 1.000000000F;
   color->Color[2] = 0.780392157F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "holmium");
+  color->Name = reg_name(I->Idx, n_color, "holmium");
   color->Color[0] = 0.000000000F;
   color->Color[1] = 1.000000000F;
   color->Color[2] = 0.611764706F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "erbium");
+  color->Name = reg_name(I->Idx, n_color, "erbium");
   color->Color[0] = 0.000000000F;
   color->Color[1] = 0.901960784F;
   color->Color[2] = 0.458823529F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "thulium");
+  color->Name = reg_name(I->Idx, n_color, "thulium");
   color->Color[0] = 0.000000000F;
   color->Color[1] = 0.831372549F;
   color->Color[2] = 0.321568627F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "ytterbium");
+  color->Name = reg_name(I->Idx, n_color, "ytterbium");
   color->Color[0] = 0.000000000F;
   color->Color[1] = 0.749019608F;
   color->Color[2] = 0.219607843F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "lutetium");
+  color->Name = reg_name(I->Idx, n_color, "lutetium");
   color->Color[0] = 0.000000000F;
   color->Color[1] = 0.670588235F;
   color->Color[2] = 0.141176471F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "hafnium");
+  color->Name = reg_name(I->Idx, n_color, "hafnium");
   color->Color[0] = 0.301960784F;
   color->Color[1] = 0.760784314F;
   color->Color[2] = 1.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "tantalum");
+  color->Name = reg_name(I->Idx, n_color, "tantalum");
   color->Color[0] = 0.301960784F;
   color->Color[1] = 0.650980392F;
   color->Color[2] = 1.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "tungsten");
+  color->Name = reg_name(I->Idx, n_color, "tungsten");
   color->Color[0] = 0.129411765F;
   color->Color[1] = 0.580392157F;
   color->Color[2] = 0.839215686F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "rhenium");
+  color->Name = reg_name(I->Idx, n_color, "rhenium");
   color->Color[0] = 0.149019608F;
   color->Color[1] = 0.490196078F;
   color->Color[2] = 0.670588235F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "osmium");
+  color->Name = reg_name(I->Idx, n_color, "osmium");
   color->Color[0] = 0.149019608F;
   color->Color[1] = 0.400000000F;
   color->Color[2] = 0.588235294F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "iridium");
+  color->Name = reg_name(I->Idx, n_color, "iridium");
   color->Color[0] = 0.090196078F;
   color->Color[1] = 0.329411765F;
   color->Color[2] = 0.529411765F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "platinum");
+  color->Name = reg_name(I->Idx, n_color, "platinum");
   color->Color[0] = 0.815686275F;
   color->Color[1] = 0.815686275F;
   color->Color[2] = 0.878431373F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "gold");
+  color->Name = reg_name(I->Idx, n_color, "gold");
   color->Color[0] = 1.000000000F;
   color->Color[1] = 0.819607843F;
   color->Color[2] = 0.137254902F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "mercury");
+  color->Name = reg_name(I->Idx, n_color, "mercury");
   color->Color[0] = 0.721568627F;
   color->Color[1] = 0.721568627F;
   color->Color[2] = 0.815686275F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "thallium");
+  color->Name = reg_name(I->Idx, n_color, "thallium");
   color->Color[0] = 0.650980392F;
   color->Color[1] = 0.329411765F;
   color->Color[2] = 0.301960784F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "lead");
+  color->Name = reg_name(I->Idx, n_color, "lead");
   color->Color[0] = 0.341176471F;
   color->Color[1] = 0.349019608F;
   color->Color[2] = 0.380392157F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "bismuth");
+  color->Name = reg_name(I->Idx, n_color, "bismuth");
   color->Color[0] = 0.619607843F;
   color->Color[1] = 0.309803922F;
   color->Color[2] = 0.709803922F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "polonium");
+  color->Name = reg_name(I->Idx, n_color, "polonium");
   color->Color[0] = 0.670588235F;
   color->Color[1] = 0.360784314F;
   color->Color[2] = 0.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "astatine");
+  color->Name = reg_name(I->Idx, n_color, "astatine");
   color->Color[0] = 0.458823529F;
   color->Color[1] = 0.309803922F;
   color->Color[2] = 0.270588235F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "radon");
+  color->Name = reg_name(I->Idx, n_color, "radon");
   color->Color[0] = 0.258823529F;
   color->Color[1] = 0.509803922F;
   color->Color[2] = 0.588235294F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "francium");
+  color->Name = reg_name(I->Idx, n_color, "francium");
   color->Color[0] = 0.258823529F;
   color->Color[1] = 0.000000000F;
   color->Color[2] = 0.400000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "radium");
+  color->Name = reg_name(I->Idx, n_color, "radium");
   color->Color[0] = 0.000000000F;
   color->Color[1] = 0.490196078F;
   color->Color[2] = 0.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "actinium");
+  color->Name = reg_name(I->Idx, n_color, "actinium");
   color->Color[0] = 0.439215686F;
   color->Color[1] = 0.670588235F;
   color->Color[2] = 0.980392157F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "thorium");
+  color->Name = reg_name(I->Idx, n_color, "thorium");
   color->Color[0] = 0.000000000F;
   color->Color[1] = 0.729411765F;
   color->Color[2] = 1.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "protactinium");
+  color->Name = reg_name(I->Idx, n_color, "protactinium");
   color->Color[0] = 0.000000000F;
   color->Color[1] = 0.631372549F;
   color->Color[2] = 1.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "uranium");
+  color->Name = reg_name(I->Idx, n_color, "uranium");
   color->Color[0] = 0.000000000F;
   color->Color[1] = 0.560784314F;
   color->Color[2] = 1.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "neptunium");
+  color->Name = reg_name(I->Idx, n_color, "neptunium");
   color->Color[0] = 0.000000000F;
   color->Color[1] = 0.501960784F;
   color->Color[2] = 1.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "plutonium");
+  color->Name = reg_name(I->Idx, n_color, "plutonium");
   color->Color[0] = 0.000000000F;
   color->Color[1] = 0.419607843F;
   color->Color[2] = 1.000000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "americium");
+  color->Name = reg_name(I->Idx, n_color, "americium");
   color->Color[0] = 0.329411765F;
   color->Color[1] = 0.360784314F;
   color->Color[2] = 0.949019608F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "curium");
+  color->Name = reg_name(I->Idx, n_color, "curium");
   color->Color[0] = 0.470588235F;
   color->Color[1] = 0.360784314F;
   color->Color[2] = 0.890196078F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "berkelium");
+  color->Name = reg_name(I->Idx, n_color, "berkelium");
   color->Color[0] = 0.541176471F;
   color->Color[1] = 0.309803922F;
   color->Color[2] = 0.890196078F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "californium");
+  color->Name = reg_name(I->Idx, n_color, "californium");
   color->Color[0] = 0.631372549F;
   color->Color[1] = 0.211764706F;
   color->Color[2] = 0.831372549F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "einsteinium");
+  color->Name = reg_name(I->Idx, n_color, "einsteinium");
   color->Color[0] = 0.701960784F;
   color->Color[1] = 0.121568627F;
   color->Color[2] = 0.831372549F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "fermium");
+  color->Name = reg_name(I->Idx, n_color, "fermium");
   color->Color[0] = 0.701960784F;
   color->Color[1] = 0.121568627F;
   color->Color[2] = 0.729411765F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "mendelevium");
+  color->Name = reg_name(I->Idx, n_color, "mendelevium");
   color->Color[0] = 0.701960784F;
   color->Color[1] = 0.050980392F;
   color->Color[2] = 0.650980392F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "nobelium");
+  color->Name = reg_name(I->Idx, n_color, "nobelium");
   color->Color[0] = 0.741176471F;
   color->Color[1] = 0.050980392F;
   color->Color[2] = 0.529411765F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "lawrencium");
+  color->Name = reg_name(I->Idx, n_color, "lawrencium");
   color->Color[0] = 0.780392157F;
   color->Color[1] = 0.000000000F;
   color->Color[2] = 0.400000000F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "rutherfordium");
+  color->Name = reg_name(I->Idx, n_color, "rutherfordium");
   color->Color[0] = 0.800000000F;
   color->Color[1] = 0.000000000F;
   color->Color[2] = 0.349019608F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "dubnium");
+  color->Name = reg_name(I->Idx, n_color, "dubnium");
   color->Color[0] = 0.819607843F;
   color->Color[1] = 0.000000000F;
   color->Color[2] = 0.309803922F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "seaborgium");
+  color->Name = reg_name(I->Idx, n_color, "seaborgium");
   color->Color[0] = 0.850980392F;
   color->Color[1] = 0.000000000F;
   color->Color[2] = 0.270588235F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "bohrium");
+  color->Name = reg_name(I->Idx, n_color, "bohrium");
   color->Color[0] = 0.878431373F;
   color->Color[1] = 0.000000000F;
   color->Color[2] = 0.219607843F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "hassium");
+  color->Name = reg_name(I->Idx, n_color, "hassium");
   color->Color[0] = 0.901960784F;
   color->Color[1] = 0.000000000F;
   color->Color[2] = 0.180392157F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "meitnerium");
+  color->Name = reg_name(I->Idx, n_color, "meitnerium");
   color->Color[0] = 0.921568627F;
   color->Color[1] = 0.000000000F;
   color->Color[2] = 0.149019608F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "deuterium");
+  color->Name = reg_name(I->Idx, n_color, "deuterium");
   color->Color[0] = 0.9F;
   color->Color[1] = 0.9F;
   color->Color[2] = 0.9F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "lonepair");
+  color->Name = reg_name(I->Idx, n_color, "lonepair");
   color->Color[0] = 0.5F;
   color->Color[1] = 0.5F;
   color->Color[2] = 0.5F;
   n_color++;
   color++;
 
-  color->Name = reg_name(I->Lex, I->Idx, n_color, "pseudoatom");
+  color->Name = reg_name(I->Idx, n_color, "pseudoatom");
   color->Color[0] = 0.9F;
   color->Color[1] = 0.9F;
   color->Color[2] = 0.9F;
diff -upNr pymol-open-source-2.3.0/layer1/Color.h pymol-open-source-2.3.3/layer1/Color.h
--- pymol-open-source-2.3.0/layer1/Color.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/Color.h	2019-08-22 10:24:47.682589828 +0200
@@ -17,6 +17,9 @@ Z* -------------------------------------
 #ifndef _H_Color
 #define _H_Color
 
+#include <unordered_map>
+#include <string>
+
 #include"os_python.h"
 
 #include"Rep.h"
@@ -42,7 +45,7 @@ Z* -------------------------------------
 #define cColor_TRGB_Mask  0xC0000000
 
 typedef struct {
-  int Name;
+  const char* Name;
   Vector3f Color, LutColor;
   char LutColorFlag;
   char Custom, Fixed;
@@ -51,7 +54,7 @@ typedef struct {
 } ColorRec;
 
 typedef struct {
-  int Name;
+  const char* Name;
   void *Ptr;
   int Type;
   /* not saved */
@@ -59,6 +62,7 @@ typedef struct {
 } ExtRec;
 
 struct CColor {
+  using ColorIdx = int;
   ColorRec *Color{};
   int NColor{};
   ExtRec *Ext{};
@@ -67,8 +71,7 @@ struct CColor {
   std::vector<unsigned int> ColorTable{};
   float Gamma = 1.0f;
   int BigEndian{};
-  OVLexicon *Lex{};
-  OVOneToOne *Idx{};
+  std::unordered_map<std::string, ColorIdx> Idx;
   float RGBColor[3]{};            /* save global float for returning (float*) */
   char RGBName[11]{}; // "0xTTRRGGBB"
   /* not stored */
diff -upNr pymol-open-source-2.3.0/layer1/Extrude.cpp pymol-open-source-2.3.3/layer1/Extrude.cpp
--- pymol-open-source-2.3.0/layer1/Extrude.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/Extrude.cpp	2019-08-22 10:24:47.682589828 +0200
@@ -91,16 +91,16 @@ int ExtrudeCircle(CExtrude * I, int n, f
   FreeP(I->tv);
   FreeP(I->tn);
 
-  I->sv = Alloc(float, 3 * (n + 1));
+  I->sv = pymol::malloc<float>(3 * (n + 1));
   CHECKOK(ok, I->sv);
   if (ok)
-    I->sn = Alloc(float, 3 * (n + 1));
+    I->sn = pymol::malloc<float>(3 * (n + 1));
   CHECKOK(ok, I->sn);
   if (ok)
-    I->tv = Alloc(float, 3 * (n + 1));
+    I->tv = pymol::malloc<float>(3 * (n + 1));
   CHECKOK(ok, I->tv);
   if (ok)
-    I->tn = Alloc(float, 3 * (n + 1));
+    I->tn = pymol::malloc<float>(3 * (n + 1));
   CHECKOK(ok, I->tn);
 
   if (ok){
@@ -153,16 +153,16 @@ int ExtrudeOval(CExtrude * I, int n, flo
   FreeP(I->tv);
   FreeP(I->tn);
 
-  I->sv = Alloc(float, 3 * (n + 1));
+  I->sv = pymol::malloc<float>(3 * (n + 1));
   CHECKOK(ok, I->sv);
   if (ok)
-    I->sn = Alloc(float, 3 * (n + 1));
+    I->sn = pymol::malloc<float>(3 * (n + 1));
   CHECKOK(ok, I->sn);
   if (ok)
-    I->tv = Alloc(float, 3 * (n + 1));
+    I->tv = pymol::malloc<float>(3 * (n + 1));
   CHECKOK(ok, I->tv);
   if (ok)
-    I->tn = Alloc(float, 3 * (n + 1));
+    I->tn = pymol::malloc<float>(3 * (n + 1));
   CHECKOK(ok, I->tn);
   I->Ns = n;
 
@@ -211,16 +211,16 @@ int ExtrudeRectangle(CExtrude * I, float
   FreeP(I->tv);
   FreeP(I->tn);
 
-  I->sv = Alloc(float, 3 * (I->Ns + 1));
+  I->sv = pymol::malloc<float>(3 * (I->Ns + 1));
   CHECKOK(ok, I->sv);
   if (ok)
-    I->sn = Alloc(float, 3 * (I->Ns + 1));
+    I->sn = pymol::malloc<float>(3 * (I->Ns + 1));
   CHECKOK(ok, I->sn);
   if (ok)
-    I->tv = Alloc(float, 3 * (I->Ns + 1));
+    I->tv = pymol::malloc<float>(3 * (I->Ns + 1));
   CHECKOK(ok, I->tv);
   if (ok)
-    I->tn = Alloc(float, 3 * (I->Ns + 1));
+    I->tn = pymol::malloc<float>(3 * (I->Ns + 1));
   CHECKOK(ok, I->tn);
 
   if (!ok){
@@ -327,16 +327,16 @@ int ExtrudeDumbbell1(CExtrude * I, float
   FreeP(I->tv);
   FreeP(I->tn);
 
-  I->sv = Alloc(float, 3 * (I->Ns + 1));
+  I->sv = pymol::malloc<float>(3 * (I->Ns + 1));
   CHECKOK(ok, I->sv);
   if (ok)
-    I->sn = Alloc(float, 3 * (I->Ns + 1));
+    I->sn = pymol::malloc<float>(3 * (I->Ns + 1));
   CHECKOK(ok, I->sn);
   if (ok)
-    I->tv = Alloc(float, 3 * (I->Ns + 1));
+    I->tv = pymol::malloc<float>(3 * (I->Ns + 1));
   CHECKOK(ok, I->tv);
   if (ok)
-    I->tn = Alloc(float, 3 * (I->Ns + 1));
+    I->tn = pymol::malloc<float>(3 * (I->Ns + 1));
   CHECKOK(ok, I->tn);
 
   if (!ok){
@@ -432,16 +432,16 @@ int ExtrudeDumbbell2(CExtrude * I, int n
   FreeP(I->tv);
   FreeP(I->tn);
   
-  I->sv = Alloc(float, 3 * (n + 1));
+  I->sv = pymol::malloc<float>(3 * (n + 1));
   CHECKOK(ok, I->sv);
   if (ok)
-    I->sn = Alloc(float, 3 * (n + 1));
+    I->sn = pymol::malloc<float>(3 * (n + 1));
   CHECKOK(ok, I->sn);
   if (ok)
-    I->tv = Alloc(float, 3 * (n + 1));
+    I->tv = pymol::malloc<float>(3 * (n + 1));
   CHECKOK(ok, I->tv);
   if (ok)
-    I->tn = Alloc(float, 3 * (n + 1));
+    I->tn = pymol::malloc<float>(3 * (n + 1));
   CHECKOK(ok, I->tn);
 
   if (!ok){
@@ -587,7 +587,7 @@ int ExtrudeComputeTangents(CExtrude * I)
   PRINTFD(I->G, FB_Extrude)
     " ExtrudeComputeTangents-DEBUG: entered.\n" ENDFD;
 
-  nv = Alloc(float, I->N * 3);
+  nv = pymol::malloc<float>(I->N * 3);
   CHECKOK(ok, nv);
   if (!ok)
     return ok;
@@ -746,10 +746,10 @@ int ExtrudeCGOSurfaceTube(CExtrude * I,
     " ExtrudeCGOSurfaceTube-DEBUG: entered.\n" ENDFD;
 
   if(I->N && I->Ns) {
-    TV = Alloc(float, 3 * (I->Ns + 1) * I->N);
+    TV = pymol::malloc<float>(3 * (I->Ns + 1) * I->N);
     CHECKOK(ok, TV);
     if (ok)
-      TN = Alloc(float, 3 * (I->Ns + 1) * I->N);
+      TN = pymol::malloc<float>(3 * (I->Ns + 1) * I->N);
     CHECKOK(ok, TN);
     /* compute transformed shape vertices */
 
@@ -1115,9 +1115,9 @@ int ExtrudeCGOSurfaceVariableTube(CExtru
 
   if(I->N && I->Ns) {
 
-    TV = Alloc(float, 3 * (I->Ns + 1) * I->N);
-    TN = Alloc(float, 3 * (I->Ns + 1) * I->N);
-    AN = Alloc(float, 3 * I->N);        /* normals adjusted for changing widths */
+    TV = pymol::malloc<float>(3 * (I->Ns + 1) * I->N);
+    TN = pymol::malloc<float>(3 * (I->Ns + 1) * I->N);
+    AN = pymol::malloc<float>(3 * I->N);        /* normals adjusted for changing widths */
 
     /* compute transformed shape vertices */
 
@@ -1389,10 +1389,10 @@ int ExtrudeCGOSurfacePolygon(CExtrude *
 
   if(I->N && I->Ns) {
 
-    TV = Alloc(float, 3 * (I->Ns + 1) * I->N);
+    TV = pymol::malloc<float>(3 * (I->Ns + 1) * I->N);
     CHECKOK(ok, TV);
     if (ok)
-      TN = Alloc(float, 3 * (I->Ns + 1) * I->N);
+      TN = pymol::malloc<float>(3 * (I->Ns + 1) * I->N);
     CHECKOK(ok, TN);
     /* compute transformed shape vertices */
 
@@ -1589,10 +1589,10 @@ int ExtrudeCGOSurfacePolygonTaper(CExtru
 
   if(I->N && I->Ns) {
 
-    TV = Alloc(float, 3 * (I->Ns + 1) * I->N);
+    TV = pymol::malloc<float>(3 * (I->Ns + 1) * I->N);
     CHECKOK(ok, TV);
     if (ok)
-      TN = Alloc(float, 3 * (I->Ns + 1) * I->N);
+      TN = pymol::malloc<float>(3 * (I->Ns + 1) * I->N);
     CHECKOK(ok, TN);
     /* compute transformed shape vertices */
 
@@ -1729,10 +1729,10 @@ int ExtrudeCGOSurfaceStrand(CExtrude * I
 
   if(I->N && I->Ns) {
 
-    TV = Alloc(float, 3 * (I->Ns + 1) * I->N);
+    TV = pymol::malloc<float>(3 * (I->Ns + 1) * I->N);
     CHECKOK(ok, TV);
     if (ok)
-      TN = Alloc(float, 3 * (I->Ns + 1) * I->N);
+      TN = pymol::malloc<float>(3 * (I->Ns + 1) * I->N);
     CHECKOK(ok, TN);
     /* compute transformed shape vertices */
 
@@ -2175,7 +2175,7 @@ int ExtrudeComputePuttyScaleFactors(CExt
     /* now compute window average */
 
     {
-      float *SF = Alloc(float, I->N);
+      float *SF = pymol::malloc<float>(I->N);
       int w, ww;
       float accum;
       int cnt;
@@ -2229,22 +2229,22 @@ int ExtrudeAllocPointsNormalsColors(CExt
     FreeP(I->alpha);
     FreeP(I->i);
     FreeP(I->sf);               /* PUTTY */
-    I->p = Alloc(float, 3 * (n + 1));
+    I->p = pymol::malloc<float>(3 * (n + 1));
     CHECKOK(ok, I->p);
     if (ok)
-      I->n = Alloc(float, 9 * (n + 1));
+      I->n = pymol::malloc<float>(9 * (n + 1));
     CHECKOK(ok, I->n);
     if (ok)
-      I->c = Alloc(float, 3 * (n + 1));
+      I->c = pymol::malloc<float>(3 * (n + 1));
     CHECKOK(ok, I->c);
     if (ok)
-      I->alpha = Alloc(float, n + 1);
+      I->alpha = pymol::malloc<float>(n + 1);
     CHECKOK(ok, I->alpha);
     if (ok)
-      I->i = Alloc(unsigned int, 3 * (n + 1));
+      I->i = pymol::malloc<unsigned int>(3 * (n + 1));
     CHECKOK(ok, I->i);
     if (ok)
-      I->sf = Alloc(float, n + 1);        /* PUTTY: scale factors */
+      I->sf = pymol::malloc<float>(n + 1);        /* PUTTY: scale factors */
     CHECKOK(ok, I->sf);
     if (!ok){
       FreeP(I->p);
diff -upNr pymol-open-source-2.3.0/layer1/FontType.cpp pymol-open-source-2.3.3/layer1/FontType.cpp
--- pymol-open-source-2.3.0/layer1/FontType.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/FontType.cpp	2019-08-22 10:24:47.682589828 +0200
@@ -75,9 +75,6 @@ typedef struct {
   CTypeFace *TypeFace;
 } CFontType;
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static const char *_FontTypeRenderOpenGL(RenderInfo * info,
                                    CFontType * I, const char *st,
                                    float size, int flat, float *rpos, short needSize, short relativeMode, short shouldRender SHADERCGOARG)
@@ -109,7 +106,7 @@ static const char *_FontTypeRenderOpenGL
       float screenWorldOffset[3] = { 0.0F, 0.0F, 0.0F };
       float tot_height;
       if (nlines>1){
-	line_widths = Calloc(float, nlines);
+	line_widths = pymol::calloc<float>(nlines);
       }
       if(size < _0) {
         size = (int) (0.5F - size / v_scale);
@@ -347,7 +344,7 @@ static const char *FontTypeRenderRay(CRa
     float *line_widths = NULL;
     float tot_height;
     if (nlines>1){
-      line_widths = Calloc(float, nlines);
+      line_widths = pymol::calloc<float>(nlines);
     }
     if(size < _0) {
       size = (int) (0.5F - size / v_scale);
diff -upNr pymol-open-source-2.3.0/layer1/Ortho.cpp pymol-open-source-2.3.3/layer1/Ortho.cpp
--- pymol-open-source-2.3.0/layer1/Ortho.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/Ortho.cpp	2019-08-22 10:24:47.682589828 +0200
@@ -15,6 +15,8 @@ I* Additional authors of this source fil
 Z* -------------------------------------------------------------------
 */
 
+#include <vector>
+#include <memory>
 #include <queue>
 #include <string>
 #include <array>
@@ -50,7 +52,6 @@ Z* -------------------------------------
 #include "Vector.h"
 #include "CGO.h"
 #include "MyPNG.h"
-#include "MacPyMOL.h"
 #include "File.h"
 #include "LangUtil.h"
 
@@ -63,60 +64,81 @@ Z* -------------------------------------
 
 #define CMD_QUEUE_MASK 0x3
 
-struct _COrtho {
-  Block *Blocks;
-  Block *GrabbedBy, *ClickedIn;
-  int X, Y, Height, Width;
-  int LastX, LastY, LastModifiers;
-  int ActiveButton;
-  int DrawText;
-  int InputFlag;                /* whether or not we have active input on the line */
-
-  OrthoLineType Line[OrthoSaveLines + 1];
-  OrthoLineType History[OrthoHistoryLines + 1];
-  int HistoryLine, HistoryView;
-  int CurLine, CurChar, PromptChar, CursorChar;
-  int AutoOverlayStopLine;
-  FILE *Pipe;
-  char Prompt[255];
-  int ShowLines;
-  char Saved[OrthoLineLength];
-  int SavedPC, SavedCC;
-  float TextColor[3], OverlayColor[3], WizardBackColor[3], WizardTextColor[3];
-  int DirtyFlag;
-  double BusyLast, BusyLastUpdate;
-  int BusyStatus[4];
-  char BusyMessage[255];
-  char *WizardPromptVLA;
-  int SplashFlag;
-  int HaveSeqViewer;
-  BlockRect LoopRect;
-  int LoopFlag;
-  int cmdNestLevel;
+class COrtho {
+public:
+  std::vector<Block*> Blocks{};
+  Block *GrabbedBy{}, *ClickedIn{};
+  int X{}, Y{}, Height{}, Width{};
+  int LastX{}, LastY{}, LastModifiers{};
+  int ActiveButton{};
+  int DrawText{};
+  int InputFlag{};                /* whether or not we have active input on the line */
+
+  OrthoLineType Line[OrthoSaveLines + 1]{};
+  OrthoLineType History[OrthoHistoryLines + 1]{};
+  int HistoryLine{}, HistoryView{};
+  int CurLine{}, CurChar{}, PromptChar{}, CursorChar{};
+  int AutoOverlayStopLine{};
+  char Prompt[255]{};
+  int ShowLines{};
+  char Saved[OrthoLineLength]{};
+  int SavedPC{}, SavedCC{};
+  float TextColor[3]{}, OverlayColor[3]{}, WizardBackColor[3]{}, WizardTextColor[3]{};
+  int DirtyFlag{};
+  double BusyLast{}, BusyLastUpdate{};
+  int BusyStatus[4]{};
+  char BusyMessage[255]{};
+  char *WizardPromptVLA{};
+  int SplashFlag{};
+  int HaveSeqViewer{};
+  BlockRect LoopRect{};
+  int LoopFlag{};
+  int cmdNestLevel{};
   std::array<std::queue<std::string>, CMD_QUEUE_MASK + 1> cmdQueue;
   std::queue<std::string> *cmdActiveQueue;
-  int cmdActiveBusy;
+  int cmdActiveBusy{};
   std::queue<std::string> feedback;
-  int Pushed;
+  int Pushed{};
   std::vector<std::unique_ptr<CDeferred>> deferred; //Ortho manages DeferredObjs
-  int RenderMode;
-  GLint ViewPort[4];
-  int WrapXFlag;
-  GLenum ActiveGLBuffer;
-  double DrawTime, LastDraw;
-  int WrapClickSide;            /* ugly kludge for finding click side in geowall stereo mode */
+  int RenderMode{};
+  GLint ViewPort[4]{};
+  int WrapXFlag{};
+  GLenum ActiveGLBuffer{};
+  double DrawTime{}, LastDraw{};
+  int WrapClickSide{};            /* ugly kludge for finding click side in geowall stereo mode */
 
   /* packing information */
-  int WizardHeight;
-  int TextBottom;
+  int WizardHeight{};
+  int TextBottom{};
 
-  int IssueViewportWhenReleased;
-  GLuint bg_texture_id;
-  short bg_texture_needs_update;
-  CGO *bgCGO;
-  //void *bgData;  // this is the image data set from CMol, takes precedence of bg_gradient or bg_image_filename
-  std::shared_ptr<pymol::Image> bgData;
-  CGO *orthoCGO, *orthoFastCGO;
+  int IssueViewportWhenReleased{};
+  GLuint bg_texture_id{};
+  short bg_texture_needs_update{};
+  CGO *bgCGO{};
+  std::shared_ptr<pymol::Image> bgData; // this is the image data set from CMol, takes precedence of bg_gradient or bg_image_filename
+  CGO *orthoCGO{}, *orthoFastCGO{};
+
+  /**
+   * Finds last block located and coordinate (x, y)
+   * @param x cursor X location
+   * @param y cursor Y location
+   * @return pointer to last block located at (x, y)
+   */
+  Block* findBlock(int x, int y);
+
+public:
+  /**
+   * Draws all blocks
+   * @param orthoCGO CGO to append to
+   */
+  void draw(CGO* orthoCGO);
+
+  /**
+   * Draws all blocks
+   * @param orthoCGO CGO to append to
+   * @return true if anything was drawn to CGO
+   */
+  bool fastDraw(CGO* orthoCGO);
 };
 
 bool OrthoBackgroundDataIsSet(const COrtho& ortho)
@@ -599,18 +621,6 @@ void OrthoBusyDraw(PyMOLGlobals * G, int
     I->BusyLast = now;
     if(PIsGlutThread()) {
 
-#ifdef _MACPYMOL_XCODE
-      /* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in "os_proprietary.h") */
-      float busyValue = 0.0F;
-      if(I->BusyStatus[1]) {
-        busyValue = (I->BusyStatus[0] * 1.0F / I->BusyStatus[1]);
-      }
-      if(I->BusyStatus[3]) {
-        busyValue = (I->BusyStatus[2] * 1.0F / I->BusyStatus[3]);
-      }
-      MacPyMOL_SetProgress(busyValue);
-      /* END PROPRIETARY CODE SEGMENT */
-#else
       if(G->HaveGUI && G->ValidContext
           // only draw into GL_FRONT if default draw buffer is GL_BACK
           // (not the case for QOpenGLWidget)
@@ -710,7 +720,6 @@ void OrthoBusyDraw(PyMOLGlobals * G, int
         OrthoPopMatrix(G);
         OrthoDirty(G);
       }
-#endif
 
     }
   }
@@ -1222,8 +1231,7 @@ void OrthoUngrab(PyMOLGlobals * G)
 /*========================================================================*/
 void OrthoAttach(PyMOLGlobals * G, Block * block, int type)
 {
-  COrtho *I = G->Ortho;
-  ListInsert(I->Blocks, block, NULL, next, Block);
+  G->Ortho->Blocks.push_back(block);
 }
 
 
@@ -1233,7 +1241,10 @@ void OrthoDetach(PyMOLGlobals * G, Block
   COrtho *I = G->Ortho;
   if(I->GrabbedBy == block)
     I->GrabbedBy = NULL;
-  ListDetach(I->Blocks, block, next, Block);
+  auto iter = std::find(I->Blocks.begin(), I->Blocks.end(), block);
+  if(iter != I->Blocks.end()){
+    I->Blocks.erase(iter);
+  }
 }
 
 float *OrthoGetOverlayColor(PyMOLGlobals * G)
@@ -1623,8 +1634,8 @@ void OrthoDoDraw(PyMOLGlobals * G, int r
 	if(SettingGetGlobal_b(G, cSetting_internal_gui) && 
 	   SettingGetGlobal_b(G, cSetting_use_shaders)){
 	  CGO *orthoFastCGO = CGONew(G);
-	    CGOFree(I->orthoFastCGO);
-	  if (I->Blocks->recursiveFastDraw(orthoFastCGO)){
+          CGOFree(I->orthoFastCGO);
+	  if (G->Ortho->fastDraw(orthoFastCGO)){
 	    int ok = true;
 	    CGO *expandedCGO;
 	    CGOStop(orthoFastCGO);
@@ -1793,10 +1804,10 @@ void OrthoDoDraw(PyMOLGlobals * G, int r
         block = SeqGetBlock(G);
         active_tmp = block->active;
         block->active = false;
-        I->Blocks->recursiveDraw(orthoCGO);
+        G->Ortho->draw(orthoCGO);
         block->active = active_tmp;
       } else {
-        I->Blocks->recursiveDraw(orthoCGO);
+        G->Ortho->draw(orthoCGO);
       }
 
       PRINTFD(G, FB_Ortho)
@@ -2271,8 +2282,8 @@ void OrthoReshape(PyMOLGlobals * G, int
     block->setMargin(sceneTop, 0, sceneBottom, sceneRight);
 
     block = NULL;
-    while(ListIterate(I->Blocks, block, next)){
-        block->reshape(width, height);
+    for(auto block : I->Blocks){
+      block->reshape(width, height);
     }
 
     WizardRefresh(G);           /* safe to call even if no wizard exists */
@@ -2304,17 +2315,6 @@ void OrthoReshapeWizard(PyMOLGlobals * G
   }
 }
 
-
-/*========================================================================*/
-static
-Block *OrthoFindBlock(PyMOLGlobals * G, int x, int y)
-{
-  COrtho *I = G->Ortho;
-
-  return (I->Blocks->recursiveFind(x, y));
-}
-
-
 /*========================================================================*/
 int OrthoGetWrapClickSide(PyMOLGlobals * G)
 {
@@ -2364,12 +2364,9 @@ int OrthoButton(PyMOLGlobals * G, int bu
   if(state == P_GLUT_DOWN) {
     I->ActiveButton = button;
     if(I->GrabbedBy) {
-      if(I->GrabbedBy->inside)
-        block = I->GrabbedBy->inside->recursiveFind(x, y);
-      else
-        block = I->GrabbedBy;
+      block = I->GrabbedBy;
     } else if(!block)
-      block = OrthoFindBlock(G, x, y);
+      block = G->Ortho->findBlock(x, y);
     if(block) {
       I->ClickedIn = block;
       handled = block->click(button, x, y, mod);
@@ -2503,13 +2500,7 @@ int OrthoInit(PyMOLGlobals * G, int show
 {
   COrtho *I = NULL;
 
-  if((I = (G->Ortho = Calloc(COrtho, 1)))) {
-
-    new (&I->deferred)(decltype(I->deferred));
-    new (&I->feedback)(decltype(I->feedback));
-    new (&I->cmdQueue)(decltype(I->cmdQueue));
-
-    ListInit(I->Blocks);
+  if((I = (G->Ortho = new COrtho()))) {
 
     I->ActiveButton = -1;
     I->Pushed = 0;
@@ -2603,16 +2594,12 @@ void OrthoFree(PyMOLGlobals * G)
     I->cmdActiveQueue = NULL;
   }
 
-  pymol::destroy_at(&I->deferred);
-  pymol::destroy_at(&I->feedback);
-  pymol::destroy_at(&I->cmdQueue);
-
   I->bgData = nullptr;
 
     CGOFree(I->bgCGO);
   CGOFree(I->orthoCGO);
   CGOFree(I->orthoFastCGO);
-  FreeP(G->Ortho);
+  delete G->Ortho;
 }
 
 
@@ -2763,9 +2750,9 @@ void OrthoPasteIn(PyMOLGlobals * G, cons
     I->InputFlag = true;
 }
 
-#if 0
 /* TODO: Removed. Check in Mobile PyMOL to see if needed - PYMOL-3148*/
 void OrthoSetBackgroundImage(PyMOLGlobals * G, const char *image_data, int width, int height){
+#if 0
   COrtho *I = G->Ortho;
   int buff_total = width * height;  
   short should_update = 0;
@@ -2777,7 +2764,7 @@ void OrthoSetBackgroundImage(PyMOLGlobal
     should_update = 1;
   }
   if (buff_total){
-    I->bgData = Alloc(unsigned char, buff_total*4);
+    I->bgData = pymol::malloc<unsigned char>(buff_total*4);
     I->bgWidth = width;
     I->bgHeight = height;
     memcpy(I->bgData, image_data, buff_total * 4);
@@ -2794,8 +2781,8 @@ void OrthoSetBackgroundImage(PyMOLGlobal
     G->ShaderMgr->Reload_All_Shaders();
     I->bg_texture_needs_update = 1;
   }
-}
 #endif
+}
 
 void OrthoInvalidateDoDraw(PyMOLGlobals * G)
 {
@@ -2805,3 +2792,31 @@ void OrthoInvalidateDoDraw(PyMOLGlobals
     PyMOL_NeedRedisplay(G->PyMOL);
   }
 }
+
+void COrtho::draw(CGO* orthoCGO)
+{
+  for (auto block : Blocks) {
+    block->recursiveDraw(orthoCGO);
+  }
+}
+
+bool COrtho::fastDraw(CGO* orthoCGO)
+{
+  bool ret{false};
+  for (auto block : Blocks) {
+    ret |= block->recursiveFastDraw(orthoCGO);
+  }
+  return ret;
+}
+
+Block* COrtho::findBlock(int x, int y)
+{
+  for (auto blockIter = Blocks.rbegin(); blockIter != Blocks.rend();
+       ++blockIter) {
+    auto blockFound = (*blockIter)->recursiveFind(x, y);
+    if (blockFound != nullptr) {
+      return blockFound;
+    }
+  }
+  return nullptr;
+}
diff -upNr pymol-open-source-2.3.0/layer1/Ortho.h pymol-open-source-2.3.3/layer1/Ortho.h
--- pymol-open-source-2.3.0/layer1/Ortho.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/Ortho.h	2019-08-22 10:24:47.682589828 +0200
@@ -25,8 +25,6 @@ Z* -------------------------------------
 #define cOrthoBottomSceneMargin DIP2PIXEL(18)
 #define cOrthoLineHeight DIP2PIXEL(12)
 
-#include <vector>
-#include <memory>
 #include <string>
 
 #include"os_gl.h"
diff -upNr pymol-open-source-2.3.0/layer1/PConvArgs.h pymol-open-source-2.3.3/layer1/PConvArgs.h
--- pymol-open-source-2.3.0/layer1/PConvArgs.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/PConvArgs.h	2019-08-22 10:24:47.686590479 +0200
@@ -3,9 +3,8 @@
  * PConvArgsFromPyList
  *
  * Templated convenience function to create a Python list from
- * 2 to 6 (arbitrary number with C++11) arguments and vice versa
+ * arbitrary number and vice versa
  *
- * TODO: remove non-variadic part when full C++11 supports becomes available
  */
 
 #include "os_python.h"
@@ -16,9 +15,6 @@
  * PConvArgsToPyList
  */
 
-#if __cplusplus >= 201103L
-// variadic templates
-
 inline void _PConvArgsToPyList_SetItem(PyObject * list, int i) {
 }
 
@@ -35,68 +31,10 @@ inline PyObject * PConvArgsToPyList(cons
   return list;
 }
 
-#else
-// no variadic templates
-
-template <class A, class B>
-inline PyObject * PConvArgsToPyList(const A& a, const B& b) {
-  PyObject * obj = PyList_New(2);
-  PyList_SET_ITEM(obj, 0, PConvToPyObject(a));
-  PyList_SET_ITEM(obj, 1, PConvToPyObject(b));
-  return obj;
-}
-
-template <class A, class B, class C>
-inline PyObject * PConvArgsToPyList(const A& a, const B& b, const C& c) {
-  PyObject * obj = PyList_New(3);
-  PyList_SET_ITEM(obj, 0, PConvToPyObject(a));
-  PyList_SET_ITEM(obj, 1, PConvToPyObject(b));
-  PyList_SET_ITEM(obj, 2, PConvToPyObject(c));
-  return obj;
-}
-
-template <class A, class B, class C, class D>
-inline PyObject * PConvArgsToPyList(const A& a, const B& b, const C& c, const D& d) {
-  PyObject * obj = PyList_New(4);
-  PyList_SET_ITEM(obj, 0, PConvToPyObject(a));
-  PyList_SET_ITEM(obj, 1, PConvToPyObject(b));
-  PyList_SET_ITEM(obj, 2, PConvToPyObject(c));
-  PyList_SET_ITEM(obj, 3, PConvToPyObject(d));
-  return obj;
-}
-
-template <class A, class B, class C, class D, class E>
-inline PyObject * PConvArgsToPyList(const A& a, const B& b, const C& c, const D& d, const E& e) {
-  PyObject * obj = PyList_New(5);
-  PyList_SET_ITEM(obj, 0, PConvToPyObject(a));
-  PyList_SET_ITEM(obj, 1, PConvToPyObject(b));
-  PyList_SET_ITEM(obj, 2, PConvToPyObject(c));
-  PyList_SET_ITEM(obj, 3, PConvToPyObject(d));
-  PyList_SET_ITEM(obj, 4, PConvToPyObject(e));
-  return obj;
-}
-
-template <class A, class B, class C, class D, class E, class F>
-inline PyObject * PConvArgsToPyList(const A& a, const B& b, const C& c, const D& d, const E& e, const F& f) {
-  PyObject * obj = PyList_New(6);
-  PyList_SET_ITEM(obj, 0, PConvToPyObject(a));
-  PyList_SET_ITEM(obj, 1, PConvToPyObject(b));
-  PyList_SET_ITEM(obj, 2, PConvToPyObject(c));
-  PyList_SET_ITEM(obj, 3, PConvToPyObject(d));
-  PyList_SET_ITEM(obj, 4, PConvToPyObject(e));
-  PyList_SET_ITEM(obj, 5, PConvToPyObject(f));
-  return obj;
-}
-
-#endif
-
 /*
  * PConvArgsFromPyList
  */
 
-#if __cplusplus >= 201103L
-// variadic templates
-
 inline bool _PConvArgsFromPyList_GetItem(PyMOLGlobals * G, PyObject * list, int len, int i) {
   return (len == i);
 }
@@ -116,57 +54,3 @@ inline bool PConvArgsFromPyList(PyMOLGlo
   return _PConvArgsFromPyList_GetItem(G, list, len, 0, args...);
 }
 
-#else
-// no variadic templates
-
-template <class A, class B>
-inline bool PConvArgsFromPyList(PyMOLGlobals * G, PyObject * obj, A& a, B& b) {
-  int len = PyList_Size(obj);
-  if (len > 0) PConvFromPyObject(G, PyList_GetItem(obj, 0), a);
-  if (len > 1) PConvFromPyObject(G, PyList_GetItem(obj, 1), b);
-  return true;
-}
-
-template <class A, class B, class C>
-inline bool PConvArgsFromPyList(PyMOLGlobals * G, PyObject * obj, A& a, B& b, C& c) {
-  int len = PyList_Size(obj);
-  if (len > 0) PConvFromPyObject(G, PyList_GetItem(obj, 0), a);
-  if (len > 1) PConvFromPyObject(G, PyList_GetItem(obj, 1), b);
-  if (len > 2) PConvFromPyObject(G, PyList_GetItem(obj, 2), c);
-  return true;
-}
-
-template <class A, class B, class C, class D>
-inline bool PConvArgsFromPyList(PyMOLGlobals * G, PyObject * obj, A& a, B& b, C& c, D& d) {
-  int len = PyList_Size(obj);
-  if (len > 0) PConvFromPyObject(G, PyList_GetItem(obj, 0), a);
-  if (len > 1) PConvFromPyObject(G, PyList_GetItem(obj, 1), b);
-  if (len > 2) PConvFromPyObject(G, PyList_GetItem(obj, 2), c);
-  if (len > 3) PConvFromPyObject(G, PyList_GetItem(obj, 3), d);
-  return true;
-}
-
-template <class A, class B, class C, class D, class E>
-inline bool PConvArgsFromPyList(PyMOLGlobals * G, PyObject * obj, A& a, B& b, C& c, D& d, E& e) {
-  int len = PyList_Size(obj);
-  if (len > 0) PConvFromPyObject(G, PyList_GetItem(obj, 0), a);
-  if (len > 1) PConvFromPyObject(G, PyList_GetItem(obj, 1), b);
-  if (len > 2) PConvFromPyObject(G, PyList_GetItem(obj, 2), c);
-  if (len > 3) PConvFromPyObject(G, PyList_GetItem(obj, 3), d);
-  if (len > 4) PConvFromPyObject(G, PyList_GetItem(obj, 4), e);
-  return true;
-}
-
-template <class A, class B, class C, class D, class E, class F>
-inline bool PConvArgsFromPyList(PyMOLGlobals * G, PyObject * obj, A& a, B& b, C& c, D& d, E& e, F& f) {
-  int len = PyList_Size(obj);
-  if (len > 0) PConvFromPyObject(G, PyList_GetItem(obj, 0), a);
-  if (len > 1) PConvFromPyObject(G, PyList_GetItem(obj, 1), b);
-  if (len > 2) PConvFromPyObject(G, PyList_GetItem(obj, 2), c);
-  if (len > 3) PConvFromPyObject(G, PyList_GetItem(obj, 3), d);
-  if (len > 4) PConvFromPyObject(G, PyList_GetItem(obj, 4), e);
-  if (len > 5) PConvFromPyObject(G, PyList_GetItem(obj, 5), f);
-  return true;
-}
-
-#endif
diff -upNr pymol-open-source-2.3.0/layer1/PConv.cpp pymol-open-source-2.3.3/layer1/PConv.cpp
--- pymol-open-source-2.3.0/layer1/PConv.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/PConv.cpp	2019-08-22 10:24:47.686590479 +0200
@@ -534,7 +534,7 @@ int PConvPyListToFloatArrayImpl(PyObject
     if (as_vla) {
       (*f) = VLAlloc(float, l);
     } else {
-      (*f) = Alloc(float, l);
+      (*f) = pymol::malloc<float>(l);
     }
 
     auto strval = PyBytes_AsSomeString(obj);
@@ -552,7 +552,7 @@ int PConvPyListToFloatArrayImpl(PyObject
     if (as_vla) {
       (*f) = VLAlloc(float, l);
     } else {
-      (*f) = Alloc(float, l);
+      (*f) = pymol::malloc<float>(l);
     }
 
     ff = (*f);
@@ -648,7 +648,7 @@ int PConvPyListToDoubleArray(PyObject *
       ok = -1;
     else
       ok = l;
-    (*f) = Alloc(double, l);
+    (*f) = pymol::malloc<double>(l);
     ff = (*f);
     for(a = 0; a < l; a++)
       *(ff++) = PyFloat_AsDouble(PyList_GetItem(obj, a));
@@ -672,7 +672,7 @@ int PConvPyListToIntArrayImpl(PyObject *
     if (as_vla) {
       (*f) = VLAlloc(int, l);
     } else {
-      (*f) = Alloc(int, l);
+      (*f) = pymol::malloc<int>(l);
     }
 
     auto strval = PyBytes_AsSomeString(obj);
@@ -690,7 +690,7 @@ int PConvPyListToIntArrayImpl(PyObject *
     if (as_vla) {
       (*f) = VLAlloc(int, l);
     } else {
-      (*f) = Alloc(int, l);
+      (*f) = pymol::malloc<int>(l);
     }
 
     ff = (*f);
diff -upNr pymol-open-source-2.3.0/layer1/P.cpp pymol-open-source-2.3.3/layer1/P.cpp
--- pymol-open-source-2.3.0/layer1/P.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/P.cpp	2019-08-22 10:24:47.686590479 +0200
@@ -455,7 +455,7 @@ PyObject *SettingWrapperObjectSubScript(
       // object-state, object, or global
       ret = SettingGetPyObject(G,
           wobj->cs ? wobj->cs->Setting : NULL,
-          wobj->obj->Obj.Setting, setting_id);
+          wobj->obj->Setting, setting_id);
     }
   }
   return PConvAutoNone(ret);
@@ -659,7 +659,7 @@ PyObject * WrapperObjectSubScript(PyObje
       }
       break;
     case cPType_model:
-      ret = PyString_FromString(wobj->obj->Obj.Name);
+      ret = PyString_FromString(wobj->obj->Name);
       break;
     case cPType_index:
       {
@@ -1980,7 +1980,7 @@ void PSetupEmbedded(PyMOLGlobals * G, in
     char *pymol_path = getenv("PYMOL_PATH");
     if(pymol_path) {
       PyObject *os = PyImport_AddModule("os");  /* borrowed ref */
-      char *buffer = Alloc(char, strlen(pymol_path) + 100);
+      char *buffer = pymol::malloc<char>(strlen(pymol_path) + 100);
       if(os && buffer) {
         PyObject *envir = PyObject_GetAttrString(os, "environ");
         if(envir) {
@@ -2061,7 +2061,6 @@ void PConvertOptions(CPyMOLOptions * rec
   rec->stereo_mode = PyInt_AsLong(PyObject_GetAttrString(options, "stereo_mode"));
   rec->zoom_mode = PyInt_AsLong(PyObject_GetAttrString(options, "zoom_mode"));
   rec->no_quit = PyInt_AsLong(PyObject_GetAttrString(options, "no_quit"));
-  rec->retina = PyInt_AsLong(PyObject_GetAttrString(options, "retina"));
   rec->launch_status = PyInt_AsLong(PyObject_GetAttrString(options, "launch_status"));
   rec->gldebug = PyInt_AsLong(PyObject_GetAttrString(options, "gldebug"));
 
@@ -2171,7 +2170,7 @@ void PInit(PyMOLGlobals * G, int global_
     ErrFatal(G, "PyMOL", "can't find globals for 'pymol'");
 
   if(global_instance) {         /* if global singleton PyMOL... */
-    G->P_inst = Calloc(CP_inst, 1);
+    G->P_inst = pymol::calloc<CP_inst>(1);
     G->P_inst->obj = P_pymol;
     G->P_inst->dict = P_pymol_dict;
     {
diff -upNr pymol-open-source-2.3.0/layer1/PyMOLObject.cpp pymol-open-source-2.3.3/layer1/PyMOLObject.cpp
--- pymol-open-source-2.3.0/layer1/PyMOLObject.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/PyMOLObject.cpp	2019-08-22 10:24:47.686590479 +0200
@@ -604,8 +604,15 @@ void ObjectAdjustStateRebuildRange(CObje
   }
 }
 
-void ObjectMakeValidName(char *name)
+/**
+ * Replaces invalid characters in the given object name with an underscore,
+ * or strips them if they are terminal or sequential.
+ * @param[in,out] name Object name to validate
+ * @return true if name was modified, false otherwise
+ */
+bool ObjectMakeValidName(char *name)
 {
+  bool modified = false;
   char *p = name, *q;
   if(p) {
     /* currently legal are A to Z, a to z, 0 to 9, -, _, + */
@@ -624,6 +631,7 @@ void ObjectMakeValidName(char *name)
             break;
         /* must be an ASCII-visible character */
         *p = 1;                 /* placeholder for non-printable */
+        modified = true;
       }
       p++;
     }
@@ -656,6 +664,7 @@ void ObjectMakeValidName(char *name)
       p++;
     }
   }
+  return modified;
 }
 
 /*
@@ -664,14 +673,32 @@ void ObjectMakeValidName(char *name)
  */
 void ObjectMakeValidName(PyMOLGlobals * G, char *name)
 {
-  ObjectMakeValidName(name);
+  if (ObjectMakeValidName(name)) {
+    PRINTFB(G, FB_Executive, FB_Warnings)
+      " Warning: Invalid characters in '%s' have been replaced or stripped\n",
+      name ENDFB(G);
+  }
 
   if (SelectorNameIsKeyword(G, name)) {
     PRINTFB(G, FB_Executive, FB_Warnings)
       " Warning: '%s' is a reserved keyword, appending underscore\n", name
       ENDFB(G);
     strcat(name, "_");
-  } else if (strcmp(name, "protein") == 0 || strcmp(name, "nucleic") == 0) {
+    return;
+  }
+
+  static bool once_protein = false;
+  static bool once_nucleic = false;
+
+  if (!once_protein && strcmp(name, "protein") == 0) {
+    once_protein = true;
+  } else if (!once_nucleic && strcmp(name, "nucleic") == 0) {
+    once_nucleic = true;
+  } else {
+    return;
+  }
+
+  {
     // Warn the user if "protein" or "nucleic" are used as names, but
     // don't modify the name (yet).
     PRINTFB(G, FB_Executive, FB_Warnings)
@@ -820,7 +847,7 @@ int ObjectCopyHeader(CObject * I, const
 
 
 /*========================================================================*/
-void ObjectCombineTTT(CObject * I, float *ttt, int reverse_order, int store)
+void ObjectCombineTTT(CObject * I, const float *ttt, int reverse_order, int store)
 {
   if(I->type == cObjectGroup) {
     ExecutiveGroupCombineTTT(I->G, I, ttt, reverse_order,store);
@@ -1291,7 +1318,7 @@ void ObjectStateCopy(CObjectState * dst,
   *dst = *src;
   /* deep copy matrices if necessary */
   if(src->Matrix) {
-    dst->Matrix = Alloc(double, 16);
+    dst->Matrix = pymol::malloc<double>(16);
     if(dst->Matrix) {
       copy44d(src->Matrix, dst->Matrix);
     }
@@ -1310,7 +1337,7 @@ int ObjectStateSetMatrix(CObjectState *
   int ok = true;
   if(matrix) {
     if(!I->Matrix)
-      I->Matrix = Alloc(double, 16);
+      I->Matrix = pymol::malloc<double>(16);
     CHECKOK(ok, I->Matrix);
     if(I->Matrix) {
       copy44d(matrix, I->Matrix);
@@ -1327,7 +1354,7 @@ void ObjectStateRightCombineMatrixR44d(C
 {
   if(matrix) {
     if(!I->Matrix) {
-      I->Matrix = Alloc(double, 16);
+      I->Matrix = pymol::malloc<double>(16);
       copy44d(matrix, I->Matrix);
     } else {
       right_multiply44d44d(I->Matrix, matrix);
@@ -1340,7 +1367,7 @@ void ObjectStateLeftCombineMatrixR44d(CO
 {
   if(matrix) {
     if(!I->Matrix) {
-      I->Matrix = Alloc(double, 16);
+      I->Matrix = pymol::malloc<double>(16);
       copy44d(matrix, I->Matrix);
     } else {
       left_multiply44d44d(matrix, I->Matrix);
@@ -1354,7 +1381,7 @@ void ObjectStateCombineMatrixTTT(CObject
 
   if(matrix) {
     if(!I->Matrix) {
-      I->Matrix = Alloc(double, 16);
+      I->Matrix = pymol::malloc<double>(16);
       convertTTTfR44d(matrix, I->Matrix);
     } else {
       double tmp[16];
@@ -1376,7 +1403,7 @@ double *ObjectStateGetMatrix(CObjectStat
 double *ObjectStateGetInvMatrix(CObjectState * I)
 {
   if(I->Matrix && !I->InvMatrix) {
-    I->InvMatrix = Alloc(double, 16);
+    I->InvMatrix = pymol::malloc<double>(16);
     xx_matrix_invert(I->InvMatrix, I->Matrix, 4);
   }
   return I->InvMatrix;
@@ -1385,7 +1412,7 @@ double *ObjectStateGetInvMatrix(CObjectS
 void ObjectStateTransformMatrix(CObjectState * I, double *matrix)
 {
   if(!I->Matrix) {
-    I->Matrix = Alloc(double, 16);
+    I->Matrix = pymol::malloc<double>(16);
     if(I->Matrix) {
       copy44d(matrix, I->Matrix);
     }
diff -upNr pymol-open-source-2.3.0/layer1/PyMOLObject.h pymol-open-source-2.3.3/layer1/PyMOLObject.h
--- pymol-open-source-2.3.0/layer1/PyMOLObject.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/PyMOLObject.h	2019-08-22 10:24:47.686590479 +0200
@@ -118,7 +118,7 @@ void ObjectInit(PyMOLGlobals * G, CObjec
 int ObjectCopyHeader(CObject * I, const CObject * src);
 void ObjectPurge(CObject * I);
 void ObjectSetName(CObject * I, const char *name);
-void ObjectMakeValidName(char *name);
+bool ObjectMakeValidName(char *name);
 void ObjectMakeValidName(PyMOLGlobals * G, char *name);
 void ObjectPurgeSettings(CObject * I);
 void ObjectFree(CObject * I);
@@ -130,7 +130,7 @@ void ObjectPrepareContext(CObject * I, R
 void ObjectSetTTT(CObject * I, const float *ttt, int state,int store);
 int ObjectGetTTT(CObject * I, const float **ttt, int state);
 int ObjectGetTotalMatrix(CObject * I, int state, int history, double *matrix);
-void ObjectCombineTTT(CObject * I, float *ttt, int reverse_order, int store);
+void ObjectCombineTTT(CObject * I, const float *ttt, int reverse_order, int store);
 void ObjectTranslateTTT(CObject * T, float *v,int store);
 void ObjectSetTTTOrigin(CObject * I, float *origin);
 void ObjectResetTTT(CObject * I,int store);
diff -upNr pymol-open-source-2.3.0/layer1/Ray.cpp pymol-open-source-2.3.3/layer1/Ray.cpp
--- pymol-open-source-2.3.0/layer1/Ray.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/Ray.cpp	2019-08-22 10:24:47.690591131 +0200
@@ -43,11 +43,7 @@ Z* -------------------------------------
 
 #define SettingGetfv SettingGetGlobal_3fv
 
-#ifdef _PYMOL_INLINE
-#undef _PYMOL_INLINE
-#include"Basis.cpp"
-#define _PYMOL_INLINE
-#endif
+#include"Basis.h"
 
 #ifndef RAY_SMALL
 #define RAY_SMALL 0.00001
@@ -218,9 +214,6 @@ int RayGetNPrimitives(CRay * I)
 
 /*========================================================================*/
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static void RayGetSphereNormal(CRay * I, RayInfo * r)
 {
 
@@ -235,9 +228,6 @@ static void RayGetSphereNormal(CRay * I,
   normalize3f(r->surfnormal);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static void RayGetSphereNormalPerspective(CRay * I, RayInfo * r)
 {
 
@@ -463,9 +453,6 @@ static void fill_gradient(CRay * I, int
 }
 
 /*========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static void RayReflectAndTexture(CRay * I, RayInfo * r, int perspective)
 {
   if(r->prim->wobble)
@@ -1664,7 +1651,7 @@ static void VectorHash_Free(VectorHash *
 
 static VectorHash *VectorHash_New(void)
 {
-  VectorHash *I = Calloc(VectorHash, 1);
+  VectorHash *I = pymol::calloc<VectorHash>(1);
   if(I) {
     I->elem = VLACalloc(VectorHashElem, 100);
     if(!I->elem) {
@@ -2374,7 +2361,7 @@ void RayRenderIDTF(CRay * I, char **node
          mesh->face_shading_list appropriately for each face */
 
       {
-        IdtfMaterial *material = Calloc(IdtfMaterial, 1);
+        IdtfMaterial *material = pymol::calloc<IdtfMaterial>(1);
         if(material &&
            (material->color_list = VLAlloc(float, 4)) &&
            (material->color_hash = VectorHash_New())) {
@@ -5633,9 +5620,9 @@ void RayRender(CRay * I, unsigned int *i
     buffer_size = width * height;
   }
   if(ray_trace_mode) {
-    depth = Calloc(float, width * height);
+    depth = pymol::calloc<float>(width * height);
   } else if(oversample_cutoff) {
-    depth = Calloc(float, width * height);
+    depth = pymol::calloc<float>(width * height);
   }
   ambient = SettingGetGlobal_f(I->G, cSetting_ambient);
 
@@ -5885,7 +5872,7 @@ void RayRender(CRay * I, unsigned int *i
 #ifndef _PYMOL_NOPY
     if(shadows && (n_thread > 1)) {     /* parallel execution */
 
-      CRayHashThreadInfo *thread_info = Calloc(CRayHashThreadInfo, I->NBasis);
+      CRayHashThreadInfo *thread_info = pymol::calloc<CRayHashThreadInfo>(I->NBasis);
 
       /* rendering map */
 
@@ -5993,7 +5980,7 @@ void RayRender(CRay * I, unsigned int *i
 
     if (ok){
       /* now spawn threads as needed */
-      CRayThreadInfo *rt = Calloc(CRayThreadInfo, n_thread);
+      CRayThreadInfo *rt = pymol::calloc<CRayThreadInfo>(n_thread);
 
       int x_start = 0, y_start = 0;
       int x_stop = 0, y_stop = 0;
@@ -6145,7 +6132,7 @@ void RayRender(CRay * I, unsigned int *i
   }
 
   if(ok && depth && ray_trace_mode) {
-    float *delta = Alloc(float, 3 * width * height);
+    float *delta = pymol::malloc<float>(3 * width * height);
     int x, y;
     ErrChkPtr(I->G, delta);
     if (ok) {
@@ -6232,7 +6219,7 @@ void RayRender(CRay * I, unsigned int *i
         }
 
         if(fogFlag) {           /* make sure we have depth values at every potentially drawn pixel */
-          float *tmp = Alloc(float, width * height);
+          float *tmp = pymol::malloc<float>(width * height);
           float dep;
           float *p, *q;
           int cnt;
@@ -6510,7 +6497,7 @@ void RayRender(CRay * I, unsigned int *i
 
   if(ok && antialias > 1) {
     /* now spawn threads as needed */
-    CRayAntiThreadInfo *rt = Calloc(CRayAntiThreadInfo, n_thread);
+    CRayAntiThreadInfo *rt = pymol::calloc<CRayAntiThreadInfo>(n_thread);
 
     for(a = 0; a < n_thread; a++) {
       rt[a].width = width;
@@ -6898,7 +6885,6 @@ int CRay::cylinder3fv(const float *v1, c
 
   p->type = cPrimCylinder;
   p->r1 = r;
-  p->trans = I->Trans;
   p->cap1 = cCylCapFlat;
   p->cap2 = cCylCapFlat;
   p->wobble = I->Wobble;
@@ -6939,7 +6925,8 @@ int CRay::cylinder3fv(const float *v1, c
   (*vv++) = (*c2++);
   (*vv++) = (*c2++);
 
-  p->trans = 1.0 - alpha1;
+  // FIXME: alpha1 is not used
+  p->trans = 1.0 - alpha2;
   {
     float *v;
     vv = p->ic;
@@ -6994,7 +6981,6 @@ int CRay::customCylinder3fv(const float
 
   p->type = cPrimCylinder;
   p->r1 = r;
-  p->trans = I->Trans;
   p->cap1 = cap1;
   p->cap2 = cap2;
   p->wobble = I->Wobble;
@@ -7036,7 +7022,8 @@ int CRay::customCylinder3fv(const float
   (*vv++) = (*c2++);
   vv = p->ic;
 
-  p->trans = 1.0f - alpha1;
+  // FIXME: alpha1 is not used
+  p->trans = 1.0f - alpha2;
 
   {
     float *v;
diff -upNr pymol-open-source-2.3.0/layer1/Scene.cpp pymol-open-source-2.3.3/layer1/Scene.cpp
--- pymol-open-source-2.3.0/layer1/Scene.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/Scene.cpp	2019-08-22 10:24:47.690591131 +0200
@@ -59,7 +59,6 @@ Z* -------------------------------------
 #include"ScrollBar.h"
 #include "ShaderMgr.h"
 #include "PopUp.h"
-#include "MacPyMOL.h"
 #include <string>
 #include <vector>
 #include <algorithm>
@@ -1844,12 +1843,12 @@ bool ScenePNG(PyMOLGlobals * G, const ch
     if(MyPNGWrite(png, *saveImage, dpi, format, quiet, screen_gamma, file_gamma)) {
       if(!quiet) {
         PRINTFB(G, FB_Scene, FB_Actions)
-          " ScenePNG: wrote %dx%d pixel image to file \"%s\".\n",
+          " %s: wrote %dx%d pixel image to file \"%s\".\n", __func__,
           width, I->Image->getHeight(), png ENDFB(G);
       }
     } else {
       PRINTFB(G, FB_Scene, FB_Errors)
-        " ScenePNG-Error: error writing \"%s\"! Please check directory...\n",
+        " %s-Error: error writing \"%s\"! Please check directory...\n", __func__,
         png ENDFB(G);
     }
   }
@@ -1893,7 +1892,7 @@ int SceneCountFrames(PyMOLGlobals * G)
         I->NFrame = n;
     }
   }
-  PRINTFD(G, FB_Scene)" SceneCountFrames: leaving... I->NFrame %d\n", I->NFrame ENDFD
+  PRINTFD(G, FB_Scene)" %s: leaving... I->NFrame %d\n", __func__, I->NFrame ENDFD
   return I->NFrame;
 }
 
@@ -1909,7 +1908,7 @@ void SceneSetFrame(PyMOLGlobals * G, int
 
   newFrame = SettingGetGlobal_i(G, cSetting_frame) - 1;
   PRINTFD(G, FB_Scene)
-    " SceneSetFrame: entered.\n" ENDFD;
+    " %s: entered.\n", __func__ ENDFD;
   switch (mode) {
   case -1:                     /* movie/frame override - go to this state absolutely! */
     newState = frame;
@@ -2007,7 +2006,7 @@ void SceneSetFrame(PyMOLGlobals * G, int
     SeqChanged(G); // SceneInvalidate(G);
   }
   PRINTFD(G, FB_Scene)
-    " SceneSetFrame: leaving...\n" ENDFD;
+    " %s: leaving...\n", __func__ ENDFD;
   OrthoInvalidateDoDraw(G);
 }
 
@@ -2022,7 +2021,7 @@ void SceneDirty(PyMOLGlobals * G)
   CScene *I = G->Scene;
 
   PRINTFD(G, FB_Scene)
-    " SceneDirty: called.\n" ENDFD;
+    " %s: called.\n", __func__ ENDFD;
 
   if(I) {
     if(!I->DirtyFlag) {
@@ -2117,6 +2116,9 @@ int SceneMakeMovieImage(PyMOLGlobals * G
   PRINTFB(G, FB_Scene, FB_Blather)
     " Scene: Making movie image.\n" ENDFB(G);
 
+  // PYMOL-3209 objects inside hidden groups become visible
+  ExecutiveUpdateSceneMembers(G);
+
   mode = SceneValidateImageMode(G, mode, width || height);
 
   I->DirtyFlag = false;
@@ -2873,7 +2875,7 @@ int SceneDrawImageOverlay(PyMOLGlobals *
 	
 	if(tmp_height && tmp_width) {
 	  unsigned int buffer_size = tmp_height * tmp_width * 4;
-	  unsigned char *buffer = Alloc(unsigned char, buffer_size);
+	  unsigned char *buffer = pymol::malloc<unsigned char>(buffer_size);
 	  
 	  if(buffer && data) {
 	    unsigned char *p = data;
@@ -2995,7 +2997,7 @@ int SceneDrawImageOverlay(PyMOLGlobals *
       }
 
       unsigned int n_word = tmp_height * tmp_width;
-      unsigned int *tmp_buffer = Alloc(unsigned int, n_word);
+      unsigned int *tmp_buffer = pymol::malloc<unsigned int>(n_word);
       ColorGetBkrdContColor(G, rgba, false);
       color_word = ColorGet32BitWord(G, rgba);
       
@@ -3077,7 +3079,7 @@ int SceneDrawImageOverlay(PyMOLGlobals *
     } else if(I->CopyForced) {        /* near-exact fit */
       float rgba[4] = { 0.0F, 0.0F, 0.0F, 1.0F };
       unsigned int n_word = height * width;
-      unsigned int *tmp_buffer = Alloc(unsigned int, n_word);
+      unsigned int *tmp_buffer = pymol::malloc<unsigned int>(n_word);
       ColorGetBkrdContColor(G, rgba, false);
       
       if(tmp_buffer) {
@@ -4275,7 +4277,7 @@ static int SceneClick(Block * block, int
           break;
         }
         PRINTFB(G, FB_Scene, FB_Blather)
-          " SceneClick: no atom found nearby.\n" ENDFB(G);
+          " %s: no atom found nearby.\n", __func__ ENDFB(G);
         SceneInvalidate(G);     /* this here to prevent display weirdness after
                                    an unsuccessful picking pass... not sure it helps though */
         OrthoRestorePrompt(G);
@@ -6362,7 +6364,7 @@ void SceneUpdate(PyMOLGlobals * G, int f
           int cnt = I->NonGadgetObjs.size();
 
           if(cnt) {
-            CObjectUpdateThreadInfo *thread_info = Alloc(CObjectUpdateThreadInfo, cnt);
+            CObjectUpdateThreadInfo *thread_info = pymol::malloc<CObjectUpdateThreadInfo>(cnt);
             if(thread_info) {
               cnt = 0;
               for (auto& NonGadgetObj : I->NonGadgetObjs) {
@@ -6439,7 +6441,7 @@ void SceneUpdate(PyMOLGlobals * G, int f
   }
 
   PRINTFD(G, FB_Scene)
-    " SceneUpdate: leaving...\n" ENDFD;
+    " %s: leaving...\n", __func__ ENDFD;
 }
 
 
@@ -6453,7 +6455,7 @@ int SceneRenderCached(PyMOLGlobals * G)
   int renderedFlag = false;
   int draw_mode = SettingGetGlobal_i(G, cSetting_draw_mode);
   PRINTFD(G, FB_Scene)
-    " SceneRenderCached: entered.\n" ENDFD;
+    " %s: entered.\n", __func__ ENDFD;
 
   G->ShaderMgr->Check_Reload();
   if(I->DirtyFlag) {
@@ -6497,7 +6499,7 @@ int SceneRenderCached(PyMOLGlobals * G)
   }
 
   PRINTFD(G, FB_Scene)
-    " SceneRenderCached: leaving...renderedFlag %d\n", renderedFlag ENDFD;
+    " %s: leaving...renderedFlag %d\n", __func__, renderedFlag ENDFD;
 
   return (renderedFlag);
 }
diff -upNr pymol-open-source-2.3.0/layer1/ScenePicking.cpp pymol-open-source-2.3.3/layer1/ScenePicking.cpp
--- pymol-open-source-2.3.0/layer1/ScenePicking.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/ScenePicking.cpp	2019-08-22 10:24:47.690591131 +0200
@@ -8,7 +8,6 @@
 #include"MemoryDebug.h"
 #include"PyMOL.h"
 #include"P.h"
-#include "MacPyMOL.h"
 #include "Err.h"
 
 typedef unsigned char pix[4];
@@ -78,7 +77,7 @@ unsigned int SceneFindTriplet(PyMOLGloba
     if (!hasFrameBufferBinding())
       glReadBuffer(gl_buffer);
 #endif
-    extra_safe_buffer = Alloc(pix, w * h * 21);
+    extra_safe_buffer = pymol::malloc<pix>(w * h * 21);
     buffer = extra_safe_buffer + (w * h * 10);
 
     PyMOLReadPixels(x - cRangeVal, y - cRangeVal, cRangeVal * 2 + 1, cRangeVal * 2 + 1, GL_RGBA,
@@ -328,7 +327,7 @@ unsigned int *SceneReadTriplets(PyMOLGlo
        ReadPixels implementations tend to trash RAM surrounding the
        target block */
 
-    extra_safe_buffer = Alloc(pix, w * h * 11);
+    extra_safe_buffer = pymol::malloc<pix>(w * h * 11);
     buffer = extra_safe_buffer + (w * h * 5);
 
     result = VLAlloc(unsigned int, w * h);
diff -upNr pymol-open-source-2.3.0/layer1/SceneRender.cpp pymol-open-source-2.3.3/layer1/SceneRender.cpp
--- pymol-open-source-2.3.0/layer1/SceneRender.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/SceneRender.cpp	2019-08-22 10:24:47.694591783 +0200
@@ -401,6 +401,8 @@ void SceneRender(PyMOLGlobals * G, Picki
       short render_to_texture_for_pp = 0;
       /* STANDARD RENDERING */
 
+      start_time = UtilGetSeconds(G);
+
       glEnable(GL_BLEND);
       glBlendFunc_default();
     
diff -upNr pymol-open-source-2.3.0/layer1/Setting.cpp pymol-open-source-2.3.3/layer1/Setting.cpp
--- pymol-open-source-2.3.0/layer1/Setting.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/Setting.cpp	2019-08-22 10:24:47.694591783 +0200
@@ -93,7 +93,7 @@ bool SettingLevelCheck(PyMOLGlobals * G,
 static CSetting *SettingCopyAll(PyMOLGlobals * G, const CSetting * src, CSetting * dst)
 {
   if(!dst) {
-    dst = Calloc(CSetting, 1);
+    dst = pymol::calloc<CSetting>(1);
   } else {
     SettingPurge(dst);
   }
@@ -587,7 +587,7 @@ static void SettingUniqueInit(PyMOLGloba
 {
   CSettingUnique *I = G->SettingUnique;
 
-  if((I = (G->SettingUnique = Calloc(CSettingUnique, 1)))) {
+  if((I = (G->SettingUnique = pymol::calloc<CSettingUnique>(1)))) {
     I->id2offset = OVOneToOne_New(G->Context->heap);
     {
       int a;
@@ -2977,7 +2977,7 @@ void SettingInitGlobal(PyMOLGlobals * G,
   int (*set_b) (CSetting * I, int index, int value) = SettingSet_b;
 
   if(alloc || !I) {
-    I = (G->Setting = Calloc(CSetting, 1));
+    I = (G->Setting = pymol::calloc<CSetting>(1));
     SettingUniqueInit(G);
     SettingInit(G, I);
   }
@@ -3018,11 +3018,6 @@ void SettingInitGlobal(PyMOLGlobals * G,
       set_i(I, cSetting_stereo_mode, cStereo_quadbuffer);      /* quadbuffer if we can */
     }
 
-    if(G->Option->retina) {
-      _gScaleFactor = 2;
-      set_i(I, cSetting_display_scale_factor, _gScaleFactor);
-    }
-
     /* In order to get electrostatic potentials in kT from the Coulomb equation... 
 
        PyMOL charges: Q, in e
diff -upNr pymol-open-source-2.3.0/layer1/Setting.h pymol-open-source-2.3.3/layer1/Setting.h
--- pymol-open-source-2.3.0/layer1/Setting.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/Setting.h	2019-08-22 10:24:47.694591783 +0200
@@ -263,7 +263,7 @@ int SettingCheckFontID(PyMOLGlobals * G,
  * the current state (state == -2), or all states (state == -1). Takes
  * static singletons into account. Zero iterations if state >= nstate.
  *
- * StateIterator iter(G, I->Obj.Setting, state, I->NState);
+ * StateIterator iter(G, I->Setting, state, I->NState);
  * while(iter.next()) {
  *   printf("in state %d\n", iter.state);
  * }
diff -upNr pymol-open-source-2.3.0/layer1/Text.cpp pymol-open-source-2.3.3/layer1/Text.cpp
--- pymol-open-source-2.3.0/layer1/Text.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/Text.cpp	2019-08-22 10:24:47.694591783 +0200
@@ -473,7 +473,7 @@ const char *TextRenderRay(PyMOLGlobals *
 int TextInit(PyMOLGlobals * G)
 {
   CText *I = NULL;
-  if((I = (G->Text = Calloc(CText, 1)))) {
+  if((I = (G->Text = pymol::calloc<CText>(1)))) {
     int i = 0;
     for (; i < NFONTS; i++) {
       I->XHRFetched[i] = 0;
diff -upNr pymol-open-source-2.3.0/layer1/TypeFace.cpp pymol-open-source-2.3.3/layer1/TypeFace.cpp
--- pymol-open-source-2.3.0/layer1/TypeFace.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/TypeFace.cpp	2019-08-22 10:24:47.694591783 +0200
@@ -65,7 +65,7 @@ CTypeFace *TypeFaceLoad(PyMOLGlobals * G
 {
   CType *I = G->Type;
   int ok = true;
-  CTypeFace *result = Calloc(CTypeFace, 1);
+  CTypeFace *result = pymol::calloc<CTypeFace>(1);
   if(result) {
     FT_Error error = FT_New_Memory_Face(I->library, dat, len, 0, &result->Face);
     result->G = G;
@@ -129,7 +129,7 @@ void TypeFaceFree(CTypeFace * I)
 int TypeInit(PyMOLGlobals * G)
 {
   CType *I;
-  if((I = (G->Type = Calloc(CType, 1)))) {
+  if((I = (G->Type = pymol::calloc<CType>(1)))) {
     FT_Error error = FT_Init_FreeType(&I->library);
     return !error;
   }
diff -upNr pymol-open-source-2.3.0/layer1/View.cpp pymol-open-source-2.3.3/layer1/View.cpp
--- pymol-open-source-2.3.0/layer1/View.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer1/View.cpp	2019-08-22 10:24:47.694591783 +0200
@@ -696,7 +696,7 @@ int ViewElemSmooth(CViewElem * first, CV
     window = (int) n;
   delta = (window - 1) / 2;
   if(n && delta) {
-    CViewElem *cpy = Alloc(CViewElem, (n + 2 * delta));
+    CViewElem *cpy = pymol::malloc<CViewElem>((n + 2 * delta));
     CViewElem *src, *dst;
     int a, b, c, cnt;
     memcpy(cpy + delta, first, sizeof(CViewElem) * n);
@@ -1120,11 +1120,11 @@ int ViewElemInterpolate(PyMOLGlobals * G
     dump44f(firstR44f, "first");
 
   for(a = 0; a < n; a++) {
-    float fxn = ((float) a + 1) / (n + 1);
-    float fxn_1;
+    double fxn = (a + 1.0) / (n + 1.0);
+    double fxn_1 = 1.0 - fxn;
 
     if(timing_flag) {
-      timing = (first->timing * (1.0F - fxn) + (last->timing * fxn));
+      timing = (first->timing * fxn_1) + (last->timing * fxn);
     }
 
     if(state_flag) { /* states are interpolated linearly by default */
diff -upNr pymol-open-source-2.3.0/layer2/AssemblyHelpers.cpp pymol-open-source-2.3.3/layer2/AssemblyHelpers.cpp
--- pymol-open-source-2.3.0/layer2/AssemblyHelpers.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/AssemblyHelpers.cpp	2019-08-22 10:24:47.694591783 +0200
@@ -70,6 +70,6 @@ void ObjectMoleculeSetAssemblyCSets(
 
   // all_states for multi-model assembly
   if (I->NCSet > 1) {
-    SettingSet(cSetting_all_states, true, &I->Obj);
+    SettingSet(cSetting_all_states, true, I);
   }
 }
diff -upNr pymol-open-source-2.3.0/layer2/AtomInfo.cpp pymol-open-source-2.3.3/layer2/AtomInfo.cpp
--- pymol-open-source-2.3.0/layer2/AtomInfo.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/AtomInfo.cpp	2019-08-22 10:24:47.694591783 +0200
@@ -180,7 +180,7 @@ void BondTypeInit2(BondType *bond, int i
 int AtomInfoInit(PyMOLGlobals * G)
 {
   CAtomInfo *I = NULL;
-  if((I = (G->AtomInfo = Calloc(CAtomInfo, 1)))) {
+  if((I = (G->AtomInfo = pymol::calloc<CAtomInfo>(1)))) {
     AtomInfoPrimeColors(G);
     I->NextUniqueID = 1;
     return 1;
@@ -1156,8 +1156,19 @@ void AtomInfoCombine(PyMOLGlobals * G, A
 
 
 /*========================================================================*/
+/**
+ * Make atom names in `atInfo1` unique w.r.t.\ `atInfo0` (and to `atInfo1` itself).
+ * @param atInfo0 List of reference atoms
+ * @param n0 Size of atInfo0 list
+ * @param atInfo1 List of atoms which need to be made unique
+ * @param flag1 Optional whitelist mask for `atInfo1` or NULL
+ * @param n1 Size of atInfo1 list
+ * @param mol Optional reference molecule to limit to atoms with coordinates
+ * @return Number of renamed atoms
+ */
 int AtomInfoUniquefyNames(PyMOLGlobals * G, const AtomInfoType * atInfo0, int n0,
-                          AtomInfoType * atInfo1, int *flag1, int n1)
+                          AtomInfoType * atInfo1, int *flag1, int n1,
+                          const ObjectMolecule * mol)
 {
   /* makes sure all names in atInfo1 are unique WRT 0 and 1 */
 
@@ -1221,27 +1232,20 @@ int AtomInfoUniquefyNames(PyMOLGlobals *
       if(atInfo0) {
         /* check within object 2 */
 
-        if(!lai0)
-          bracketFlag = true;
-        else if(!AtomInfoSameResidue(G, lai0, ai1))
-          bracketFlag = true;
-        else
-          bracketFlag = false;
-        if(bracketFlag) {
+        if (!lai0 || !AtomInfoSameResidue(G, lai0, ai1)) {
           AtomInfoBracketResidue(G, atInfo0, n0, ai1, &st0, &nd0);
           lai0 = ai1;
         }
-        ai0 = atInfo0 + st0;
-        for(a = st0; a <= nd0; a++) {
-          if(!WordMatchExact(G, ai1->name, ai0->name, true))
-            ai0++;
-          else if(!AtomInfoSameResidue(G, ai1, ai0))
-            ai0++;
-          else if(ai1 != ai0) {
+
+        for (a = st0; a <= nd0; ++a) {
+          ai0 = atInfo0 + a;
+
+          if (WordMatchExact(G, ai1->name, ai0->name, true) &&
+              AtomInfoSameResidue(G, ai1, ai0) && ai1 != ai0 &&
+              (!mol || mol->atomHasAnyCoordinates(a))) {
             matchFlag = true;
             break;
-          } else
-            ai0++;
+          }
         }
       }
     }
@@ -1266,6 +1270,19 @@ int AtomInfoUniquefyNames(PyMOLGlobals *
   return result;
 }
 
+/**
+ * Make atom names in `atoms` unique w.r.t.\ atoms-with-coordinates in `mol`.
+ * @param mol Reference molecule
+ * @param atoms List of atoms which need to be made unique
+ * @param natoms Size of atoms list
+ * @return Number of renamed atoms
+ */
+int AtomInfoUniquefyNames(
+    const ObjectMolecule* mol, AtomInfoType* atoms, size_t natoms)
+{
+  return AtomInfoUniquefyNames(
+      mol->G, mol->AtomInfo, mol->NAtom, atoms, nullptr, natoms, mol);
+}
 
 /*========================================================================*/
 void AtomInfoBracketResidue(PyMOLGlobals * G, const AtomInfoType * ai0, int n0,
diff -upNr pymol-open-source-2.3.0/layer2/AtomInfo.h pymol-open-source-2.3.3/layer2/AtomInfo.h
--- pymol-open-source-2.3.0/layer2/AtomInfo.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/AtomInfo.h	2019-08-22 10:24:47.694591783 +0200
@@ -414,7 +414,11 @@ void AtomInfoBracketResidueFast(PyMOLGlo
                                 int *st, int *nd);
 
 int AtomInfoUniquefyNames(PyMOLGlobals * G, const AtomInfoType * atInfo0, int n0,
-                          AtomInfoType * atInfo1, int *flag1, int n1);
+                          AtomInfoType * atInfo1, int *flag1, int n1,
+                          const ObjectMolecule* mol = nullptr);
+int AtomInfoUniquefyNames(
+    const ObjectMolecule* mol, AtomInfoType* atoms, size_t natoms);
+
 bool AtomResiFromResv(char *resi, size_t size, int resv, char inscode);
 inline bool AtomResiFromResv(char *resi, size_t size, const AtomInfoType * ai) {
   return AtomResiFromResv(resi, size, ai->resv, ai->inscode);
diff -upNr pymol-open-source-2.3.0/layer2/CifMoleculeReader.cpp pymol-open-source-2.3.3/layer2/CifMoleculeReader.cpp
--- pymol-open-source-2.3.0/layer2/CifMoleculeReader.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/CifMoleculeReader.cpp	2019-08-22 10:24:47.698592434 +0200
@@ -396,7 +396,7 @@ static void ConnectComponent(ObjectMolec
   if (i_end - i_start < 2)
     return;
 
-  auto G = I->Obj.G;
+  auto G = I->G;
   AtomInfoType *a1, *a2, *ai = I->AtomInfo;
   int order;
 
@@ -446,7 +446,7 @@ static void ConnectComponent(ObjectMolec
 static int ObjectMoleculeConnectComponents(ObjectMolecule * I,
     bond_dict_t * bond_dict=nullptr) {
 
-  PyMOLGlobals * G = I->Obj.G;
+  PyMOLGlobals * G = I->G;
   int i_start = 0, i_prev_c = 0, i_prev_o3 = 0;
 
   if (!bond_dict) {
@@ -1977,7 +1977,7 @@ static ObjectMolecule *ObjectMoleculeRea
 
   // allocate ObjectMolecule
   ObjectMolecule * I = ObjectMoleculeNew(G, (discrete > 0));
-  I->Obj.Color = AtomInfoUpdateAutoColor(G);
+  I->Color = AtomInfoUpdateAutoColor(G);
 
   // read coordsets from datablock
   if ((csets = read_atom_site(G, datablock, &I->AtomInfo, info, I->DiscreteFlag))) {
@@ -2192,7 +2192,7 @@ ObjectMolecule *ObjectMoleculeReadCifStr
 
     // multiplexing
     ObjectSetName((CObject*) obj, it->first);
-    ExecutiveDelete(G, obj->Obj.Name);
+    ExecutiveDelete(G, obj->Name);
     ExecutiveManageObject(G, (CObject*) obj, zoom, true);
   }
 
diff -upNr pymol-open-source-2.3.0/layer2/CoordSet.cpp pymol-open-source-2.3.3/layer2/CoordSet.cpp
--- pymol-open-source-2.3.0/layer2/CoordSet.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/CoordSet.cpp	2019-08-22 10:24:47.698592434 +0200
@@ -689,14 +689,14 @@ int CoordSetGetAtomTxfVertex(CoordSet *
 
   /* apply state transformation */
   if(I->State.Matrix && (SettingGet_i(I->State.G,
-          obj->Obj.Setting, I->Setting,
+          obj->Setting, I->Setting,
           cSetting_matrix_mode) > 0)) {
     transform44d3f(I->State.Matrix, v, v);
   }
 
   /* object transformation */
-  if(obj->Obj.TTTFlag) {
-    transformTTT44f3f(obj->Obj.TTT, v, v);
+  if(obj->TTTFlag) {
+    transformTTT44f3f(obj->TTT, v, v);
   }
 
   return true;
@@ -851,12 +851,12 @@ bool CoordSetInsureOrthogonal(PyMOLGloba
 }
 
 /*========================================================================*/
-static char RotateU(const double *matrix, float *anisou)
 /* Rotates the ANISOU vector
  *
  * matrix: flat 4x4, but only rotation (upper left 3x3) is considered
  * anisou: has 6 elements (of symmetric 3x3) and will be rotated in-place
  */
+bool RotateU(const double *matrix, float *anisou)
 {
   int i, j, k;
   float Re[3][3];
@@ -1109,7 +1109,7 @@ void CoordSet::invalidateRep(int type, i
   /* graphical representations need redrawing */
   if(level == cRepInvVisib) {
     /* cartoon_side_chain_helper */
-    if(SettingGet_b(I->State.G, I->Setting, I->Obj->Obj.Setting,
+    if(SettingGet_b(I->State.G, I->Setting, I->Obj->Setting,
                     cSetting_cartoon_side_chain_helper)) {
       if((type == cRepCyl) || (type == cRepLine) || (type == cRepSphere))
         invalidateRep(cRepCartoon, cRepInvVisib2);
@@ -1120,7 +1120,7 @@ void CoordSet::invalidateRep(int type, i
       }
     }
     /* ribbon_side_chain_helper */
-    if(SettingGet_b(I->State.G, I->Setting, I->Obj->Obj.Setting,
+    if(SettingGet_b(I->State.G, I->Setting, I->Obj->Setting,
                     cSetting_ribbon_side_chain_helper)) {
       if((type == cRepCyl) || (type == cRepLine) || (type == cRepSphere))
         invalidateRep(cRepRibbon, cRepInvVisib2);
@@ -1131,7 +1131,7 @@ void CoordSet::invalidateRep(int type, i
       }
     }
     /* line_stick helper  */
-    if(SettingGet_b(I->State.G, I->Setting, I->Obj->Obj.Setting,
+    if(SettingGet_b(I->State.G, I->Setting, I->Obj->Setting,
                     cSetting_line_stick_helper)) {
       if(type == cRepCyl)
         invalidateRep(cRepLine, cRepInvVisib2);
@@ -1222,10 +1222,10 @@ void CoordSet::update(int state)
 {
   CoordSet * I = this;
   int a;
-  PyMOLGlobals *G = I->Obj->Obj.G;
+  PyMOLGlobals *G = I->Obj->G;
 
   PRINTFB(G, FB_CoordSet, FB_Blather) " CoordSetUpdate-Entered: object %s state %d cset %p\n",
-    I->Obj->Obj.Name, state, (void *) I
+    I->Obj->Name, state, (void *) I
     ENDFB(G);
 
   OrthoBusyFast(G, 0, cRepCnt);
@@ -1250,7 +1250,7 @@ void CoordSet::update(int state)
   OrthoBusyFast(G, 1, 1);
   if(Feedback(G, FB_CoordSet, FB_Blather)) {
     printf(" CoordSetUpdate-Leaving: object %s state %d cset %p\n",
-           I->Obj->Obj.Name, state, (void *) I);
+           I->Obj->Name, state, (void *) I);
   }
 }
 
@@ -1310,7 +1310,7 @@ void CoordSet::render(RenderInfo * info)
     " CoordSetRender: entered (%p).\n", (void *) I ENDFD;
 
   if(!(info->ray || info->pick) &&
-     (SettingGet_i(G, I->Setting, I->Obj->Obj.Setting,
+     (SettingGet_i(G, I->Setting, I->Obj->Setting,
                    cSetting_defer_builds_mode) == 5)) {
     if(!info->pass) {
       ObjectUseColor((CObject *) I->Obj);
@@ -1332,13 +1332,13 @@ void CoordSet::render(RenderInfo * info)
     int a, aa, abit, aastart = 0, aaend = cRepCnt;
     ::Rep *r;
     int sculpt_vdw_vis_mode = SettingGet_i(G, I->Setting,
-					   I->Obj->Obj.Setting,
+					   I->Obj->Setting,
 					   cSetting_sculpt_vdw_vis_mode);
     if((!pass) && sculpt_vdw_vis_mode && 
-       I->SculptCGO && (I->Obj->Obj.visRep & cRepCGOBit)) {
+       I->SculptCGO && (I->Obj->visRep & cRepCGOBit)) {
       if(ray) {
         int ok = CGORenderRay(I->SculptCGO, ray, info,
-			      ColorGet(G, I->Obj->Obj.Color), NULL, I->Setting, I->Obj->Obj.Setting);
+			      ColorGet(G, I->Obj->Color), NULL, I->Setting, I->Obj->Setting);
 	if (!ok){
 	  CGOFree(I->SculptCGO);
 	  CGOFree(I->SculptShaderCGO);
@@ -1361,10 +1361,10 @@ void CoordSet::render(RenderInfo * info)
 	  }
 	  if (I->SculptShaderCGO){
 	    CGORenderGL(I->SculptShaderCGO, NULL,
-			I->Setting, I->Obj->Obj.Setting, info, NULL);
+			I->Setting, I->Obj->Setting, info, NULL);
 	  } else {
 	    CGORenderGL(I->SculptCGO, NULL,
-			I->Setting, I->Obj->Obj.Setting, info, NULL);
+			I->Setting, I->Obj->Setting, info, NULL);
 	  }
         }
       }
@@ -1372,7 +1372,7 @@ void CoordSet::render(RenderInfo * info)
 
     if (pick){
       int pick_labels = SettingGet_i(G, I->Setting,
-				     I->Obj->Obj.Setting,
+				     I->Obj->Setting,
 				     cSetting_pick_labels);
       if (pick_labels == 2){ // only pick labels
 	aastart = cRepLabel;
@@ -1398,10 +1398,10 @@ void CoordSet::render(RenderInfo * info)
           if(I->Obj)
             ray->wobble(
                          SettingGet_i(G, I->Setting,
-                                      I->Obj->Obj.Setting,
+                                      I->Obj->Setting,
                                       cSetting_ray_texture),
                          SettingGet_3fv(G, I->Setting,
-                                        I->Obj->Obj.Setting,
+                                        I->Obj->Setting,
                                         cSetting_ray_texture_settings));
           else
             ray->wobble(
@@ -1409,7 +1409,7 @@ void CoordSet::render(RenderInfo * info)
                                       NULL, cSetting_ray_texture),
                          SettingGet_3fv(G, I->Setting, NULL,
                                         cSetting_ray_texture_settings));
-          ray->color3fv(ColorGet(G, I->Obj->Obj.Color));
+          ray->color3fv(ColorGet(G, I->Obj->Color));
         }
 
         if(r->fRender) {        /* do OpenGL rendering in three passes */
@@ -1785,7 +1785,7 @@ void AtomStateGetSetting(ATOMSTATEGETSET
   if (AtomSettingGetIfDefined(G, ai, setting_id, out))
     return;
 
-  *out = SettingGet<V>(G, cs->Setting, obj->Obj.Setting, setting_id);
+  *out = SettingGet<V>(G, cs->Setting, obj->Setting, setting_id);
 }
 
 template void AtomStateGetSetting(ATOMSTATEGETSETTINGARGS, int * out);
diff -upNr pymol-open-source-2.3.0/layer2/CoordSet.h pymol-open-source-2.3.3/layer2/CoordSet.h
--- pymol-open-source-2.3.0/layer2/CoordSet.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/CoordSet.h	2019-08-22 10:24:47.698592434 +0200
@@ -221,4 +221,7 @@ template <typename V> void SettingSet(in
   SettingSet(cs->State.G, &cs->Setting, index, value);
 }
 
+// Rotates the ANISOU vector
+bool RotateU(const double *matrix, float *anisou);
+
 #endif
diff -upNr pymol-open-source-2.3.0/layer2/DistSet.cpp pymol-open-source-2.3.3/layer2/DistSet.cpp
--- pymol-open-source-2.3.0/layer2/DistSet.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/DistSet.cpp	2019-08-22 10:24:47.698592434 +0200
@@ -64,7 +64,7 @@ int DistSetMoveLabel(DistSet * I, int at
       result = 1;
       lp = I->LabPos + a1;
       if(!lp->mode) {
-        const float *lab_pos = SettingGet_3fv(obj->Obj.G, NULL, obj->Obj.Setting,
+        const float *lab_pos = SettingGet_3fv(obj->G, NULL, obj->Setting,
                                         cSetting_label_position);
         copy3f(lab_pos, lp->pos);
       }
@@ -158,7 +158,7 @@ static CMeasureInfo * MeasureInfoListFro
   ll = PyList_Size(list);
 
   for (i = 0; i < ll; i++) {
-    ok_assert(1, item = Alloc(CMeasureInfo, 1));
+    ok_assert(1, item = pymol::malloc<CMeasureInfo>(1));
     ListPrepend(I, item, next);
 
     val = CPythonVal_PyList_GetItem(G, list, i);
@@ -434,7 +434,7 @@ void DistSet::render(RenderInfo * info)
   ::Rep *r;
   for(a = 0; a < I->NRep; a++)
   {
-    if(!GET_BIT(I->Obj->Obj.visRep, a))
+    if(!GET_BIT(I->Obj->visRep, a))
       continue;
     if(!I->Rep[a]) {
       switch(a) {
@@ -457,7 +457,7 @@ void DistSet::render(RenderInfo * info)
         r = I->Rep[a];
         if(ray || pick) {
           if(ray)
-            ray->color3fv(ColorGet(I->State.G, I->Obj->Obj.Color));
+            ray->color3fv(ColorGet(I->State.G, I->Obj->Color));
           r->fRender(r, info);
         } else {
           ObjectUseColor((CObject *) I->Obj);
diff -upNr pymol-open-source-2.3.0/layer2/GadgetSet.cpp pymol-open-source-2.3.3/layer2/GadgetSet.cpp
--- pymol-open-source-2.3.0/layer2/GadgetSet.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/GadgetSet.cpp	2019-08-22 10:24:47.698592434 +0200
@@ -286,7 +286,7 @@ void GadgetSet::render(RenderInfo * info
   context.object = I->Obj;
   context.state = I->State;
 
-  color = ColorGet(I->G, I->Obj->Obj.Color);
+  color = ColorGet(I->G, I->Obj->Color);
 
   if(pass < 0 || ray || pick) {
     PyMOLGlobals *G = I->G;
@@ -300,7 +300,7 @@ void GadgetSet::render(RenderInfo * info
 	RayPushTTT(ray);
 	RaySetTTT(ray, true, mat);  /* Used to set the ray-tracing matrix,
 				       this works, but is there another way to do this? */
-	CGORenderRay(I->ShapeCGO, ray, info, color, NULL, I->Obj->Obj.Setting, NULL);
+	CGORenderRay(I->ShapeCGO, ray, info, color, NULL, I->Obj->Setting, NULL);
 	RayPopTTT(ray);
       }
     } else if(G->HaveGUI && G->ValidContext) {
@@ -335,12 +335,12 @@ void GadgetSet::render(RenderInfo * info
 	}
         if(I->PickCGO) {
 	  if (use_shader){
-	    CGORenderGLPicking(I->PickCGO, info, &context, I->Obj->Obj.Setting, NULL);
+	    CGORenderGLPicking(I->PickCGO, info, &context, I->Obj->Setting, NULL);
 #ifndef PURE_OPENGL_ES_2
 	  } else {
 	    glDisable(GL_DEPTH_TEST);
 	    glTranslatef(I->Coord[0],I->Coord[1],I->Coord[2]);
-	    CGORenderGLPicking(I->PickShapeCGO, info, &context, I->Obj->Obj.Setting, NULL);
+	    CGORenderGLPicking(I->PickShapeCGO, info, &context, I->Obj->Setting, NULL);
 	    glTranslatef(-I->Coord[0],-I->Coord[1],-I->Coord[2]);
 	    glEnable(GL_DEPTH_TEST);
 #endif
@@ -377,12 +377,12 @@ void GadgetSet::render(RenderInfo * info
         if(I->StdCGO) {
 	  if (use_shader){
 	    if (color)
-              CGORenderGL(I->StdCGO, NULL, I->Obj->Obj.Setting, NULL, info, NULL);
+              CGORenderGL(I->StdCGO, NULL, I->Obj->Setting, NULL, info, NULL);
 #ifndef PURE_OPENGL_ES_2
 	  } else {
 	    glDisable(GL_DEPTH_TEST);
 	    glTranslatef(I->Coord[0],I->Coord[1],I->Coord[2]);
-	    CGORenderGL(I->ShapeCGO, NULL, I->Obj->Obj.Setting, NULL, info, NULL);
+	    CGORenderGL(I->ShapeCGO, NULL, I->Obj->Setting, NULL, info, NULL);
 	    glTranslatef(-I->Coord[0],-I->Coord[1],-I->Coord[2]);
 	    glEnable(GL_DEPTH_TEST);
 #endif
diff -upNr pymol-open-source-2.3.0/layer2/HydrogenAdder.cpp pymol-open-source-2.3.3/layer2/HydrogenAdder.cpp
--- pymol-open-source-2.3.0/layer2/HydrogenAdder.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/HydrogenAdder.cpp	2019-08-22 10:24:47.698592434 +0200
@@ -121,7 +121,7 @@ bool get_planer_normal_cs(
 int ObjectMoleculeSetMissingNeighborCoords(
     ObjectMolecule* I, CoordSet* cs, unsigned atm, bool h_fix)
 {
-  auto G = I->Obj.G;
+  auto G = I->G;
   int n_present = 0;
   float cbuf[4 * 3];
   int present_atm = -1;
@@ -265,7 +265,7 @@ int ObjectMoleculeSetMissingNeighborCoor
  */
 int ObjectMoleculeAddSeleHydrogensRefactored(ObjectMolecule* I, int sele, int state)
 {
-  auto G = I->Obj.G;
+  auto G = I->G;
   auto const n_atom_old = I->NAtom;
 
   bool seleFlag = false;
@@ -338,7 +338,7 @@ int ObjectMoleculeAddSeleHydrogensRefact
       I->NAtom - n_atom_old);
 
   // fill coordinates
-  for (StateIterator iter(G, I->Obj.Setting, state, I->NCSet); iter.next();) {
+  for (StateIterator iter(G, I->Setting, state, I->NCSet); iter.next();) {
     CoordSet* cs = I->CSet[iter.state];
     if (!cs)
       continue;
diff -upNr pymol-open-source-2.3.0/layer2/MmtfMoleculeReader.cpp pymol-open-source-2.3.3/layer2/MmtfMoleculeReader.cpp
--- pymol-open-source-2.3.0/layer2/MmtfMoleculeReader.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/MmtfMoleculeReader.cpp	2019-08-22 10:24:47.698592434 +0200
@@ -157,7 +157,7 @@ ObjectMolecule * ObjectMoleculeReadMmtfS
   tai.q = 1.0f;
 
   I = ObjectMoleculeNew(G, /* discrete */ 1);
-  I->Obj.Color = AtomInfoUpdateAutoColor(G);
+  I->Color = AtomInfoUpdateAutoColor(G);
   I->NAtom = container->numAtoms;
   I->NCSet = container->numModels;
   I->Bond = VLAlloc(BondType, container->numBonds);
diff -upNr pymol-open-source-2.3.0/layer2/Mol2Typing.cpp pymol-open-source-2.3.3/layer2/Mol2Typing.cpp
--- pymol-open-source-2.3.0/layer2/Mol2Typing.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/Mol2Typing.cpp	2019-08-22 10:24:47.698592434 +0200
@@ -118,7 +118,7 @@ static int sulfurCountOxygenNeighbors(Ob
  * Pre-condition: ObjectMoleculeVerifyChemistry
  */
 const char * getMOL2Type(ObjectMolecule * obj, int atm) {
-  auto G = obj->Obj.G;
+  auto G = obj->G;
   auto ai = obj->AtomInfo + atm;
 
   switch (ai->protons) {
diff -upNr pymol-open-source-2.3.0/layer2/ObjectAlignment.cpp pymol-open-source-2.3.3/layer2/ObjectAlignment.cpp
--- pymol-open-source-2.3.0/layer2/ObjectAlignment.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectAlignment.cpp	2019-08-22 10:24:47.702593085 +0200
@@ -163,7 +163,7 @@ int ObjectAlignmentAsStrVLA(PyMOLGlobals
   int max_name_len = 12;        /* default indentation */
 
   if(state < 0)
-    state = ObjectGetCurrentState(&I->Obj, false);
+    state = ObjectGetCurrentState(I, false);
   if(state < 0)
     state = SceneGetState(G);
   if((state >= 0) && (state < I->NState)) {
@@ -182,7 +182,7 @@ int ObjectAlignmentAsStrVLA(PyMOLGlobals
       }
 
       {
-        int align_sele = SelectorIndexByName(G, I->Obj.Name);
+        int align_sele = SelectorIndexByName(G, I->Name);
         if(align_sele >= 0) {
           int nRow = 0;
           ov_size nCol = 0;
@@ -199,12 +199,12 @@ int ObjectAlignmentAsStrVLA(PyMOLGlobals
                alignment and count the name length */
 
             while(ExecutiveIterateObjectMolecule(G, &obj, &hidden)) {
-              if((obj->Obj.Enabled || !active_only) && (obj->Obj.Name[0] != '_')) {
+              if((obj->Enabled || !active_only) && (obj->Name[0] != '_')) {
                 int a;
                 AtomInfoType *ai = obj->AtomInfo;
                 for(a = 0; a < obj->NAtom; a++) {
                   if(SelectorIsMember(G, ai->selEntry, align_sele)) {
-                    int name_len = strlen(obj->Obj.Name);
+                    int name_len = strlen(obj->Name);
                     if(max_name_len < name_len)
                       max_name_len = name_len;
                     VLACheck(row_vla, CSeqRow, nRow);
@@ -290,13 +290,13 @@ int ObjectAlignmentAsStrVLA(PyMOLGlobals
             }
             /* allocate storage for the sequence alignment */
 
-            cons_str = Calloc(char, nCol + 1);  /* conservation string */
+            cons_str = pymol::calloc<char>(nCol + 1);  /* conservation string */
 
             {
               int a;
               for(a = 0; a < nRow; a++) {
                 row = row_vla + a;
-                row->txt = Calloc(char, nCol + 1);
+                row->txt = pymol::calloc<char>(nCol + 1);
                 row->len = 0;
                 row->last_ai = NULL;
                 row->cCol = 0;
@@ -424,7 +424,7 @@ int ObjectAlignmentAsStrVLA(PyMOLGlobals
                 done = true;
                 for(a = 0; a < nRow; a++) {
                   row = row_vla + a;
-                  UtilNPadVLA(&vla, &len, row->obj->Obj.Name, max_name_len + 1);
+                  UtilNPadVLA(&vla, &len, row->obj->Name, max_name_len + 1);
                   if(seq_len < row->len) {
                     UtilNPadVLA(&vla, &len, row->txt + seq_len, block_width);
                   }
@@ -811,8 +811,9 @@ static int ObjectAlignmentAllStatesFromP
     ok = PyList_Check(list);
   if(ok) {
     for(a = 0; a < I->NState; a++) {
+      auto *val = PyList_GetItem(list, a);
       ok =
-        ObjectAlignmentStateFromPyList(I->Obj.G, I->State + a, PyList_GetItem(list, a),
+        ObjectAlignmentStateFromPyList(I->G, I->State + a, val,
                                        version);
       if(!ok)
         break;
@@ -836,8 +837,10 @@ int ObjectAlignmentNewFromPyList(PyMOLGl
   if(ok)
     ok = (I != NULL);
 
-  if(ok)
-    ok = ObjectFromPyList(G, PyList_GetItem(list, 0), &I->Obj);
+  if(ok){
+    auto *val = PyList_GetItem(list, 0);
+    ok = ObjectFromPyList(G, val, I);
+  }
   if(ok)
     ok = PConvPyIntToInt(PyList_GetItem(list, 1), &I->NState);
   if(ok)
@@ -856,7 +859,7 @@ PyObject *ObjectAlignmentAsPyList(Object
   PyObject *result = NULL;
 
   result = PyList_New(3);
-  PyList_SetItem(result, 0, ObjectAsPyList(&I->Obj));
+  PyList_SetItem(result, 0, ObjectAsPyList(I));
   PyList_SetItem(result, 1, PyInt_FromLong(I->NState));
   PyList_SetItem(result, 2, ObjectAlignmentAllStatesAsPyList(I));
 
@@ -876,7 +879,7 @@ static void ObjectAlignmentFree(ObjectAl
     OVOneToAny_DEL_AUTO_NULL(I->State[a].id2tag);
   }
   VLAFreeP(I->State);
-  ObjectPurge(&I->Obj);
+  ObjectPurge(I);
   OOFreeP(I);
 }
 
@@ -893,22 +896,22 @@ void ObjectAlignmentRecomputeExtent(Obje
       if(CGOGetExtent(I->State[a].primitiveCGO, mn, mx)) {
         if(!extent_flag) {
           extent_flag = true;
-          copy3f(mx, I->Obj.ExtentMax);
-          copy3f(mn, I->Obj.ExtentMin);
+          copy3f(mx, I->ExtentMax);
+          copy3f(mn, I->ExtentMin);
         } else {
-          max3f(mx, I->Obj.ExtentMax, I->Obj.ExtentMax);
-          min3f(mn, I->Obj.ExtentMin, I->Obj.ExtentMin);
+          max3f(mx, I->ExtentMax, I->ExtentMax);
+          min3f(mn, I->ExtentMin, I->ExtentMin);
         }
       }
     }
-  I->Obj.ExtentFlag = extent_flag;
+  I->ExtentFlag = extent_flag;
 }
 
 
 /*========================================================================*/
 void ObjectAlignmentUpdate(ObjectAlignment * I)
 {
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   int update_needed = false;
   {
     int a;
@@ -1052,7 +1055,7 @@ void ObjectAlignmentUpdate(ObjectAlignme
       I->ForceState = 0;
     }
     if(state < 0)
-      state = SettingGet_i(I->Obj.G, NULL, I->Obj.Setting, cSetting_state) - 1;
+      state = SettingGet_i(I->G, NULL, I->Setting, cSetting_state) - 1;
     if(state < 0)
       state = SceneGetState(G);
     if(state >= I->NState)
@@ -1062,13 +1065,13 @@ void ObjectAlignmentUpdate(ObjectAlignme
     if(state < I->NState) {
       ObjectAlignmentState *oas = I->State + state;
       if(oas->id2tag) {
-        SelectorDelete(G, I->Obj.Name);
-        SelectorCreateFromTagDict(G, I->Obj.Name, oas->id2tag, false);
+        SelectorDelete(G, I->Name);
+        SelectorCreateFromTagDict(G, I->Name, oas->id2tag, false);
         I->SelectionState = state;
       }
     }
   }
-  SceneInvalidate(I->Obj.G);
+  SceneInvalidate(I->G);
 }
 
 
@@ -1084,7 +1087,7 @@ static int ObjectAlignmentGetNState(Obje
 
 static void ObjectAlignmentRender(ObjectAlignment * I, RenderInfo * info)
 {
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   int state = info->state;
   CRay *ray = info->ray;
   auto pick = info->pick;
@@ -1092,24 +1095,24 @@ static void ObjectAlignmentRender(Object
   ObjectAlignmentState *sobj = NULL;
   const float *color;
 
-  ObjectPrepareContext(&I->Obj, info);
+  ObjectPrepareContext(I, info);
 
-  color = ColorGet(G, I->Obj.Color);
+  color = ColorGet(G, I->Color);
 
   if (pick)
     return;
 
   if(pass>0 || ray) {
-    if((I->Obj.visRep & cRepCGOBit)) {
+    if((I->visRep & cRepCGOBit)) {
 
-      for(StateIterator iter(G, I->Obj.Setting, state, I->NState); iter.next();) {
+      for(StateIterator iter(G, I->Setting, state, I->NState); iter.next();) {
         sobj = I->State + iter.state;
 
         if (!sobj->primitiveCGO)
           continue;
 
 	if(ray) {
-	    CGORenderRay(sobj->primitiveCGO, ray, info, color, NULL, I->Obj.Setting, NULL);
+	    CGORenderRay(sobj->primitiveCGO, ray, info, color, NULL, I->Setting, NULL);
 	} else if(G->HaveGUI && G->ValidContext) {
 #ifndef PURE_OPENGL_ES_2
 	  if(!info->line_lighting)
@@ -1165,7 +1168,7 @@ static void ObjectAlignmentRender(Object
           }
 
           if (cgo) {
-            CGORenderGL(cgo, color, I->Obj.Setting, NULL, info, NULL);
+            CGORenderGL(cgo, color, I->Setting, NULL, info, NULL);
           }
 
 #ifndef PURE_OPENGL_ES_2
@@ -1180,7 +1183,7 @@ static void ObjectAlignmentRender(Object
 static void ObjectAlignmentInvalidate(ObjectAlignment * I, int rep, int level, int state)
 {
   if((rep == cRepAll) || (rep == cRepCGO)) {
-    for(StateIterator iter(I->Obj.G, I->Obj.Setting, state, I->NState); iter.next();) {
+    for(StateIterator iter(I->G, I->Setting, state, I->NState); iter.next();) {
       ObjectAlignmentState *sobj = I->State + iter.state;
       sobj->valid = false;
       CGOFree(sobj->renderCGO);
@@ -1201,12 +1204,12 @@ static ObjectAlignment *ObjectAlignmentN
   I->SelectionState = -1;
   I->ForceState = -1;
 
-  I->Obj.type = cObjectAlignment;
-  I->Obj.fFree = (void (*)(CObject *)) ObjectAlignmentFree;
-  I->Obj.fUpdate = (void (*)(CObject *)) ObjectAlignmentUpdate;
-  I->Obj.fRender = (void (*)(CObject *, RenderInfo *)) ObjectAlignmentRender;
-  I->Obj.fGetNFrame = (int (*)(CObject *)) ObjectAlignmentGetNState;
-  I->Obj.fInvalidate = (void (*)(CObject *, int rep, int level, int state))
+  I->type = cObjectAlignment;
+  I->fFree = (void (*)(CObject *)) ObjectAlignmentFree;
+  I->fUpdate = (void (*)(CObject *)) ObjectAlignmentUpdate;
+  I->fRender = (void (*)(CObject *, RenderInfo *)) ObjectAlignmentRender;
+  I->fGetNFrame = (int (*)(CObject *)) ObjectAlignmentGetNState;
+  I->fInvalidate = (void (*)(CObject *, int rep, int level, int state))
     ObjectAlignmentInvalidate;
 
   return (I);
@@ -1224,7 +1227,7 @@ ObjectAlignment *ObjectAlignmentDefine(P
   ObjectAlignment *I = NULL;
 
   if(obj) {
-    if(obj->Obj.type != cObjectAlignment)       /* TODO: handle this */
+    if(obj->type != cObjectAlignment)       /* TODO: handle this */
       obj = NULL;
   }
   if(!obj) {
@@ -1244,7 +1247,7 @@ ObjectAlignment *ObjectAlignmentDefine(P
     ObjectAlignmentState *oas = I->State + state;
     oas->valid = false;
     if(guide) {
-      strcpy(oas->guide, guide->Obj.Name);
+      strcpy(oas->guide, guide->Name);
     }
     if(align_vla) {
       if(merge && oas->alignVLA) {
diff -upNr pymol-open-source-2.3.0/layer2/ObjectAlignment.h pymol-open-source-2.3.3/layer2/ObjectAlignment.h
--- pymol-open-source-2.3.0/layer2/ObjectAlignment.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectAlignment.h	2019-08-22 10:24:47.702593085 +0200
@@ -37,12 +37,11 @@ typedef struct ObjectAlignmentState {
   bool renderCGO_has_trilines;
 } ObjectAlignmentState;
 
-typedef struct ObjectAlignment {
-  CObject Obj;
+struct ObjectAlignment : public CObject {
   ObjectAlignmentState *State;
   int NState;
   int SelectionState, ForceState;
-} ObjectAlignment;
+};
 
 void ObjectAlignmentUpdate(ObjectAlignment * I);
 
diff -upNr pymol-open-source-2.3.0/layer2/ObjectCallback.cpp pymol-open-source-2.3.3/layer2/ObjectCallback.cpp
--- pymol-open-source-2.3.0/layer2/ObjectCallback.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectCallback.cpp	2019-08-22 10:24:47.702593085 +0200
@@ -39,7 +39,7 @@ static void ObjectCallbackFree(ObjectCal
 {
 #ifndef _PYMOL_NOPY
   int a;
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   int blocked = PAutoBlock(G);
   for(a = 0; a < I->NState; a++) {
     if(I->State[a].PObj) {
@@ -50,7 +50,7 @@ static void ObjectCallbackFree(ObjectCal
   PAutoUnblock(G, blocked);
 #endif
   VLAFreeP(I->State);
-  ObjectPurge(&I->Obj);
+  ObjectPurge(I);
   OOFreeP(I);
 }
 
@@ -59,7 +59,7 @@ static void ObjectCallbackFree(ObjectCal
 
 static void ObjectCallbackUpdate(ObjectCallback * I)
 {
-  SceneInvalidate(I->Obj.G);
+  SceneInvalidate(I->G);
 }
 
 
@@ -72,7 +72,7 @@ static void ObjectCallbackRender(ObjectC
   CRay *ray = info->ray;
   auto pick = info->pick;
   int pass = info->pass;
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   ObjectCallbackState *sobj = NULL;
 
   if(pass != 1) /* for now, the callback should be called during the first pass (opaque), so 
@@ -96,11 +96,11 @@ static void ObjectCallbackRender(ObjectC
   if(!I->State || I->NState == 0)
     return;
 
-  ObjectPrepareContext(&I->Obj, info);
+  ObjectPrepareContext(I, info);
 
-  if((I->Obj.visRep & cRepCallbackBit)) {
+  if((I->visRep & cRepCallbackBit)) {
     int blocked = PAutoBlock(G);
-    for(StateIterator iter(G, I->Obj.Setting, state, I->NState); iter.next();) {
+    for(StateIterator iter(G, I->Setting, state, I->NState); iter.next();) {
       sobj = I->State + iter.state;
       if(!sobj->is_callable)
         continue;
@@ -132,12 +132,12 @@ ObjectCallback *ObjectCallbackNew(PyMOLG
   I->State = VLACalloc(ObjectCallbackState, 10);       /* autozero */
   I->NState = 0;
 
-  I->Obj.type = cObjectCallback;
-  I->Obj.fFree = (void (*)(CObject *)) ObjectCallbackFree;
-  I->Obj.fUpdate = (void (*)(CObject *)) ObjectCallbackUpdate;
-  I->Obj.fRender = (void (*)(CObject *, RenderInfo *))
+  I->type = cObjectCallback;
+  I->fFree = (void (*)(CObject *)) ObjectCallbackFree;
+  I->fUpdate = (void (*)(CObject *)) ObjectCallbackUpdate;
+  I->fRender = (void (*)(CObject *, RenderInfo *))
     ObjectCallbackRender;
-  I->Obj.fGetNFrame = (int (*)(CObject *)) ObjectCallbackGetNStates;
+  I->fGetNFrame = (int (*)(CObject *)) ObjectCallbackGetNStates;
 
   return (I);
 }
@@ -205,11 +205,11 @@ void ObjectCallbackRecomputeExtent(Objec
           if(PConvPyListToExtent(py_ext, mn, mx)) {
             if(!extent_flag) {
               extent_flag = true;
-              copy3f(mx, I->Obj.ExtentMax);
-              copy3f(mn, I->Obj.ExtentMin);
+              copy3f(mx, I->ExtentMax);
+              copy3f(mn, I->ExtentMin);
             } else {
-              max3f(mx, I->Obj.ExtentMax, I->Obj.ExtentMax);
-              min3f(mn, I->Obj.ExtentMin, I->Obj.ExtentMin);
+              max3f(mx, I->ExtentMax, I->ExtentMax);
+              min3f(mn, I->ExtentMin, I->ExtentMin);
             }
           }
           Py_DECREF(py_ext);
@@ -217,7 +217,7 @@ void ObjectCallbackRecomputeExtent(Objec
       }
     }
 #endif
-  I->Obj.ExtentFlag = extent_flag;
+  I->ExtentFlag = extent_flag;
 
 }
 
@@ -254,7 +254,7 @@ static int ObjectCallbackAllStatesFromPy
 
   for(int a = 0; a < I->NState; a++) {
     PyObject *val = PyList_GetItem(list, a);
-    ObjectCallbackStateFromPyObject(I->Obj.G, I->State + a, val);
+    ObjectCallbackStateFromPyObject(I->G, I->State + a, val);
   }
 
   result = true;
@@ -262,9 +262,9 @@ ok_except1:
   if(PyErr_Occurred()) {
     PyErr_Print();
 
-    PRINTFB(I->Obj.G, FB_ObjectCallback, FB_Warnings)
+    PRINTFB(I->G, FB_ObjectCallback, FB_Warnings)
       " Warning: could not load callback object\n"
-      ENDFB(I->Obj.G);
+      ENDFB(I->G);
   }
 
   Py_XDECREF(list);
@@ -282,7 +282,7 @@ int ObjectCallbackNewFromPyList(PyMOLGlo
   ok_assert(1, I = ObjectCallbackNew(G));
 
   val = PyList_GetItem(list, 0);
-  ok_assert(2, ObjectFromPyList(G, val, &I->Obj));
+  ok_assert(2, ObjectFromPyList(G, val, I));
 
   val = PyList_GetItem(list, 1);
   ok_assert(2, ObjectCallbackAllStatesFromPyObject(I, val));
@@ -324,9 +324,9 @@ static PyObject *ObjectCallbackAllStates
   if(PyErr_Occurred()) {
     PyErr_Print();
 
-    PRINTFB(I->Obj.G, FB_ObjectCallback, FB_Warnings)
+    PRINTFB(I->G, FB_ObjectCallback, FB_Warnings)
       " Warning: callable needs to be picklable for session storage\n"
-      ENDFB(I->Obj.G);
+      ENDFB(I->G);
   }
 
   return result;
@@ -339,7 +339,7 @@ PyObject *ObjectCallbackAsPyList(ObjectC
   ok_assert(1, states = ObjectCallbackAllStatesAsPyObject(I));
 
   result = PyList_New(2);
-  PyList_SetItem(result, 0, ObjectAsPyList(&I->Obj));
+  PyList_SetItem(result, 0, ObjectAsPyList(I));
   PyList_SetItem(result, 1, states);
 
 ok_except1:
diff -upNr pymol-open-source-2.3.0/layer2/ObjectCallback.h pymol-open-source-2.3.3/layer2/ObjectCallback.h
--- pymol-open-source-2.3.0/layer2/ObjectCallback.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectCallback.h	2019-08-22 10:24:47.702593085 +0200
@@ -26,11 +26,10 @@ typedef struct {
   bool is_callable;
 } ObjectCallbackState;
 
-typedef struct ObjectCallback {
-  CObject Obj;
+struct ObjectCallback : public CObject {
   ObjectCallbackState *State;
   int NState;
-} ObjectCallback;
+};
 
 ObjectCallback *ObjectCallbackNew(PyMOLGlobals * G);
 ObjectCallback *ObjectCallbackDefine(PyMOLGlobals * G, ObjectCallback * obj,
diff -upNr pymol-open-source-2.3.0/layer2/ObjectCGO.cpp pymol-open-source-2.3.3/layer2/ObjectCGO.cpp
--- pymol-open-source-2.3.0/layer2/ObjectCGO.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectCGO.cpp	2019-08-22 10:24:47.702593085 +0200
@@ -101,8 +101,9 @@ static int ObjectCGOAllStatesFromPyList(
     ok = PyList_Check(list);
   if(ok) {
     for(a = 0; a < I->NState; a++) {
+      auto *val = PyList_GetItem(list, a);
       ok =
-        ObjectCGOStateFromPyList(I->Obj.G, I->State + a, PyList_GetItem(list, a),
+        ObjectCGOStateFromPyList(I->G, I->State + a, val,
                                  version);
       if(!ok)
         break;
@@ -127,8 +128,10 @@ int ObjectCGONewFromPyList(PyMOLGlobals
   if(ok)
     ok = (I != NULL);
 
-  if(ok)
-    ok = ObjectFromPyList(G, PyList_GetItem(list, 0), &I->Obj);
+  if(ok){
+    auto *val = PyList_GetItem(list, 0);
+    ok = ObjectFromPyList(G, val, I);
+  }
   if(ok)
     ok = PConvPyIntToInt(PyList_GetItem(list, 1), &I->NState);
   if(ok)
@@ -147,7 +150,7 @@ PyObject *ObjectCGOAsPyList(ObjectCGO *
   PyObject *result = NULL;
 
   result = PyList_New(3);
-  PyList_SetItem(result, 0, ObjectAsPyList(&I->Obj));
+  PyList_SetItem(result, 0, ObjectAsPyList(I));
   PyList_SetItem(result, 1, PyInt_FromLong(I->NState));
   PyList_SetItem(result, 2, ObjectCGOAllStatesAsPyList(I));
 
@@ -165,7 +168,7 @@ void ObjectCGOFree(ObjectCGO * I)
     CGOFree(I->State[a].origCGO);
   }
   VLAFreeP(I->State);
-  ObjectPurge(&I->Obj);
+  ObjectPurge(I);
   OOFreeP(I);
 }
 
@@ -188,11 +191,11 @@ void ObjectCGORecomputeExtent(ObjectCGO
       if(CGOGetExtent(cgo, mn, mx)) {
         if(!extent_flag) {
           extent_flag = true;
-          copy3f(mx, I->Obj.ExtentMax);
-          copy3f(mn, I->Obj.ExtentMin);
+          copy3f(mx, I->ExtentMax);
+          copy3f(mn, I->ExtentMin);
         } else {
-          max3f(mx, I->Obj.ExtentMax, I->Obj.ExtentMax);
-          min3f(mn, I->Obj.ExtentMin, I->Obj.ExtentMin);
+          max3f(mx, I->ExtentMax, I->ExtentMax);
+          min3f(mn, I->ExtentMin, I->ExtentMin);
         }
       }
       if (!has_normals && cgo && CGOHasNormals(cgo)){
@@ -200,9 +203,9 @@ void ObjectCGORecomputeExtent(ObjectCGO
       }
     }
   }
-  I->Obj.ExtentFlag = extent_flag;
-  SettingCheckHandle(I->Obj.G, &I->Obj.Setting);
-  SettingSet_i(I->Obj.Setting, cSetting_cgo_lighting, has_normals);
+  I->ExtentFlag = extent_flag;
+  SettingCheckHandle(I->G, &I->Setting);
+  SettingSet_i(I->Setting, cSetting_cgo_lighting, has_normals);
 }
 
 
@@ -244,7 +247,7 @@ static void ObjectCGOUpdate(ObjectCGO *
       ocs->renderCGO = 0;
     }
   }
-  SceneInvalidate(I->Obj.G);    /* needed ? */
+  SceneInvalidate(I->G);    /* needed ? */
 }
 
 
@@ -266,7 +269,7 @@ static void ObjectCGORenderState(PyMOLGl
         if (cgo_lighting && CGOHasAnyTriangleVerticesWithoutNormals(cgo)) {
           cgo = cgo_copy = CGOGenerateNormalsForTriangles(cgo);
         }
-        CGORenderRay(cgo, ray, info, color, ramp, I->Obj.Setting, NULL);
+        CGORenderRay(cgo, ray, info, color, ramp, I->Setting, NULL);
         CGOFree(cgo_copy);
       }
     }
@@ -277,8 +280,8 @@ static void ObjectCGORenderState(PyMOLGl
       if(sobj && ((sobj->hasTransparency ^ pass_is_opaque) || (sobj->hasOpaque == pass_is_opaque))){
 	{
 	  CShaderPrg *shaderPrg;
-	  int two_sided_lighting = SettingGet_i(G, I->Obj.Setting, NULL, cSetting_two_sided_lighting);
-          bool backface_cull = SettingGet_i(G, I->Obj.Setting, NULL, cSetting_backface_cull);
+	  int two_sided_lighting = SettingGet_i(G, I->Setting, NULL, cSetting_two_sided_lighting);
+          bool backface_cull = SettingGet_i(G, I->Setting, NULL, cSetting_backface_cull);
 	  if (two_sided_lighting<0){
 	    two_sided_lighting = !cgo_lighting;
 	  }
@@ -311,12 +314,12 @@ static void ObjectCGORenderState(PyMOLGl
 	    shaderPrg->Set1i("two_sided_lighting_enabled", two_sided_lighting);
 	    sobj->renderCGO->use_shader = use_shader;
 	    sobj->renderCGO->debug = SettingGetGlobal_i(G, cSetting_cgo_debug);
-	    CGORenderGL(sobj->renderCGO, color, I->Obj.Setting, NULL, info, NULL);
+	    CGORenderGL(sobj->renderCGO, color, I->Setting, NULL, info, NULL);
 	    shaderPrg->Disable();
 	  } else {
 	    sobj->renderCGO->use_shader = use_shader;
 	    sobj->renderCGO->debug = SettingGetGlobal_i(G, cSetting_cgo_debug);
-	    CGORenderGL(sobj->renderCGO, color, I->Obj.Setting, NULL, info, NULL);
+	    CGORenderGL(sobj->renderCGO, color, I->Setting, NULL, info, NULL);
 	  }
 
 	    if (backface_cull){
@@ -357,7 +360,7 @@ static void ObjectCGOGenerateCGO(PyMOLGl
     } else {
       colorWithA[0] = 1.f; colorWithA[1] = 1.f; colorWithA[2] = 1.f;
     }
-    colorWithA[3] = 1.f - SettingGet_f(G, I->Obj.Setting, NULL, cSetting_cgo_transparency);
+    colorWithA[3] = 1.f - SettingGet_f(G, I->Setting, NULL, cSetting_cgo_transparency);
     preOpt = sobj->origCGO;
 
     bool hasTransparency = (colorWithA[3] < 1.f || CGOHasTransparency(preOpt));
@@ -437,7 +440,7 @@ static void ObjectCGOGenerateCGO(PyMOLGl
     }
 
     if (ramp){
-      convertcgo = CGOColorByRamp(G, preOpt, ramp, state, I->Obj.Setting);
+      convertcgo = CGOColorByRamp(G, preOpt, ramp, state, I->Setting);
       CGOFree(preOpt);
       preOpt = convertcgo;
     }
@@ -491,7 +494,7 @@ static void ObjectCGOGenerateCGO(PyMOLGl
 
 static void ObjectCGORender(ObjectCGO * I, RenderInfo * info)
 {
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   int state = info->state;
   CRay *ray = info->ray;
   int pass = info->pass;
@@ -502,18 +505,18 @@ static void ObjectCGORender(ObjectCGO *
   
   use_shader = SettingGetGlobal_b(G, cSetting_cgo_use_shader) &
     SettingGetGlobal_b(G, cSetting_use_shaders);
-  cgo_lighting = SettingGet_i(G, I->Obj.Setting, NULL, cSetting_cgo_lighting);
+  cgo_lighting = SettingGet_i(G, I->Setting, NULL, cSetting_cgo_lighting);
 
-  ObjectPrepareContext(&I->Obj, info);
-  ramp = ColorGetRamp(G, I->Obj.Color);
-  color = ColorGet(G, I->Obj.Color);
+  ObjectPrepareContext(I, info);
+  ramp = ColorGetRamp(G, I->Color);
+  color = ColorGet(G, I->Color);
 
   if(!I->State)
     return;
 
   if(pass || info->ray) {
-    if((I->Obj.visRep & cRepCGOBit)) {
-      for(StateIterator iter(G, I->Obj.Setting, state, I->NState); iter.next();) {
+    if((I->visRep & cRepCGOBit)) {
+      for(StateIterator iter(G, I->Setting, state, I->NState); iter.next();) {
         sobj = I->State + iter.state;
         if (!sobj->origCGO)
           continue;
@@ -535,13 +538,13 @@ ObjectCGO *ObjectCGONew(PyMOLGlobals * G
 
   I->State = VLACalloc(ObjectCGOState, 10);
   I->NState = 0;
-  I->Obj.type = cObjectCGO;
-  I->Obj.fFree = (void (*)(CObject *)) ObjectCGOFree;
-  I->Obj.fUpdate = (void (*)(CObject *)) ObjectCGOUpdate;
-  I->Obj.fInvalidate = (void (*)(CObject *, int rep, int level, int state))
+  I->type = cObjectCGO;
+  I->fFree = (void (*)(CObject *)) ObjectCGOFree;
+  I->fUpdate = (void (*)(CObject *)) ObjectCGOUpdate;
+  I->fInvalidate = (void (*)(CObject *, int rep, int level, int state))
     ObjectCGOInvalidate;
-  I->Obj.fRender = (void (*)(CObject *, RenderInfo *)) ObjectCGORender;
-  I->Obj.fGetNFrame = (int (*)(CObject *)) ObjectCGOGetNState;
+  I->fRender = (void (*)(CObject *, RenderInfo *)) ObjectCGORender;
+  I->fGetNFrame = (int (*)(CObject *)) ObjectCGOGetNState;
 
   return (I);
 }
@@ -606,7 +609,7 @@ ObjectCGO *ObjectCGOFromCGO(PyMOLGlobals
   ObjectCGO *I = NULL;
 
   if(obj) {
-    if(obj->Obj.type != cObjectCGO)     /* TODO: handle this */
+    if(obj->type != cObjectCGO)     /* TODO: handle this */
       obj = NULL;
   }
   if(!obj) {
@@ -662,7 +665,7 @@ ObjectCGO *ObjectCGODefine(PyMOLGlobals
   int est;
 
   if(obj) {
-    if(obj->Obj.type != cObjectCGO)     /* TODO: handle this */
+    if(obj->type != cObjectCGO)     /* TODO: handle this */
       obj = NULL;
   }
   if(!obj) {
@@ -716,7 +719,7 @@ ObjectCGO *ObjectCGOFromFloatArray(PyMOL
   int est;
 
   if(obj) {
-    if(obj->Obj.type != cObjectCGO)     /* TODO: handle this */
+    if(obj->type != cObjectCGO)     /* TODO: handle this */
       obj = NULL;
   }
   if(!obj) {
diff -upNr pymol-open-source-2.3.0/layer2/ObjectCGO.h pymol-open-source-2.3.3/layer2/ObjectCGO.h
--- pymol-open-source-2.3.0/layer2/ObjectCGO.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectCGO.h	2019-08-22 10:24:47.702593085 +0200
@@ -28,11 +28,10 @@ typedef struct ObjectCGOState {
   bool renderWithShaders, hasTransparency, cgo_lighting, hasOpaque;
 } ObjectCGOState;
 
-typedef struct ObjectCGO {
-  CObject Obj;
+struct ObjectCGO : public CObject {
   ObjectCGOState *State;
   int NState;
-} ObjectCGO;
+};
 
 ObjectCGO *ObjectCGONew(PyMOLGlobals * G);
 ObjectCGO *ObjectCGODefine(PyMOLGlobals * G, ObjectCGO * obj, PyObject * pycgo,
diff -upNr pymol-open-source-2.3.0/layer2/ObjectDist.cpp pymol-open-source-2.3.3/layer2/ObjectDist.cpp
--- pymol-open-source-2.3.0/layer2/ObjectDist.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectDist.cpp	2019-08-22 10:24:47.702593085 +0200
@@ -45,15 +45,15 @@ int ObjectDistGetLabelTxfVertex(ObjectDi
   int result = 0;
   if(I->DSet) {
     if(state < 0)
-      state = SettingGet_i(I->Obj.G, NULL, I->Obj.Setting, cSetting_state) - 1;
+      state = SettingGet_i(I->G, NULL, I->Setting, cSetting_state) - 1;
     if(state < 0)
-      state = SceneGetState(I->Obj.G);
+      state = SceneGetState(I->G);
     if(I->NDSet == 1)
       state = 0;                /* static singletons always active here it seems */
     state = state % I->NDSet;
     {
       DistSet *ds = I->DSet[state];
-      if((!ds) && (SettingGet_b(I->Obj.G, I->Obj.Setting, NULL, cSetting_all_states))) {
+      if((!ds) && (SettingGet_b(I->G, I->Setting, NULL, cSetting_all_states))) {
         state = 0;
         ds = I->DSet[state];
       }
@@ -76,7 +76,7 @@ int ObjectDistMoveLabel(ObjectDist * I,
     state = 0;
   state = state % I->NDSet;
   if((!I->DSet[state])
-     && (SettingGet_b(I->Obj.G, I->Obj.Setting, NULL, cSetting_all_states)))
+     && (SettingGet_b(I->G, I->Setting, NULL, cSetting_all_states)))
     state = 0;
   /* find the corresponding distance set, for this state */
   ds = I->DSet[state];
@@ -85,7 +85,7 @@ int ObjectDistMoveLabel(ObjectDist * I,
     /* force this object to redraw itself; invalidate the Label's coordinates
      * with the new data set, ds */
     ds->invalidateRep(cRepLabel, cRepInvCoord);
-    /*      ExecutiveUpdateCoordDepends(I->Obj.G,I); */
+    /*      ExecutiveUpdateCoordDepends(I->G,I); */
   }
   return (result);
 }
@@ -120,7 +120,7 @@ int ObjectDistMoveWithObject(ObjectDist
     }
   }
 	
-  PRINTFD(I->Obj.G, FB_ObjectDist) " ObjectDist-Move: Out of Move\n" ENDFD;
+  PRINTFD(I->G, FB_ObjectDist) " ObjectDist-Move: Out of Move\n" ENDFD;
   return result;
 }
 /* -- JV end */
@@ -167,7 +167,7 @@ static DistSet *ObjectDistGetDistSetFrom
       int a, offset;
 
       range = max_id - min_id + 1;
-      lookup = Calloc(int, range);
+      lookup = pymol::calloc<int>(range);
       for(a = 0; a < obj->NAtom; a++) {
         offset = obj->AtomInfo[a].id - min_id;
         if(lookup[offset])
@@ -311,14 +311,14 @@ void ObjectDistUpdateExtents(ObjectDist
   DistSet *ds;
 
   /* update extents */
-  copy3f(maxv, I->Obj.ExtentMin);
-  copy3f(minv, I->Obj.ExtentMax);
-  I->Obj.ExtentFlag = false;
+  copy3f(maxv, I->ExtentMin);
+  copy3f(minv, I->ExtentMax);
+  I->ExtentFlag = false;
   for(a = 0; a < I->NDSet; a++) {
     ds = I->DSet[a];
     if(ds) {
-      if(DistSetGetExtent(ds, I->Obj.ExtentMin, I->Obj.ExtentMax))
-        I->Obj.ExtentFlag = true;
+      if(DistSetGetExtent(ds, I->ExtentMin, I->ExtentMax))
+        I->ExtentFlag = true;
     }
   }
 }
@@ -347,8 +347,10 @@ static int ObjectDistDSetFromPyList(Obje
   if(ok) {
     VLACheck(I->DSet, DistSet *, I->NDSet);
     for(a = 0; a < I->NDSet; a++) {
-      if(ok)
-        ok = DistSetFromPyList(I->Obj.G, PyList_GetItem(list, a), &I->DSet[a]);
+      if(ok){
+        auto *val = PyList_GetItem(list, a);
+        ok = DistSetFromPyList(I->G, val, &I->DSet[a]);
+      }
       if(ok)
         I->DSet[a]->Obj = I;
     }
@@ -364,7 +366,7 @@ PyObject *ObjectDistAsPyList(ObjectDist
   /* first, dump the atoms */
 
   result = PyList_New(4);
-  PyList_SetItem(result, 0, ObjectAsPyList(&I->Obj));
+  PyList_SetItem(result, 0, ObjectAsPyList(I));
   PyList_SetItem(result, 1, PyInt_FromLong(I->NDSet));
   PyList_SetItem(result, 2, ObjectDistDSetAsPyList(I));
   PyList_SetItem(result, 3, PyInt_FromLong(0));
@@ -385,8 +387,10 @@ int ObjectDistNewFromPyList(PyMOLGlobals
   if(ok)
     ok = (I != NULL);
 
-  if(ok)
-    ok = ObjectFromPyList(G, PyList_GetItem(list, 0), &I->Obj);
+  if(ok){
+    auto *val = PyList_GetItem(list, 0);
+    ok = ObjectFromPyList(G, val, I);
+  }
   if(ok)
     ok = PConvPyIntToInt(PyList_GetItem(list, 1), &I->NDSet);
   if(ok)
@@ -414,11 +418,11 @@ int ObjectDistGetNFrames(ObjectDist * I)
 void ObjectDistUpdate(ObjectDist * I)
 {
   int a;
-  OrthoBusyPrime(I->Obj.G);
+  OrthoBusyPrime(I->G);
   for(a = 0; a < I->NDSet; a++)
     if(I->DSet[a]) {
-      OrthoBusySlow(I->Obj.G, a, I->NDSet);
-      /*           printf(" ObjectDist: updating state %d of \"%s\".\n" , a+1, I->Obj.Name); */
+      OrthoBusySlow(I->G, a, I->NDSet);
+      /*           printf(" ObjectDist: updating state %d of \"%s\".\n" , a+1, I->Name); */
       I->DSet[a]->update(a);
     }
 }
@@ -428,7 +432,7 @@ void ObjectDistUpdate(ObjectDist * I)
 void ObjectDistInvalidateRep(ObjectDist * I, int rep)
 {
   int a;
-  PRINTFD(I->Obj.G, FB_ObjectDist)
+  PRINTFD(I->G, FB_ObjectDist)
     " ObjectDistInvalidateRep: entered.\n" ENDFD;
 
   for(a = 0; a < I->NDSet; a++)
@@ -458,21 +462,21 @@ static void ObjectDistRender(ObjectDist
   if (!shouldRender)
     return;
 
-  ObjectPrepareContext(&I->Obj, info);
-
-    for(StateIterator iter(I->Obj.G, I->Obj.Setting, state, I->NDSet);
-        iter.next();) {
-      DistSet * ds = I->DSet[iter.state];
-      if(ds)
-        ds->render(info);
-    }
+  ObjectPrepareContext(I, info);
+  
+  for(StateIterator iter(I->G, I->Setting, state, I->NDSet);
+      iter.next();) {
+    DistSet * ds = I->DSet[iter.state];
+    if(ds)
+      ds->render(info);
+  }
 }
 
 #if 0
 static CSetting **ObjectDistGetSettingHandle(ObjectDist * I, int state)
 {
   if(state < 0) {
-    return (&I->Obj.Setting);
+    return (&I->Setting);
   } else {
     return (NULL);
   }
@@ -481,7 +485,7 @@ static CSetting **ObjectDistGetSettingHa
 
 static void ObjectDistInvalidate(CObject * Iarg, int rep, int level, int state){
   ObjectDist * I = (ObjectDist*)Iarg;
-  for(StateIterator iter(I->Obj.G, I->Obj.Setting, state, I->NDSet);
+  for(StateIterator iter(I->G, I->Setting, state, I->NDSet);
       iter.next();) {
     DistSet * ds = I->DSet[iter.state];
     if(ds)
@@ -494,20 +498,20 @@ ObjectDist *ObjectDistNew(PyMOLGlobals *
 {
   OOAlloc(G, ObjectDist);
   ObjectInit(G, (CObject *) I);
-  I->Obj.type = cObjectMeasurement;
+  I->type = cObjectMeasurement;
   I->DSet = VLACalloc(DistSet *, 10);  /* auto-zero */
   I->NDSet = 0;
-  I->Obj.fRender = (void (*)(CObject *, RenderInfo * info)) ObjectDistRender;
-  I->Obj.fFree = (void (*)(CObject *)) ObjectDistFree;
-  I->Obj.fUpdate = (void (*)(CObject *)) ObjectDistUpdate;
-  I->Obj.fInvalidate = (void (*)(CObject *, int, int, int)) ObjectDistInvalidate;
-  I->Obj.fGetNFrame = (int (*)(CObject *)) ObjectDistGetNFrames;
+  I->fRender = (void (*)(CObject *, RenderInfo * info)) ObjectDistRender;
+  I->fFree = (void (*)(CObject *)) ObjectDistFree;
+  I->fUpdate = (void (*)(CObject *)) ObjectDistUpdate;
+  I->fInvalidate = (void (*)(CObject *, int, int, int)) ObjectDistInvalidate;
+  I->fGetNFrame = (int (*)(CObject *)) ObjectDistGetNFrames;
 #if 0
-  I->Obj.fGetSettingHandle = (CSetting ** (*)(CObject *, int state))
+  I->fGetSettingHandle = (CSetting ** (*)(CObject *, int state))
     ObjectDistGetSettingHandle;
 #endif
-  I->Obj.fDescribeElement = NULL;
-  I->Obj.Color = ColorGetIndex(G, "dash");
+  I->fDescribeElement = NULL;
+  I->Color = ColorGetIndex(G, "dash");
   return (I);
 }
 
@@ -845,6 +849,6 @@ void ObjectDistFree(ObjectDist * I)
       I->DSet[a] = NULL;
     }
   VLAFreeP(I->DSet);
-  ObjectPurge(&I->Obj);
+  ObjectPurge(I);
   OOFreeP(I); /* from OOAlloc */
 }
diff -upNr pymol-open-source-2.3.0/layer2/ObjectDist.h pymol-open-source-2.3.3/layer2/ObjectDist.h
--- pymol-open-source-2.3.0/layer2/ObjectDist.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectDist.h	2019-08-22 10:24:47.702593085 +0200
@@ -24,14 +24,12 @@ Z* -------------------------------------
 
 /* NOTE: "Dist" names & symbols should be updated to "Measurement" */
 
-typedef struct ObjectDist {
-  /* base class, this IS-A CObject */
-  CObject Obj;
+struct ObjectDist : public CObject {
   /* Array of pointers to DistSets */
   struct DistSet **DSet;
   /* number of dist sets */
   int NDSet;
-} ObjectDist;
+};
 
 ObjectDist *ObjectDistNewFromSele(PyMOLGlobals * G, ObjectDist * oldObj,
                                   int sele1, int sele2, int mode, float cutoff,
diff -upNr pymol-open-source-2.3.0/layer2/ObjectGadget.cpp pymol-open-source-2.3.3/layer2/ObjectGadget.cpp
--- pymol-open-source-2.3.0/layer2/ObjectGadget.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectGadget.cpp	2019-08-22 10:24:47.702593085 +0200
@@ -228,7 +228,7 @@ ObjectGadget *ObjectGadgetTest(PyMOLGlob
 
   I->GSet[0] = gs;
   I->NGSet = 1;
-  I->Obj.Context = 1;
+  I->Context = 1;
   gs->update();
   ObjectGadgetUpdateExtents(I);
   return (I);
@@ -243,14 +243,14 @@ void ObjectGadgetUpdateExtents(ObjectGad
   GadgetSet *ds;
 
   /* update extents */
-  copy3f(maxv, I->Obj.ExtentMin);
-  copy3f(minv, I->Obj.ExtentMax);
-  I->Obj.ExtentFlag = false;
+  copy3f(maxv, I->ExtentMin);
+  copy3f(minv, I->ExtentMax);
+  I->ExtentFlag = false;
   for(a = 0; a < I->NGSet; a++) {
     ds = I->GSet[a];
     if(ds) {
-      if(GadgetSetGetExtent(ds, I->Obj.ExtentMin, I->Obj.ExtentMax))
-        I->Obj.ExtentFlag = true;
+      if(GadgetSetGetExtent(ds, I->ExtentMin, I->ExtentMax))
+        I->ExtentFlag = true;
     }
   }
 }
@@ -281,8 +281,10 @@ static int ObjectGadgetGSetFromPyList(Ob
   if(ok) {
     VLACheck(I->GSet, GadgetSet *, I->NGSet);
     for(a = 0; a < I->NGSet; a++) {
-      if(ok)
-        ok = GadgetSetFromPyList(I->Obj.G, PyList_GetItem(list, a), &I->GSet[a], version);
+      if(ok){
+        auto *val = PyList_GetItem(list, a);
+        ok = GadgetSetFromPyList(I->G, val, &I->GSet[a], version);
+      }
       if(ok && I->GSet[a]) {
         I->GSet[a]->Obj = I;
         I->GSet[a]->State = a;
@@ -302,8 +304,10 @@ int ObjectGadgetInitFromPyList(PyMOLGlob
     ok = PyList_Check(list);
   /* TO SUPPORT BACKWARDS COMPATIBILITY...
      Always check ll when adding new PyList_GetItem's */
-  if(ok)
-    ok = ObjectFromPyList(G, PyList_GetItem(list, 0), &I->Obj);
+  if(ok){
+    auto *val = PyList_GetItem(list, 0);
+    ok = ObjectFromPyList(G, val, I);
+  }
   if(ok)
     ok = PConvPyIntToInt(PyList_GetItem(list, 1), &I->GadgetType);
   if(ok)
@@ -373,7 +377,7 @@ PyObject *ObjectGadgetPlainAsPyList(Obje
   /* first, dump the atoms */
 
   result = PyList_New(5);
-  PyList_SetItem(result, 0, ObjectAsPyList(&I->Obj));
+  PyList_SetItem(result, 0, ObjectAsPyList(I));
   PyList_SetItem(result, 1, PyInt_FromLong(I->GadgetType));
   PyList_SetItem(result, 2, PyInt_FromLong(I->NGSet));
   PyList_SetItem(result, 3, ObjectGadgetGSetAsPyList(I, incl_cgos));
@@ -408,7 +412,7 @@ void ObjectGadgetPurge(ObjectGadget * I)
       I->GSet[a] = NULL;
     }
   VLAFreeP(I->GSet);
-  ObjectPurge(&I->Obj);
+  ObjectPurge(I);
 }
 
 void ObjectGadgetFree(ObjectGadget * I)
@@ -420,11 +424,11 @@ void ObjectGadgetFree(ObjectGadget * I)
 void ObjectGadgetUpdateStates(ObjectGadget * I)
 {
   int a;
-  OrthoBusyPrime(I->Obj.G);
+  OrthoBusyPrime(I->G);
   for(a = 0; a < I->NGSet; a++)
     if(I->GSet[a]) {
-      OrthoBusySlow(I->Obj.G, a, I->NGSet);
-      /*           printf(" ObjectGadget: updating state %d of \"%s\".\n" , a+1, I->Obj.Name); */
+      OrthoBusySlow(I->G, a, I->NGSet);
+      /*           printf(" ObjectGadget: updating state %d of \"%s\".\n" , a+1, I->Name); */
       I->GSet[a]->update();
     }
 }
@@ -456,8 +460,8 @@ static void ObjectGadgetRender(ObjectGad
   int pass = info->pass;
   if(pass < 0 || info->ray || info->pick) {
 
-    ObjectPrepareContext(&I->Obj, info);
-    for(StateIterator iter(I->Obj.G, I->Obj.Setting, state, I->NGSet);
+    ObjectPrepareContext(I, info);
+    for(StateIterator iter(I->G, I->Setting, state, I->NGSet);
         iter.next();) {
       GadgetSet * gs = I->GSet[iter.state];
       gs->render(info);
@@ -471,16 +475,16 @@ void ObjectGadgetInit(PyMOLGlobals * G,
 {
   ObjectInit(G, (CObject *) I);
 
-  I->Obj.type = cObjectGadget;
+  I->type = cObjectGadget;
   I->GSet = VLACalloc(GadgetSet *, 10);        /* auto-zero */
   I->NGSet = 0;
   I->Changed = true;
 
-  I->Obj.fFree = (void (*)(CObject *)) ObjectGadgetFree;
-  I->Obj.fUpdate = (void (*)(CObject *)) ObjectGadgetUpdate;
-  I->Obj.fRender = (void (*)(CObject *, RenderInfo * info)) ObjectGadgetRender;
-  I->Obj.fGetNFrame = (int (*)(CObject *)) ObjectGadgetGetNState;
-  I->Obj.fDescribeElement = NULL;
+  I->fFree = (void (*)(CObject *)) ObjectGadgetFree;
+  I->fUpdate = (void (*)(CObject *)) ObjectGadgetUpdate;
+  I->fRender = (void (*)(CObject *, RenderInfo * info)) ObjectGadgetRender;
+  I->fGetNFrame = (int (*)(CObject *)) ObjectGadgetGetNState;
+  I->fDescribeElement = NULL;
   I->CurGSet = 0;
 }
 
diff -upNr pymol-open-source-2.3.0/layer2/ObjectGadget.h pymol-open-source-2.3.3/layer2/ObjectGadget.h
--- pymol-open-source-2.3.0/layer2/ObjectGadget.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectGadget.h	2019-08-22 10:24:47.702593085 +0200
@@ -24,14 +24,13 @@ Z* -------------------------------------
 
 #include"GadgetSet.h"
 
-typedef struct ObjectGadget {
-  CObject Obj;
+struct ObjectGadget : public CObject {
   struct GadgetSet **GSet;
   int NGSet;
   int CurGSet;
   int GadgetType;
   int Changed;
-} ObjectGadget;
+};
 
 #define cGadgetPlain 0
 #define cGadgetRamp 1
diff -upNr pymol-open-source-2.3.0/layer2/ObjectGadgetRamp.cpp pymol-open-source-2.3.3/layer2/ObjectGadgetRamp.cpp
--- pymol-open-source-2.3.0/layer2/ObjectGadgetRamp.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectGadgetRamp.cpp	2019-08-22 10:24:47.706593737 +0200
@@ -43,7 +43,7 @@ static int ObjectGadgetRampHandleInputCo
 
 void ObjectGadgetRampFree(ObjectGadgetRamp * I)
 {
-  ColorForgetExt(I->Gadget.Obj.G, I->Gadget.Obj.Name);
+  ColorForgetExt(I->Gadget.G, I->Gadget.Name);
   VLAFreeP(I->Level);
   VLAFreeP(I->Color);
   VLAFreeP(I->LevelTmp);
@@ -51,9 +51,6 @@ void ObjectGadgetRampFree(ObjectGadgetRa
   OOFreeP(I);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static void ObjectGadgetRampCalculate(ObjectGadgetRamp * I, float v, float *result)
 {
   const float _1 = 1.0F;
@@ -219,9 +216,6 @@ static int _ObjectGadgetRampInterpolate(
   return (ok);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int _ObjectGadgetRampBlend(ObjectGadgetRamp * I, float *color,
                                   const float *table, int mode)
 {
@@ -333,7 +327,7 @@ static int ObjectGadgetRampInterpolateWi
           copy3f(object, dst);
           break;
         default:               /* allow nested ramps */
-          ColorGetRamped(I->Gadget.Obj.G, index, vertex, dst, state);
+          ColorGetRamped(I->Gadget.G, index, vertex, dst, state);
           break;
       }
       dst += 3;
@@ -382,7 +376,7 @@ PyObject *ObjectGadgetRampAsPyList(Objec
   // I->Special, removed in PyMOL 1.8
   bool any = false;
   int* special = NULL;
-  int pse_export_version = SettingGetGlobal_f(I->Gadget.Obj.G, cSetting_pse_export_version) * 1000;
+  int pse_export_version = SettingGetGlobal_f(I->Gadget.G, cSetting_pse_export_version) * 1000;
   if (I->Color && pse_export_version < 1800) {
     int n_color = VLAGetSize(I->Color) / 3;
     special = VLAlloc(int, n_color);
@@ -482,8 +476,8 @@ int ObjectGadgetRampInterVertex(ObjectGa
   switch (I->RampType) {
   case cRampMap:
     if(!I->Map)
-      I->Map = ExecutiveFindObjectMapByName(I->Gadget.Obj.G, I->SrcName);
-    if(!ExecutiveValidateObjectPtr(I->Gadget.Obj.G, (CObject *) I->Map, cObjectMap))
+      I->Map = ExecutiveFindObjectMapByName(I->Gadget.G, I->SrcName);
+    if(!ExecutiveValidateObjectPtr(I->Gadget.G, (CObject *) I->Map, cObjectMap))
       ok = false;
     else {
       int src_state;
@@ -492,7 +486,7 @@ int ObjectGadgetRampInterVertex(ObjectGa
       else
         src_state = state;
       if(src_state < 0)
-        src_state = SceneGetState(I->Gadget.Obj.G);
+        src_state = SceneGetState(I->Gadget.G);
       if(ok)
         ok = (I->Map != NULL);
       if(ok)
@@ -503,15 +497,15 @@ int ObjectGadgetRampInterVertex(ObjectGa
     break;
   case cRampMol:
     if(!I->Mol)
-      I->Mol = ExecutiveFindObjectMoleculeByName(I->Gadget.Obj.G, I->SrcName);
-    if(!ExecutiveValidateObjectPtr(I->Gadget.Obj.G, (CObject *) I->Mol, cObjectMolecule))
+      I->Mol = ExecutiveFindObjectMoleculeByName(I->Gadget.G, I->SrcName);
+    if(!ExecutiveValidateObjectPtr(I->Gadget.G, (CObject *) I->Mol, cObjectMolecule))
       ok = false;
     else {
       float cutoff = 1.0F;
       float dist;
       int sub_vdw = false;
       if(state < 0)
-        state = SceneGetState(I->Gadget.Obj.G);
+        state = SceneGetState(I->Gadget.G);
       if(I->Level && I->NLevel) {
         cutoff = I->Level[I->NLevel - 1];
         if(I->Level[0] < 0.0F) {
@@ -525,14 +519,14 @@ int ObjectGadgetRampInterVertex(ObjectGa
 	if (I->Mol->NCSet==1) // if only one state, then set state to 0
 	  state = 0;
         if(SettingGet_b
-           (I->Gadget.Obj.G, I->Gadget.Obj.Setting, NULL,
+           (I->Gadget.G, I->Gadget.Setting, NULL,
             cSetting_ramp_blend_nearby_colors)) {
           float atomic[3];
           int index =
             ObjectMoleculeGetNearestBlendedColor(I->Mol, pos, cutoff, state, &dist,
                                                  atomic, sub_vdw);
           if(index >= 0) {
-            const float *object = ColorGetRaw(I->Gadget.Obj.G, I->Mol->Obj.Color);
+            const float *object = ColorGetRaw(I->Gadget.G, I->Mol->Color);
 
             if(!ObjectGadgetRampInterpolateWithSpecial(I, dist, color, atomic,
                                                        object, pos, state, false)) {
@@ -549,8 +543,8 @@ int ObjectGadgetRampInterVertex(ObjectGa
           int index =
             ObjectMoleculeGetNearestAtomIndex(I->Mol, pos, cutoff, state, &dist);
           if(index >= 0) {
-            const float *atomic = ColorGetRaw(I->Gadget.Obj.G, I->Mol->AtomInfo[index].color);
-            const float *object = ColorGetRaw(I->Gadget.Obj.G, I->Mol->Obj.Color);
+            const float *atomic = ColorGetRaw(I->Gadget.G, I->Mol->AtomInfo[index].color);
+            const float *object = ColorGetRaw(I->Gadget.G, I->Mol->Color);
 
             if(sub_vdw) {
               dist -= I->Mol->AtomInfo[index].vdw;
@@ -597,12 +591,12 @@ static void ObjectGadgetRampUpdateCGO(Ob
   int font_id = 0;
   int n_color = I->Color ? VLAGetSize(I->Color) / 3 : 0;
 
-  blocked = PAutoBlock(I->Gadget.Obj.G);
-  font_id = VFontLoad(I->Gadget.Obj.G, 1.0, 1, 1, true);
+  blocked = PAutoBlock(I->Gadget.G);
+  font_id = VFontLoad(I->Gadget.G, 1.0, 1, 1, true);
   if(blocked)
-    PUnblock(I->Gadget.Obj.G);
+    PUnblock(I->Gadget.G);
 
-  cgo = CGONewSized(I->Gadget.Obj.G, 100);
+  cgo = CGONewSized(I->Gadget.G, 100);
 
   /* behind text */
   CGOBegin(cgo, GL_TRIANGLE_STRIP);
@@ -629,7 +623,7 @@ static void ObjectGadgetRampUpdateCGO(Ob
     float color[] = { 1.f, 1.f, 1.f };
     /* left text for ramp */
     sprintf(buffer, "%0.3f", I->Level[0]);
-    VFontWriteToCGO(I->Gadget.Obj.G, font_id, cgo, buffer, pos, scale, axes, color);
+    VFontWriteToCGO(I->Gadget.G, font_id, cgo, buffer, pos, scale, axes, color);
 
     /* right text, right justified for ramp */
     pos[0] = I->width + I->border - exindent;
@@ -637,8 +631,8 @@ static void ObjectGadgetRampUpdateCGO(Ob
     pos[2] = I->border + I->text_raise ;
     sprintf(buffer, "%0.3f", I->Level[I->NLevel - 1]);
     /* indent for right justification */
-    VFontIndent(I->Gadget.Obj.G, font_id, buffer, pos, scale, axes, -1.f);
-    VFontWriteToCGO(I->Gadget.Obj.G, font_id, cgo, buffer, pos, scale, axes, color);
+    VFontIndent(I->Gadget.G, font_id, buffer, pos, scale, axes, -1.f);
+    VFontWriteToCGO(I->Gadget.G, font_id, cgo, buffer, pos, scale, axes, color);
   }
 
   /* center */
@@ -679,7 +673,7 @@ static void ObjectGadgetRampUpdateCGO(Ob
 
       if(!GetSpecial(src)) {
         copy3f(src, tmp);
-        ColorLookupColor(I->Gadget.Obj.G, tmp);
+        ColorLookupColor(I->Gadget.G, tmp);
       }
 
       if (a == n_color) {
@@ -764,7 +758,7 @@ static void ObjectGadgetRampUpdateCGO(Ob
   CGOPreloadFonts(gs->ShapeCGO);
   //#endif
 
-  cgo = CGONewSized(I->Gadget.Obj.G, 100);
+  cgo = CGONewSized(I->Gadget.G, 100);
   CGODotwidth(cgo, 5);
   CGOPickColor(cgo, 0, cPickableGadget);
 
@@ -820,10 +814,10 @@ static void ObjectGadgetRampBuild(Object
   GadgetSet *gs = NULL;
   ObjectGadget *og;
 
-  OrthoBusyPrime(I->Gadget.Obj.G);
+  OrthoBusyPrime(I->Gadget.G);
 
   og = &I->Gadget;
-  gs = GadgetSetNew(I->Gadget.Obj.G);
+  gs = GadgetSetNew(I->Gadget.G);
 
   gs->NCoord = 2;
   I->var_index = gs->NCoord;
@@ -844,7 +838,7 @@ static void ObjectGadgetRampBuild(Object
 
   og->GSet[0] = gs;
   og->NGSet = 1;
-  og->Obj.Context = 1;          /* unit window */
+  og->Context = 1;          /* unit window */
   gs->Obj = (ObjectGadget *) I;
   gs->State = 0;
 
@@ -869,7 +863,7 @@ void ObjectGadgetRampUpdate(ObjectGadget
         for(a = 0; a < I->NLevel; a++) {
           I->Level[a] = I->Level[a] * scale;
         }
-        ExecutiveInvalidateRep(I->Gadget.Obj.G, cKeywordAll, cRepAll, cRepInvColor);
+        ExecutiveInvalidateRep(I->Gadget.G, cKeywordAll, cRepAll, cRepInvColor);
       }
       break;
     default:
@@ -878,13 +872,13 @@ void ObjectGadgetRampUpdate(ObjectGadget
           float mean = (I->Level[0] + I->Level[1]) / 2.0F;
           I->Level[0] = (I->Level[0] - mean) * scale + mean;
           I->Level[1] = (I->Level[1] - mean) * scale + mean;
-          ExecutiveInvalidateRep(I->Gadget.Obj.G, cKeywordAll, cRepAll, cRepInvColor);
+          ExecutiveInvalidateRep(I->Gadget.G, cKeywordAll, cRepAll, cRepInvColor);
         }
         break;
       } else if(I->NLevel == 3) {
         I->Level[0] = (I->Level[0] - I->Level[1]) * scale + I->Level[1];
         I->Level[2] = (I->Level[2] - I->Level[1]) * scale + I->Level[1];
-        ExecutiveInvalidateRep(I->Gadget.Obj.G, cKeywordAll, cRepAll, cRepInvColor);
+        ExecutiveInvalidateRep(I->Gadget.G, cKeywordAll, cRepAll, cRepInvColor);
       }
     }
     VLAFreeP(I->LevelTmp);
@@ -895,7 +889,7 @@ void ObjectGadgetRampUpdate(ObjectGadget
       }
     ObjectGadgetUpdateExtents(&I->Gadget);
     I->Gadget.Changed = false;
-    SceneChanged(I->Gadget.Obj.G);
+    SceneChanged(I->Gadget.G);
   }
 }
 
@@ -919,10 +913,10 @@ static int ObjectGadgetRampHandleInputCo
     }
 
     if(n_color != I->NLevel && I->NLevel != 2) {
-      PRINTFB(I->Gadget.Obj.G, FB_ObjectGadget, FB_Warnings)
+      PRINTFB(I->Gadget.G, FB_ObjectGadget, FB_Warnings)
         " GadgetRamp-Warning: number of colors (%d) and number of levels (%d) don't\n"
         " match and n_level != 2. Support for trailing extreme colors dropped in 1.8.",
-        n_color, I->NLevel ENDFB(I->Gadget.Obj.G);
+        n_color, I->NLevel ENDFB(I->Gadget.G);
     }
 
     if(n_color < I->NLevel) {
@@ -995,8 +989,8 @@ ObjectGadgetRamp *ObjectGadgetRampMapNew
 
   if (map) {
     I->Map = map;
-  I->SrcState = map_state;
-    UtilNCopy(I->SrcName, map->Obj.Name, WordLength);
+    I->SrcState = map_state;
+    UtilNCopy(I->SrcName, map->Name, WordLength);
   }
 
   return (I);
@@ -1022,7 +1016,7 @@ ObjectGadgetRamp *ObjectGadgetRampMolNew
     I->RampType = cRampMol;
     I->Mol = mol;
     I->SrcState = mol_state;
-    UtilNCopy(I->SrcName, mol->Obj.Name, WordLength);
+    UtilNCopy(I->SrcName, mol->Name, WordLength);
   }
 
   if (color_vla || calc_mode > 0) {
@@ -1062,9 +1056,9 @@ ObjectGadgetRamp *ObjectGadgetRampNew(Py
   I->Color = NULL;
   I->SrcName[0] = 0;
 
-  I->Gadget.Obj.fUpdate = (void (*)(CObject *)) ObjectGadgetRampUpdate;
-  I->Gadget.Obj.fFree = (void (*)(CObject *)) ObjectGadgetRampFree;
-  I->Gadget.Obj.fInvalidate =
+  I->Gadget.fUpdate = (void (*)(CObject *)) ObjectGadgetRampUpdate;
+  I->Gadget.fFree = (void (*)(CObject *)) ObjectGadgetRampFree;
+  I->Gadget.fInvalidate =
     (void (*)(CObject *, int, int, int)) ObjectGadgetRampInvalidate;
 
   I->Mol = NULL;
diff -upNr pymol-open-source-2.3.0/layer2/ObjectGroup.cpp pymol-open-source-2.3.3/layer2/ObjectGroup.cpp
--- pymol-open-source-2.3.0/layer2/ObjectGroup.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectGroup.cpp	2019-08-22 10:24:47.706593737 +0200
@@ -41,8 +41,10 @@ int ObjectGroupNewFromPyList(PyMOLGlobal
   I = ObjectGroupNew(G);
   if(ok)
     ok = (I != NULL);
-  if(ok)
-    ok = ObjectFromPyList(G, PyList_GetItem(list, 0), &I->Obj);
+  if(ok){
+    auto *val = PyList_GetItem(list, 0);
+    ok = ObjectFromPyList(G, val, I);
+  }
   if(ok)
     ok = PConvPyIntToInt(PyList_GetItem(list, 1), &I->OpenOrClosed);
   if(ok && (ll > 2))
@@ -60,7 +62,7 @@ PyObject *ObjectGroupAsPyList(ObjectGrou
   PyObject *result = NULL;
 
   result = PyList_New(3);
-  PyList_SetItem(result, 0, ObjectAsPyList(&I->Obj));
+  PyList_SetItem(result, 0, ObjectAsPyList(I));
   PyList_SetItem(result, 1, PyInt_FromLong(I->OpenOrClosed));
   PyList_SetItem(result, 2, ObjectStateAsPyList(&I->State));
   return (PConvAutoNone(result));
@@ -72,7 +74,7 @@ PyObject *ObjectGroupAsPyList(ObjectGrou
 static void ObjectGroupFree(ObjectGroup * I)
 {
   ObjectStatePurge(&I->State);
-  ObjectPurge(&I->Obj);
+  ObjectPurge(I);
   OOFreeP(I);
 }
 
@@ -91,11 +93,11 @@ ObjectGroup *ObjectGroupNew(PyMOLGlobals
 
   ObjectInit(G, (CObject *) I);
 
-  I->Obj.type = cObjectGroup;
-  I->Obj.fFree = (void (*)(CObject *)) ObjectGroupFree;
-  I->Obj.fRender = NULL;
+  I->type = cObjectGroup;
+  I->fFree = (void (*)(CObject *)) ObjectGroupFree;
+  I->fRender = NULL;
   I->OpenOrClosed = false;
-  I->Obj.fGetObjectState = (CObjectState * (*)(CObject *, int state))
+  I->fGetObjectState = (CObjectState * (*)(CObject *, int state))
     ObjectGroupGetObjectState;
 
   ObjectStateInit(G, &I->State);
diff -upNr pymol-open-source-2.3.0/layer2/ObjectGroup.h pymol-open-source-2.3.3/layer2/ObjectGroup.h
--- pymol-open-source-2.3.0/layer2/ObjectGroup.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectGroup.h	2019-08-22 10:24:47.706593737 +0200
@@ -21,12 +21,10 @@ Z* -------------------------------------
 
 #include"PyMOLObject.h"
 
-typedef struct ObjectGroup {
-  CObject Obj;
+struct ObjectGroup : public CObject {
   int OpenOrClosed;
   CObjectState State;           /* groups only have one state */
-
-} ObjectGroup;
+};
 
 ObjectGroup *ObjectGroupNew(PyMOLGlobals * G);
 
diff -upNr pymol-open-source-2.3.0/layer2/ObjectMap.cpp pymol-open-source-2.3.3/layer2/ObjectMap.cpp
--- pymol-open-source-2.3.0/layer2/ObjectMap.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectMap.cpp	2019-08-22 10:24:47.706593737 +0200
@@ -146,7 +146,7 @@ int ObjectMapValidXtal(ObjectMap * I, in
  */
 void ObjectMapTransformMatrix(ObjectMap * I, int state, double *matrix)
 {
-  for(StateIterator iter(I->Obj.G, I->Obj.Setting, state, I->NState); iter.next();) {
+  for(StateIterator iter(I->G, I->Setting, state, I->NState); iter.next();) {
     ObjectMapState *ms = I->State + iter.state;
     if(ms->Active) {
       ObjectStateTransformMatrix(&ms->State, matrix);
@@ -163,7 +163,7 @@ void ObjectMapTransformMatrix(ObjectMap
  */   
 void ObjectMapResetMatrix(ObjectMap * I, int state)
 {
-  for(StateIterator iter(I->Obj.G, I->Obj.Setting, state, I->NState); iter.next();) {
+  for(StateIterator iter(I->G, I->Setting, state, I->NState); iter.next();) {
     ObjectMapState *ms = I->State + iter.state;
     if(ms->Active) {
       ObjectStateResetMatrix(&ms->State);
@@ -203,7 +203,7 @@ int ObjectMapSetMatrix(ObjectMap * I, in
 {
   bool result = false;
 
-  for(StateIterator iter(I->Obj.G, I->Obj.Setting, state, I->NState); iter.next();) {
+  for(StateIterator iter(I->G, I->Setting, state, I->NState); iter.next();) {
     ObjectMapState *ms = I->State + iter.state;
     if(ms->Active) {
       ObjectStateSetMatrix(&ms->State, matrix);
@@ -451,7 +451,7 @@ int ObjectMapInterpolate(ObjectMap * I,
     if(matrix) {
       /* we have to back-transform points */
       if(n > 1) {
-        txf = Alloc(float, 3 * n);
+        txf = pymol::malloc<float>(3 * n);
       }
 
       const float *src = array;
@@ -990,17 +990,17 @@ int ObjectMapTrim(ObjectMap * I, int sta
   if(state < 0) {
     for(a = 0; a < I->NState; a++) {
       if(I->State[a].Active) {
-        if(ObjectMapStateTrim(I->Obj.G, &I->State[a], mn, mx, quiet))
+        if(ObjectMapStateTrim(I->G, &I->State[a], mn, mx, quiet))
           update = true;
         else
           result = false;
       }
     }
   } else if((state >= 0) && (state < I->NState) && (I->State[state].Active)) {
-    update = result = ObjectMapStateTrim(I->Obj.G, &I->State[state], mn, mx, quiet);
+    update = result = ObjectMapStateTrim(I->G, &I->State[state], mn, mx, quiet);
   } else {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Errors)
-      " ObjectMap-Error: invalidate state.\n" ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Errors)
+      " ObjectMap-Error: invalidate state.\n" ENDFB(I->G);
     result = false;
   }
   if(update)
@@ -1015,13 +1015,13 @@ int ObjectMapDouble(ObjectMap * I, int s
   if(state < 0) {
     for(a = 0; a < I->NState; a++) {
       if(I->State[a].Active)
-        result = result && ObjectMapStateDouble(I->Obj.G, &I->State[a]);
+        result = result && ObjectMapStateDouble(I->G, &I->State[a]);
     }
   } else if((state >= 0) && (state < I->NState) && (I->State[state].Active)) {
-    ObjectMapStateDouble(I->Obj.G, &I->State[state]);
+    ObjectMapStateDouble(I->G, &I->State[state]);
   } else {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Errors)
-      " ObjectMap-Error: invalidate state.\n" ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Errors)
+      " ObjectMap-Error: invalidate state.\n" ENDFB(I->G);
     result = false;
   }
   return (result);
@@ -1034,14 +1034,14 @@ int ObjectMapHalve(ObjectMap * I, int st
   if(state < 0) {
     for(a = 0; a < I->NState; a++) {
       if(I->State[a].Active)
-        result = result && ObjectMapStateHalve(I->Obj.G, &I->State[a], smooth);
+        result = result && ObjectMapStateHalve(I->G, &I->State[a], smooth);
     }
 
   } else if((state >= 0) && (state < I->NState) && (I->State[state].Active)) {
-    ObjectMapStateHalve(I->Obj.G, &I->State[state], smooth);
+    ObjectMapStateHalve(I->G, &I->State[state], smooth);
   } else {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Errors)
-      " ObjectMap-Error: invalidate state.\n" ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Errors)
+      " ObjectMap-Error: invalidate state.\n" ENDFB(I->G);
     result = false;
   }
   ObjectMapUpdateExtents(I);
@@ -1393,7 +1393,7 @@ static int ObjectMapStateCopy(PyMOLGloba
 	I->Symmetry = NULL;
 
       if(src->Origin) {
-        I->Origin = Alloc(float, 3);
+        I->Origin = pymol::malloc<float>(3);
         if(I->Origin) {
           copy3f(src->Origin, I->Origin);
         }
@@ -1402,7 +1402,7 @@ static int ObjectMapStateCopy(PyMOLGloba
       }
 
       if(src->Range) {
-        I->Range = Alloc(float, 3);
+        I->Range = pymol::malloc<float>(3);
         if(I->Range) {
           copy3f(src->Range, I->Range);
         }
@@ -1411,7 +1411,7 @@ static int ObjectMapStateCopy(PyMOLGloba
       }
 
       if(src->Grid) {
-        I->Grid = Alloc(float, 3);
+        I->Grid = pymol::malloc<float>(3);
         if(I->Grid) {
           copy3f(src->Grid, I->Grid);
         }
@@ -1420,7 +1420,7 @@ static int ObjectMapStateCopy(PyMOLGloba
       }
 
       if(src->Dim) {
-        I->Dim = Alloc(int, 4);
+        I->Dim = pymol::malloc<int>(4);
         if(I->Dim) {
           copy3f(src->Dim, I->Dim);
         }
@@ -1544,7 +1544,8 @@ static int ObjectMapAllStatesFromPyList(
     ok = PyList_Check(list);
   if(ok) {
     for(a = 0; a < I->NState; a++) {
-      ok = ObjectMapStateFromPyList(I->Obj.G, I->State + a, PyList_GetItem(list, a));
+      auto *val = PyList_GetItem(list, a);
+      ok = ObjectMapStateFromPyList(I->G, I->State + a, val);
       if(!ok)
         break;
     }
@@ -1557,7 +1558,7 @@ PyObject *ObjectMapAsPyList(ObjectMap *
   PyObject *result = NULL;
 
   result = PyList_New(3);
-  PyList_SetItem(result, 0, ObjectAsPyList(&I->Obj));
+  PyList_SetItem(result, 0, ObjectAsPyList(I));
   PyList_SetItem(result, 1, PyInt_FromLong(I->NState));
   PyList_SetItem(result, 2, ObjectMapAllStatesAsPyList(I));
 
@@ -1580,8 +1581,10 @@ int ObjectMapNewFromPyList(PyMOLGlobals
   if(ok)
     ok = (I != NULL);
 
-  if(ok)
-    ok = ObjectFromPyList(G, PyList_GetItem(list, 0), &I->Obj);
+  if(ok){
+    auto *val = PyList_GetItem(list, 0);
+    ok = ObjectFromPyList(G, val, I);
+  }  
   if(ok)
     ok = PConvPyIntToInt(PyList_GetItem(list, 1), &I->NState);
   if(ok)
@@ -1605,7 +1608,7 @@ int ObjectMapNewCopy(PyMOLGlobals * G, c
   if(ok)
     ok = (I != NULL);
   if(ok)
-    ok = ObjectCopyHeader(&I->Obj, &src->Obj);
+    ok = ObjectCopyHeader(I, src);
   if(ok) {
     if(source_state == -1) {    /* all states */
       int state;
@@ -1637,7 +1640,7 @@ int ObjectMapNewCopy(PyMOLGlobals * G, c
 
 ObjectMapState *ObjectMapGetState(ObjectMap * I, int state)
 {
-  for(StateIterator iter(I->Obj.G, I->Obj.Setting, state, I->NState); iter.next();) {
+  for(StateIterator iter(I->G, I->Setting, state, I->NState); iter.next();) {
     return I->State + iter.state;
   }
   return NULL;
@@ -1653,7 +1656,7 @@ ObjectMapState *ObjectMapStatePrime(Obje
     I->NState = state + 1;
   }
   ms = &I->State[state];
-  ObjectMapStateInit(I->Obj.G, ms);
+  ObjectMapStateInit(I->G, ms);
   return (ms);
 }
 
@@ -1675,7 +1678,7 @@ void ObjectMapUpdateExtents(ObjectMap *
   int a;
   float *min_ext, *max_ext;
   float tr_min[3], tr_max[3];
-  I->Obj.ExtentFlag = false;
+  I->ExtentFlag = false;
 
   for(a = 0; a < I->NState; a++) {
     ObjectMapState *ms = I->State + a;
@@ -1700,30 +1703,30 @@ void ObjectMapUpdateExtents(ObjectMap *
         max_ext = ms->ExtentMax;
       }
 
-      if(!I->Obj.ExtentFlag) {
-        copy3f(min_ext, I->Obj.ExtentMin);
-        copy3f(max_ext, I->Obj.ExtentMax);
-        I->Obj.ExtentFlag = true;
+      if(!I->ExtentFlag) {
+        copy3f(min_ext, I->ExtentMin);
+        copy3f(max_ext, I->ExtentMax);
+        I->ExtentFlag = true;
       } else {
-        min3f(min_ext, I->Obj.ExtentMin, I->Obj.ExtentMin);
-        max3f(max_ext, I->Obj.ExtentMax, I->Obj.ExtentMax);
+        min3f(min_ext, I->ExtentMin, I->ExtentMin);
+        max3f(max_ext, I->ExtentMax, I->ExtentMax);
       }
     }
   }
 
-  if(I->Obj.TTTFlag && I->Obj.ExtentFlag) {
+  if(I->TTTFlag && I->ExtentFlag) {
     const float *ttt;
     double tttd[16];
-    if(ObjectGetTTT(&I->Obj, &ttt, -1)) {
+    if(ObjectGetTTT(I, &ttt, -1)) {
       convertTTTfR44d(ttt, tttd);
       MatrixTransformExtentsR44d3f(tttd,
-                                   I->Obj.ExtentMin, I->Obj.ExtentMax,
-                                   I->Obj.ExtentMin, I->Obj.ExtentMax);
+                                   I->ExtentMin, I->ExtentMax,
+                                   I->ExtentMin, I->ExtentMax);
     }
   }
 
-  PRINTFD(I->Obj.G, FB_ObjectMap)
-    " ObjectMapUpdateExtents-DEBUG: ExtentFlag %d\n", I->Obj.ExtentFlag ENDFD;
+  PRINTFD(I->G, FB_ObjectMap)
+    " ObjectMapUpdateExtents-DEBUG: ExtentFlag %d\n", I->ExtentFlag ENDFD;
 }
 
 void ObjectMapStateClamp(ObjectMapState * I, float clamp_floor, float clamp_ceiling)
@@ -1797,26 +1800,26 @@ static void ObjectMapFree(ObjectMap * I)
   int a;
   for(a = 0; a < I->NState; a++) {
     if(I->State[a].Active)
-      ObjectMapStatePurge(I->Obj.G, I->State + a);
+      ObjectMapStatePurge(I->G, I->State + a);
   }
   VLAFreeP(I->State);
-  ObjectPurge(&I->Obj);
+  ObjectPurge(I);
   OOFreeP(I);
 }
 
 static void ObjectMapUpdate(ObjectMap * I)
 {
-  if(!I->Obj.ExtentFlag) {
+  if(!I->ExtentFlag) {
     ObjectMapUpdateExtents(I);
-    if(I->Obj.ExtentFlag)
-      SceneInvalidate(I->Obj.G);
+    if(I->ExtentFlag)
+      SceneInvalidate(I->G);
   }
 }
 
 static void ObjectMapInvalidate(ObjectMap * I, int rep, int level, int state)
 {
   if(level >= cRepInvExtents) {
-    I->Obj.ExtentFlag = false;
+    I->ExtentFlag = false;
   }
   if((rep < 0) || (rep == cRepDot)) {
     int a;
@@ -1826,7 +1829,7 @@ static void ObjectMapInvalidate(ObjectMa
       CGOFree(I->State[a].shaderCGO);
     }
   }
-  SceneInvalidate(I->Obj.G);
+  SceneInvalidate(I->G);
 }
 
 /* Has no prototype */
@@ -1899,7 +1902,7 @@ static CGO* ObjectMapCGOGenerate(PyMOLGl
 
 static void ObjectMapRender(ObjectMap * I, RenderInfo * info)
 {
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   int state = info->state;
   CRay *ray = info->ray;
   auto pick = info->pick;
@@ -1909,7 +1912,7 @@ static void ObjectMapRender(ObjectMap *
   if(pass)
     return;
 
-  for(StateIterator iter(G, I->Obj.Setting, state, I->NState);
+  for(StateIterator iter(G, I->Setting, state, I->NState);
       iter.next();) {
     state = iter.state;
     if(I->State[state].Active)
@@ -1918,7 +1921,7 @@ static void ObjectMapRender(ObjectMap *
     if(ms) {
       float *corner = ms->Corner;
       float tr_corner[24];
-      ObjectPrepareContext(&I->Obj, info);
+      ObjectPrepareContext(I, info);
 
       if(ms->State.Matrix) {    /* transform the corners before drawing */
         int a;
@@ -1928,11 +1931,11 @@ static void ObjectMapRender(ObjectMap *
         corner = tr_corner;
       }
 
-      if((I->Obj.visRep & cRepExtentBit)) {
+      if((I->visRep & cRepExtentBit)) {
         if(ray) {
           const float *vc;
           float radius = ray->PixelRadius / 1.4142F;
-          vc = ColorGet(G, I->Obj.Color);
+          vc = ColorGet(G, I->Color);
           ray->color3fv(vc);
           ray->sausage3fv(corner + 3 * 0, corner + 3 * 1, radius, vc, vc);
           ray->sausage3fv(corner + 3 * 0, corner + 3 * 2, radius, vc, vc);
@@ -1951,7 +1954,7 @@ static void ObjectMapRender(ObjectMap *
 #ifndef PURE_OPENGL_ES_2
           } else if (!info->use_shaders) {
             // immediate
-            ObjectUseColor(&I->Obj);
+            ObjectUseColor(I);
             glDisable(GL_LIGHTING);
             glBegin(GL_LINES);
             glVertex3fv(corner + 3 * 0);
@@ -2004,7 +2007,7 @@ static void ObjectMapRender(ObjectMap *
               if (shaderPrg) {
                 shaderPrg->SetLightingEnabled(0);
 
-                CGORenderGL(ms->shaderCGO, ColorGet(G, I->Obj.Color),
+                CGORenderGL(ms->shaderCGO, ColorGet(G, I->Color),
                     NULL, NULL, info, NULL);
                 shaderPrg->Disable();
               }
@@ -2013,7 +2016,7 @@ static void ObjectMapRender(ObjectMap *
         }
       }
 
-      if((I->Obj.visRep & cRepDotBit)) {
+      if((I->visRep & cRepDotBit)) {
         if(!ms->have_range) {
           double sum = 0.0, sumsq = 0.0;
           CField *data = ms->Field->data;
@@ -2034,7 +2037,7 @@ static void ObjectMapRender(ObjectMap *
             ms->have_range = true;
           }
         }
-        if(ms->have_range && SettingGet_b(G, NULL, I->Obj.Setting, cSetting_dot_normals)) {
+        if(ms->have_range && SettingGet_b(G, NULL, I->Setting, cSetting_dot_normals)) {
           IsofieldComputeGradients(G, ms->Field);
         }
         if(ms->have_range) {
@@ -2044,7 +2047,7 @@ static void ObjectMapRender(ObjectMap *
           CField *points = ms->Field->points;
           CField *gradients = NULL;
 
-          if(SettingGet_b(G, NULL, I->Obj.Setting, cSetting_dot_normals)) {
+          if(SettingGet_b(G, NULL, I->Setting, cSetting_dot_normals)) {
             gradients = ms->Field->gradients;
           }
           if(data && points) {
@@ -2062,16 +2065,16 @@ static void ObjectMapRender(ObjectMap *
             float *raw_gradient = NULL;
             float high_cut = ms->high_cutoff, low_cut = ms->low_cutoff;
             float width =
-              SettingGet_f(G, NULL, I->Obj.Setting, cSetting_dot_width);
+              SettingGet_f(G, NULL, I->Setting, cSetting_dot_width);
 
             if(ray) {
               float radius = ray->PixelRadius * width / 1.4142F;
               float vc[3];
-              int color = I->Obj.Color;
-              int ramped = ColorCheckRamped(G, I->Obj.Color);
+              int color = I->Color;
+              int ramped = ColorCheckRamped(G, I->Color);
 
               {
-                const float *tmp = ColorGet(G, I->Obj.Color);
+                const float *tmp = ColorGet(G, I->Color);
                 copy3f(tmp, vc);
               }
 
@@ -2095,15 +2098,15 @@ static void ObjectMapRender(ObjectMap *
                   glDisable(GL_LIGHTING);
                 }
                 {
-                  int ramped = ColorCheckRamped(G, I->Obj.Color);
+                  int ramped = ColorCheckRamped(G, I->Color);
                   float vc[3];
-                  int color = I->Obj.Color;
+                  int color = I->Color;
                   float gt[3];
 
                   glPointSize(width);
                   glDisable(GL_POINT_SMOOTH);
                   glBegin(GL_POINTS);
-                  ObjectUseColor(&I->Obj);
+                  ObjectUseColor(I);
                   for(a = 0; a < cnt; a++) {
                     float f_val = *(raw_data++);
                     RAW_POINT_TRANSFORM(raw_point_ptr, raw_point);
@@ -2170,17 +2173,17 @@ ObjectMap *ObjectMapNew(PyMOLGlobals * G
   OOAlloc(G, ObjectMap);
 
   ObjectInit(G, (CObject *) I);
-  I->Obj.type = cObjectMap;
+  I->type = cObjectMap;
 
   I->NState = 0;
   I->State = VLACalloc(ObjectMapState, 1);     /* autozero important */
 
-  I->Obj.visRep = cRepExtentBit;
-  I->Obj.fFree = (void (*)(CObject *)) ObjectMapFree;
-  I->Obj.fUpdate = (void (*)(CObject *)) ObjectMapUpdate;
-  I->Obj.fRender = (void (*)(CObject *, RenderInfo *)) ObjectMapRender;
-  I->Obj.fInvalidate = (void (*)(CObject *, int, int, int)) ObjectMapInvalidate;
-  I->Obj.fGetNFrame = (int (*)(CObject *)) ObjectMapGetNStates;
+  I->visRep = cRepExtentBit;
+  I->fFree = (void (*)(CObject *)) ObjectMapFree;
+  I->fUpdate = (void (*)(CObject *)) ObjectMapUpdate;
+  I->fRender = (void (*)(CObject *, RenderInfo *)) ObjectMapRender;
+  I->fInvalidate = (void (*)(CObject *, int, int, int)) ObjectMapInvalidate;
+  I->fGetNFrame = (int (*)(CObject *)) ObjectMapGetNStates;
 
   return (I);
 }
@@ -2202,9 +2205,9 @@ ObjectMapState *ObjectMapNewStateFromDes
   *(md) = *(inp_md);
 
   if(I) {
-    ms->Origin = Alloc(float, 3);
-    ms->Range = Alloc(float, 3);
-    ms->Grid = Alloc(float, 3);
+    ms->Origin = pymol::malloc<float>(3);
+    ms->Range = pymol::malloc<float>(3);
+    ms->Grid = pymol::malloc<float>(3);
     ms->MapSource = cMapSourceDesc;
   }
   switch (md->mode) {
@@ -2224,16 +2227,16 @@ ObjectMapState *ObjectMapNewStateFromDes
         md->Dim[a]++;
     }
 
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Blather)
+    PRINTFB(I->G, FB_ObjectMap, FB_Blather)
       " ObjectMap: Dim %d %d %d\n", md->Dim[0], md->Dim[1], md->Dim[2]
-      ENDFB(I->Obj.G);
+      ENDFB(I->G);
 
     average3f(md->MaxCorner, md->MinCorner, v);
     for(a = 0; a < 3; a++) {
       md->MinCorner[a] = v[a] - 0.5F * md->Dim[a] * md->Grid[a];
     }
 
-    if(Feedback(I->Obj.G, FB_ObjectMap, FB_Blather)) {
+    if(Feedback(I->G, FB_ObjectMap, FB_Blather)) {
       dump3f(md->MinCorner, " ObjectMap: MinCorner:");
       dump3f(md->MaxCorner, " ObjectMap: MaxCorner:");
       dump3f(md->Grid, " ObjectMap: Grid:");
@@ -2276,7 +2279,7 @@ ObjectMapState *ObjectMapNewStateFromDes
       ms->FDim[a] = ms->Max[a] - ms->Min[a] + 1;
     ms->FDim[3] = 3;
 
-    ms->Field = IsosurfFieldAlloc(I->Obj.G, ms->FDim);
+    ms->Field = IsosurfFieldAlloc(I->G, ms->FDim);
     if(!ms->Field)
       ok = false;
     else {
@@ -2335,13 +2338,13 @@ ObjectMapState *ObjectMapNewStateFromDes
     ObjectMapUpdateExtents(I);
   }
   if(!ok) {
-    ErrMessage(I->Obj.G, "ObjectMap", "Unable to create map");
+    ErrMessage(I->G, "ObjectMap", "Unable to create map");
     ObjectMapFree(I);
     I = NULL;
   } else {
     if(!quiet) {
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Actions)
-        " ObjectMap: Map created.\n" ENDFB(I->Obj.G);
+      PRINTFB(I->G, FB_ObjectMap, FB_Actions)
+        " ObjectMap: Map created.\n" ENDFB(I->G);
     }
   }
 
@@ -2408,8 +2411,8 @@ static int ObjectMapCCP4StrToMap(ObjectM
   int expectation;
 
   if(bytes < 256 * sizeof(int)) {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Errors)
-      " ObjectMapCCP4: Map appears to be truncated -- aborting." ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Errors)
+      " ObjectMapCCP4: Map appears to be truncated -- aborting." ENDFB(I->G);
     return (0);
   }
 
@@ -2422,9 +2425,9 @@ static int ObjectMapCCP4StrToMap(ObjectM
     I->NState = state + 1;
   }
   ms = &I->State[state];
-  ObjectMapStateInit(I->Obj.G, ms);
+  ObjectMapStateInit(I->G, ms);
 
-  normalize = SettingGetGlobal_b(I->Obj.G, cSetting_normalize_ccp4_maps);
+  normalize = SettingGetGlobal_b(I->G, cSetting_normalize_ccp4_maps);
 
   p = CCP4Str;
   little_endian = *((char *) &little_endian);
@@ -2432,8 +2435,8 @@ static int ObjectMapCCP4StrToMap(ObjectM
 
   if(little_endian != map_endian) {
     if(!quiet) {
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Blather)
-        " ObjectMapCCP4: Map appears to be reverse endian, swapping...\n" ENDFB(I->Obj.G);
+      PRINTFB(I->G, FB_ObjectMap, FB_Blather)
+        " ObjectMapCCP4: Map appears to be reverse endian, swapping...\n" ENDFB(I->G);
     }
     swap_endian(p, 256, sizeof(int));
   }
@@ -2443,8 +2446,8 @@ static int ObjectMapCCP4StrToMap(ObjectM
   nr = *(i++);                  /* rows */
   ns = *(i++);                  /* sections */
   if(!quiet) {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Blather)
-      " ObjectMapCCP4: NC %d   NR %d   NS %d\n", nc, nr, ns ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Blather)
+      " ObjectMapCCP4: NC %d   NR %d   NS %d\n", nc, nr, ns ENDFB(I->G);
   }
   map_mode = *(i++);            /* mode */
 
@@ -2459,24 +2462,24 @@ static int ObjectMapCCP4StrToMap(ObjectM
     bytes_per_pt = 4; // float
     break;
   default:
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Errors)
+    PRINTFB(I->G, FB_ObjectMap, FB_Errors)
       "ObjectMapCCP4-ERR: Only map mode 0-2 currently supported (this map is mode %d)",
-      map_mode ENDFB(I->Obj.G);
+      map_mode ENDFB(I->G);
     return (0);
   }
 
   if(!quiet) {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Blather)
-      " ObjectMapCCP4: Map is mode %d.\n", map_mode ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Blather)
+      " ObjectMapCCP4: Map is mode %d.\n", map_mode ENDFB(I->G);
   }
   ncstart = *(i++);
   nrstart = *(i++);
   nsstart = *(i++);
 
   if(!quiet) {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Blather)
+    PRINTFB(I->G, FB_ObjectMap, FB_Blather)
       " ObjectMapCCP4: NCSTART %d   NRSTART %d   NSSTART  %d\n",
-      ncstart, nrstart, nsstart ENDFB(I->Obj.G);
+      ncstart, nrstart, nsstart ENDFB(I->G);
   }
 
   nx = *(i++);
@@ -2484,8 +2487,8 @@ static int ObjectMapCCP4StrToMap(ObjectM
   nz = *(i++);
 
   if(!quiet) {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Blather)
-      " ObjectMapCCP4: NX %d   NY %d   NZ  %d \n", nx, ny, nz ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Blather)
+      " ObjectMapCCP4: NX %d   NY %d   NZ  %d \n", nx, ny, nz ENDFB(I->G);
   }
 
   xlen = *(float *) (i++);
@@ -2493,8 +2496,8 @@ static int ObjectMapCCP4StrToMap(ObjectM
   zlen = *(float *) (i++);
 
   if(!quiet) {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Blather)
-      " ObjectMapCCP4: X %8.3f   Y %8.3f  Z  %8.3f \n", xlen, ylen, zlen ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Blather)
+      " ObjectMapCCP4: X %8.3f   Y %8.3f  Z  %8.3f \n", xlen, ylen, zlen ENDFB(I->G);
   }
 
   alpha = *(float *) (i++);
@@ -2502,9 +2505,9 @@ static int ObjectMapCCP4StrToMap(ObjectM
   gamma = *(float *) (i++);
 
   if(!quiet) {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Blather)
+    PRINTFB(I->G, FB_ObjectMap, FB_Blather)
       " ObjectMapCCP4: alpha %8.3f   beta %8.3f  gamma %8.3f \n",
-      alpha, beta, gamma ENDFB(I->Obj.G);
+      alpha, beta, gamma ENDFB(I->G);
   }
 
   mapc = *(i++);
@@ -2512,8 +2515,8 @@ static int ObjectMapCCP4StrToMap(ObjectM
   maps = *(i++);
 
   if(!quiet) {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Blather)
-      " ObjectMapCCP4: MAPC %d   MAPR %d  MAPS  %d \n", mapc, mapr, maps ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Blather)
+      " ObjectMapCCP4: MAPC %d   MAPR %d  MAPS  %d \n", mapc, mapr, maps ENDFB(I->G);
   }
 
   // AMIN, AMAX, AMEAN
@@ -2551,9 +2554,9 @@ static int ObjectMapCCP4StrToMap(ObjectM
       // Xo(map) = S * (Xo(atoms) - t)
       ObjectStateSetMatrix(&ms->State, matrix);
 
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
+      PRINTFB(I->G, FB_ObjectMap, FB_Details)
         " ObjectMapCCP4: Applied skew transformation\n"
-        ENDFB(I->Obj.G);
+        ENDFB(I->G);
     }
   }
 
@@ -2570,10 +2573,10 @@ static int ObjectMapCCP4StrToMap(ObjectM
     ObjectStateSetMatrix(&ms->State, matrix);
 
     if (!quiet) {
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
+      PRINTFB(I->G, FB_ObjectMap, FB_Details)
         " ObjectMapCCP4: Applied MRC 2000 ORIGIN %.2f %.2f %.2f\n",
         mrc2000origin[0], mrc2000origin[1], mrc2000origin[2]
-          ENDFB(I->Obj.G);
+          ENDFB(I->G);
     }
   }
 
@@ -2581,8 +2584,8 @@ static int ObjectMapCCP4StrToMap(ObjectM
   stdev = *(float *) (i++);
 
   if(!quiet) {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Blather)
-      " ObjectMapCCP4: AMIN %f AMAX %f AMEAN %f ARMS %f\n", mind, maxd, mean, stdev ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Blather)
+      " ObjectMapCCP4: AMIN %f AMAX %f AMEAN %f ARMS %f\n", mind, maxd, mean, stdev ENDFB(I->G);
   }
 
   n_pts = nc * ns * nr;
@@ -2593,35 +2596,35 @@ static int ObjectMapCCP4StrToMap(ObjectM
     nz = nx;
 
     if(!quiet) {
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Warnings)
+      PRINTFB(I->G, FB_ObjectMap, FB_Warnings)
         " ObjectMapCCP4: NZ value is zero, but NX = NY, so we'll guess NZ = NX = NY.\n"
-        ENDFB(I->Obj.G);
+        ENDFB(I->G);
     }
   }
 
   expectation = sym_skip + sizeof(int) * 256 + bytes_per_pt * n_pts;
 
   if(!quiet) {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Blather)
+    PRINTFB(I->G, FB_ObjectMap, FB_Blather)
       " ObjectMapCCP4: sym_skip %d bytes %d expectation %d\n",
-      sym_skip, bytes, expectation ENDFB(I->Obj.G);
+      sym_skip, bytes, expectation ENDFB(I->G);
   }
 
   if(bytes < expectation) {
     if(bytes == (expectation - sym_skip)) {
       /* accomodate bogus CCP4 map files with bad symmetry length information */
       if(!quiet) {
-        PRINTFB(I->Obj.G, FB_ObjectMap, FB_Blather)
+        PRINTFB(I->G, FB_ObjectMap, FB_Blather)
           " ObjectMapCCP4: Map has invalid symmetry length -- working around.\n"
-          ENDFB(I->Obj.G);
+          ENDFB(I->G);
       }
 
       expectation -= sym_skip;
       sym_skip = 0;
 
     } else {
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Errors)
-        " ObjectMapCCP4: Map appears to be truncated -- aborting.\n" ENDFB(I->Obj.G);
+      PRINTFB(I->G, FB_ObjectMap, FB_Errors)
+        " ObjectMapCCP4: Map appears to be truncated -- aborting.\n" ENDFB(I->G);
       return (0);
     }
   }
@@ -2670,7 +2673,7 @@ static int ObjectMapCCP4StrToMap(ObjectM
   ms->Max[maps] = ns + nsstart - 1;
 
   if(!quiet) {
-    if(Feedback(I->Obj.G, FB_ObjectMap, FB_Blather)) {
+    if(Feedback(I->G, FB_ObjectMap, FB_Blather)) {
       dump3i(ms->Div, " ObjectMapCCP4: ms->Div");
       dump3i(ms->Min, " ObjectMapCCP4: ms->Min");
       dump3i(ms->Max, " ObjectMapCCP4: ms->Max");
@@ -2703,7 +2706,7 @@ static int ObjectMapCCP4StrToMap(ObjectM
   else {
     SymmetryUpdate(ms->Symmetry);
     /*    CrystalDump(ms->Crystal); */
-    ms->Field = IsosurfFieldAlloc(I->Obj.G, ms->FDim);
+    ms->Field = IsosurfFieldAlloc(I->G, ms->FDim);
     ms->MapSource = cMapSourceCCP4;
     ms->Field->save_points = false;
 
@@ -2752,22 +2755,22 @@ static int ObjectMapCCP4StrToMap(ObjectM
   }
 
   if(!quiet) {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
+    PRINTFB(I->G, FB_ObjectMap, FB_Details)
       " ObjectMapCCP4: Map Size %d x %d x %d\n", ms->FDim[0], ms->FDim[1], ms->FDim[2]
-      ENDFB(I->Obj.G);
+      ENDFB(I->G);
   }
 
   if(!quiet) {
     if(n_pts > 1) {
       if(normalize) {
-        PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
+        PRINTFB(I->G, FB_ObjectMap, FB_Details)
           " ObjectMapCCP4: Normalizing with mean = %8.6f and stdev = %8.6f.\n",
-          mean, stdev ENDFB(I->Obj.G);
+          mean, stdev ENDFB(I->G);
       } else {
 
-        PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
+        PRINTFB(I->G, FB_ObjectMap, FB_Details)
           " ObjectMapCCP4: Map will not be normalized.\n ObjectMapCCP4: Current mean = %8.6f and stdev = %8.6f.\n",
-          mean, stdev ENDFB(I->Obj.G);
+          mean, stdev ENDFB(I->G);
       }
     }
   }
@@ -2795,13 +2798,13 @@ static int ObjectMapCCP4StrToMap(ObjectM
   fflush(stdout);
 #endif
   if(!ok) {
-    ErrMessage(I->Obj.G, "ObjectMap", "Error reading map");
+    ErrMessage(I->G, "ObjectMap", "Error reading map");
   } else {
     ms->Active = true;
     ObjectMapUpdateExtents(I);
     if(!quiet) {
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Results)
-        " ObjectMap: Map read.  Range: %5.3f to %5.3f\n", mind, maxd ENDFB(I->Obj.G);
+      PRINTFB(I->G, FB_ObjectMap, FB_Results)
+        " ObjectMap: Map read.  Range: %5.3f to %5.3f\n", mind, maxd ENDFB(I->G);
     }
   }
 
@@ -2899,6 +2902,10 @@ std::vector<char> ObjectMapStateToCCP4St
 
   buffer_i[23] = 0; // NSYMBT
 
+  float* b_skwmat = buffer_f + 25;
+  float* b_skwtrn = buffer_f + 34;
+  float* b_origin = buffer_f + 49;
+
   // skew transformation
   if (ms->State.Matrix) {
     double m[16];
@@ -2912,17 +2919,21 @@ std::vector<char> ObjectMapStateToCCP4St
     xx_matrix_invert(m, m, 4);
     copy44d33f(m, buffer_f + 25);               // SKWMAT
 
-    buffer_i[24] = 1;                           // LSKFLG
+    if (is_identityf(3, b_skwmat)) {
+      // translation only -> use origin instead of skew matrix
+      copy3(b_skwtrn, b_origin);                // MRC ORIGIN
+      zero3(b_skwtrn);
+    } else {
+      buffer_i[24] = 1;                         // LSKFLG
+    }
   }
 
   // origin (stored with skew transformation)
   if (ms->Origin && lengthsq3f(ms->Origin) > R_SMALL4) {
-    auto skwtrn = buffer_f + 34;
-    add3f(ms->Origin, skwtrn, skwtrn);          // add to SKWTRN
-
-    if (!buffer_i[24]) {
-      identity33f(buffer_f + 25);               // SKWMAT (identity)
-      buffer_i[24] = 1;                         // LSKFLG
+    if (buffer_i[24] /* LSKFLG */) {
+      add3f(ms->Origin, b_skwtrn, b_skwtrn);    // add to SKWTRN
+    } else {
+      add3f(ms->Origin, b_origin, b_origin);    // add to MRC ORIGIN
     }
   }
 
@@ -2977,7 +2988,7 @@ static int ObjectMapPHIStrToMap(ObjectMa
     I->NState = state + 1;
   }
   ms = &I->State[state];
-  ObjectMapStateInit(I->Obj.G, ms);
+  ObjectMapStateInit(I->G, ms);
 
   maxd = -FLT_MAX;
   mind = FLT_MAX;
@@ -2992,8 +3003,8 @@ static int ObjectMapPHIStrToMap(ObjectMa
 
   ParseNCopy(cc, p, 20);
   if(!quiet) {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
-      " PHIStrToMap: %s\n", cc ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Details)
+      " PHIStrToMap: %s\n", cc ENDFB(I->G);
   }
   p += 20;
   p += 4;
@@ -3001,14 +3012,14 @@ static int ObjectMapPHIStrToMap(ObjectMa
   p += 4;
   ParseNCopy(cc, p, 10);
   if(!quiet) {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
-      " PHIStrToMap: %s\n", cc ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Details)
+      " PHIStrToMap: %s\n", cc ENDFB(I->G);
   }
   p += 10;
   ParseNCopy(cc, p, 60);
   if(!quiet) {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
-      " PHIStrToMap: %s\n", cc ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Details)
+      " PHIStrToMap: %s\n", cc ENDFB(I->G);
   }
   p += 60;
   p += 4;
@@ -3035,8 +3046,8 @@ static int ObjectMapPHIStrToMap(ObjectMa
     map_dim = 65;
 
   if(!quiet) {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
-      " PHIStrToMap: Map Size %d x %d x %d\n", map_dim, map_dim, map_dim ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Details)
+      " PHIStrToMap: Map Size %d x %d x %d\n", map_dim, map_dim, map_dim ENDFB(I->G);
   }
   p += 4;
 
@@ -3055,7 +3066,7 @@ static int ObjectMapPHIStrToMap(ObjectMa
   ms->Max[1] = ms->Div[1];
   ms->Max[2] = ms->Div[2];
 
-  ms->Field = IsosurfFieldAlloc(I->Obj.G, ms->FDim);
+  ms->Field = IsosurfFieldAlloc(I->G, ms->FDim);
   ms->MapSource = cMapSourceGeneralPurpose;
   ms->Field->save_points = false;
 
@@ -3089,13 +3100,13 @@ static int ObjectMapPHIStrToMap(ObjectMa
   p += 4;
   ParseNCopy(cc, p, 16);
   if(!quiet) {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
-      " PHIStrToMap: %s\n", cc ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Details)
+      " PHIStrToMap: %s\n", cc ENDFB(I->G);
   }
   p += 16;
   p += 4;
 
-  ms->Grid = Alloc(float, 3);
+  ms->Grid = pymol::malloc<float>(3);
   p += 4;
   if(little_endian != map_endian) {
     rev[0] = p[3];
@@ -3113,7 +3124,7 @@ static int ObjectMapPHIStrToMap(ObjectMa
   ms->Grid[2] = ms->Grid[0];
   p += 4;
 
-  ms->Origin = Alloc(float, 3);
+  ms->Origin = pymol::malloc<float>(3);
   if(little_endian != map_endian) {
     rev[0] = p[3];
     rev[1] = p[2];
@@ -3221,13 +3232,13 @@ static int ObjectMapPHIStrToMap(ObjectMa
    */
 
   if(!ok) {
-    ErrMessage(I->Obj.G, "ObjectMap", "Error reading map");
+    ErrMessage(I->G, "ObjectMap", "Error reading map");
   } else {
     ms->Active = true;
     ObjectMapUpdateExtents(I);
     if(!quiet) {
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Results)
-        " ObjectMap: Map read.  Range: %5.3f to %5.3f\n", mind, maxd ENDFB(I->Obj.G);
+      PRINTFB(I->G, FB_ObjectMap, FB_Results)
+        " ObjectMap: Map read.  Range: %5.3f to %5.3f\n", mind, maxd ENDFB(I->G);
     }
   }
   return (ok);
@@ -3254,7 +3265,7 @@ static int ObjectMapXPLORStrToMap(Object
   }
 
   ms = &I->State[state];
-  ObjectMapStateInit(I->Obj.G, ms);
+  ObjectMapStateInit(I->G, ms);
 
   maxd = -FLT_MAX;
   mind = FLT_MAX;
@@ -3341,7 +3352,7 @@ static int ObjectMapXPLORStrToMap(Object
       ok = false;
     else {
       SymmetryUpdate(ms->Symmetry);
-      ms->Field = IsosurfFieldAlloc(I->Obj.G, ms->FDim);
+      ms->Field = IsosurfFieldAlloc(I->G, ms->FDim);
       ms->MapSource = cMapSourceCrystallographic;
       ms->Field->save_points = false;
       for(c = 0; c < ms->FDim[2]; c++) {
@@ -3415,13 +3426,13 @@ static int ObjectMapXPLORStrToMap(Object
   fflush(stdout);
 #endif
   if(!ok) {
-    ErrMessage(I->Obj.G, "ObjectMap", "Error reading map");
+    ErrMessage(I->G, "ObjectMap", "Error reading map");
   } else {
     ms->Active = true;
     ObjectMapUpdateExtents(I);
     if(!quiet) {
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Results)
-        " ObjectMap: Map read.  Range = %5.3f to %5.3f\n", mind, maxd ENDFB(I->Obj.G);
+      PRINTFB(I->G, FB_ObjectMap, FB_Results)
+        " ObjectMap: Map read.  Range = %5.3f to %5.3f\n", mind, maxd ENDFB(I->G);
     }
   }
 
@@ -3468,7 +3479,7 @@ static int ObjectMapFLDStrToMap(ObjectMa
     I->NState = state + 1;
   }
   ms = &I->State[state];
-  ObjectMapStateInit(I->Obj.G, ms);
+  ObjectMapStateInit(I->G, ms);
 
   maxd = -FLT_MAX;
   mind = FLT_MAX;
@@ -3606,17 +3617,17 @@ static int ObjectMapFLDStrToMap(ObjectMa
 
     int pass = 0;
 
-    ms->Origin = Alloc(float, 3);
-    ms->Range = Alloc(float, 3);
-    ms->Grid = Alloc(float, 3);
+    ms->Origin = pymol::malloc<float>(3);
+    ms->Range = pymol::malloc<float>(3);
+    ms->Grid = pymol::malloc<float>(3);
 
     copy3f(ms->ExtentMin, ms->Origin);
     subtract3f(ms->ExtentMax, ms->ExtentMin, ms->Range);
     ms->FDim[3] = 3;
 
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
+    PRINTFB(I->G, FB_ObjectMap, FB_Details)
       " FLDStrToMap: Map Size %d x %d x %d\n", ms->FDim[0], ms->FDim[1], ms->FDim[2]
-      ENDFB(I->Obj.G);
+      ENDFB(I->G);
 
     for(a = 0; a < 3; a++) {
       ms->Min[a] = 0;
@@ -3629,7 +3640,7 @@ static int ObjectMapFLDStrToMap(ObjectMa
         ms->Grid[a] = 0.0F;
     }
 
-    ms->Field = IsosurfFieldAlloc(I->Obj.G, ms->FDim);
+    ms->Field = IsosurfFieldAlloc(I->G, ms->FDim);
     ms->MapSource = cMapSourceFLD;
     ms->Field->save_points = false;
 
@@ -3739,12 +3750,12 @@ static int ObjectMapFLDStrToMap(ObjectMa
     ms->Active = true;
     ObjectMapUpdateExtents(I);
     if(!quiet) {
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Results)
-        " ObjectMap: Map read.  Range: %5.3f to %5.3f\n", mind, maxd ENDFB(I->Obj.G);
+      PRINTFB(I->G, FB_ObjectMap, FB_Results)
+        " ObjectMap: Map read.  Range: %5.3f to %5.3f\n", mind, maxd ENDFB(I->G);
     }
   } else {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Errors)
-      " Error: unable to read FLD file.\n" ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Errors)
+      " Error: unable to read FLD file.\n" ENDFB(I->G);
     /*  printf(" got_ndim %d\n",got_ndim);
        printf(" got_dim1 %d\n",got_dim1);
        printf(" got_dim2 %d\n",got_dim2);
@@ -3790,8 +3801,8 @@ static int ObjectMapBRIXStrToMap(ObjectM
   int normalize;
   int swap_bytes;
 
-  normalize = SettingGetGlobal_b(I->Obj.G, cSetting_normalize_o_maps);
-  swap_bytes = SettingGetGlobal_b(I->Obj.G, cSetting_swap_dsn6_bytes);
+  normalize = SettingGetGlobal_b(I->G, cSetting_normalize_o_maps);
+  swap_bytes = SettingGetGlobal_b(I->G, cSetting_swap_dsn6_bytes);
   if(state < 0)
     state = I->NState;
   if(I->NState <= state) {
@@ -3799,7 +3810,7 @@ static int ObjectMapBRIXStrToMap(ObjectM
     I->NState = state + 1;
   }
   ms = &I->State[state];
-  ObjectMapStateInit(I->Obj.G, ms);
+  ObjectMapStateInit(I->G, ms);
 
   maxd = -FLT_MAX;
   mind = FLT_MAX;
@@ -3819,7 +3830,7 @@ static int ObjectMapBRIXStrToMap(ObjectM
 
       if(!got_origin) {
         pp = ParseWordCopy(cc, p, 6);
-        if(WordMatch(I->Obj.G, "origin", cc, true) < 0) {
+        if(WordMatch(I->G, "origin", cc, true) < 0) {
           p = ParseWordCopy(cc, pp, 50);
           if(sscanf(cc, "%d", &ms->Min[0]) == 1) {
             p = ParseWordCopy(cc, p, 50);
@@ -3835,7 +3846,7 @@ static int ObjectMapBRIXStrToMap(ObjectM
 
       if(!got_extent) {
         pp = ParseWordCopy(cc, p, 6);
-        if(WordMatch(I->Obj.G, "extent", cc, true) < 0) {
+        if(WordMatch(I->G, "extent", cc, true) < 0) {
           p = ParseWordCopy(cc, pp, 50);
           if(sscanf(cc, "%d", &ms->Max[0]) == 1) {
             p = ParseWordCopy(cc, p, 50);
@@ -3854,7 +3865,7 @@ static int ObjectMapBRIXStrToMap(ObjectM
 
       if(!got_grid) {
         pp = ParseWordCopy(cc, p, 4);
-        if(WordMatch(I->Obj.G, "grid", cc, true) < 0) {
+        if(WordMatch(I->G, "grid", cc, true) < 0) {
           p = ParseWordCopy(cc, pp, 50);
           if(sscanf(cc, "%d", &ms->Div[0]) == 1) {
             p = ParseWordCopy(cc, p, 50);
@@ -3870,7 +3881,7 @@ static int ObjectMapBRIXStrToMap(ObjectM
 
       if(!got_cell) {
         pp = ParseWordCopy(cc, p, 4);
-        if(WordMatch(I->Obj.G, "cell", cc, true) < 0) {
+        if(WordMatch(I->G, "cell", cc, true) < 0) {
           p = ParseWordCopy(cc, pp, 50);
 
           if(sscanf(cc, "%f", &ms->Symmetry->Crystal->Dim[0]) == 1) {
@@ -3896,7 +3907,7 @@ static int ObjectMapBRIXStrToMap(ObjectM
 
       if(!got_plus) {
         pp = ParseWordCopy(cc, p, 4);
-        if(WordMatch(I->Obj.G, "plus", cc, true) < 0) {
+        if(WordMatch(I->G, "plus", cc, true) < 0) {
           p = ParseWordCopy(cc, pp, 50);
           if(sscanf(cc, "%f", &plus) == 1) {
             got_plus = true;
@@ -3906,7 +3917,7 @@ static int ObjectMapBRIXStrToMap(ObjectM
 
       if(!got_prod) {
         pp = ParseWordCopy(cc, p, 4);
-        if(WordMatch(I->Obj.G, "prod", cc, true) < 0) {
+        if(WordMatch(I->G, "prod", cc, true) < 0) {
           p = ParseWordCopy(cc, pp, 50);
           if(sscanf(cc, "%f", &prod) == 1) {
             got_prod = true;
@@ -3916,7 +3927,7 @@ static int ObjectMapBRIXStrToMap(ObjectM
 
       if(!got_sigma) {
         pp = ParseWordCopy(cc, p, 5);
-        if(WordMatch(I->Obj.G, "sigma", cc, true) < 0) {
+        if(WordMatch(I->G, "sigma", cc, true) < 0) {
           p = ParseWordCopy(cc, pp, 50);
           if(sscanf(cc, "%f", &sigma) == 1) {
             got_sigma = true;
@@ -3965,9 +3976,9 @@ static int ObjectMapBRIXStrToMap(ObjectM
     }
 
     if(!passed_endian_check) {
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Errors)
+      PRINTFB(I->G, FB_ObjectMap, FB_Errors)
         " Error: This looks like a DSN6 map file, but I can't match endianness.\n"
-        ENDFB(I->Obj.G);
+        ENDFB(I->G);
     } else {
       shint_ptr = (short int *) p;
 
@@ -4014,8 +4025,8 @@ static int ObjectMapBRIXStrToMap(ObjectM
 
   if(got_origin && got_extent && got_grid && got_cell && got_plus && got_prod) {
 
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Blather)
-      " BRIXStrToMap: Prod = %8.3f, Plus = %8.3f\n", prod, plus ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Blather)
+      " BRIXStrToMap: Prod = %8.3f, Plus = %8.3f\n", prod, plus ENDFB(I->G);
 
     ms->FDim[0] = ms->Max[0] - ms->Min[0] + 1;
     ms->FDim[1] = ms->Max[1] - ms->Min[1] + 1;
@@ -4025,7 +4036,7 @@ static int ObjectMapBRIXStrToMap(ObjectM
       ok = false;
     else {
       SymmetryUpdate(ms->Symmetry);
-      ms->Field = IsosurfFieldAlloc(I->Obj.G, ms->FDim);
+      ms->Field = IsosurfFieldAlloc(I->G, ms->FDim);
       ms->MapSource = cMapSourceBRIX;
       ms->Field->save_points = false;
 
@@ -4131,25 +4142,25 @@ static int ObjectMapBRIXStrToMap(ObjectM
 
       transform33f3f(ms->Symmetry->Crystal->FracToReal, v, ms->ExtentMax);
 
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
+      PRINTFB(I->G, FB_ObjectMap, FB_Details)
         " BRIXStrToMap: Map Size %d x %d x %d\n", ms->FDim[0], ms->FDim[1], ms->FDim[2]
-        ENDFB(I->Obj.G);
+        ENDFB(I->G);
 
       if(got_sigma) {
-        PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
-          " BRIXStrToMap: Reported Sigma = %8.3f\n", sigma ENDFB(I->Obj.G);
+        PRINTFB(I->G, FB_ObjectMap, FB_Details)
+          " BRIXStrToMap: Reported Sigma = %8.3f\n", sigma ENDFB(I->G);
       }
 
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
-        " BRIXStrToMap: Range = %5.6f to %5.6f\n", mind, maxd ENDFB(I->Obj.G);
+      PRINTFB(I->G, FB_ObjectMap, FB_Details)
+        " BRIXStrToMap: Range = %5.6f to %5.6f\n", mind, maxd ENDFB(I->G);
 
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
+      PRINTFB(I->G, FB_ObjectMap, FB_Details)
         " BRIXStrToMap: Calculated Mean = %8.3f, Sigma = %8.3f\n", calc_mean, calc_sigma
-        ENDFB(I->Obj.G);
+        ENDFB(I->G);
 
       if(normalize) {
-        PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
-          " BRIXStrToMap: Normalizing...\n" ENDFB(I->Obj.G);
+        PRINTFB(I->G, FB_ObjectMap, FB_Details)
+          " BRIXStrToMap: Normalizing...\n" ENDFB(I->G);
       }
 
       ms->Active = true;
@@ -4157,8 +4168,8 @@ static int ObjectMapBRIXStrToMap(ObjectM
 
     }
   } else {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Errors)
-      " Error: unable to read BRIX/DSN6 file.\n" ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Errors)
+      " Error: unable to read BRIX/DSN6 file.\n" ENDFB(I->G);
   }
 
   return (ok);
@@ -4206,8 +4217,8 @@ static int ObjectMapGRDStrToMap(ObjectMa
     I->NState = state + 1;
   }
   ms = &I->State[state];
-  ObjectMapStateInit(I->Obj.G, ms);
-  normalize = SettingGetGlobal_b(I->Obj.G, cSetting_normalize_grd_maps);
+  ObjectMapStateInit(I->G, ms);
+  normalize = SettingGetGlobal_b(I->G, cSetting_normalize_grd_maps);
   maxd = -FLT_MAX;
   mind = FLT_MAX;
 
@@ -4282,8 +4293,8 @@ end d
 */
 
     if(!quiet) {
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Warnings)
-        " ObjectMapGRD-Warning: Binary GRD reader not yet validated.\n" ENDFB(I->Obj.G);
+      PRINTFB(I->G, FB_ObjectMap, FB_Warnings)
+        " ObjectMapGRD-Warning: Binary GRD reader not yet validated.\n" ENDFB(I->G);
     }
 
     if(little_endian != map_endian) {
@@ -4320,8 +4331,8 @@ end d
     f = (float *) p;
   }
 
-  PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
-    " ObjectMap: %s\n", cc ENDFB(I->Obj.G);
+  PRINTFB(I->G, FB_ObjectMap, FB_Details)
+    " ObjectMap: %s\n", cc ENDFB(I->G);
 
   if(ascii)
     p = ParseNextLine(p);
@@ -4339,9 +4350,9 @@ end d
       block_len_check = *((int *) (f++));
 
       if(rev_union.block_len != block_len_check) {
-        PRINTFB(I->Obj.G, FB_ObjectMap, FB_Warnings)
+        PRINTFB(I->G, FB_ObjectMap, FB_Warnings)
           " ObjectMapGRD-Warning: block length not matched -- not a true GRD binary?\n"
-          ENDFB(I->Obj.G);
+          ENDFB(I->G);
       }
 
       rev_union.block_len = *((int *) (f++));
@@ -4351,9 +4362,9 @@ end d
 
       if((ivary) || (nbyte != 4) || (intdat)) {
         if(!quiet) {
-          PRINTFB(I->Obj.G, FB_ObjectMap, FB_Warnings)
+          PRINTFB(I->G, FB_ObjectMap, FB_Warnings)
             " ObjectMapGRD-Warning: funky ivary, nbyte, intdat -- not a true GRD binary?\n"
-            ENDFB(I->Obj.G);
+            ENDFB(I->G);
         }
       }
     }
@@ -4482,9 +4493,9 @@ end d
 
       block_len_check = *((int *) (f++));
       if(rev_union.block_len != block_len_check) {
-        PRINTFB(I->Obj.G, FB_ObjectMap, FB_Warnings)
+        PRINTFB(I->G, FB_ObjectMap, FB_Warnings)
           " ObjectMapGRD-Warning: block length not matched -- not a true GRD binary?\n"
-          ENDFB(I->Obj.G);
+          ENDFB(I->G);
       }
     }
   }
@@ -4503,7 +4514,7 @@ end d
 
     ms->FDim[3] = 3;
 
-    if(Feedback(I->Obj.G, FB_ObjectMap, FB_Blather)) {
+    if(Feedback(I->G, FB_ObjectMap, FB_Blather)) {
       dump3i(ms->Div, "ms->Div");
       dump3i(ms->Min, "ms->Min");
       dump3i(ms->Max, "ms->Max");
@@ -4511,14 +4522,14 @@ end d
     }
 
     SymmetryUpdate(ms->Symmetry);
-    ms->Field = IsosurfFieldAlloc(I->Obj.G, ms->FDim);
+    ms->Field = IsosurfFieldAlloc(I->G, ms->FDim);
     ms->MapSource = cMapSourceGRD;
     ms->Field->save_points = false;
 
     switch (fast_axis) {
     case 3:                    /* Fast Y - BROKEN! */
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Warnings)
-        " ObjectMapGRD-Warning: fast_axis %d unsupported!\n", fast_axis ENDFB(I->Obj.G);
+      PRINTFB(I->G, FB_ObjectMap, FB_Warnings)
+        " ObjectMapGRD-Warning: fast_axis %d unsupported!\n", fast_axis ENDFB(I->G);
       /* intentional fall though... */
     case 1:                    /* Fast X */
     default:
@@ -4567,9 +4578,9 @@ end d
     stdev = (float) sqrt1d((sumsq - (sum * sum / n_pts)) / (n_pts - 1));
 
     if(normalize) {
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
+      PRINTFB(I->G, FB_ObjectMap, FB_Details)
         " ObjectMapGRDStrToMap: Normalizing: mean = %8.6f and stdev = %8.6f.\n",
-        mean, stdev ENDFB(I->Obj.G);
+        mean, stdev ENDFB(I->G);
       if(stdev < R_SMALL8)
         stdev = 1.0F;
       for(c = 0; c < ms->FDim[2]; c++)
@@ -4580,9 +4591,9 @@ end d
           }
         }
     } else {
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
+      PRINTFB(I->G, FB_ObjectMap, FB_Details)
         " ObjectMapGRDStrToMap: Mean = %8.6f and stdev = %8.6f.\n",
-        mean, stdev ENDFB(I->Obj.G);
+        mean, stdev ENDFB(I->G);
     }
   }
 
@@ -4613,19 +4624,19 @@ end d
 
     transform33f3f(ms->Symmetry->Crystal->FracToReal, v, ms->ExtentMax);
 
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
+    PRINTFB(I->G, FB_ObjectMap, FB_Details)
       " GRDXStrToMap: Map Size %d x %d x %d\n", ms->FDim[0], ms->FDim[1], ms->FDim[2]
-      ENDFB(I->Obj.G);
+      ENDFB(I->G);
 
     ms->Active = true;
     ObjectMapUpdateExtents(I);
     if(!quiet) {
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Results)
-        " ObjectMap: Map read.  Range: %5.3f to %5.3f\n", mind, maxd ENDFB(I->Obj.G);
+      PRINTFB(I->G, FB_ObjectMap, FB_Results)
+        " ObjectMap: Map read.  Range: %5.3f to %5.3f\n", mind, maxd ENDFB(I->G);
     }
   } else {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Errors)
-      " Error: unable to read GRD file.\n" ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Errors)
+      " Error: unable to read GRD file.\n" ENDFB(I->G);
   }
 
   return (ok);
@@ -4653,8 +4664,8 @@ static ObjectMap *ObjectMapReadXPLORStr(
     }
     ObjectMapXPLORStrToMap(I, XPLORStr, state, quiet);
 
-    SceneChanged(I->Obj.G);
-    SceneCountFrames(I->Obj.G);
+    SceneChanged(I->G);
+    SceneCountFrames(I->G);
   }
   return (I);
 }
@@ -4912,10 +4923,10 @@ static int ObjectMapDXStrToMap(ObjectMap
     I->NState = state + 1;
   }
   ms = &I->State[state];
-  ObjectMapStateInit(I->Obj.G, ms);
+  ObjectMapStateInit(I->G, ms);
 
-  ms->Origin = Alloc(float, 3);
-  ms->Grid = Alloc(float, 3);
+  ms->Origin = pymol::malloc<float>(3);
+  ms->Grid = pymol::malloc<float>(3);
 
   maxd = -FLT_MAX;
   mind = FLT_MAX;
@@ -4946,9 +4957,9 @@ static int ObjectMapDXStrToMap(ObjectMap
   }
 
   if(ok && (stage == 1)) {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
+    PRINTFB(I->G, FB_ObjectMap, FB_Details)
       " DXStrToMap: Dimensions: %d %d %d\n", ms->FDim[0], ms->FDim[1], ms->FDim[2]
-      ENDFB(I->Obj.G);
+      ENDFB(I->G);
   }
 
   /* get the origin */
@@ -4974,10 +4985,10 @@ static int ObjectMapDXStrToMap(ObjectMap
   }
 
   if(ok && (stage == 2)) {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
+    PRINTFB(I->G, FB_ObjectMap, FB_Details)
       " DXStrToMap: Origin %8.3f %8.3f %8.3f\n", ms->Origin[0], ms->Origin[1],
       ms->Origin[2]
-      ENDFB(I->Obj.G);
+      ENDFB(I->G);
   }
 
   float delta[9];
@@ -5016,7 +5027,7 @@ static int ObjectMapDXStrToMap(ObjectMap
         ms->Grid[2] = delta[8];
       } else {
         if(!ms->State.Matrix)
-          ms->State.Matrix = Alloc(double, 16);
+          ms->State.Matrix = pymol::malloc<double>(16);
 
         copy33f44d(delta, ms->State.Matrix);
         ms->State.Matrix[3] = ms->Origin[0];
@@ -5030,9 +5041,9 @@ static int ObjectMapDXStrToMap(ObjectMap
   }
 
   if(ok && (stage == 3)) {
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
+    PRINTFB(I->G, FB_ObjectMap, FB_Details)
       " DXStrToMap: Grid %8.3f %8.3f %8.3f\n", ms->Grid[0], ms->Grid[1], ms->Grid[2]
-      ENDFB(I->Obj.G);
+      ENDFB(I->G);
   }
 
   while(ok && (*p) && (stage == 3)) {
@@ -5056,11 +5067,11 @@ static int ObjectMapDXStrToMap(ObjectMap
   if(stage == 4) {
 
     if(ok && (stage == 4)) {
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
-        " DXStrToMap: %d data points.\n", n_items ENDFB(I->Obj.G);
+      PRINTFB(I->G, FB_ObjectMap, FB_Details)
+        " DXStrToMap: %d data points.\n", n_items ENDFB(I->G);
     }
 
-    ms->Field = IsosurfFieldAlloc(I->Obj.G, ms->FDim);
+    ms->Field = IsosurfFieldAlloc(I->G, ms->FDim);
     ms->MapSource = cMapSourceGeneralPurpose;
     ms->Field->save_points = false;
 
@@ -5133,13 +5144,13 @@ static int ObjectMapDXStrToMap(ObjectMap
     ok = false;
 
   if(!ok) {
-    ErrMessage(I->Obj.G, "ObjectMap", "Error reading map");
+    ErrMessage(I->G, "ObjectMap", "Error reading map");
   } else {
     ms->Active = true;
     ObjectMapUpdateExtents(I);
     if(!quiet) {
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Results)
-        " ObjectMap: Map read.  Range: %5.3f to %5.3f\n", mind, maxd ENDFB(I->Obj.G);
+      PRINTFB(I->G, FB_ObjectMap, FB_Results)
+        " ObjectMap: Map read.  Range: %5.3f to %5.3f\n", mind, maxd ENDFB(I->G);
     }
   }
   return (ok);
@@ -5237,10 +5248,10 @@ static int ObjectMapACNTStrToMap(ObjectM
   }
 
   ms = &I->State[state];
-  ObjectMapStateInit(I->Obj.G, ms);
+  ObjectMapStateInit(I->G, ms);
 
-  ms->Origin = Alloc(float, 3);
-  ms->Grid = Alloc(float, 3);
+  ms->Origin = pymol::malloc<float>(3);
+  ms->Grid = pymol::malloc<float>(3);
 
   maxd = -FLT_MAX;
   mind = FLT_MAX;
@@ -5282,25 +5293,25 @@ static int ObjectMapACNTStrToMap(ObjectM
 
   if(ok && (stage == 3)) {
 
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
+    PRINTFB(I->G, FB_ObjectMap, FB_Details)
       " ACNTStrToMap: Dimensions: %d %d %d\n", ms->FDim[0], ms->FDim[1], ms->FDim[2]
-      ENDFB(I->Obj.G);
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
+      ENDFB(I->G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Details)
       " ACNTStrToMap: Origin %8.3f %8.3f %8.3f\n", ms->Origin[0], ms->Origin[1],
       ms->Origin[2]
-      ENDFB(I->Obj.G);
-    PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
+      ENDFB(I->G);
+    PRINTFB(I->G, FB_ObjectMap, FB_Details)
       " ACNTStrToMap: Grid %8.3f %8.3f %8.3f\n", ms->Grid[0], ms->Grid[1], ms->Grid[2]
-      ENDFB(I->Obj.G);
+      ENDFB(I->G);
 
     n_items = ms->FDim[0] * ms->FDim[1] * ms->FDim[2];
 
     if(ok && (stage == 1)) {
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Details)
-        " ACNTStrToMap: %d data points.\n", n_items ENDFB(I->Obj.G);
+      PRINTFB(I->G, FB_ObjectMap, FB_Details)
+        " ACNTStrToMap: %d data points.\n", n_items ENDFB(I->G);
     }
 
-    ms->Field = IsosurfFieldAlloc(I->Obj.G, ms->FDim);
+    ms->Field = IsosurfFieldAlloc(I->G, ms->FDim);
     ms->MapSource = cMapSourceGeneralPurpose;
     ms->Field->save_points = false;
 
@@ -5369,13 +5380,13 @@ static int ObjectMapACNTStrToMap(ObjectM
     ok = false;
 
   if(!ok) {
-    ErrMessage(I->Obj.G, "ObjectMap", "Error reading map");
+    ErrMessage(I->G, "ObjectMap", "Error reading map");
   } else {
     ms->Active = true;
     ObjectMapUpdateExtents(I);
     if(!quiet) {
-      PRINTFB(I->Obj.G, FB_ObjectMap, FB_Results)
-        " ObjectMap: Map read.  Range: %5.3f to %5.3f\n", mind, maxd ENDFB(I->Obj.G);
+      PRINTFB(I->G, FB_ObjectMap, FB_Results)
+        " ObjectMap: Map read.  Range: %5.3f to %5.3f\n", mind, maxd ENDFB(I->G);
     }
   }
   return (ok);
@@ -5608,7 +5619,7 @@ int ObjectMapSetBorder(ObjectMap * I, fl
   int a;
   int result = true;
   if(state == -2)
-    state = ObjectGetCurrentState(&I->Obj, false);
+    state = ObjectGetCurrentState(I, false);
   for(a = 0; a < I->NState; a++) {
     if((state < 0) || (state == a)) {
       if(I->State[a].Active)
@@ -5954,8 +5965,8 @@ ObjectMap *ObjectMapLoadChemPyMap(PyMOLG
       ms->Active = true;
       ObjectMapUpdateExtents(I);
       if(!quiet) {
-        PRINTFB(I->Obj.G, FB_ObjectMap, FB_Results)
-          " ObjectMap: Map read.  Range: %5.3f to %5.3f\n", mind, maxd ENDFB(I->Obj.G);
+        PRINTFB(I->G, FB_ObjectMap, FB_Results)
+          " ObjectMap: Map read.  Range: %5.3f to %5.3f\n", mind, maxd ENDFB(I->G);
       }
     }
 
diff -upNr pymol-open-source-2.3.0/layer2/ObjectMap.h pymol-open-source-2.3.3/layer2/ObjectMap.h
--- pymol-open-source-2.3.0/layer2/ObjectMap.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectMap.h	2019-08-22 10:24:47.710594388 +0200
@@ -64,11 +64,10 @@ typedef struct ObjectMapState {
   float high_cutoff, low_cutoff;
 } ObjectMapState;
 
-typedef struct ObjectMap {
-  CObject Obj;
+struct ObjectMap : public CObject {
   ObjectMapState *State;
   int NState;
-} ObjectMap;
+};
 
 #define cObjectMap_OrthoMinMaxGrid 0
 
diff -upNr pymol-open-source-2.3.0/layer2/ObjectMesh.cpp pymol-open-source-2.3.3/layer2/ObjectMesh.cpp
--- pymol-open-source-2.3.0/layer2/ObjectMesh.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectMesh.cpp	2019-08-22 10:24:47.710594388 +0200
@@ -84,7 +84,7 @@ static PyObject *ObjectMeshStateAsPyList
 }
 
 static int ObjectMeshStateMapExists(ObjectMesh *I, ObjectMeshState *ms){
-  return ExecutiveFindObjectMapByName(I->Obj.G, ms->MapName) ? 1 : 0;
+  return ExecutiveFindObjectMapByName(I->G, ms->MapName) ? 1 : 0;
 }
 
 int ObjectMeshAllMapsInStatesExist(ObjectMesh * I)
@@ -207,7 +207,8 @@ static int ObjectMeshAllStatesFromPyList
     ok = PyList_Check(list);
   if(ok) {
     for(a = 0; a < I->NState; a++) {
-      ok = ObjectMeshStateFromPyList(I->Obj.G, I->State + a, PyList_GetItem(list, a));
+      auto *el = PyList_GetItem(list, a);
+      ok = ObjectMeshStateFromPyList(I->G, I->State + a, el);
       if(!ok)
         break;
     }
@@ -233,7 +234,7 @@ int ObjectMeshNewFromPyList(PyMOLGlobals
     ok = (I != NULL);
 
   if(ok)
-    ok = ObjectFromPyList(G, PyList_GetItem(list, 0), &I->Obj);
+    ok = ObjectFromPyList(G, PyList_GetItem(list, 0), I);
   if(ok)
     ok = PConvPyIntToInt(PyList_GetItem(list, 1), &I->NState);
   if(ok)
@@ -258,25 +259,25 @@ PyObject *ObjectMeshAsPyList(ObjectMesh
 
   if (allMapsExist){
     result = PyList_New(3);
-    PyList_SetItem(result, 0, ObjectAsPyList(&I->Obj));
+    PyList_SetItem(result, 0, ObjectAsPyList(I));
     PyList_SetItem(result, 1, PyInt_FromLong(I->NState));
     PyList_SetItem(result, 2, ObjectMeshAllStatesAsPyList(I));
   } else {
     /* save ObjectMesh as ObjectCGO */
-    ObjectCGO *retObjectCGO = ObjectCGONew(I->Obj.G);
-    ObjectCopyHeader(&retObjectCGO->Obj, &I->Obj);
-    retObjectCGO->Obj.type = cObjectCGO;
+    ObjectCGO *retObjectCGO = ObjectCGONew(I->G);
+    ObjectCopyHeader(retObjectCGO, I);
+    retObjectCGO->type = cObjectCGO;
 
     int a;
-    PRINTFB(I->Obj.G, FB_ObjectMesh, FB_Errors)
+    PRINTFB(I->G, FB_ObjectMesh, FB_Errors)
       "ObjectMesh-Warning: map has been deleted, saving as CGO.\n"
-      ENDFB(I->Obj.G);
+      ENDFB(I->G);
     for(a = 0; a < I->NState; a++) {
       CGO *cgo = ObjectMeshRenderImpl(I, 0, 1, a);
-      retObjectCGO = ObjectCGOFromCGO(I->Obj.G, retObjectCGO, cgo, a);
+      retObjectCGO = ObjectCGOFromCGO(I->G, retObjectCGO, cgo, a);
       
     }
-    ObjectSetRepVisMask(&retObjectCGO->Obj, cRepCGOBit, cVis_AS);
+    ObjectSetRepVisMask(retObjectCGO, cRepCGOBit, cVis_AS);
     result = ObjectCGOAsPyList(retObjectCGO);
     ObjectCGOFree(retObjectCGO);
   }
@@ -314,7 +315,7 @@ static void ObjectMeshFree(ObjectMesh *
       ObjectMeshStateFree(I->State + a);
   }
   VLAFreeP(I->State);
-  ObjectPurge(&I->Obj);
+  ObjectPurge(I);
 
   OOFreeP(I);
 }
@@ -346,7 +347,7 @@ void ObjectMeshDump(ObjectMesh * I, cons
   FILE *f;
   f = fopen(fname, "wb");
   if(!f)
-    ErrMessage(I->Obj.G, "ObjectMeshDump", "can't open file for writing");
+    ErrMessage(I->G, "ObjectMeshDump", "can't open file for writing");
   else {
     if(state < I->NState) {
       n = I->State[state].N;
@@ -364,19 +365,19 @@ void ObjectMeshDump(ObjectMesh * I, cons
         }
     }
     fclose(f);
-    PRINTFB(I->Obj.G, FB_ObjectMesh, FB_Actions)
-      " ObjectMeshDump: %s written to %s\n", I->Obj.Name, fname ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMesh, FB_Actions)
+      " ObjectMeshDump: %s written to %s\n", I->Name, fname ENDFB(I->G);
   }
 }
 
 static void ObjectMeshInvalidate(ObjectMesh * I, int rep, int level, int state)
 {
   if(level >= cRepInvExtents) {
-    I->Obj.ExtentFlag = false;
+    I->ExtentFlag = false;
   }
   if((rep == cRepMesh) || (rep == cRepAll) || (rep == cRepCell)) {
 
-    for(StateIterator iter(I->Obj.G, NULL, state, I->NState); iter.next();) {
+    for(StateIterator iter(I->G, NULL, state, I->NState); iter.next();) {
       ObjectMeshState *ms = I->State + iter.state;
 
       CGOFree(ms->shaderCGO);
@@ -385,12 +386,12 @@ static void ObjectMeshInvalidate(ObjectM
       ms->RefreshFlag = true;
       if(level >= cRepInvAll) {
         ms->ResurfaceFlag = true;
-        SceneChanged(I->Obj.G);
+        SceneChanged(I->G);
       } else if(level >= cRepInvColor) {
         ms->RecolorFlag = true;
-        SceneChanged(I->Obj.G);
+        SceneChanged(I->G);
       } else {
-        SceneInvalidate(I->Obj.G);
+        SceneInvalidate(I->G);
       }
     }
   }
@@ -421,7 +422,7 @@ int ObjectMeshSetLevel(ObjectMesh * I, f
   if(state >= I->NState) {
     ok = false;
   } else {
-    for(StateIterator iter(I->Obj.G, NULL, state, I->NState); iter.next();) {
+    for(StateIterator iter(I->G, NULL, state, I->NState); iter.next();) {
       ObjectMeshState *ms = I->State + iter.state;
       if(ms->Active) {
         ms->ResurfaceFlag = true;
@@ -440,15 +441,15 @@ static void ObjectMeshStateUpdateColors(
   int cur_color = -1;
 
   if(ms->MeshMode == 0) {
-    cur_color = SettingGet_color(I->Obj.G, I->Obj.Setting, NULL, cSetting_mesh_color);
+    cur_color = SettingGet_color(I->G, I->Setting, NULL, cSetting_mesh_color);
   } else if(ms->MeshMode == 1) {
-    cur_color = SettingGet_color(I->Obj.G, I->Obj.Setting, NULL, cSetting_dot_color);
+    cur_color = SettingGet_color(I->G, I->Setting, NULL, cSetting_dot_color);
   }
 
   if(cur_color == -1)
-    cur_color = I->Obj.Color;
+    cur_color = I->Color;
 
-  if(ColorCheckRamped(I->Obj.G, cur_color))
+  if(ColorCheckRamped(I->G, cur_color))
     one_color_flag = false;
 
   ms->OneColor = cur_color;
@@ -469,17 +470,17 @@ static void ObjectMeshStateUpdateColors(
 
     if(!ms->VC) {
       ms->VCsize = n_vert;
-      ms->VC = Alloc(float, n_vert * 3);
+      ms->VC = pymol::malloc<float>(n_vert * 3);
     }
     if(!ms->RC) {
-      ms->RC = Alloc(int, n_vert);
+      ms->RC = pymol::malloc<int>(n_vert);
     }
     rc = ms->RC;
     vc = ms->VC;
     if(vc) {
       for(a = 0; a < n_vert; a++) {
         if(a == base_n_vert) {
-          int new_color = SettingGet_color(I->Obj.G, I->Obj.Setting,
+          int new_color = SettingGet_color(I->G, I->Setting,
                                            NULL, cSetting_mesh_negative_color);
           if(new_color == -1)
             new_color = cur_color;
@@ -488,12 +489,12 @@ static void ObjectMeshStateUpdateColors(
             cur_color = new_color;
           }
         }
-        if(ColorCheckRamped(I->Obj.G, cur_color)) {
-          ColorGetRamped(I->Obj.G, cur_color, v, vc, state);
+        if(ColorCheckRamped(I->G, cur_color)) {
+          ColorGetRamped(I->G, cur_color, v, vc, state);
           *rc = cur_color;
           ramped_flag = true;
         } else {
-          const float *col = ColorGet(I->Obj.G, cur_color);
+          const float *col = ColorGet(I->G, cur_color);
           copy3f(col, vc);
         }
         rc++;
@@ -507,7 +508,7 @@ static void ObjectMeshStateUpdateColors(
       FreeP(ms->RC);
     } else if((!ramped_flag)
               ||
-              (!SettingGet_b(I->Obj.G, NULL, I->Obj.Setting, cSetting_ray_color_ramps))) {
+              (!SettingGet_b(I->G, NULL, I->Setting, cSetting_ray_color_ramps))) {
       FreeP(ms->RC);
     }
   }
@@ -515,7 +516,7 @@ static void ObjectMeshStateUpdateColors(
 
 static void ObjectMeshUpdate(ObjectMesh * I)
 {
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   int a;
   int c;
   ObjectMeshState *ms;
@@ -535,18 +536,18 @@ static void ObjectMeshUpdate(ObjectMesh
   int last_flag = 0;
   int h, k, l;
   int i, j;
-  int mesh_skip = SettingGet_i(G, I->Obj.Setting, NULL, cSetting_mesh_skip);
+  int mesh_skip = SettingGet_i(G, I->Setting, NULL, cSetting_mesh_skip);
 
   MapType *voxelmap;            /* this has nothing to do with isosurfaces... */
   for(a = 0; a < I->NState; a++) {
     ms = I->State + a;
     if(ms->Active) {
 
-      map = ExecutiveFindObjectMapByName(I->Obj.G, ms->MapName);
+      map = ExecutiveFindObjectMapByName(I->G, ms->MapName);
       if(!map) {
-        PRINTFB(I->Obj.G, FB_ObjectMesh, FB_Errors)
+        PRINTFB(I->G, FB_ObjectMesh, FB_Errors)
           "ObjectMeshUpdate-Error: map '%s' has been deleted.\n", ms->MapName
-          ENDFB(I->Obj.G);
+          ENDFB(I->G);
         ms->ResurfaceFlag = false;
       }
       if(map) {
@@ -558,7 +559,7 @@ static void ObjectMeshUpdate(ObjectMesh
             ms->Crystal = *(oms->Symmetry->Crystal);
           }
 
-          if((I->Obj.visRep & cRepCellBit)) {
+          if((I->visRep & cRepCellBit)) {
             CGOFree(ms->UnitCellCGO);
             ms->UnitCellCGO = CrystalGetUnitCellCGO(&ms->Crystal);
           }
@@ -572,14 +573,14 @@ static void ObjectMeshUpdate(ObjectMesh
         }
       }
 
-      if(map && oms && ms->N && ms->V && (I->Obj.visRep & cRepMeshBit)) {
+      if(map && oms && ms->N && ms->V && (I->visRep & cRepMeshBit)) {
         if(ms->ResurfaceFlag) {
           Isofield *field = NULL;
           ms->RecolorFlag = true;
           ms->ResurfaceFlag = false;
           if(!ms->quiet) {
             PRINTFB(G, FB_ObjectMesh, FB_Details)
-              " ObjectMesh: updating \"%s\".\n", I->Obj.Name ENDFB(G);
+              " ObjectMesh: updating \"%s\".\n", I->Name ENDFB(G);
           }
           if(ms->Field) {
             field = ms->Field;
@@ -601,7 +602,7 @@ static void ObjectMeshUpdate(ObjectMesh
                 max_ext = ms->ExtentMax;
               }
 
-              IsosurfGetRange(I->Obj.G, field, oms->Symmetry->Crystal,
+              IsosurfGetRange(I->G, field, oms->Symmetry->Crystal,
                               min_ext, max_ext, ms->Range, true);
             }
             /*                      printf("Mesh-DEBUG: %d %d %d %d %d %d\n",
@@ -611,14 +612,14 @@ static void ObjectMeshUpdate(ObjectMesh
                ms->Range[3],
                ms->Range[4],
                ms->Range[5]); */
-            IsosurfVolume(I->Obj.G, I->Obj.Setting, NULL,
+            IsosurfVolume(I->G, I->Setting, NULL,
                           field,
                           ms->Level,
                           &ms->N, &ms->V,
                           ms->Range, ms->MeshMode, mesh_skip, ms->AltLevel);
 
             if(!SettingGet_b
-               (I->Obj.G, I->Obj.Setting, NULL, cSetting_mesh_negative_visible)) {
+               (I->G, I->Setting, NULL, cSetting_mesh_negative_visible)) {
               ms->base_n_V = VLAGetSize(ms->V);
             } else if(ms->MeshMode != 3) {
               /* do we want the negative surface too? */
@@ -626,7 +627,7 @@ static void ObjectMeshUpdate(ObjectMesh
               int *N2 = VLAlloc(int, 10000);
               float *V2 = VLAlloc(float, 10000);
 
-              IsosurfVolume(I->Obj.G, I->Obj.Setting, NULL,
+              IsosurfVolume(I->G, I->Setting, NULL,
                             field,
                             -ms->Level,
                             &N2, &V2, ms->Range, ms->MeshMode, mesh_skip, ms->AltLevel);
@@ -682,7 +683,7 @@ static void ObjectMeshUpdate(ObjectMesh
             }
 
             /* cull my friend, cull */
-            voxelmap = MapNew(I->Obj.G,
+            voxelmap = MapNew(I->G,
                               -carve_buffer, ms->AtomVertex,
                               VLAGetSize(ms->AtomVertex) / 3, NULL);
             if(voxelmap) {
@@ -763,12 +764,12 @@ static void ObjectMeshUpdate(ObjectMesh
       CGOFree(ms->shaderCGO);
       CGOFree(ms->shaderUnitCellCGO);
     }
-    SceneInvalidate(I->Obj.G);
+    SceneInvalidate(I->G);
   }
-  if(!I->Obj.ExtentFlag) {
+  if(!I->ExtentFlag) {
     ObjectMeshRecomputeExtent(I);
-    if(I->Obj.ExtentFlag)
-      SceneInvalidate(I->Obj.G);
+    if(I->ExtentFlag)
+      SceneInvalidate(I->G);
   }
 }
 
@@ -781,20 +782,22 @@ static void ObjectMeshRender(ObjectMesh
 static short ObjectMeshStateRenderShader(ObjectMeshState *ms, ObjectMesh *I,
     RenderInfo *info, short mesh_as_cylinders, float mesh_width)
 {
-  PyMOLGlobals *G = I->Obj.G;
-  CShaderPrg *shaderPrg;
+  PyMOLGlobals *G = I->G;
+  CShaderPrg *shaderPrg = nullptr;
 
   if (!mesh_as_cylinders) {
     shaderPrg = G->ShaderMgr->Enable_DefaultShader(info->pass);
     shaderPrg->SetLightingEnabled(0);
     shaderPrg->Set1i("two_sided_lighting_enabled",
 		     SceneGetTwoSidedLighting(G));
-  if (!shaderPrg)
-    return false;
   }
 
   CGORenderGL(ms->shaderCGO, NULL, NULL, NULL, info, NULL);
 
+  if (shaderPrg) {
+    shaderPrg->Disable();
+  }
+
   if (ms->shaderUnitCellCGO){
     shaderPrg = G->ShaderMgr->Enable_DefaultShader(info->pass);
     shaderPrg->SetLightingEnabled(0);
@@ -807,7 +810,7 @@ static short ObjectMeshStateRenderShader
 
 static CGO *ObjectMeshRenderImpl(ObjectMesh * I, RenderInfo * info, int returnCGO, int stateArg)
 {
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   float *v = NULL;
   float *vc;
   int *rc;
@@ -818,7 +821,7 @@ static CGO *ObjectMeshRenderImpl(ObjectM
   int pass = 0;
   int *n = NULL;
   int c;
-  float line_width, mesh_width = SettingGet_f(I->Obj.G, I->Obj.Setting, NULL, cSetting_mesh_width);
+  float line_width, mesh_width = SettingGet_f(I->G, I->Setting, NULL, cSetting_mesh_width);
   ObjectMeshState *ms = NULL;
   int ok = true;
 
@@ -832,9 +835,9 @@ static CGO *ObjectMeshRenderImpl(ObjectM
   }
 
   line_width = SceneGetDynamicLineWidth(info, mesh_width);
-  ObjectPrepareContext(&I->Obj, info);
+  ObjectPrepareContext(I, info);
 
-  for(StateIterator iter(I->Obj.G, I->Obj.Setting, state, I->NState); iter.next();) {
+  for(StateIterator iter(I->G, I->Setting, state, I->NState); iter.next();) {
     ms = I->State + iter.state;
 
     if(!ms->Active || !ms->V || !ms->N)
@@ -844,30 +847,30 @@ static CGO *ObjectMeshRenderImpl(ObjectM
         v = ms->V;
         n = ms->N;
         if(ok && ray) {
-          if(ms->UnitCellCGO && (I->Obj.visRep & cRepCellBit)){
-            ok &= CGORenderRay(ms->UnitCellCGO, ray, info, ColorGet(I->Obj.G, I->Obj.Color),
-			       NULL, I->Obj.Setting, NULL);
+          if(ms->UnitCellCGO && (I->visRep & cRepCellBit)){
+            ok &= CGORenderRay(ms->UnitCellCGO, ray, info, ColorGet(I->G, I->Color),
+			       NULL, I->Setting, NULL);
 	    if (!ok){
 	      CGOFree(ms->UnitCellCGO);
 	      break;
 	    }
 	  }
           if(ms->MeshMode != 1) {
-            radius = SettingGet_f(I->Obj.G, I->Obj.Setting, NULL, cSetting_mesh_radius);
+            radius = SettingGet_f(I->G, I->Setting, NULL, cSetting_mesh_radius);
 
             if(radius == 0.0F) {
               radius = ray->PixelRadius * line_width / 2.0F;
             }
           } else {
-            radius = SettingGet_f(I->Obj.G, I->Obj.Setting, NULL, cSetting_dot_radius);
+            radius = SettingGet_f(I->G, I->Setting, NULL, cSetting_dot_radius);
             if(radius == 0.0F) {
               radius =
-                ray->PixelRadius * SettingGet_f(I->Obj.G, I->Obj.Setting, NULL,
+                ray->PixelRadius * SettingGet_f(I->G, I->Setting, NULL,
                                                 cSetting_dot_width) / 1.4142F;
             }
           }
 
-          if(ok && n && v && (I->Obj.visRep & cRepMeshBit)) {
+          if(ok && n && v && (I->visRep & cRepMeshBit)) {
             float cc[3];
             float colA[3], colB[3];
             ColorGetEncoded(G, ms->OneColor, cc);
@@ -952,10 +955,10 @@ static CGO *ObjectMeshRenderImpl(ObjectM
 		shaderCGO->use_shader = true;
 	      }
 
-	      if(ms->UnitCellCGO && (I->Obj.visRep & cRepCellBit)) {
-		const float *color = ColorGet(I->Obj.G, I->Obj.Color);
+	      if(ms->UnitCellCGO && (I->visRep & cRepCellBit)) {
+		const float *color = ColorGet(I->G, I->Color);
 		if (!use_shader) {
-		  CGORenderGL(ms->UnitCellCGO, color, I->Obj.Setting, NULL, info, NULL);
+		  CGORenderGL(ms->UnitCellCGO, color, I->Setting, NULL, info, NULL);
 		} else if(!ms->shaderUnitCellCGO) {
 		  CGO *newUnitCellCGO = CGONewSized(G, 0);
 		  CGOColorv(newUnitCellCGO, color);
@@ -978,19 +981,19 @@ static CGO *ObjectMeshRenderImpl(ObjectM
 	      if (use_shader){
 		ok &= CGOResetNormal(shaderCGO, true);
 	      } else {
-		SceneResetNormal(I->Obj.G, false);
+		SceneResetNormal(I->G, false);
 	      }
-	      if(n && v && (I->Obj.visRep & cRepMeshBit)) {
+	      if(n && v && (I->visRep & cRepMeshBit)) {
 		if(use_shader) {
 		  vc = ms->VC;
 
 		  if(!vc)
-		    ok &= CGOColorv(shaderCGO, ColorGet(I->Obj.G, ms->OneColor));
+		    ok &= CGOColorv(shaderCGO, ColorGet(I->G, ms->OneColor));
 
 		  if (!mesh_as_cylinders){
 		    if(ms->MeshMode == 1){
 		      ok &= CGODotwidth(shaderCGO, SettingGet_f
-				  (I->Obj.G, I->Obj.Setting, NULL, cSetting_dot_width));
+				  (I->G, I->Setting, NULL, cSetting_dot_width));
 		    } else {
 		      ok &= CGOSpecial(shaderCGO, LINEWIDTH_DYNAMIC_MESH); 
 		    }
@@ -1054,10 +1057,10 @@ static CGO *ObjectMeshRenderImpl(ObjectM
 		  vc = ms->VC;
 
 		  if(!vc)
-		    glColor3fv(ColorGet(I->Obj.G, ms->OneColor));
+		    glColor3fv(ColorGet(I->G, ms->OneColor));
 		  if(ms->MeshMode == 1){
 		    glPointSize(SettingGet_f
-				(I->Obj.G, I->Obj.Setting, NULL, cSetting_dot_width));
+				(I->G, I->Setting, NULL, cSetting_dot_width));
 		  } else {
 		    glLineWidth(line_width);
 		  }
@@ -1134,9 +1137,9 @@ static CGO *ObjectMeshRenderImpl(ObjectM
     }
   }
   if (!ok){
-    I->Obj.invalidate(cRepMesh, cRepInvPurge, -1);
-    I->Obj.invalidate(cRepCGO, cRepInvPurge, -1);
-    ObjectSetRepVisMask(&I->Obj, 0, cVis_AS);
+    I->invalidate(cRepMesh, cRepInvPurge, -1);
+    I->invalidate(cRepCGO, cRepInvPurge, -1);
+    ObjectSetRepVisMask(I, 0, cVis_AS);
   }
 
   return NULL;
@@ -1166,19 +1169,19 @@ ObjectMesh *ObjectMeshNew(PyMOLGlobals *
     CHECKOK(ok, I->State);
   }
   if (ok){
-    I->Obj.type = cObjectMesh;
+    I->type = cObjectMesh;
     
-    I->Obj.fFree = (void (*)(CObject *)) ObjectMeshFree;
-    I->Obj.fUpdate = (void (*)(CObject *)) ObjectMeshUpdate;
-    I->Obj.fRender = (void (*)(CObject *, RenderInfo *)) ObjectMeshRender;
-    I->Obj.fInvalidate = (void (*)(CObject *, int, int, int)) ObjectMeshInvalidate;
-    I->Obj.fGetNFrame = (int (*)(CObject *)) ObjectMeshGetNStates;
+    I->fFree = (void (*)(CObject *)) ObjectMeshFree;
+    I->fUpdate = (void (*)(CObject *)) ObjectMeshUpdate;
+    I->fRender = (void (*)(CObject *, RenderInfo *)) ObjectMeshRender;
+    I->fInvalidate = (void (*)(CObject *, int, int, int)) ObjectMeshInvalidate;
+    I->fGetNFrame = (int (*)(CObject *)) ObjectMeshGetNStates;
   }
   if (!ok){
     ObjectMeshFree(I);
     I = NULL;
   }
-  /*  I->Obj.fGetCaption = (char *(*)(CObject *))ObjectMeshGetCaption; */
+  /*  I->fGetCaption = (char *(*)(CObject *))ObjectMeshGetCaption; */
   return (I);
 }
 
@@ -1251,7 +1254,7 @@ ObjectMesh *ObjectMeshFromXtalSym(PyMOLG
   }
 
   if (ok){
-    strcpy(ms->MapName, map->Obj.Name);
+    strcpy(ms->MapName, map->Name);
     ms->MapState = map_state;
     oms = ObjectMapGetState(map, map_state);
 
@@ -1304,7 +1307,7 @@ ObjectMesh *ObjectMeshFromXtalSym(PyMOLG
           fdim[0] = eff_range[3] - eff_range[0];
           fdim[1] = eff_range[4] - eff_range[1];
           fdim[2] = eff_range[5] - eff_range[2];
-          ms->Field = IsosurfFieldAlloc(I->Obj.G, fdim);
+          ms->Field = IsosurfFieldAlloc(I->G, fdim);
 
           expand_result =
             IsosurfExpand(oms->Field, ms->Field, oms->Symmetry->Crystal, sym, eff_range);
@@ -1352,7 +1355,7 @@ ObjectMesh *ObjectMeshFromXtalSym(PyMOLG
     if(I) {
       ObjectMeshRecomputeExtent(I);
     }
-    I->Obj.ExtentFlag = true;
+    I->ExtentFlag = true;
     /*  printf("Brick %d %d %d %d %d %d\n",I->Range[0],I->Range[1],I->Range[2],I->Range[3],I->Range[4],I->Range[5]); */
   }
   if(!ok && created) {
@@ -1391,26 +1394,26 @@ void ObjectMeshRecomputeExtent(ObjectMes
       if(ms->ExtentFlag) {
         if(!extent_flag) {
           extent_flag = true;
-          copy3f(ms->ExtentMax, I->Obj.ExtentMax);
-          copy3f(ms->ExtentMin, I->Obj.ExtentMin);
+          copy3f(ms->ExtentMax, I->ExtentMax);
+          copy3f(ms->ExtentMin, I->ExtentMin);
         } else {
-          max3f(ms->ExtentMax, I->Obj.ExtentMax, I->Obj.ExtentMax);
-          min3f(ms->ExtentMin, I->Obj.ExtentMin, I->Obj.ExtentMin);
+          max3f(ms->ExtentMax, I->ExtentMax, I->ExtentMax);
+          min3f(ms->ExtentMin, I->ExtentMin, I->ExtentMin);
         }
       }
     }
   }
 
-  I->Obj.ExtentFlag = extent_flag;
+  I->ExtentFlag = extent_flag;
 
-  if(I->Obj.TTTFlag && I->Obj.ExtentFlag) {
+  if(I->TTTFlag && I->ExtentFlag) {
     const float *ttt;
     double tttd[16];
-    if(ObjectGetTTT(&I->Obj, &ttt, -1)) {
+    if(ObjectGetTTT(I, &ttt, -1)) {
       convertTTTfR44d(ttt, tttd);
       MatrixTransformExtentsR44d3f(tttd,
-                                   I->Obj.ExtentMin, I->Obj.ExtentMax,
-                                   I->Obj.ExtentMin, I->Obj.ExtentMax);
+                                   I->ExtentMin, I->ExtentMax,
+                                   I->ExtentMin, I->ExtentMax);
     }
   }
 }
diff -upNr pymol-open-source-2.3.0/layer2/ObjectMesh.h pymol-open-source-2.3.3/layer2/ObjectMesh.h
--- pymol-open-source-2.3.0/layer2/ObjectMesh.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectMesh.h	2019-08-22 10:24:47.710594388 +0200
@@ -51,11 +51,10 @@ typedef struct {
   CGO *shaderUnitCellCGO;
 } ObjectMeshState;
 
-typedef struct ObjectMesh {
-  CObject Obj;
+struct ObjectMesh : public CObject {
   ObjectMeshState *State;
   int NState;
-} ObjectMesh;
+};
 
 ObjectMesh *ObjectMeshFromBox(PyMOLGlobals * G, ObjectMesh * obj, ObjectMap * map,
                               int map_state,
diff -upNr pymol-open-source-2.3.0/layer2/ObjectMolecule2.cpp pymol-open-source-2.3.3/layer2/ObjectMolecule2.cpp
--- pymol-open-source-2.3.0/layer2/ObjectMolecule2.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectMolecule2.cpp	2019-08-22 10:24:47.718595691 +0200
@@ -229,7 +229,7 @@ int ObjectMoleculeAddPseudoatom(ObjectMo
                                 int hetatm, float b, float q, const char *label,
                                 float *pos, int color, int state, int mode, int quiet)
 {
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   int start_state = 0, stop_state = 0;
   int extant_only = false;
   int ai_merged = false;
@@ -247,7 +247,7 @@ int ObjectMoleculeAddPseudoatom(ObjectMo
     start_state = state;
     stop_state = state + 1;
   } else if(state == -1) {      /* current state */
-    start_state = ObjectGetCurrentState(&I->Obj, true);
+    start_state = ObjectGetCurrentState(I, true);
     stop_state = start_state + 1;
   } else {                      /* all states */
     if(sele_index >= 0) {
@@ -290,19 +290,19 @@ int ObjectMoleculeAddPseudoatom(ObjectMo
     ai->flags |= cAtomFlag_inorganic; // suppress auto_show_classified
 
     if(color < 0) {
-      AtomInfoAssignColors(I->Obj.G, ai);
+      AtomInfoAssignColors(I->G, ai);
       if((ai->elem[0] == 'C') && (ai->elem[1] == 0))
         /* carbons are always colored according to the object color */
-        ai->color = I->Obj.Color;
+        ai->color = I->Color;
     } else {
       ai->color = color;
     }
-    AtomInfoAssignParameters(I->Obj.G, ai);
-    AtomInfoUniquefyNames(I->Obj.G, I->AtomInfo, I->NAtom, ai, NULL, 1);
+    AtomInfoAssignParameters(I->G, ai);
+    AtomInfoUniquefyNames(I->G, I->AtomInfo, I->NAtom, ai, NULL, 1);
     if(!quiet) {
       PRINTFB(G, FB_ObjectMolecule, FB_Actions)
         " ObjMol: created %s/%s/%s/%s`%d%c/%s\n",
-        I->Obj.Name, LexStr(G, ai->segi), LexStr(G, ai->chain),
+        I->Name, LexStr(G, ai->segi), LexStr(G, ai->chain),
         LexStr(G, ai->resn), ai->resv, ai->getInscode(true),
         LexStr(G, ai->name) ENDFB(G);
     }
@@ -325,7 +325,7 @@ int ObjectMoleculeAddPseudoatom(ObjectMo
         op.code = OMOP_CSetSumVertices;
         op.cs1 = state;
 
-        ExecutiveObjMolSeleOp(I->Obj.G, sele_index, &op);
+        ExecutiveObjMolSeleOp(I->G, sele_index, &op);
 
         if(op.i1) {
           float factor = 1.0F / op.i1;
@@ -339,7 +339,7 @@ int ObjectMoleculeAddPseudoatom(ObjectMo
               op.code = OMOP_CSetMaxDistToPt;
               copy3f(pos_array, op.v1);
               op.cs1 = state;
-              ExecutiveObjMolSeleOp(I->Obj.G, sele_index, &op);
+              ExecutiveObjMolSeleOp(I->G, sele_index, &op);
               vdw = op.f1;
               break;
             case 2:
@@ -347,7 +347,7 @@ int ObjectMoleculeAddPseudoatom(ObjectMo
               op.code = OMOP_CSetSumSqDistToPt;
               copy3f(pos_array, op.v1);
               op.cs1 = state;
-              ExecutiveObjMolSeleOp(I->Obj.G, sele_index, &op);
+              ExecutiveObjMolSeleOp(I->G, sele_index, &op);
               vdw = sqrt1f(op.d1 / op.i1);
               break;
             case 0:
@@ -363,7 +363,7 @@ int ObjectMoleculeAddPseudoatom(ObjectMo
         }
       } else if(!pos) {
         pos = pos_array;
-        SceneGetCenter(I->Obj.G, pos);
+        SceneGetCenter(I->G, pos);
       }
 
       if(pos) {                 /* only add coordinate to state if we have position for it */
@@ -416,7 +416,7 @@ int *ObjectMoleculeGetPrioritizedOtherIn
   int a, b;
   int b1, b2, a1, a2, a3;
   OtherRec *o;
-  OtherRec *other = Calloc(OtherRec, cs->NIndex);
+  OtherRec *other = pymol::calloc<OtherRec>(cs->NIndex);
   int *result = NULL;
   int offset;
   int n_alloc = 0;
@@ -449,12 +449,12 @@ int *ObjectMoleculeGetPrioritizedOtherIn
       n_alloc += populate_other(other + a2, a1, I->AtomInfo + b1, bd, I->Neighbor);
     }
     bd++;
-    ok &= !I->Obj.G->Interrupt;
+    ok &= !I->G->Interrupt;
   }
   if (ok){
     n_alloc = 3 * (n_alloc + cs->NIndex);
     o = other;
-    result = Alloc(int, n_alloc);
+    result = pymol::malloc<int>(n_alloc);
     CHECKOK(ok, result);
   }
   if (ok){
@@ -542,7 +542,7 @@ int *ObjectMoleculeGetPrioritizedOtherIn
 
     }
     bd++;
-    ok &= !I->Obj.G->Interrupt;
+    ok &= !I->G->Interrupt;
   }
   FreeP(other);
   return result;
@@ -562,7 +562,7 @@ int ObjectMoleculeGetNearestBlendedColor
   color[2] = 0.0F;
 
   if(state < 0)
-    state = ObjectGetCurrentState(&I->Obj, true);
+    state = ObjectGetCurrentState(I, true);
 
   if((state >= 0) && (state < I->NCSet)) {
     CoordSet *cs = I->CSet[state];
@@ -595,7 +595,7 @@ int ObjectMoleculeGetNearestBlendedColor
                 }
                 if(test < cutoff2) {
                   float weight = cutoff - sqrt1f(test);
-                  const float *at_col = ColorGet(I->Obj.G, I->AtomInfo[cs->IdxToAtm[j]].color);
+                  const float *at_col = ColorGet(I->G, I->AtomInfo[cs->IdxToAtm[j]].color);
                   color[0] += at_col[0] * weight;
                   color[1] += at_col[1] * weight;
                   color[2] += at_col[2] * weight;
@@ -622,7 +622,7 @@ int ObjectMoleculeGetNearestBlendedColor
           }
           if(test < cutoff2) {
             float weight = cutoff - sqrt1f(test);
-            const float *at_col = ColorGet(I->Obj.G, I->AtomInfo[cs->IdxToAtm[j]].color);
+            const float *at_col = ColorGet(I->G, I->AtomInfo[cs->IdxToAtm[j]].color);
             color[0] += at_col[0] * weight;
             color[1] += at_col[1] * weight;
             color[2] += at_col[2] * weight;
@@ -660,7 +660,7 @@ int ObjectMoleculeGetNearestAtomIndex(Ob
   int result = -1;
   float nearest = -1.0F;
   if(state < 0)
-    state = ObjectGetCurrentState(&I->Obj, true);
+    state = ObjectGetCurrentState(I, true);
   if((state >= 0) && (state < I->NCSet)) {
     CoordSet *cs = I->CSet[state];
     if(cs) {
@@ -781,7 +781,7 @@ int ObjectMoleculeGetPrioritizedOther(in
 int ObjectMoleculeIsAtomBondedToName(ObjectMolecule * obj, int a0, const char *name, int same_res)
 {
   int a2, s;
-  PyMOLGlobals * G = obj->Obj.G;
+  PyMOLGlobals * G = obj->G;
   AtomInfoType *ai2, *ai0 = obj->AtomInfo + a0;
 
   if(a0 >= 0) {
@@ -837,7 +837,7 @@ int ObjectMoleculeDoesAtomNeighborSele(O
       if(a1 < 0)
         break;
       ai = I->AtomInfo + a1;
-      if(SelectorIsMember(I->Obj.G, ai->selEntry, sele)) {
+      if(SelectorIsMember(I->G, ai->selEntry, sele)) {
         result = true;
         break;
       }
@@ -1441,13 +1441,13 @@ void ObjectMoleculeFixChemistry(ObjectMo
     s1 = ai1->selEntry;
     s2 = ai2->selEntry;
 
-    if((SelectorIsMember(I->Obj.G, s1, sele1) &&
-        SelectorIsMember(I->Obj.G, s2, sele2)) ||
-       (SelectorIsMember(I->Obj.G, s2, sele1) && SelectorIsMember(I->Obj.G, s1, sele2))) {
+    if((SelectorIsMember(I->G, s1, sele1) &&
+        SelectorIsMember(I->G, s2, sele2)) ||
+       (SelectorIsMember(I->G, s2, sele1) && SelectorIsMember(I->G, s1, sele2))) {
       order = -1;
-      if(strlen(LexStr(I->Obj.G, ai1->resn)) < 4) {       /* Standard disconnected PDB residue */
-        if(AtomInfoSameResidue(I->Obj.G, ai1, ai2)) {
-          assign_pdb_known_residue(I->Obj.G, ai1, ai2, &order);
+      if(strlen(LexStr(I->G, ai1->resn)) < 4) {       /* Standard disconnected PDB residue */
+        if(AtomInfoSameResidue(I->G, ai1, ai2)) {
+          assign_pdb_known_residue(I->G, ai1, ai2, &order);
         }
       }
       if(order > 0) {
@@ -1465,7 +1465,7 @@ void ObjectMoleculeFixChemistry(ObjectMo
   }
   if(flag) {
     ObjectMoleculeInvalidate(I, cRepAll, cRepInvAll, -1);
-    SceneChanged(I->Obj.G);
+    SceneChanged(I->G);
   }
 }
 
@@ -1516,7 +1516,7 @@ int ObjectMoleculeConvertIDsToIndices(Ob
       int a, offset;
 
       range = max_id - min_id + 1;
-      lookup = Calloc(int, range);
+      lookup = pymol::calloc<int>(range);
       for(a = 0; a < I->NAtom; a++) {
         offset = I->AtomInfo[a].id - min_id;
         if(!lookup[offset])
@@ -1596,16 +1596,16 @@ static int get_multi_object_status(const
  */
 int ObjectMoleculeAutoDisableAtomNameWildcard(ObjectMolecule * I)
 {
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   char wildcard = 0;
   int found_wildcard = false;
 
   {
-    const char *tmp = SettingGet_s(G, NULL, I->Obj.Setting, cSetting_atom_name_wildcard);
+    const char *tmp = SettingGet_s(G, NULL, I->Setting, cSetting_atom_name_wildcard);
     if(tmp && tmp[0]) {
       wildcard = *tmp;
     } else {
-      tmp = SettingGet_s(G, NULL, I->Obj.Setting, cSetting_wildcard);
+      tmp = SettingGet_s(G, NULL, I->Setting, cSetting_wildcard);
       if(tmp) {
         wildcard = *tmp;
       }
@@ -1633,7 +1633,7 @@ int ObjectMoleculeAutoDisableAtomNameWil
     }
     if(found_wildcard) {
       ExecutiveSetObjSettingFromString(G, cSetting_atom_name_wildcard, " ",
-                                       &I->Obj, -1, true, true);
+                                       I, -1, true, true);
     }
   }
   return found_wildcard;
@@ -1717,7 +1717,7 @@ static void ObjectMoleculePDBStr2CoordSe
             p = ntrim(cc, p, 6);      /* get context name */
             if(WordMatchExact(G, "ALIGN", cc, true)) {        /* ALIGN is special */
               if(!m4x->align) {
-                m4x->align = Calloc(M4XAlignType, 1);
+		m4x->align = pymol::calloc<M4XAlignType>(1);
                 CHECKOK(*ok, m4x->align);
                 if (*ok){
                   M4XAlignInit(m4x->align);
@@ -1838,7 +1838,7 @@ static void sshash_free(SSHash *hash) {
 }
 
 static SSHash * sshash_new() {
-  SSHash *hash = Calloc(SSHash, 1);
+  SSHash *hash = pymol::calloc<SSHash>(1);
   ok_assert(1, hash);
   hash->n_ss = 1;
   hash->ss_list = VLAlloc(SSEntry, 50);
@@ -1871,7 +1871,7 @@ static int sshash_register_rec(SSHash *
   for (a = 0, chain = ss_chain1; a < 2; a++, chain = ss_chain2) {
     // allocate new array for chain if necc.
     if(!hash->ss[chain]) {
-      ok_assert(1, hash->ss[chain] = Calloc(int, cResvMask + 1));
+      ok_assert(1, hash->ss[chain] = pymol::calloc<int>(cResvMask + 1));
     }
 
     sst = NULL;
@@ -3002,7 +3002,7 @@ pqr_done:
           maxAt = atInfo[a].id;
       /* build index */
       maxAt++;
-      idx = Alloc(int, maxAt + 1);
+      idx = pymol::malloc<int>(maxAt + 1);
       CHECKOK(ok, idx);
       if (ok){
 	for(a = 0; a < maxAt; a++) {
@@ -3151,63 +3151,63 @@ void ObjectMoleculeM4XAnnotate(ObjectMol
       cont = m4x->context + a;
 
       if(cont->site) {
-        UtilNCopy(name, I->Obj.Name, sizeof(WordType));
+        UtilNCopy(name, I->Name, sizeof(WordType));
         UtilNConcat(name, "_", sizeof(WordType));
         UtilNConcat(name, cont->name, sizeof(WordType));
         UtilNConcat(name, "_site", sizeof(WordType));
-        SelectorSelectByID(I->Obj.G, name, I, cont->site, cont->n_site);
+        SelectorSelectByID(I->G, name, I, cont->site, cont->n_site);
       }
       if(cont->ligand) {
-        UtilNCopy(name, I->Obj.Name, sizeof(WordType));
+        UtilNCopy(name, I->Name, sizeof(WordType));
         UtilNConcat(name, "_", sizeof(WordType));
         UtilNConcat(name, cont->name, sizeof(WordType));
         UtilNConcat(name, "_ligand", sizeof(WordType));
-        SelectorSelectByID(I->Obj.G, name, I, cont->ligand, cont->n_ligand);
+        SelectorSelectByID(I->G, name, I, cont->ligand, cont->n_ligand);
       }
       if(cont->water) {
-        UtilNCopy(name, I->Obj.Name, sizeof(WordType));
+        UtilNCopy(name, I->Name, sizeof(WordType));
         UtilNConcat(name, "_", sizeof(WordType));
         UtilNConcat(name, cont->name, sizeof(WordType));
         UtilNConcat(name, "_water", sizeof(WordType));
-        SelectorSelectByID(I->Obj.G, name, I, cont->water, cont->n_water);
+        SelectorSelectByID(I->G, name, I, cont->water, cont->n_water);
       }
       if(cont->hbond) {
         ObjectDist *distObj;
-        UtilNCopy(name, I->Obj.Name, sizeof(WordType));
+        UtilNCopy(name, I->Name, sizeof(WordType));
         UtilNConcat(name, "_", sizeof(WordType));
         UtilNConcat(name, cont->name, sizeof(WordType));
         UtilNConcat(name, "_hbond", sizeof(WordType));
-        ExecutiveDelete(I->Obj.G, name);
-        distObj = ObjectDistNewFromM4XBond(I->Obj.G, NULL,
+        ExecutiveDelete(I->G, name);
+        distObj = ObjectDistNewFromM4XBond(I->G, NULL,
                                            I, cont->hbond, cont->n_hbond, nbr_sele);
         if(match_colors)
-          distObj->Obj.Color = I->Obj.Color;
+          distObj->Color = I->Color;
         else
-          distObj->Obj.Color = ColorGetIndex(I->Obj.G, "yellow");
+          distObj->Color = ColorGetIndex(I->G, "yellow");
         ObjectSetName((CObject *) distObj, name);
         if(distObj)
-          ExecutiveManageObject(I->Obj.G, (CObject *) distObj, false, true);
+          ExecutiveManageObject(I->G, (CObject *) distObj, false, true);
       }
 
       if(cont->nbond && 0) {
         /*        ObjectDist *distObj; */
-        UtilNCopy(name, I->Obj.Name, sizeof(WordType));
+        UtilNCopy(name, I->Name, sizeof(WordType));
         UtilNConcat(name, "_", sizeof(WordType));
         UtilNConcat(name, cont->name, sizeof(WordType));
         UtilNConcat(name, "_nbond", sizeof(WordType));
-        ExecutiveDelete(I->Obj.G, name);
-        /*        distObj = ObjectDistNewFromM4XBond(I->Obj.G,NULL,
+        ExecutiveDelete(I->G, name);
+        /*        distObj = ObjectDistNewFromM4XBond(I->G,NULL,
            I,
            cont->nbond,
            cont->n_nbond);
            if(distObj)
-           ExecutiveManageObject(I->Obj.G,(CObject*)distObj,false,true); */
+           ExecutiveManageObject(I->G,(CObject*)distObj,false,true); */
 
         {
           CGO *cgo = NULL;
           ObjectCGO *ocgo;
 
-          cgo = CGONew(I->Obj.G);
+          cgo = CGONew(I->G);
           /*
              CGOBegin(cgo,GL_LINES);
              for(a=0;a<op1.nvv1;a++) {
@@ -3217,24 +3217,24 @@ void ObjectMoleculeM4XAnnotate(ObjectMol
            */
           CGOEnd(cgo);
           CGOStop(cgo);
-          ocgo = ObjectCGOFromCGO(I->Obj.G, NULL, cgo, 0);
+          ocgo = ObjectCGOFromCGO(I->G, NULL, cgo, 0);
           if(match_colors)
-            ocgo->Obj.Color = I->Obj.Color;
+            ocgo->Color = I->Color;
           else
-            ocgo->Obj.Color = ColorGetIndex(I->Obj.G, "yellow");
+            ocgo->Color = ColorGetIndex(I->G, "yellow");
           ObjectSetName((CObject *) ocgo, name);
-          ExecutiveDelete(I->Obj.G, ocgo->Obj.Name);
+          ExecutiveDelete(I->G, ocgo->Name);
 
-          ExecutiveManageObject(I->Obj.G, (CObject *) ocgo, false, true);
+          ExecutiveManageObject(I->G, (CObject *) ocgo, false, true);
 
-          SceneInvalidate(I->Obj.G);
+          SceneInvalidate(I->G);
         }
 
       }
 
     }
     if(script_file)
-      PParse(I->Obj.G, script_file);
+      PParse(I->G, script_file);
   }
 }
 
@@ -3544,9 +3544,9 @@ static int ObjectMoleculeCSetFromPyList(
     VLACheck(I->CSet, CoordSet *, I->NCSet);
     for(a = 0; a < I->NCSet; a++) {
       if(ok)
-        ok = CoordSetFromPyList(I->Obj.G, PyList_GetItem(list, a), &I->CSet[a]);
-      PRINTFB(I->Obj.G, FB_ObjectMolecule, FB_Debugging)
-        " ObjectMoleculeCSetFromPyList: ok %d after CoordSet %d\n", ok, a ENDFB(I->Obj.G);
+        ok = CoordSetFromPyList(I->G, PyList_GetItem(list, a), &I->CSet[a]);
+      PRINTFB(I->G, FB_ObjectMolecule, FB_Debugging)
+        " %s: ok %d after CoordSet %d\n", __func__, ok, a ENDFB(I->G);
 
       if(ok)
         if(I->CSet[a])          /* WLD 030205 */
@@ -3564,8 +3564,8 @@ static PyObject *ObjectMoleculeBondAsPyL
   int a;
 
 #ifndef PICKLETOOLS
-  PyMOLGlobals *G = I->Obj.G;
-  int pse_export_version = SettingGetGlobal_f(I->Obj.G, cSetting_pse_export_version) * 1000;
+  PyMOLGlobals *G = I->G;
+  int pse_export_version = SettingGetGlobal_f(I->G, cSetting_pse_export_version) * 1000;
 
   if (SettingGetGlobal_b(G, cSetting_pse_binary_dump) && (!pse_export_version || pse_export_version >= 1765)){
     /* For the pse_binary_dump, save entire Bond array to a binary string array
@@ -3607,7 +3607,7 @@ static PyObject *ObjectMoleculeBondAsPyL
 
 static int ObjectMoleculeBondFromPyList(ObjectMolecule * I, PyObject * list)
 {
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   int ok = true;
   int a;
   int stereo, ll = 0;
@@ -3660,7 +3660,7 @@ static int ObjectMoleculeBondFromPyList(
     if(ok)
       ok = PConvPyIntToInt(PyList_GetItem(bond_list, 1), &bond->index[1]);
     if(ok)
-      if((ok = CPythonVal_PConvPyIntToInt_From_List(I->Obj.G, bond_list, 2, &stereo)))
+      if((ok = CPythonVal_PConvPyIntToInt_From_List(I->G, bond_list, 2, &stereo)))
         bond->order = stereo;
     if(ok)
       ok = PConvPyIntToInt(PyList_GetItem(bond_list, 3), &bond->id);
@@ -3684,19 +3684,19 @@ static int ObjectMoleculeBondFromPyList(
   }
   }
   PRINTFB(G, FB_ObjectMolecule, FB_Debugging)
-    " ObjectMoleculeBondFromPyList: ok %d after restore\n", ok ENDFB(G);
+    " %s: ok %d after restore\n", __func__, ok ENDFB(G);
 
   return (ok);
 }
 
 static PyObject *ObjectMoleculeAtomAsPyList(ObjectMolecule * I)
 {
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   PyObject *result = NULL;
   AtomInfoType *ai;
   int a;
 #ifndef PICKLETOOLS
-  int pse_export_version = SettingGetGlobal_f(I->Obj.G, cSetting_pse_export_version) * 1000;
+  int pse_export_version = SettingGetGlobal_f(I->G, cSetting_pse_export_version) * 1000;
 
   if (SettingGetGlobal_b(G, cSetting_pse_binary_dump) && (!pse_export_version || pse_export_version >= 1765)){
     /* For the pse_binary_dump, record all strings in lex and
@@ -3722,7 +3722,7 @@ static PyObject *ObjectMoleculeAtomAsPyL
       totalstlen += lexlen + 1;
     }
     int strinfolen = totalstlen + sizeof(int) * (lexIDs.size() + 1);
-    void *strinfo = Alloc(unsigned char, strinfolen);
+    void *strinfo = pymol::malloc<unsigned char>(strinfolen);
     int *strval = (int*)strinfo;
     *(strval++) = lexIDs.size(); // first write number of strings into binary data string
     char *strpl = (char*)((char*)strinfo + (1 + lexIDs.size()) * sizeof(int));
@@ -3760,7 +3760,7 @@ static PyObject *ObjectMoleculeAtomAsPyL
   result = PyList_New(I->NAtom);
   ai = I->AtomInfo;
   for(a = 0; a < I->NAtom; a++) {
-    PyList_SetItem(result, a, AtomInfoAsPyList(I->Obj.G, ai));
+    PyList_SetItem(result, a, AtomInfoAsPyList(I->G, ai));
     ai++;
   }
   return (PConvAutoNone(result));
@@ -3768,7 +3768,7 @@ static PyObject *ObjectMoleculeAtomAsPyL
 
 static int ObjectMoleculeAtomFromPyList(ObjectMolecule * I, PyObject * list)
 {
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   int ok = true;
   int a, ll = 0;
   AtomInfoType *ai;
@@ -3845,13 +3845,13 @@ static int ObjectMoleculeAtomFromPyList(
     CHECKOK(ok, I->AtomInfo);
     ai = I->AtomInfo;
     for(a = 0; ok && a < I->NAtom; a++) {
-      if(ok)
-        ok = AtomInfoFromPyList(I->Obj.G, ai, PyList_GetItem(list, a));
+      PyObject *val = PyList_GetItem(list, a);
+      ok &= AtomInfoFromPyList(I->G, ai, val);
       ai++;
     }
   }
-  PRINTFB(I->Obj.G, FB_ObjectMolecule, FB_Debugging)
-    " ObjectMoleculeAtomFromPyList: ok %d \n", ok ENDFB(I->Obj.G);
+  PRINTFB(I->G, FB_ObjectMolecule, FB_Debugging)
+    " %s: ok %d \n", __func__, ok ENDFB(I->G);
   return (ok);
 }
 
@@ -3874,8 +3874,10 @@ int ObjectMoleculeNewFromPyList(PyMOLGlo
     I = ObjectMoleculeNew(G, discrete_flag);
   CHECKOK(ok, I);
 
-  if(ok)
-    ok = ObjectFromPyList(G, PyList_GetItem(list, 0), &I->Obj);
+  if(ok){
+    PyObject *val = PyList_GetItem(list, 0);
+    ok = ObjectFromPyList(G, val, I);
+  }
   if(ok)
     ok = PConvPyIntToInt(PyList_GetItem(list, 1), &I->NCSet);
   if(ok)
@@ -3927,7 +3929,7 @@ PyObject *ObjectMoleculeAsPyList(ObjectM
   /* first, dump the atoms */
 
   result = PyList_New(16);
-  PyList_SetItem(result, 0, ObjectAsPyList(&I->Obj));
+  PyList_SetItem(result, 0, ObjectAsPyList(I));
   PyList_SetItem(result, 1, PyInt_FromLong(I->NCSet));
   PyList_SetItem(result, 2, PyInt_FromLong(I->NBond));
   PyList_SetItem(result, 3, PyInt_FromLong(I->NAtom));
@@ -3942,10 +3944,10 @@ PyObject *ObjectMoleculeAsPyList(ObjectM
   PyList_SetItem(result, 12, PyInt_FromLong(I->BondCounter));
   PyList_SetItem(result, 13, PyInt_FromLong(I->AtomCounter));
 
-  float pse_export_version = SettingGetGlobal_f(I->Obj.G, cSetting_pse_export_version);
+  float pse_export_version = SettingGetGlobal_f(I->G, cSetting_pse_export_version);
 
   if(I->DiscreteFlag
-      && (pse_export_version || !SettingGetGlobal_b(I->Obj.G, cSetting_pse_binary_dump))
+      && (pse_export_version || !SettingGetGlobal_b(I->G, cSetting_pse_binary_dump))
       && pse_export_version < 1.7699) {
     int *dcs;
     int a;
@@ -3960,7 +3962,7 @@ PyObject *ObjectMoleculeAsPyList(ObjectM
       }
     }
 
-    dcs = Alloc(int, I->NAtom);
+    dcs = pymol::malloc<int>(I->NAtom);
 
     for(a = 0; a < I->NAtom; a++) {
       cs = I->DiscreteCSet[a];
@@ -4068,7 +4070,7 @@ int ObjectMoleculeConnect(ObjectMolecule
                           int connectModeOverride)
 {
 #define cMULT 1
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   int a, b, c, d, e, f, i, j;
   int a1, a2;
   float *v1, *v2;
@@ -4122,11 +4124,11 @@ int ObjectMoleculeConnect(ObjectMolecule
        * (possibly) supplied CONECT records... */
 
       PRINTFB(G, FB_ObjectMolecule, FB_Blather)
-        " ObjectMoleculeConnect: Searching for bonds amongst %d coordinates.\n",
+        " %s: Searching for bonds amongst %d coordinates.\n", __func__,
         cs->NIndex ENDFB(G);
       if(Feedback(G, FB_ObjectMolecule, FB_Debugging)) {
         for(a = 0; a < cs->NIndex; a++)
-          printf(" ObjectMoleculeConnect: coord %d %8.3f %8.3f %8.3f\n",
+          printf(" %s: coord %d %8.3f %8.3f %8.3f\n", __func__,
                  a, cs->Coord[a * 3], cs->Coord[a * 3 + 1], cs->Coord[a * 3 + 2]);
       }
 
@@ -4137,7 +4139,7 @@ int ObjectMoleculeConnect(ObjectMolecule
       case 2:                  /* distance-based only */  {
           /* distance-based bond location  */
           int violations = 0;
-          int *cnt = Alloc(int, cs->NIndex);
+          int *cnt = pymol::malloc<int>(cs->NIndex);
           int valcnt;
 
 	  CHECKOK(ok, cnt);
@@ -4217,7 +4219,7 @@ int ObjectMoleculeConnect(ObjectMolecule
                               if(violations > (cs->NIndex >> 3)) {
                                 /* if more than 12% of the structure has excessive #'s of bonds... */
                                 PRINTFB(G, FB_ObjectMolecule, FB_Blather)
-                                  " ObjectMoleculeConnect: Assuming chains are discrete...\n"
+                                  " %s: Assuming chains are discrete...\n", __func__
                                   ENDFB(G);
                                 discrete_chains = 1;
                                 repeat = true;
@@ -4226,7 +4228,7 @@ int ObjectMoleculeConnect(ObjectMolecule
                             }
 
                             if(!ai1->hetatm || ai1->resn == G->lex_const.MSE) {
-                              if(AtomInfoSameResidue(I->Obj.G, ai1, ai2)) {
+                              if(AtomInfoSameResidue(I->G, ai1, ai2)) {
                                 /* hookup standard disconnected PDB residue */
                                 assign_pdb_known_residue(G, ai1, ai2, &order);
                               }
@@ -4254,10 +4256,10 @@ int ObjectMoleculeConnect(ObjectMolecule
         break;
       }
       PRINTFB(G, FB_ObjectMolecule, FB_Blather)
-        " ObjectMoleculeConnect: Found %d bonds.\n", nBond ENDFB(G);
+        " %s: Found %d bonds.\n", __func__, nBond ENDFB(G);
       if(Feedback(G, FB_ObjectMolecule, FB_Debugging)) {
         for(a = 0; a < nBond; a++)
-          printf(" ObjectMoleculeConnect: bond %d ind0 %d ind1 %d\n",
+          printf(" %s: bond %d ind0 %d ind1 %d\n", __func__,
                  a, (*bond)[a].index[0], (*bond)[a].index[1]);
       }
     }
@@ -4270,7 +4272,7 @@ int ObjectMoleculeConnect(ObjectMolecule
     int check_conect_all = false;
     int pdb_conect_all = false;
     PRINTFB(G, FB_ObjectMolecule, FB_Blather)
-      " ObjectMoleculeConnect: incorporating explicit bonds. %d %d\n",
+      " %s: incorporating explicit bonds. %d %d\n", __func__,
       nBond, cs->NTmpBond ENDFB(G);
     if((nBond == 0) && (cs->NTmpBond > 0) &&
        bondSearchMode && (connect_mode == 0) && cs->NIndex) {
@@ -4325,10 +4327,10 @@ int ObjectMoleculeConnect(ObjectMolecule
       
       if(pdb_conect_all) {
 	int dummy;
-	if(!SettingGetIfDefined_b(G, I->Obj.Setting, cSetting_pdb_conect_all, &dummy)) {
+	if(!SettingGetIfDefined_b(G, I->Setting, cSetting_pdb_conect_all, &dummy)) {
 	  CSetting **handle = NULL;
-	  if(I->Obj.fGetSettingHandle) {
-	    handle = I->Obj.fGetSettingHandle(&I->Obj, -1);
+	  if(I->fGetSettingHandle) {
+	    handle = I->fGetSettingHandle(I, -1);
 	    if(handle) {
 	      SettingCheckHandle(G, handle);
 	      SettingSet_b(*handle, cSetting_pdb_conect_all, true);
@@ -4367,7 +4369,7 @@ int ObjectMoleculeConnect(ObjectMolecule
   }
 
   PRINTFD(G, FB_ObjectMolecule)
-    " ObjectMoleculeConnect: elminating duplicates with %d bonds...\n", nBond ENDFD;
+    " %s: elminating duplicates with %d bonds...\n", __func__, nBond ENDFD;
 
   if(ok && !I->DiscreteFlag) {
     UtilSortInPlace(G, (*bond), nBond, sizeof(BondType), (UtilOrderFn *) BondInOrder);
@@ -4404,7 +4406,7 @@ int ObjectMoleculeConnect(ObjectMolecule
   }
 
   PRINTFD(G, FB_ObjectMolecule)
-    " ObjectMoleculeConnect: leaving with %d bonds...\n", nBond ENDFD;
+    " %s: leaving with %d bonds...\n", __func__, nBond ENDFD;
   if (ok)
     *nbond = nBond;
   return ok;
@@ -4424,7 +4426,7 @@ int ObjectMoleculeSort(ObjectMolecule *
     int n_bytes = sizeof(int) * I->NAtom;
     int already_in_order = true;
     int i_NAtom = I->NAtom;
-    index = AtomInfoGetSortedIndex(I->Obj.G, I, I->AtomInfo, i_NAtom, &outdex);
+    index = AtomInfoGetSortedIndex(I->G, I, I->AtomInfo, i_NAtom, &outdex);
     CHECKOK(ok, index);
     if (ok){
       for(a = 0; a < i_NAtom; a++) {
@@ -4465,7 +4467,7 @@ int ObjectMoleculeSort(ObjectMolecule *
         }
       }
 
-      ExecutiveUniqueIDAtomDictInvalidate(I->Obj.G);
+      ExecutiveUniqueIDAtomDictInvalidate(I->G);
 
       pymol::vla<AtomInfoType> atInfo(i_NAtom);
       CHECKOK(ok, atInfo);
@@ -4501,9 +4503,9 @@ int ObjectMoleculeSort(ObjectMolecule *
         I->DiscreteAtmToIdx = dAtmToIdx;
       }
     }
-    AtomInfoFreeSortedIndexes(I->Obj.G, &index, &outdex);
+    AtomInfoFreeSortedIndexes(I->G, &index, &outdex);
     if (ok){
-      UtilSortInPlace(I->Obj.G, I->Bond, I->NBond, sizeof(BondType),
+      UtilSortInPlace(I->G, I->Bond, I->NBond, sizeof(BondType),
 		      (UtilOrderFn *) BondInOrder);
       /* sort...important! */
       ObjectMoleculeInvalidate(I, cRepAll, cRepInvAtoms, -1);     /* important */
diff -upNr pymol-open-source-2.3.0/layer2/ObjectMolecule.cpp pymol-open-source-2.3.3/layer2/ObjectMolecule.cpp
--- pymol-open-source-2.3.0/layer2/ObjectMolecule.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectMolecule.cpp	2019-08-22 10:24:47.714595039 +0200
@@ -109,7 +109,7 @@ void ObjectMoleculeRemoveDuplicateBonds(
   }
 
   // get sorted indices
-  int * sorted = Alloc(int, I->NBond);
+  int * sorted = pymol::malloc<int>(I->NBond);
   UtilSortIndexGlobals(G, I->NBond, I->Bond, sorted,
       (UtilOrderFnGlobals *) BondTypeInOrder);
 
@@ -243,8 +243,8 @@ int ObjectMoleculeSetDiscrete(PyMOLGloba
   maxnatom = I->NAtom * I->NCSet;
 
   // mapping (for bonds): atom_old -> atom_new
-  ok_assert(1, aostate2an = Alloc(int, I->NAtom));
-  ok_assert(1, bondseen = Calloc(char , I->NBond));
+  ok_assert(1, aostate2an = pymol::malloc<int>(I->NAtom));
+  ok_assert(1, bondseen = pymol::calloc<char >(I->NBond));
 
   // discrete setup
   I->DiscreteFlag = discrete;
@@ -347,13 +347,13 @@ int ObjectMoleculeSetDiscrete(PyMOLGloba
 
 ok_except1:
   PRINTFB(G, FB_ObjectMolecule, FB_Errors)
-    " ObjectMoleculeSetDiscrete: memory allocation failed\n" ENDFB(G);
+    " %s: memory allocation failed\n", __func__ ENDFB(G);
   return false;
 }
 
 int ObjectMoleculeCheckFullStateSelection(ObjectMolecule * I, int sele, int state)
 {
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   int result = false;
   if((state >= 0) && (state < I->NCSet)) {
     AtomInfoType *ai = I->AtomInfo;
@@ -391,8 +391,8 @@ static char *ObjectMoleculeGetCaption(Ob
   const char *frozen_str = "";
 
   int state = ObjectGetCurrentState((CObject *) I, false);
-  int counter_mode = SettingGet_i(I->Obj.G, I->Obj.Setting, NULL, cSetting_state_counter_mode);
-  int frozen = SettingGetIfDefined_i(I->Obj.G, I->Obj.Setting, cSetting_state, &objState);
+  int counter_mode = SettingGet_i(I->G, I->Setting, NULL, cSetting_state_counter_mode);
+  int frozen = SettingGetIfDefined_i(I->G, I->Setting, cSetting_state, &objState);
 
   /* if frozen print (blue) STATE / NSTATES
    * if not frozen, print STATE/NSTATES
@@ -681,7 +681,7 @@ int ObjectMoleculeXferValences(ObjectMol
 {
   int *matched = NULL;
   int match_found = false;
-  PyMOLGlobals *G = Ia->Obj.G;
+  PyMOLGlobals *G = Ia->G;
   if(Ia == Ib)
     return false;
 
@@ -692,7 +692,7 @@ int ObjectMoleculeXferValences(ObjectMol
     int max_match = Ia->NAtom + Ia->NBond;
     if(max_match < (Ib->NAtom + Ib->NBond))
       max_match = (Ib->NAtom + Ib->NBond);
-    matched = Calloc(int, max_match * 4);
+    matched = pymol::calloc<int>(max_match * 4);
   }
 
   {
@@ -785,21 +785,21 @@ int ObjectMoleculeXferValences(ObjectMol
   return match_found;
 }
 
-void ObjectMoleculeTransformState44f(ObjectMolecule * I, int state, float *matrix,
+void ObjectMoleculeTransformState44f(ObjectMolecule * I, int state, const float *matrix,
                                      int log_trans, int homogenous, int transformed)
 {
   int a;
   float tmp_matrix[16];
   CoordSet *cs;
-  int use_matrices = SettingGet_i(I->Obj.G, I->Obj.Setting, NULL, cSetting_matrix_mode);
+  int use_matrices = SettingGet_i(I->G, I->Setting, NULL, cSetting_matrix_mode);
   if(use_matrices<0) use_matrices = 0;
   if(!use_matrices) {
-    ObjectMoleculeTransformSelection(I, state, -1, matrix, log_trans, I->Obj.Name,
+    ObjectMoleculeTransformSelection(I, state, -1, matrix, log_trans, I->Name,
                                      homogenous, true);
   } else {
     double dbl_matrix[16];
     if(state == -2)
-      state = ObjectGetCurrentState(&I->Obj, false);
+      state = ObjectGetCurrentState(I, false);
     /* ensure homogenous matrix to preserve programmer sanity */
     if(!homogenous) {
       convertTTTfR44d(matrix, dbl_matrix);
@@ -821,7 +821,7 @@ void ObjectMoleculeTransformState44f(Obj
         ObjectStateLeftCombineMatrixR44d(&cs->State, dbl_matrix);
     } else if(I->NCSet == 1) {  /* static singleton state */
       cs = I->CSet[0];
-      if(cs && SettingGet_b(I->Obj.G, I->Obj.Setting, NULL, cSetting_static_singletons)) {
+      if(cs && SettingGet_b(I->G, I->Setting, NULL, cSetting_static_singletons)) {
         ObjectStateLeftCombineMatrixR44d(&cs->State, dbl_matrix);
       }
     }
@@ -839,7 +839,7 @@ static int ObjectMoleculeFixSeleHydrogen
 
   ai0 = I->AtomInfo;
   for(a = 0; a < I->NAtom; a++) {
-    if(SelectorIsMember(I->Obj.G, ai0->selEntry, sele)) {
+    if(SelectorIsMember(I->G, ai0->selEntry, sele)) {
       seleFlag = true;
       break;
     }
@@ -848,15 +848,15 @@ static int ObjectMoleculeFixSeleHydrogen
   if(seleFlag) {
     seleFlag = false;
     if(!ObjectMoleculeVerifyChemistry(I, state)) {
-      ErrMessage(I->Obj.G, " AddHydrogens", "missing chemical geometry information.");
+      ErrMessage(I->G, " AddHydrogens", "missing chemical geometry information.");
     } else {
       if (ok)
 	ok &= ObjectMoleculeUpdateNeighbors(I);
       ai0 = I->AtomInfo;
       for(a = 0; a < I->NAtom; a++) {
         if(!ai0->isHydrogen()) {    /* only do heavies */
-          if(SelectorIsMember(I->Obj.G, ai0->selEntry, sele)) {
-            for(StateIterator iter(I->Obj.G, I->Obj.Setting, state, I->NCSet);
+          if(SelectorIsMember(I->G, ai0->selEntry, sele)) {
+            for(StateIterator iter(I->G, I->Setting, state, I->NCSet);
                 iter.next();) {
               auto cs = I->CSet[iter.state];
               if (!cs)
@@ -1009,7 +1009,7 @@ ObjectMolecule *ObjectMoleculeLoadTRJFil
 
   f = pymol_fopen(fname, "rb");
   if(!f) {
-    ErrMessage(G, "ObjectMoleculeLoadTRJFile", "Unable to open file!");
+    ErrMessage(G, __func__, "Unable to open file!");
   } else {
     if(I->CSTmpl) {
       cs = CoordSetCopy(I->CSTmpl);
@@ -1022,7 +1022,7 @@ ObjectMolecule *ObjectMoleculeLoadTRJFil
     }
 
     if(sele0 >= 0) {            /* build array of cross-references */
-      xref = Alloc(int, I->NAtom);
+      xref = pymol::malloc<int>(I->NAtom);
       c = 0;
       for(a = 0; a < I->NAtom; a++) {
         if(SelectorIsMember(G, I->AtomInfo[a].selEntry, sele0)) {
@@ -1059,7 +1059,7 @@ ObjectMolecule *ObjectMoleculeLoadTRJFil
     }
     PRINTFB(G, FB_ObjectMolecule, FB_Blather)
       " ObjMolLoadTRJFile: Loading from \"%s\".\n", fname ENDFB(G);
-    buffer = (char *) mmalloc(BUFSIZE + 1);     /* 1 MB read buffer */
+    buffer = pymol::malloc<char>(BUFSIZE + 1);     /* 1 MB read buffer */
     p = buffer;
     buffer[0] = 0;
     n_read = 0;
@@ -1348,7 +1348,7 @@ ObjectMolecule *ObjectMoleculeLoadTRJFil
   SceneCountFrames(G);
   if(zoom_flag)
     if(SettingGetGlobal_i(G, cSetting_auto_zoom)) {
-      ExecutiveWindowZoom(G, I->Obj.Name, 0.0, -1, 0, 0, quiet);        /* auto zoom (all states) */
+      ExecutiveWindowZoom(G, I->Name, 0.0, -1, 0, 0, quiet);        /* auto zoom (all states) */
     }
 
   return (I);
@@ -1397,7 +1397,7 @@ ObjectMolecule *ObjectMoleculeLoadRSTFil
 	" ObjMolLoadRSTFile: Loading from \"%s\".\n", fname ENDFB(G);
       p = buffer = FileGetContents(fname, NULL);
       if(!buffer)
-        ok = ErrMessage(G, "ObjectMoleculeLoadRSTFile", "Unable to open file!");
+        ok = ErrMessage(G, __func__, "Unable to open file!");
     }
     if (ok){
       p = nextline(p);
@@ -1477,7 +1477,7 @@ ObjectMolecule *ObjectMoleculeLoadRSTFil
   SceneCountFrames(G);
   if(zoom_flag){
     if(SettingGetGlobal_i(G, cSetting_auto_zoom)) {
-      ExecutiveWindowZoom(G, I->Obj.Name, 0.0, -1, 0, 0, quiet);        /* auto zoom (all states) */
+      ExecutiveWindowZoom(G, I->Name, 0.0, -1, 0, 0, quiet);        /* auto zoom (all states) */
     }
   }
   return (I);
@@ -1890,7 +1890,7 @@ static CoordSet *ObjectMoleculeTOPStr2Co
       p = findflag(G, buffer, "RESIDUE_LABEL", "20a4");
     }
 
-    resn = Alloc(ResName, NRES);
+    resn = pymol::malloc<ResName>(NRES);
 
     b = 0;
     for(a = 0; a < NRES; a++) {
@@ -2395,7 +2395,7 @@ ok_except1:
     if(cset)
       cset->fFree();
     cset = NULL;
-    ErrMessage(G, "ObjectMoleculeTOPStr2CoordSet", "failed");
+    ErrMessage(G, __func__, "failed");
   }
   if(atInfoPtr)
     *atInfoPtr = atInfo;
@@ -2427,7 +2427,7 @@ static ObjectMolecule *ObjectMoleculeRea
         std::swap(atInfo, I->AtomInfo);
     }
     if(ok && isNew) {
-      I->Obj.Color = AtomInfoUpdateAutoColor(G);
+      I->Color = AtomInfoUpdateAutoColor(G);
     }
 
     if (ok)
@@ -2505,10 +2505,10 @@ ObjectMolecule *ObjectMoleculeLoadTOPFil
   buffer = FileGetContents(fname, NULL);
 
   if(!buffer)
-    ErrMessage(G, "ObjectMoleculeLoadTOPFile", "Unable to open file!");
+    ErrMessage(G, __func__, "Unable to open file!");
   else {
     PRINTFB(G, FB_ObjectMolecule, FB_Blather)
-      " ObjectMoleculeLoadTOPFile: Loading from %s.\n", fname ENDFB(G);
+      " %s: Loading from %s.\n", __func__, fname ENDFB(G);
 
     I = ObjectMoleculeReadTOPStr(G, obj, buffer, frame, discrete);
     mfree(buffer);
@@ -2519,8 +2519,8 @@ ObjectMolecule *ObjectMoleculeLoadTOPFil
 
 void ObjectMoleculeSculptClear(ObjectMolecule * I)
 {
-  PRINTFD(I->Obj.G, FB_ObjectMolecule)
-    " ObjectMoleculeSculptClear: entered.\n" ENDFD;
+  PRINTFD(I->G, FB_ObjectMolecule)
+    " %s: entered.\n", __func__ ENDFD;
 
   if(I->Sculpt)
     SculptFree(I->Sculpt);
@@ -2530,19 +2530,19 @@ void ObjectMoleculeSculptClear(ObjectMol
 void ObjectMoleculeSculptImprint(ObjectMolecule * I, int state, int match_state,
                                  int match_by_segment)
 {
-  PRINTFD(I->Obj.G, FB_ObjectMolecule)
-    " ObjectMoleculeUpdateSculpt: entered.\n" ENDFD;
+  PRINTFD(I->G, FB_ObjectMolecule)
+    " %s: entered.\n", __func__ ENDFD;
 
   if(!I->Sculpt)
-    I->Sculpt = SculptNew(I->Obj.G);
+    I->Sculpt = SculptNew(I->G);
   SculptMeasureObject(I->Sculpt, I, state, match_state, match_by_segment);
 }
 
 float ObjectMoleculeSculptIterate(ObjectMolecule * I, int state, int n_cycle,
                                   float *center)
 {
-  PRINTFD(I->Obj.G, FB_ObjectMolecule)
-    " ObjectMoleculeIterateSculpt: entered.\n" ENDFD;
+  PRINTFD(I->G, FB_ObjectMolecule)
+    " %s: entered.\n", __func__ ENDFD;
   if(I->Sculpt) {
     return SculptIterateObject(I->Sculpt, I, state, n_cycle, center);
   } else
@@ -2614,7 +2614,7 @@ int ObjectMoleculeGetPhiPsi(ObjectMolecu
   float v_c[3];
   float v_cm[3];
   float v_np[3];
-  auto G = I->Obj.G;
+  auto G = I->G;
 
   ai = I->AtomInfo;
 
@@ -2712,8 +2712,8 @@ int ObjectMoleculeCheckBondSep(ObjectMol
 
   ObjectMoleculeUpdateNeighbors(I);
 
-  PRINTFD(I->Obj.G, FB_ObjectMolecule)
-    " CBS-Debug: %s %d %d %d\n", I->Obj.Name, a0, a1, dist ENDFD;
+  PRINTFD(I->G, FB_ObjectMolecule)
+    " CBS-Debug: %s %d %d %d\n", I->Name, a0, a1, dist ENDFD;
   depth = 1;
   history[depth] = a0;
   stack[depth] = I->Neighbor[a0] + 1;   /* go to first neighbor */
@@ -2739,7 +2739,7 @@ int ObjectMoleculeCheckBondSep(ObjectMol
     }
     depth--;
   }
-  PRINTFD(I->Obj.G, FB_ObjectMolecule)
+  PRINTFD(I->G, FB_ObjectMolecule)
     " CBS-Debug: result %d\n", result ENDFD;
   return result;
 }
@@ -2748,12 +2748,12 @@ int ObjectMoleculeCheckBondSep(ObjectMol
 /*========================================================================*/
 void ObjectGotoState(ObjectMolecule * I, int state)
 {
-  if((I->NCSet > 1) || (!SettingGetGlobal_b(I->Obj.G, cSetting_static_singletons))) {
+  if((I->NCSet > 1) || (!SettingGetGlobal_b(I->G, cSetting_static_singletons))) {
     if(state > I->NCSet)
       state = I->NCSet - 1;
     if(state < 0)
       state = I->NCSet - 1;
-    SceneSetFrame(I->Obj.G, 0, state);
+    SceneSetFrame(I->G, 0, state);
   }
 }
 
@@ -2763,7 +2763,7 @@ static CObjectState *ObjectMoleculeGetOb
 {
   CObjectState *result = NULL;
   if(state < 0) {
-    state = ObjectGetCurrentState(&I->Obj, true);
+    state = ObjectGetCurrentState(I, true);
   }
   if(state >= 0) {
     if(state < I->NCSet) {
@@ -2783,7 +2783,7 @@ static CSetting **ObjectMoleculeGetSetti
   }
 
   if(state < 0) {
-    return (&I->Obj.Setting);
+    return (&I->Setting);
   } else if(state < I->NCSet) {
     if(I->CSet[state]) {
       return (&I->CSet[state]->Setting);
@@ -2803,12 +2803,12 @@ int ObjectMoleculeSetStateTitle(ObjectMo
   if(state < 0)
     state = I->NCSet - 1;
   if(state >= I->NCSet) {
-    PRINTFB(I->Obj.G, FB_ObjectMolecule, FB_Errors)
-      "Error: invalid state %d\n", state + 1 ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMolecule, FB_Errors)
+      "Error: invalid state %d\n", state + 1 ENDFB(I->G);
 
   } else if(!I->CSet[state]) {
-    PRINTFB(I->Obj.G, FB_ObjectMolecule, FB_Errors)
-      "Error: empty state %d\n", state + 1 ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMolecule, FB_Errors)
+      "Error: empty state %d\n", state + 1 ENDFB(I->G);
   } else {
     UtilNCopy(I->CSet[state]->Name, text, sizeof(WordType));
     result = true;
@@ -2824,11 +2824,11 @@ const char *ObjectMoleculeGetStateTitle(
   if(state < 0)
     state = I->getState();
   if(state < 0 || state >= I->NCSet) {
-    PRINTFB(I->Obj.G, FB_ObjectMolecule, FB_Errors)
-      "Error: invalid state %d\n", state + 1 ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMolecule, FB_Errors)
+      "Error: invalid state %d\n", state + 1 ENDFB(I->G);
   } else if(!I->CSet[state]) {
-    PRINTFB(I->Obj.G, FB_ObjectMolecule, FB_Errors)
-      "Error: empty state %d\n", state + 1 ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectMolecule, FB_Errors)
+      "Error: empty state %d\n", state + 1 ENDFB(I->G);
   } else {
     result = I->CSet[state]->Name;
   }
@@ -2843,9 +2843,9 @@ const char *ObjectMoleculeGetStateTitle(
  */
 int ObjectMolecule::getState() const {
   if (NCSet == 1
-      && SettingGet_b(Obj.G, Obj.Setting, NULL, cSetting_static_singletons))
+      && SettingGet_b(G, Setting, NULL, cSetting_static_singletons))
     return 0;
-  return SettingGet_i(Obj.G, Obj.Setting, NULL, cSetting_state) - 1;
+  return SettingGet_i(G, Setting, NULL, cSetting_state) - 1;
 }
 
 
@@ -2853,7 +2853,7 @@ int ObjectMolecule::getState() const {
 void ObjectMoleculeRenderSele(ObjectMolecule * I, int curState, int sele, int vis_only SELINDICATORARG)
 {
 
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   CoordSet *cs;
   int a, *idx2atm, nIndex;
   float *coord, *v;
@@ -2862,20 +2862,20 @@ void ObjectMoleculeRenderSele(ObjectMole
   int visRep;
   float tmp_matrix[16], v_tmp[3], *matrix = NULL;
   int use_matrices =
-    SettingGet_i(I->Obj.G, I->Obj.Setting, NULL, cSetting_matrix_mode);
+    SettingGet_i(I->G, I->Setting, NULL, cSetting_matrix_mode);
 
   if(use_matrices<0) use_matrices = 0;
 
-  if (SettingGetIfDefined_i(G, I->Obj.Setting, cSetting_all_states, &a)) {
-    curState = a ? -1 : SettingGet_i(G, I->Obj.Setting, NULL, cSetting_state);
-  } else if (SettingGetIfDefined_i(G, I->Obj.Setting, cSetting_state, &a)) {
+  if (SettingGetIfDefined_i(G, I->Setting, cSetting_all_states, &a)) {
+    curState = a ? -1 : SettingGet_i(G, I->Setting, NULL, cSetting_state);
+  } else if (SettingGetIfDefined_i(G, I->Setting, cSetting_state, &a)) {
     curState = a - 1;
   }
 
   if(G->HaveGUI && G->ValidContext) {
     AtomInfoType *atInfo = I->AtomInfo;
 
-    for(StateIterator iter(G, I->Obj.Setting, curState, I->NCSet);
+    for(StateIterator iter(G, I->Setting, curState, I->NCSet);
         iter.next();) {
       if((cs = I->CSet[iter.state])) {
 	    idx2atm = cs->IdxToAtm;
@@ -2887,12 +2887,12 @@ void ObjectMoleculeRenderSele(ObjectMole
 	    } else
 	      matrix = NULL;
 	    
-	    if(I->Obj.TTTFlag) {
+	    if(I->TTTFlag) {
 	      if(!matrix) {
-		convertTTTfR44f(I->Obj.TTT, tmp_matrix);
+		convertTTTfR44f(I->TTT, tmp_matrix);
 	      } else {
 		float ttt[16];
-		convertTTTfR44f(I->Obj.TTT, ttt);
+		convertTTTfR44f(I->TTT, ttt);
 		left_multiply44f44f(ttt, tmp_matrix);
 	      }
 	      matrix = tmp_matrix;
@@ -2961,7 +2961,7 @@ static CoordSet *ObjectMoleculeXYZStr2Co
   atInfo = *atInfoPtr;
 
   p_store = p;
-  p = ncopy(cc, p, 10);
+  p = ncopy(cc, p, MAXLINELEN - 1);
   if(sscanf(cc, "%d", &nAtom) != 1) {
     nAtom = 0;
     tinker_xyz = false;
@@ -3173,7 +3173,7 @@ static CoordSet *ObjectMoleculeXYZStr2Co
     p = nextline(p);
     if(have_n_atom && (atomCount >= nAtom)) {
       int dummy;
-      ncopy(cc, p, 6);
+      ncopy(cc, p, MAXLINELEN - 1);
       if(sscanf(cc, "%d", &dummy) == 1)
         *restart = p;
       break;
@@ -3227,7 +3227,7 @@ int ObjectMoleculeAreAtomsBonded(ObjectM
 /*========================================================================*/
 int ObjectMoleculeRenameAtoms(ObjectMolecule * I, int *flag, int force)
 {
-  PyMOLGlobals * G = I->Obj.G;
+  PyMOLGlobals * G = I->G;
   AtomInfoType *ai;
   int a;
   int result;
@@ -3246,7 +3246,7 @@ int ObjectMoleculeRenameAtoms(ObjectMole
       }
     }
   }
-  result = AtomInfoUniquefyNames(I->Obj.G, NULL, 0, I->AtomInfo, flag, I->NAtom);
+  result = AtomInfoUniquefyNames(I->G, NULL, 0, I->AtomInfo, flag, I->NAtom);
   return result;
 }
 
@@ -3325,7 +3325,7 @@ static int AddCoordinateIntoCoordSet(Obj
 int ObjectMoleculeFuse(ObjectMolecule * I, int index0, ObjectMolecule * src,
                         int index1, int mode, int move_flag)
 {
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   int a;
   AtomInfoType *ai0, *ai1;
   int n, nn;
@@ -3396,7 +3396,7 @@ int ObjectMoleculeFuse(ObjectMolecule *
     auto nai = pymol::vla<AtomInfoType>(src->NAtom);
     /* copy atoms and atom info into a 1:1 direct mapping */
     if (ok)
-      cs = CoordSetNew(I->Obj.G);
+      cs = CoordSetNew(I->G);
     CHECKOK(ok, cs);
     if (ok)
       cs->Coord = VLAlloc(float, scs->NIndex * 3);
@@ -3443,7 +3443,7 @@ int ObjectMoleculeFuse(ObjectMolecule *
     }
 
     if (ok)
-      backup = Alloc(float, cs->NIndex * 3);      /* make untransformed copy of coordinate set */
+      backup = pymol::malloc<float>(cs->NIndex * 3);      /* make untransformed copy of coordinate set */
     CHECKOK(ok, backup);
     if (ok){
       for(a = 0; a < cs->NIndex; a++) {
@@ -3488,8 +3488,8 @@ int ObjectMoleculeFuse(ObjectMolecule *
       cs->enumIndices();
 
     if (ok){
-      d = AtomInfoGetBondLength(I->Obj.G, ai0 + at0, ai1 + at1);
-      AtomInfoUniquefyNames(I->Obj.G, I->AtomInfo, I->NAtom, nai, NULL, cs->NIndex);
+      d = AtomInfoGetBondLength(I->G, ai0 + at0, ai1 + at1);
+      AtomInfoUniquefyNames(I, nai, cs->NIndex);
     }
 
     /* set up tags which will enable use to continue editing bond */
@@ -3553,13 +3553,13 @@ int ObjectMoleculeFuse(ObjectMolecule *
           at1 = a;
       }
       if((at0 >= 0) && (at1 >= 0)) {
-        sprintf(sele1, "%s`%d", I->Obj.Name, at1 + 1);  /* points outward... */
-        sprintf(sele2, "%s`%d", I->Obj.Name, at0 + 1);
-        SelectorGetTmp(I->Obj.G, sele1, s1);
-        SelectorGetTmp(I->Obj.G, sele2, s2);
-        EditorSelect(I->Obj.G, s1, s2, NULL, NULL, false, true, true);
-        SelectorFreeTmp(I->Obj.G, s1);
-        SelectorFreeTmp(I->Obj.G, s2);
+        sprintf(sele1, "%s`%d", I->Name, at1 + 1);  /* points outward... */
+        sprintf(sele2, "%s`%d", I->Name, at0 + 1);
+        SelectorGetTmp(I->G, sele1, s1);
+        SelectorGetTmp(I->G, sele2, s2);
+        EditorSelect(I->G, s1, s2, NULL, NULL, false, true, true);
+        SelectorFreeTmp(I->G, s1);
+        SelectorFreeTmp(I->G, s2);
       }
     }
   }
@@ -3632,7 +3632,7 @@ int ObjectMoleculeAttach(ObjectMolecule
 
   ai = I->AtomInfo + index;
 
-  ok_assert(1, cs = CoordSetNew(I->Obj.G));
+  ok_assert(1, cs = CoordSetNew(I->G));
   ok_assert(1, cs->Coord = VLAlloc(float, 3));
 
   cs->NIndex = 1;
@@ -3649,7 +3649,7 @@ int ObjectMoleculeAttach(ObjectMolecule
   cs->enumIndices();
 
   ok_assert(1, ObjectMoleculePrepareAtom(I, index, nai));
-  d = AtomInfoGetBondLength(I->Obj.G, ai, nai);
+  d = AtomInfoGetBondLength(I->G, ai, nai);
 
   ok_assert(1, ObjectMoleculeMerge(I, std::move(nai),
         cs, false, cAIC_AllMask, true)); // will free nai and cs->TmpLinkBond
@@ -3701,7 +3701,7 @@ int ObjectMoleculeFillOpenValences(Objec
       flag = false;
 
       if (ok)
-	cs = CoordSetNew(I->Obj.G);
+	cs = CoordSetNew(I->G);
       CHECKOK(ok, cs);
       if (ok){
 	cs->Coord = VLAlloc(float, 3);
@@ -3732,7 +3732,7 @@ int ObjectMoleculeFillOpenValences(Objec
 	nai->geom = cAtomInfoSingle;
 	nai->valence = 1;
 	ok &= ObjectMoleculePrepareAtom(I, index, nai);
-	d = AtomInfoGetBondLength(I->Obj.G, ai, nai);
+	d = AtomInfoGetBondLength(I->G, ai, nai);
 	if (ok)
           ok &= ObjectMoleculeMerge(I, std::move(atInfo),
               cs, false, cAIC_AllMask, true);       /* will free nai and cs->TmpLinkBond  */
@@ -4030,17 +4030,17 @@ void ObjectMoleculeCreateSpheroid(Object
   int current;
   int cscount;
   int n_state = 0;
-  sp = I->Obj.G->Sphere->Sphere[1];
+  sp = I->G->Sphere->Sphere[1];
 
   nRow = I->NAtom * sp->nDot;
 
-  center = Alloc(float, I->NAtom * 3);
-  count = Alloc(int, I->NAtom);
-  fsum = Alloc(float, nRow);
-  max_sq = Alloc(float, I->NAtom);
+  center = pymol::malloc<float>(I->NAtom * 3);
+  count = pymol::malloc<int>(I->NAtom);
+  fsum = pymol::malloc<float>(nRow);
+  max_sq = pymol::malloc<float>(I->NAtom);
 
-  spheroid_smooth = SettingGetGlobal_f(I->Obj.G, cSetting_spheroid_smooth);
-  spheroid_fill = SettingGetGlobal_f(I->Obj.G, cSetting_spheroid_fill);
+  spheroid_smooth = SettingGetGlobal_f(I->G, cSetting_spheroid_smooth);
+  spheroid_fill = SettingGetGlobal_f(I->G, cSetting_spheroid_fill);
   /* first compute average coordinate */
 
   if(average < 1)
@@ -4056,11 +4056,11 @@ void ObjectMoleculeCreateSpheroid(Object
     }
 
     if(cscount == average || current == I->NCSet - 1) {
-      PRINTFB(I->Obj.G, FB_ObjectMolecule, FB_Details)
+      PRINTFB(I->G, FB_ObjectMolecule, FB_Details)
         " ObjectMolecule: computing spheroid from states %d to %d.\n",
-        first + 1, last ENDFB(I->Obj.G);
+        first + 1, last ENDFB(I->G);
 
-      spheroid = Alloc(float, nRow);
+      spheroid = pymol::malloc<float>(nRow);
 
       v = center;
       i = count;
@@ -4179,7 +4179,7 @@ void ObjectMoleculeCreateSpheroid(Object
 
       /* now compute surface normals */
 
-      norm = Alloc(float, nRow * 3);
+      norm = pymol::malloc<float>(nRow * 3);
       for(a = 0; a < nRow; a++) {
         zero3f(norm + a * 3);
       }
@@ -4294,9 +4294,9 @@ int ObjectMoleculePrepareAtom(ObjectMole
     ai->b = ai0->b;
     strcpy(ai->alt, ai0->alt);
     ai->inscode = ai0->inscode;
-    LexAssign(I->Obj.G, ai->segi, ai0->segi);
-    LexAssign(I->Obj.G, ai->chain, ai0->chain);
-    LexAssign(I->Obj.G, ai->resn, ai0->resn);
+    LexAssign(I->G, ai->segi, ai0->segi);
+    LexAssign(I->G, ai->chain, ai0->chain);
+    LexAssign(I->G, ai->resn, ai0->resn);
     ai->visRep = ai0->visRep;
     ai->id = -1;
 #ifdef _PYMOL_IP_EXTRAS
@@ -4304,10 +4304,10 @@ int ObjectMoleculePrepareAtom(ObjectMole
 #endif
     ai->rank = -1;
 
-    AtomInfoAssignParameters(I->Obj.G, ai);
+    AtomInfoAssignParameters(I->G, ai);
 
     if (uniquefy) {
-      AtomInfoUniquefyNames(I->Obj.G, I->AtomInfo, I->NAtom, ai, NULL, 1);
+      AtomInfoUniquefyNames(I->G, I->AtomInfo, I->NAtom, ai, NULL, 1);
     }
 
     if((ai->elem[0] == ai0->elem[0]) && (ai->elem[1] == ai0->elem[1]))
@@ -4329,10 +4329,10 @@ int ObjectMoleculePrepareAtom(ObjectMole
       }
       if(ok && !found) {
         /* if no carbon nearby, then color according to the object color */
-        ai->color = I->Obj.Color;
+        ai->color = I->Color;
       }
     } else {
-      AtomInfoAssignColors(I->Obj.G, ai);
+      AtomInfoAssignColors(I->G, ai);
     }
   }
   return ok;
@@ -4372,7 +4372,7 @@ int ObjectMoleculePreposReplAtom(ObjectM
 	      ai1 = I->AtomInfo + a1;
 	      if(ai1->protons != 1)
 		if(ObjectMoleculeGetAtomVertex(I, a, a1, v1)) {
-		  d = AtomInfoGetBondLength(I->Obj.G, ai, ai1);
+		  d = AtomInfoGetBondLength(I->G, ai, ai1);
 		  subtract3f(v0, v1, n0);
 		  normalize3f(n0);
 		  scale3f(n0, d, d0);
@@ -4404,7 +4404,7 @@ int ObjectMoleculePreposReplAtom(ObjectM
 void ObjectMoleculeSaveUndo(ObjectMolecule * I, int state, int log)
 {
   CoordSet *cs;
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   FreeP(I->UndoCoord[I->UndoIter]);
   I->UndoState[I->UndoIter] = -1;
   if(state < 0)
@@ -4414,7 +4414,7 @@ void ObjectMoleculeSaveUndo(ObjectMolecu
   state = state % I->NCSet;
   cs = I->CSet[state];
   if(cs) {
-    I->UndoCoord[I->UndoIter] = Alloc(float, cs->NIndex * 3);
+    I->UndoCoord[I->UndoIter] = pymol::malloc<float>(cs->NIndex * 3);
     memcpy(I->UndoCoord[I->UndoIter], cs->Coord, sizeof(float) * cs->NIndex * 3);
     I->UndoState[I->UndoIter] = state;
     I->UndoNIndex[I->UndoIter] = cs->NIndex;
@@ -4423,8 +4423,8 @@ void ObjectMoleculeSaveUndo(ObjectMolecu
   ExecutiveSetLastObjectEdited(G, (CObject *) I);
   if(log) {
     OrthoLineType line;
-    if(SettingGetGlobal_i(I->Obj.G, cSetting_logging)) {
-      sprintf(line, "cmd.push_undo(\"%s\",%d)\n", I->Obj.Name, state + 1);
+    if(SettingGetGlobal_i(I->G, cSetting_logging)) {
+      sprintf(line, "cmd.push_undo(\"%s\",%d)\n", I->Name, state + 1);
       PLog(G, line, cPLog_no_flush);
     }
   }
@@ -4440,7 +4440,7 @@ void ObjectMoleculeUndo(ObjectMolecule *
 
   FreeP(I->UndoCoord[I->UndoIter]);
   I->UndoState[I->UndoIter] = -1;
-  state = SceneGetState(I->Obj.G);
+  state = SceneGetState(I->G);
   if(state < 0)
     state = 0;
   if(I->NCSet == 1)
@@ -4448,7 +4448,7 @@ void ObjectMoleculeUndo(ObjectMolecule *
   state = state % I->NCSet;
   cs = I->CSet[state];
   if(cs) {
-    I->UndoCoord[I->UndoIter] = Alloc(float, cs->NIndex * 3);
+    I->UndoCoord[I->UndoIter] = pymol::malloc<float>(cs->NIndex * 3);
     memcpy(I->UndoCoord[I->UndoIter], cs->Coord, sizeof(float) * cs->NIndex * 3);
     I->UndoState[I->UndoIter] = state;
     I->UndoNIndex[I->UndoIter] = cs->NIndex;
@@ -4473,7 +4473,7 @@ void ObjectMoleculeUndo(ObjectMolecule *
         I->UndoState[I->UndoIter] = -1;
         FreeP(I->UndoCoord[I->UndoIter]);
         cs->invalidateRep(cRepAll, cRepInvCoord);
-        SceneChanged(I->Obj.G);
+        SceneChanged(I->G);
       }
     }
   }
@@ -4495,11 +4495,11 @@ int ObjectMoleculeAddBond(ObjectMolecule
   ai1 = I->AtomInfo;
   for(a1 = 0; a1 < I->NAtom; a1++) {
     s1 = ai1->selEntry;
-    if(SelectorIsMember(I->Obj.G, s1, sele0)) {
+    if(SelectorIsMember(I->G, s1, sele0)) {
       ai2 = I->AtomInfo;
       for(a2 = 0; a2 < I->NAtom; a2++) {
         s2 = ai2->selEntry;
-        if(SelectorIsMember(I->Obj.G, s2, sele1)) {
+        if(SelectorIsMember(I->G, s2, sele1)) {
           if(!I->Bond){
             I->Bond = VLACalloc(BondType, 1);
 	    BondTypeInit(I->Bond);
@@ -4556,18 +4556,18 @@ int ObjectMoleculeAdjustBonds(ObjectMole
 
       both = 0;
       s = I->AtomInfo[a0].selEntry;
-      if(SelectorIsMember(I->Obj.G, s, sele0))
+      if(SelectorIsMember(I->G, s, sele0))
         both++;
       s = I->AtomInfo[a1].selEntry;
-      if(SelectorIsMember(I->Obj.G, s, sele1))
+      if(SelectorIsMember(I->G, s, sele1))
         both++;
       if(both < 2) {            /* reverse combo */
         both = 0;
         s = I->AtomInfo[a1].selEntry;
-        if(SelectorIsMember(I->Obj.G, s, sele0))
+        if(SelectorIsMember(I->G, s, sele0))
           both++;
         s = I->AtomInfo[a0].selEntry;
-        if(SelectorIsMember(I->Obj.G, s, sele1))
+        if(SelectorIsMember(I->G, s, sele1))
           both++;
       }
 
@@ -4575,7 +4575,7 @@ int ObjectMoleculeAdjustBonds(ObjectMole
         cnt++;
         switch (mode) {
         case 0:                /* cycle */
-          switch(SettingGet_i(I->Obj.G, I->Obj.Setting, NULL, cSetting_editor_bond_cycle_mode)) {
+          switch(SettingGet_i(I->G, I->Setting, NULL, cSetting_editor_bond_cycle_mode)) {
           case 1: /* 1 arom 2 3 */
             switch(b0->order) {
             case 1:
@@ -4649,23 +4649,23 @@ int ObjectMoleculeRemoveBonds(ObjectMole
 
       both = 0;
       s = I->AtomInfo[a0].selEntry;
-      if(SelectorIsMember(I->Obj.G, s, sele0))
+      if(SelectorIsMember(I->G, s, sele0))
         both++;
       s = I->AtomInfo[a1].selEntry;
-      if(SelectorIsMember(I->Obj.G, s, sele1))
+      if(SelectorIsMember(I->G, s, sele1))
         both++;
       if(both < 2) {            /* reverse combo */
         both = 0;
         s = I->AtomInfo[a1].selEntry;
-        if(SelectorIsMember(I->Obj.G, s, sele0))
+        if(SelectorIsMember(I->G, s, sele0))
           both++;
         s = I->AtomInfo[a0].selEntry;
-        if(SelectorIsMember(I->Obj.G, s, sele1))
+        if(SelectorIsMember(I->G, s, sele1))
           both++;
       }
 
       if(both == 2) {
-        AtomInfoPurgeBond(I->Obj.G, b0);
+        AtomInfoPurgeBond(I->G, b0);
         offset--;
         b0++;
         I->AtomInfo[a0].chemFlag = false;
@@ -4695,17 +4695,17 @@ int ObjectMoleculeRemoveBonds(ObjectMole
 /*========================================================================*/
 void ObjectMoleculePurge(ObjectMolecule * I)
 {
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   int a, a0, a1;
   int *oldToNew = NULL;
   int offset = 0;
   BondType *b0, *b1;
   AtomInfoType *ai0, *ai1;
 
-  PRINTFD(I->Obj.G, FB_ObjectMolecule)
+  PRINTFD(I->G, FB_ObjectMolecule)
     " ObjMolPurge-Debug: step 1, delete object selection\n" ENDFD;
 
-  SelectorDelete(G, I->Obj.Name);       /* remove the object selection and free up any selection entries */
+  SelectorDelete(G, I->Name);       /* remove the object selection and free up any selection entries */
   /* note that we don't delete atom selection members -- those may be needed in the new object */
 
   PRINTFD(G, FB_ObjectMolecule)
@@ -4717,10 +4717,10 @@ void ObjectMoleculePurge(ObjectMolecule
   if(I->CSTmpl) {
     CoordSetPurge(I->CSTmpl);
   }
-  PRINTFD(I->Obj.G, FB_ObjectMolecule)
+  PRINTFD(I->G, FB_ObjectMolecule)
     " ObjMolPurge-Debug: step 3, old-to-new mapping\n" ENDFD;
 
-  oldToNew = Alloc(int, I->NAtom);
+  oldToNew = pymol::malloc<int>(I->NAtom);
   ai0 = I->AtomInfo;
   ai1 = I->AtomInfo;
   for(a = 0; a < I->NAtom; a++) {
@@ -4750,7 +4750,7 @@ void ObjectMoleculePurge(ObjectMolecule
 	CoordSetAdjustAtmIdx(I->CSet[a], oldToNew, I->NAtom);
   }
 
-  PRINTFD(I->Obj.G, FB_ObjectMolecule)
+  PRINTFD(I->G, FB_ObjectMolecule)
     " ObjMolPurge-Debug: step 4, bonds\n" ENDFD;
 
   offset = 0;
@@ -4761,7 +4761,7 @@ void ObjectMoleculePurge(ObjectMolecule
     a1 = b0->index[1];
     if(a0 < 0 || a1 < 0 || (oldToNew[a0] < 0) || (oldToNew[a1] < 0)) {
       /* deleting bond */
-      AtomInfoPurgeBond(I->Obj.G, b0);
+      AtomInfoPurgeBond(I->G, b0);
       offset--;
       b0++;
     } else {
@@ -4780,12 +4780,12 @@ void ObjectMoleculePurge(ObjectMolecule
   }
   FreeP(oldToNew);
 
-  PRINTFD(I->Obj.G, FB_ObjectMolecule)
+  PRINTFD(I->G, FB_ObjectMolecule)
     " ObjMolPurge-Debug: step 5, invalidate...\n" ENDFD;
 
   ObjectMoleculeInvalidate(I, cRepAll, cRepInvAtoms, -1);
 
-  PRINTFD(I->Obj.G, FB_ObjectMolecule)
+  PRINTFD(I->G, FB_ObjectMolecule)
     " ObjMolPurge-Debug: leaving...\n" ENDFD;
 
 }
@@ -5046,10 +5046,10 @@ void ObjectMoleculeGuessValences(ObjectM
     cs = I->CSet[state];
   }
   if(cs) {
-    obs_atom = Calloc(ObservedInfo, I->NAtom);
-    obs_bond = Calloc(ObservedInfo, I->NBond);
+    obs_atom = pymol::calloc<ObservedInfo>(I->NAtom);
+    obs_bond = pymol::calloc<ObservedInfo>(I->NBond);
   }
-  flag = Calloc(int, I->NAtom);
+  flag = pymol::calloc<int>(I->NAtom);
   if(flag) {
     if(!flag1) {
       int a, *flag_a = flag;
@@ -5785,9 +5785,9 @@ void ObjectMoleculeGuessValences(ObjectM
     }
   }
   if (warning1 || warning2){
-	  PRINTFB(I->Obj.G, FB_ObjectMolecule, FB_Blather)
-	    " ObjectMoleculeGuessValences(%d,%d): Unreasonable connectivity in heteroatom,\n  unsuccessful in guessing valences.\n", warning1, warning2
-	     ENDFB(I->Obj.G);
+	  PRINTFB(I->G, FB_ObjectMolecule, FB_Blather)
+	    " %s(%d,%d): Unreasonable connectivity in heteroatom,\n  unsuccessful in guessing valences.\n", __func__, warning1, warning2
+	     ENDFB(I->G);
   }
   FreeP(obs_bond);
   FreeP(obs_atom);
@@ -6312,7 +6312,7 @@ void ObjectMoleculeInferChemFromBonds(Ob
   ai = I->AtomInfo;
   for(a = 0; a < I->NAtom; a++) {
     if(!ai->chemFlag) {
-      expect = AtomInfoGetExpectedValence(I->Obj.G, ai);
+      expect = AtomInfoGetExpectedValence(I->G, ai);
       n = I->Neighbor[a];
       nn = I->Neighbor[n++];
       if(ai->geom == 3) {
@@ -6460,12 +6460,12 @@ void ObjectMoleculeInferChemFromBonds(Ob
 
 /*========================================================================*/
 int ObjectMoleculeTransformSelection(ObjectMolecule * I, int state,
-                                     int sele, float *matrix, int log,
+                                     int sele, const float *matrix, int log,
                                      const char *sname, int homogenous, int global)
 {
   /* called from "translate [5,5,5], objSele" */
   /* if sele == -1, then the whole object state is transformed */
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   int a, s;
   int flag = false;
   CoordSet *cs;
@@ -6473,11 +6473,12 @@ int ObjectMoleculeTransformSelection(Obj
   int logging;
   int all_states = false, inp_state;
   int ok = true;
-  float homo_matrix[16], tmp_matrix[16], *input_matrix = matrix;
+  float homo_matrix[16], tmp_matrix[16];
+  const float* input_matrix = matrix;
 
   inp_state = state;
   if(state == -2)
-    state = ObjectGetCurrentState(&I->Obj, false);
+    state = ObjectGetCurrentState(I, false);
   if(state < 0) {
     all_states = true;
     state = -1;
@@ -6493,7 +6494,7 @@ int ObjectMoleculeTransformSelection(Obj
     if(state < I->NCSet) {
       cs = I->CSet[state];
       if(cs) {
-        int use_matrices = SettingGet_i(G, I->Obj.Setting,
+        int use_matrices = SettingGet_i(G, I->Setting,
                                         NULL, cSetting_matrix_mode);
         if(use_matrices<0) use_matrices = 0;
 
@@ -6504,7 +6505,7 @@ int ObjectMoleculeTransformSelection(Obj
           homogenous = true;
         }
 
-        if(global &&((use_matrices && cs->State.Matrix) || I->Obj.TTTFlag)) {
+        if(global &&((use_matrices && cs->State.Matrix) || I->TTTFlag)) {
           /* if input coordinates are in the global system,
              they may need to be converted to local coordinates */
 
@@ -6512,12 +6513,12 @@ int ObjectMoleculeTransformSelection(Obj
 
           /* global to object */
 
-          if(I->Obj.TTTFlag) {
+          if(I->TTTFlag) {
             float ttt[16];
             if(matrix != tmp_matrix) {
               copy44f(matrix, tmp_matrix);
             }
-            convertTTTfR44f(I->Obj.TTT, ttt);
+            convertTTTfR44f(I->TTT, ttt);
             {
               float ttt_inv[16];
               invert_special44f44f(ttt, ttt_inv);
@@ -6596,7 +6597,7 @@ int ObjectMoleculeTransformSelection(Obj
     case cPLog_pml:
       sprintf(line,
               "_ cmd.transform_object('%s',[\\\n_ %15.9f,%15.9f,%15.9f,%15.9f,\\\n_ %15.9f,%15.9f,%15.9f,%15.9f,\\\n_ %15.9f,%15.9f,%15.9f,%15.9f,\\\n_ %15.9f,%15.9f,%15.9f,%15.9f\\\n_     ],%d,%d%s,%d)\n",
-              I->Obj.Name,
+              I->Name,
               matrix[0], matrix[1], matrix[2], matrix[3],
               matrix[4], matrix[5], matrix[6], matrix[7],
               matrix[8], matrix[9], matrix[10], matrix[11],
@@ -6608,7 +6609,7 @@ int ObjectMoleculeTransformSelection(Obj
 
       sprintf(line,
               "cmd.transform_object('%s',[\n%15.9f,%15.9f,%15.9f,%15.9f,\n%15.9f,%15.9f,%15.9f,%15.9f,\n%15.9f,%15.9f,%15.9f,%15.9f,\n%15.9f,%15.9f,%15.9f,%15.9f\n],%d,%d%s,%d)\n",
-              I->Obj.Name,
+              I->Name,
               matrix[0], matrix[1], matrix[2], matrix[3],
               matrix[4], matrix[5], matrix[6], matrix[7],
               matrix[8], matrix[9], matrix[10], matrix[11],
@@ -6632,7 +6633,7 @@ int ObjectMoleculeGetAtomIndex(ObjectMol
     return (-1);
   for(a = 0; a < I->NAtom; a++) {
     s = I->AtomInfo[a].selEntry;
-    if(SelectorIsMember(I->Obj.G, s, sele))
+    if(SelectorIsMember(I->G, s, sele))
       return (a);
   }
   return (-1);
@@ -6846,7 +6847,7 @@ static CoordSet *ObjectMoleculeChemPyMod
   if(atomList && PyList_Check(atomList))
     nAtom = PyList_Size(atomList);
   else
-    ok = ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't get atom list");
+    ok = ErrMessage(G, __func__, "can't get atom list");
 
   if(ok) {
     coord = VLAlloc(float, 3 * nAtom);
@@ -6861,10 +6862,10 @@ static CoordSet *ObjectMoleculeChemPyMod
 
       atom = PyList_GetItem(atomList, a);
       if(!atom)
-        ok = ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't get atom");
+        ok = ErrMessage(G, __func__, "can't get atom");
       crd = PyObject_GetAttrString(atom, "coord");
       if(!crd)
-        ok = ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't get coordinates");
+        ok = ErrMessage(G, __func__, "can't get coordinates");
       else {
         for(c = 0; c < 3; c++) {
           tmp = PySequence_GetItem(crd, c);
@@ -6872,7 +6873,7 @@ static CoordSet *ObjectMoleculeChemPyMod
             ok = PConvPyObjectToFloat(tmp, f++);
           Py_XDECREF(tmp);
           if(!ok) {
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't read coordinates");
+            ErrMessage(G, __func__, "can't read coordinates");
             break;
           }
         }
@@ -6888,7 +6889,7 @@ static CoordSet *ObjectMoleculeChemPyMod
             if(tmp)
               ok = PConvPyObjectToInt(tmp, &ai->id);
             if(!ok)
-              ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet",
+              ErrMessage(G, __func__,
                          "can't read atom identifier");
             Py_XDECREF(tmp);
           } else {
@@ -6908,7 +6909,7 @@ static CoordSet *ObjectMoleculeChemPyMod
           ai->name = LexIdx(G, tmp_word);
         }
         if(!ok)
-          ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't read name");
+          ErrMessage(G, __func__, "can't read name");
         Py_XDECREF(tmp);
       }
 
@@ -6922,7 +6923,7 @@ static CoordSet *ObjectMoleculeChemPyMod
             ai->textType = LexIdx(G, temp);
           }
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't read text_type");
+            ErrMessage(G, __func__, "can't read text_type");
           Py_XDECREF(tmp);
         }
       }
@@ -6937,7 +6938,7 @@ static CoordSet *ObjectMoleculeChemPyMod
             ai->custom = LexIdx(G, temp);
           }
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't read custom");
+            ErrMessage(G, __func__, "can't read custom");
           Py_XDECREF(tmp);
         }
       }
@@ -6948,7 +6949,7 @@ static CoordSet *ObjectMoleculeChemPyMod
           if(tmp)
             ok = PConvPyObjectToFloat(tmp, &ai->vdw);
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't read vdw radius");
+            ErrMessage(G, __func__, "can't read vdw radius");
           Py_XDECREF(tmp);
         } else {
           ai->vdw = 0.0f;
@@ -6960,7 +6961,7 @@ static CoordSet *ObjectMoleculeChemPyMod
           if(tmp)
             ok = PConvPyObjectToFloat(tmp, &ai->elec_radius);
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet",
+            ErrMessage(G, __func__,
                        "can't read elec. radius");
           Py_XDECREF(tmp);
         } else {
@@ -6977,7 +6978,7 @@ static CoordSet *ObjectMoleculeChemPyMod
             ai->stereo = tmp_char;
           }
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't read stereo");
+            ErrMessage(G, __func__, "can't read stereo");
           Py_XDECREF(tmp);
         } else {
           ai->stereo = 0;
@@ -6990,7 +6991,7 @@ static CoordSet *ObjectMoleculeChemPyMod
           if(tmp)
             ok = PConvPyObjectToInt(tmp, &ai->customType);
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet",
+            ErrMessage(G, __func__,
                        "can't read numeric_type");
           Py_XDECREF(tmp);
         } else {
@@ -7004,7 +7005,7 @@ static CoordSet *ObjectMoleculeChemPyMod
           if(tmp)
             ok = PConvPyObjectToChar(tmp, (char *) &ai->formalCharge);
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet",
+            ErrMessage(G, __func__,
                        "can't read formal_charge");
           Py_XDECREF(tmp);
         } else {
@@ -7018,7 +7019,7 @@ static CoordSet *ObjectMoleculeChemPyMod
           if(tmp)
             ok = PConvPyObjectToFloat(tmp, &ai->partialCharge);
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet",
+            ErrMessage(G, __func__,
                        "can't read partial_charge");
           Py_XDECREF(tmp);
         } else {
@@ -7032,7 +7033,7 @@ static CoordSet *ObjectMoleculeChemPyMod
           if(tmp)
             ok = PConvPyObjectToInt(tmp, (int *) &ai->flags);
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't read flags");
+            ErrMessage(G, __func__, "can't read flags");
           Py_XDECREF(tmp);
         } else {
           ai->flags = 0;
@@ -7046,7 +7047,7 @@ static CoordSet *ObjectMoleculeChemPyMod
           ok = PConvPyObjectToStrMaxClean(tmp, buf, sizeof(buf) - 1);
         ai->resn = LexIdx(G, buf);
         if(!ok)
-          ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't read resn");
+          ErrMessage(G, __func__, "can't read resn");
         Py_XDECREF(tmp);
       }
 
@@ -7056,7 +7057,7 @@ static CoordSet *ObjectMoleculeChemPyMod
           ResIdent tmp_ins_code;
           ok = PConvPyObjectToStrMaxClean(tmp, tmp_ins_code, sizeof(ResIdent) - 1);
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't read ins_code");
+            ErrMessage(G, __func__, "can't read ins_code");
           else if(tmp_ins_code[0] != '?') {
             ai->setInscode(tmp_ins_code[0]);
           }
@@ -7069,7 +7070,7 @@ static CoordSet *ObjectMoleculeChemPyMod
           if(tmp)
             ok = PConvPyObjectToInt(tmp, &ai->resv);
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't read resi_number");
+            ErrMessage(G, __func__, "can't read resi_number");
           Py_XDECREF(tmp);
         }
       }
@@ -7081,7 +7082,7 @@ static CoordSet *ObjectMoleculeChemPyMod
           PConvPyObjectToStrMaxClean(tmp, temp, sizeof(OrthoLineType) - 1);
         ai->segi = LexIdx(G, temp);
         if(!ok)
-          ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't read segi");
+          ErrMessage(G, __func__, "can't read segi");
         Py_XDECREF(tmp);
       }
 
@@ -7090,7 +7091,7 @@ static CoordSet *ObjectMoleculeChemPyMod
         if(tmp)
           ok = PConvPyObjectToFloat(tmp, &ai->b);
         if(!ok)
-          ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't read b value");
+          ErrMessage(G, __func__, "can't read b value");
         Py_XDECREF(tmp);
       }
 
@@ -7099,7 +7100,7 @@ static CoordSet *ObjectMoleculeChemPyMod
         if(tmp) {
           ok = PConvPyObjectToFloat(tmp, &ai->b);
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't read u value");
+            ErrMessage(G, __func__, "can't read u value");
           else
             ai->b *= (8 * cPI * cPI);   /* B-factor = 8 pi^2 U-factor */
         }
@@ -7124,7 +7125,7 @@ static CoordSet *ObjectMoleculeChemPyMod
         if(tmp)
           ok = PConvPyObjectToFloat(tmp, &ai->q);
         if(!ok)
-          ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't read occupancy");
+          ErrMessage(G, __func__, "can't read occupancy");
         Py_XDECREF(tmp);
       }
 
@@ -7135,7 +7136,7 @@ static CoordSet *ObjectMoleculeChemPyMod
           PConvPyObjectToStrMaxClean(tmp, temp, sizeof(OrthoLineType) - 1);
         ai->chain = LexIdx(G, temp);
         if(!ok)
-          ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't read chain");
+          ErrMessage(G, __func__, "can't read chain");
         Py_XDECREF(tmp);
       }
 
@@ -7144,7 +7145,7 @@ static CoordSet *ObjectMoleculeChemPyMod
         if(tmp)
           ok = PConvPyObjectToInt(tmp, &hetatm);
         if(!ok)
-          ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't read hetatm");
+          ErrMessage(G, __func__, "can't read hetatm");
         else {
           ai->hetatm = hetatm;
           if(!PTruthCallStr(atom, "has", "flags")) {
@@ -7160,7 +7161,7 @@ static CoordSet *ObjectMoleculeChemPyMod
         if(tmp)
           ok = PConvPyObjectToStrMaxClean(tmp, ai->alt, sizeof(Chain) - 1);
         if(!ok)
-          ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet",
+          ErrMessage(G, __func__,
                      "can't read alternate conformation");
         Py_XDECREF(tmp);
       }
@@ -7170,7 +7171,7 @@ static CoordSet *ObjectMoleculeChemPyMod
         if(tmp)
           ok = PConvPyObjectToStrMaxClean(tmp, ai->elem, sizeof(ElemName) - 1);
         if(!ok)
-          ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't read symbol");
+          ErrMessage(G, __func__, "can't read symbol");
         Py_XDECREF(tmp);
       }
 
@@ -7179,7 +7180,7 @@ static CoordSet *ObjectMoleculeChemPyMod
         if(tmp)
           ok = PConvPyObjectToStrMaxClean(tmp, ai->ssType, sizeof(SSType) - 1);
         if(!ok)
-          ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet",
+          ErrMessage(G, __func__,
                      "can't read secondary structure");
         Py_XDECREF(tmp);
       }
@@ -7209,7 +7210,7 @@ static CoordSet *ObjectMoleculeChemPyMod
           int color_index;
           ok = PConvPyObjectToInt(tmp, &color_index);
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "bad cartoon color info");
+            ErrMessage(G, __func__, "bad cartoon color info");
           else {
             SettingSet(G, cSetting_cartoon_color, color_index, ai);
           }
@@ -7235,7 +7236,7 @@ static CoordSet *ObjectMoleculeChemPyMod
           unsigned int trgb;
           ok = PConvPyObjectToInt(tmp, (signed int *) &trgb);
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "bad cartoon color info");
+            ErrMessage(G, __func__, "bad cartoon color info");
           else {
             char color_name[24];
             sprintf(color_name, "0x%08x", trgb);
@@ -7250,7 +7251,7 @@ static CoordSet *ObjectMoleculeChemPyMod
           unsigned int trgb;
           ok = PConvPyObjectToInt(tmp, (signed int *) &trgb);
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "bad label color info");
+            ErrMessage(G, __func__, "bad label color info");
           else {
             char color_name[24];
             sprintf(color_name, "0x%08x", trgb);
@@ -7265,7 +7266,7 @@ static CoordSet *ObjectMoleculeChemPyMod
           int color_index;
           ok = PConvPyObjectToInt(tmp, &color_index);
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "bad ribbon color info");
+            ErrMessage(G, __func__, "bad ribbon color info");
           else {
             SettingSet(G, cSetting_ribbon_color, color_index, ai);
           }
@@ -7279,7 +7280,7 @@ static CoordSet *ObjectMoleculeChemPyMod
           unsigned int trgb;
           ok = PConvPyObjectToInt(tmp, (signed int *) &trgb);
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "bad cartoon color info");
+            ErrMessage(G, __func__, "bad cartoon color info");
           else {
             char color_name[24];
             sprintf(color_name, "0x%08x", trgb);
@@ -7297,7 +7298,7 @@ static CoordSet *ObjectMoleculeChemPyMod
         if(tmp) {
           ok = PConvPyObjectToInt(tmp, (signed int *) &vis);
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "bad visibility info");
+            ErrMessage(G, __func__, "bad visibility info");
           else {
             atInfo[a].visRep = vis;
 
@@ -7321,7 +7322,7 @@ static CoordSet *ObjectMoleculeChemPyMod
         if(tmp) {
           ok = PConvPyObjectToInt(tmp, (signed int *) &trgb);
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "bad color info");
+            ErrMessage(G, __func__, "bad color info");
           else {
             char color_name[24];
             sprintf(color_name, "0x%08x", trgb);
@@ -7341,7 +7342,7 @@ static CoordSet *ObjectMoleculeChemPyMod
     if(bondList && PyList_Check(bondList))
       nBond = PyList_Size(bondList);
     else
-      ok = ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't get bond list");
+      ok = ErrMessage(G, __func__, "can't get bond list");
 
     if(ok) {
       bond = VLACalloc(BondType, nBond);
@@ -7349,18 +7350,18 @@ static CoordSet *ObjectMoleculeChemPyMod
       for(a = 0; a < nBond; a++) {
         bnd = PyList_GetItem(bondList, a);
         if(!bnd)
-          ok = ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't get bond");
+          ok = ErrMessage(G, __func__, "can't get bond");
         index = PyObject_GetAttrString(bnd, "index");
         if(!index)
           ok =
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't get bond indices");
+            ErrMessage(G, __func__, "can't get bond indices");
         else {
           for(c = 0; c < 2; c++) {
             tmp = PyList_GetItem(index, c);
             if(tmp)
               ok = PConvPyObjectToInt(tmp, &ii->index[c]);
             if(!ok) {
-              ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet",
+              ErrMessage(G, __func__,
                          "can't read coordinates");
               break;
             }
@@ -7372,7 +7373,7 @@ static CoordSet *ObjectMoleculeChemPyMod
           if(tmp)
             ok = PConvPyObjectToInt(tmp, &order);
           if(!ok)
-            ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet", "can't read bond order");
+            ErrMessage(G, __func__, "can't read bond order");
           Py_XDECREF(tmp);
           ii->order = order;
         }
@@ -7420,7 +7421,7 @@ static CoordSet *ObjectMoleculeChemPyMod
               if(tmp)
                 ok = PConvPyObjectToInt(tmp, &ii->id);
               if(!ok)
-                ErrMessage(G, "ObjectMoleculeChemPyModel2CoordSet",
+                ErrMessage(G, __func__,
                            "can't read bond identifier");
               Py_XDECREF(tmp);
             } else {
@@ -7492,7 +7493,7 @@ ObjectMolecule *ObjectMoleculeLoadChemPy
     }
 
     if(isNew) {
-      I->Obj.Color = AtomInfoUpdateAutoColor(G);
+      I->Color = AtomInfoUpdateAutoColor(G);
     }
     cset = ObjectMoleculeChemPyModel2CoordSet(G, model, &atInfo);
 
@@ -8830,7 +8831,7 @@ ObjectMolecule *ObjectMoleculeReadStr(Py
     }
 
     if(isNew) {
-      I->Obj.Color = AtomInfoUpdateAutoColor(G);
+      I->Color = AtomInfoUpdateAutoColor(G);
     }
 
     restart = NULL;
@@ -8945,11 +8946,11 @@ ObjectMolecule *ObjectMoleculeReadStr(Py
         if(successCnt > 1) {
           if(successCnt == 2) {
             PRINTFB(G, FB_ObjectMolecule, FB_Actions)
-              " ObjectMoleculeReadStr: read through molecule %d.\n", 1 ENDFB(G);
+              " %s: read through molecule %d.\n", __func__, 1 ENDFB(G);
           }
           if(UtilShouldWePrintQuantity(successCnt)) {
             PRINTFB(G, FB_ObjectMolecule, FB_Actions)
-              " ObjectMoleculeReadStr: read through molecule %d.\n", successCnt ENDFB(G);
+              " %s: read through molecule %d.\n", __func__, successCnt ENDFB(G);
           }
         }
       }
@@ -8983,7 +8984,7 @@ typedef int CompareFn(PyMOLGlobals *, co
 int ObjectMoleculeMerge(ObjectMolecule * I, pymol::vla<AtomInfoType>&& ai,
 			CoordSet * cs, int bondSearchFlag, int aic_mask, int invalidate)
 {
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   int *index, *outdex, *a2i = NULL, *i2a = NULL;
   BondType *bond = NULL;
   int a, b, lb = 0, ac;
@@ -9178,7 +9179,7 @@ int ObjectMoleculeMerge(ObjectMolecule *
   if(ok && expansionFlag) {           /* expansion flag means we have introduced at least 1 new atom */
     ok &= ObjectMoleculeConnect(I, &nBond, &bond, I->AtomInfo, cs, bondSearchFlag, -1);
     if(nBond) {
-      index = Alloc(int, nBond);
+      index = pymol::malloc<int>(nBond);
       CHECKOK(ok, index);
       c = 0;
       b = 0;
@@ -9306,7 +9307,7 @@ void ObjectMoleculeSeleOp(ObjectMolecule
   int use_matrices = false;
   CoordSet *cs;
   AtomInfoType *ai, *ai0;
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
 #ifndef _PYMOL_NOPY
   PyCodeObject *expr_co = NULL;
   int compileType = Py_single_input;
@@ -9314,7 +9315,7 @@ void ObjectMoleculeSeleOp(ObjectMolecule
 #ifdef _WEBGL
 #endif
   PRINTFD(G, FB_ObjectMolecule)
-    " ObjectMoleculeSeleOp-DEBUG: sele %d op->code %d\n", sele, op->code ENDFD;
+    " %s-DEBUG: sele %d op->code %d\n", __func__, sele, op->code ENDFD;
   if(sele >= 0) {
     const char *errstr = "Alter";
     /* always run on entry */
@@ -9502,14 +9503,14 @@ void ObjectMoleculeSeleOp(ObjectMolecule
     case OMOP_StateVRT:        /* state vertex coordinate */
       {
         int op_i2 = op->i2;
-        int obj_TTTFlag = I->Obj.TTTFlag;
+        int obj_TTTFlag = I->TTTFlag;
         int b_end = I->NCSet;
         if (op->code == OMOP_StateVRT && op->i1 < b_end) {
           b_end = op->i1 + 1;
         }
         if(op_i2) {
           use_matrices =
-            SettingGet_i(I->Obj.G, I->Obj.Setting, NULL, cSetting_matrix_mode);
+            SettingGet_i(I->G, I->Setting, NULL, cSetting_matrix_mode);
           if(use_matrices<0) use_matrices = 0;
         }
         for(a = 0; a < I->NAtom; a++) {
@@ -9542,7 +9543,7 @@ void ObjectMoleculeSeleOp(ObjectMolecule
                 }
               }
               if(obj_TTTFlag) {
-                transformTTT44f3f(I->Obj.TTT, vv2, v1);
+                transformTTT44f3f(I->TTT, vv2, v1);
                 vv2 = v1;
               }
             }
@@ -9576,7 +9577,7 @@ void ObjectMoleculeSeleOp(ObjectMolecule
       }
       break;
     case OMOP_SFIT:            /* state fitting within a single object */
-      vt = Alloc(float, 3 * op->nvv2);  /* temporary (matching) target vertex pointers */
+      vt = pymol::malloc<float>(3 * op->nvv2);  /* temporary (matching) target vertex pointers */
       cnt = 0;
       for(a = 0; a < I->NAtom; a++) {
         s = I->AtomInfo[a].selEntry;
@@ -10034,14 +10035,14 @@ void ObjectMoleculeSeleOp(ObjectMolecule
         float *op_v1 = op->v1;
         int op_i1 = op->i1;
         int op_i2 = op->i2;
-        int obj_TTTFlag = I->Obj.TTTFlag;
+        int obj_TTTFlag = I->TTTFlag;
         int i_NCSet = I->NCSet;
         int i_NAtom = I->NAtom;
         int i_DiscreteFlag = I->DiscreteFlag;
         CoordSet **i_CSet = I->CSet;
         if(op_i2) {
           use_matrices =
-            SettingGet_i(I->Obj.G, I->Obj.Setting, NULL, cSetting_matrix_mode);
+            SettingGet_i(I->G, I->Setting, NULL, cSetting_matrix_mode);
           if(use_matrices<0) use_matrices = 0;
         }
         ai = I->AtomInfo;
@@ -10069,7 +10070,7 @@ void ObjectMoleculeSeleOp(ObjectMolecule
                     }
                   }
                   if(obj_TTTFlag) {
-                    transformTTT44f3f(I->Obj.TTT, coord, v1);
+                    transformTTT44f3f(I->TTT, coord, v1);
                     coord = v1;
                   }
                 }
@@ -10094,14 +10095,14 @@ void ObjectMoleculeSeleOp(ObjectMolecule
         float *op_v2 = op->v2;
         int op_i1 = op->i1;
         int op_i2 = op->i2;
-        int obj_TTTFlag = I->Obj.TTTFlag;
+        int obj_TTTFlag = I->TTTFlag;
         int i_NCSet = I->NCSet;
         int i_NAtom = I->NAtom;
         int i_DiscreteFlag = I->DiscreteFlag;
         CoordSet **i_CSet = I->CSet;
         if(op_i2) {
           use_matrices =
-            SettingGet_i(I->Obj.G, I->Obj.Setting, NULL, cSetting_matrix_mode);
+            SettingGet_i(I->G, I->Setting, NULL, cSetting_matrix_mode);
           if(use_matrices<0) use_matrices = 0;
         }
         ai = I->AtomInfo;
@@ -10126,7 +10127,7 @@ void ObjectMoleculeSeleOp(ObjectMolecule
                     }
                   }
                   if(obj_TTTFlag) {
-                    transformTTT44f3f(I->Obj.TTT, coord, v1);
+                    transformTTT44f3f(I->TTT, coord, v1);
                     coord = v1;
                   }
                 }
@@ -10179,7 +10180,7 @@ void ObjectMoleculeSeleOp(ObjectMolecule
           }
           break;
         }
-        use_matrices = SettingGet_i(I->Obj.G, I->Obj.Setting, NULL, cSetting_matrix_mode);
+        use_matrices = SettingGet_i(I->G, I->Setting, NULL, cSetting_matrix_mode);
         if(use_matrices<0) use_matrices = 0;
         ai = I->AtomInfo;
 
@@ -10237,15 +10238,15 @@ void ObjectMoleculeSeleOp(ObjectMolecule
                 switch (op->i2) {
                 case cVis_HIDE:
                   ai->visRep &= ~(op->i1);
-                  I->Obj.visRep &= ~(op->i1); // cell
+                  I->visRep &= ~(op->i1); // cell
                   break;
                 case cVis_SHOW:
                   ai->visRep |= op->i1;
-                  I->Obj.visRep |= op->i1; // cell
+                  I->visRep |= op->i1; // cell
                   break;
                 case cVis_AS:
                   ai->visRep = op->i1;
-                  I->Obj.visRep = op->i1; // cell
+                  I->visRep = op->i1; // cell
                   break;
                 }
                 break;
@@ -10286,7 +10287,7 @@ void ObjectMoleculeSeleOp(ObjectMolecule
 			  cs = I->CSet[0];
 			}
 #ifndef _PYMOL_NOPY
-			if(PLabelAtom(I->Obj.G, I, cs, expr_co, a)) {
+			if(PLabelAtom(I->G, I, cs, expr_co, a)) {
 			  if (ai->label){
 			    op->i1++; /* only if the string has been set, report labelled */
 			  }
@@ -10302,7 +10303,7 @@ void ObjectMoleculeSeleOp(ObjectMolecule
                       break;
                     case cExecutiveLabelEvalAlt:
 		      {
-			if(PLabelAtomAlt(I->Obj.G, &I->AtomInfo[a], I->Obj.Name, op->s1, a)) {
+			if(PLabelAtomAlt(I->G, &I->AtomInfo[a], I->Name, op->s1, a)) {
 			  if (ai->label){
 			    op->i1++; /* only if the string has been set, report labelled */
 			  }
@@ -10335,7 +10336,7 @@ void ObjectMoleculeSeleOp(ObjectMolecule
 		  }
 #ifndef _PYMOL_NOPY
                   if(PAlterAtom
-                     (I->Obj.G, I, cs, expr_co, op->i2, a,
+                     (I->G, I, cs, expr_co, op->i2, a,
                       op->py_ob1))
                     op->i1++;
                   else
@@ -10353,7 +10354,7 @@ void ObjectMoleculeSeleOp(ObjectMolecule
                       a1 = cs->atmToIdx(a);
                       if(a1 >= 0) {
 #ifndef _PYMOL_NOPY
-                        if(PAlterAtomState(I->Obj.G, expr_co, op->i3,
+                        if(PAlterAtomState(I->G, expr_co, op->i3,
                                            I, cs, a, a1, op->i2, op->py_ob1)) {
                           op->i1++;
                           hit_flag = true;
@@ -10384,7 +10385,7 @@ void ObjectMoleculeSeleOp(ObjectMolecule
               cs = I->CSet[op->cs1];
             } else if(op->include_static_singletons) {
               if((I->NCSet == 1)
-                 && (SettingGet_b(G, NULL, I->Obj.Setting, cSetting_static_singletons))) {
+                 && (SettingGet_b(G, NULL, I->Setting, cSetting_static_singletons))) {
                 cs = I->CSet[0];        /*treat static singletons as present in each state */
               }
             }
@@ -10410,8 +10411,8 @@ void ObjectMoleculeSeleOp(ObjectMolecule
                           coord = v1;
                         }
                       }
-                      if(I->Obj.TTTFlag) {
-                        transformTTT44f3f(I->Obj.TTT, coord, v1);
+                      if(I->TTTFlag) {
+                        transformTTT44f3f(I->TTT, coord, v1);
                         coord = v1;
                       }
                     }
@@ -10436,8 +10437,8 @@ void ObjectMoleculeSeleOp(ObjectMolecule
                           coord = v1;
                         }
                       }
-                      if(I->Obj.TTTFlag) {
-                        transformTTT44f3f(I->Obj.TTT, coord, v1);
+                      if(I->TTTFlag) {
+                        transformTTT44f3f(I->TTT, coord, v1);
                         coord = v1;
                       }
                     }
@@ -10474,8 +10475,8 @@ void ObjectMoleculeSeleOp(ObjectMolecule
                           coord = v1;
                         }
                       }
-                      if(I->Obj.TTTFlag) {
-                        transformTTT44f3f(I->Obj.TTT, coord, v1);
+                      if(I->TTTFlag) {
+                        transformTTT44f3f(I->TTT, coord, v1);
                         coord = v1;
                       }
                     }
@@ -10516,8 +10517,8 @@ void ObjectMoleculeSeleOp(ObjectMolecule
                           coord = v1;
                         }
                       }
-                      if(I->Obj.TTTFlag) {
-                        transformTTT44f3f(I->Obj.TTT, coord, v1);
+                      if(I->TTTFlag) {
+                        transformTTT44f3f(I->TTT, coord, v1);
                         coord = v1;
                       }
                     }
@@ -10544,8 +10545,8 @@ void ObjectMoleculeSeleOp(ObjectMolecule
                           coord = v1;
                         }
                       }
-                      if(I->Obj.TTTFlag) {
-                        transformTTT44f3f(I->Obj.TTT, coord, v1);
+                      if(I->TTTFlag) {
+                        transformTTT44f3f(I->TTT, coord, v1);
                         coord = v1;
                       }
                     }
@@ -10612,8 +10613,8 @@ void ObjectMoleculeSeleOp(ObjectMolecule
                             coord = v1;
                           }
                         }
-                        if(I->Obj.TTTFlag) {
-                          transformTTT44f3f(I->Obj.TTT, coord, v1);
+                        if(I->TTTFlag) {
+                          transformTTT44f3f(I->TTT, coord, v1);
                           coord = v1;
                         }
                       }
@@ -10654,8 +10655,8 @@ void ObjectMoleculeSeleOp(ObjectMolecule
                             coord = v1;
                           }
                         }
-                        if(I->Obj.TTTFlag) {
-                          transformTTT44f3f(I->Obj.TTT, coord, v1);
+                        if(I->TTTFlag) {
+                          transformTTT44f3f(I->TTT, coord, v1);
                           coord = v1;
                         }
                       }
@@ -10779,7 +10780,7 @@ void ObjectMoleculeSeleOp(ObjectMolecule
     if(hit_flag) {
       switch (op->code) {
       case OMOP_COLR:
-        ExecutiveUpdateColorDepends(I->Obj.G, I);
+        ExecutiveUpdateColorDepends(I->G, I);
         break;
       case OMOP_TTTF:
         ObjectMoleculeTransformTTTf(I, op->ttt, -1);
@@ -10802,7 +10803,7 @@ void ObjectMoleculeSeleOp(ObjectMolecule
         ObjectMoleculeSaveUndo(I, op->i1, false);
         break;
       case OMOP_OnOff:
-        ExecutiveSetObjVisib(G, I->Obj.Name, op->i1, false);
+        ExecutiveSetObjVisib(G, I->Name, op->i1, false);
         break;
       case OMOP_RevalenceFromSource:
         if(ObjectMoleculeXferValences(I, op->i1, op->i2,
@@ -10813,8 +10814,8 @@ void ObjectMoleculeSeleOp(ObjectMolecule
         break;
       case OMOP_RevalenceByGuessing:
         {
-          int *flag1 = Calloc(int, I->NAtom);
-          int *flag2 = Calloc(int, I->NAtom);
+          int *flag1 = pymol::calloc<int>(I->NAtom);
+          int *flag2 = pymol::calloc<int>(I->NAtom);
           if(flag1 && flag2) {
             int a;
             int *f1 = flag1;
@@ -10861,12 +10862,12 @@ void ObjectMoleculeSeleOp(ObjectMolecule
 /*========================================================================*/
 void ObjectMoleculeGetAtomSele(ObjectMolecule * I, int index, char *buffer)
 {
-  PyMOLGlobals * G = I->Obj.G;
+  PyMOLGlobals * G = I->G;
   AtomInfoType *ai;
   ai = I->AtomInfo + index;
   char inscode_str[2] = { ai->inscode, '\0' };
 
-  snprintf(buffer, OrthoLineLength, "/%s/%s/%s/%s`%d%s/%s`%s", I->Obj.Name,
+  snprintf(buffer, OrthoLineLength, "/%s/%s/%s/%s`%d%s/%s`%s", I->Name,
       LexStr(G, ai->segi),
       LexStr(G, ai->chain),
       LexStr(G, ai->resn), ai->resv, inscode_str,
@@ -10890,10 +10891,10 @@ void ObjectMoleculeGetAtomSeleLog(Object
 {
   char *p = quote ? buffer + 1 : buffer;
 
-  if(SettingGetGlobal_b(I->Obj.G, cSetting_robust_logs)) {
+  if(SettingGetGlobal_b(I->G, cSetting_robust_logs)) {
     ObjectMoleculeGetAtomSele(I, index, p);
   } else {
-    sprintf(p, "(%s`%d)", I->Obj.Name, index + 1);
+    sprintf(p, "(%s`%d)", I->Name, index + 1);
   }
 
   if (quote) {
@@ -10911,20 +10912,20 @@ void ObjectMoleculeGetAtomSeleFast(Objec
 
   if(ai->segi) {
     strcpy(segi, "s;");
-    strcat(segi, LexStr(I->Obj.G, ai->segi));
+    strcat(segi, LexStr(I->G, ai->segi));
   } else {
     strcpy(segi, "s;''");
   }
   if(ai->chain) {
     strcpy(chain, "c;");
-    strcat(chain, LexStr(I->Obj.G, ai->chain));
+    strcat(chain, LexStr(I->G, ai->chain));
   } else {
     strcpy(chain, "c;''");
   }
   sprintf(resi, "i;%d%c", ai->resv, ai->inscode);
   if(ai->name) {
     strcpy(name, "n;");
-    strcat(name, LexStr(I->Obj.G, ai->name));
+    strcat(name, LexStr(I->G, ai->name));
   } else {
     strcpy(name, "n;''");
   }
@@ -10934,7 +10935,7 @@ void ObjectMoleculeGetAtomSeleFast(Objec
   } else {
     strcpy(alt, "alt ''");
   }
-  sprintf(buffer, "(%s&%s&%s&%s&%s&%s)", I->Obj.Name, segi, chain, resi, name, alt);
+  sprintf(buffer, "(%s&%s&%s&%s&%s&%s)", I->Name, segi, chain, resi, name, alt);
 }
 
 
@@ -10989,7 +10990,7 @@ static void ObjMolCoordSetUpdateSpawn(Py
 static void ObjectMoleculeUpdate(ObjectMolecule * I)
 {
   int a; /*, ok; */
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
 
   OrthoBusyPrime(G);
   /* if the cached representation is invalid, reset state */
@@ -11015,9 +11016,9 @@ static void ObjectMoleculeUpdate(ObjectM
     int start = 0;
     int stop = I->NCSet;
     /* set start and stop given an object */
-    ObjectAdjustStateRebuildRange(&I->Obj, &start, &stop);
+    ObjectAdjustStateRebuildRange(I, &start, &stop);
     if((I->NCSet == 1)
-       && (SettingGet_b(G, I->Obj.Setting, NULL, cSetting_static_singletons))) {
+       && (SettingGet_b(G, I->Setting, NULL, cSetting_static_singletons))) {
       start = 0;
       stop = 1;
     }
@@ -11041,7 +11042,7 @@ static void ObjectMoleculeUpdate(ObjectM
           if((a<I->NCSet) && I->CSet[a])
             cnt++;
         {
-          CCoordSetUpdateThreadInfo *thread_info = Alloc(CCoordSetUpdateThreadInfo, cnt);
+          CCoordSetUpdateThreadInfo *thread_info = pymol::malloc<CCoordSetUpdateThreadInfo>(cnt);
           if(thread_info) {
             cnt = 0;
             for(a = start; a < stop; a++) {
@@ -11066,14 +11067,14 @@ static void ObjectMoleculeUpdate(ObjectM
             OrthoBusySlow(G, a, I->NCSet);
             PRINTFB(G, FB_ObjectMolecule, FB_Blather)
               " ObjectMolecule-DEBUG: updating representations for state %d of \"%s\".\n",
-              a + 1, I->Obj.Name ENDFB(G);
+              a + 1, I->Name ENDFB(G);
             I->CSet[a]->update(a);
           }
         }
       }
     }
     /* if the unit cell is shown, redraw it */
-    if((I->Obj.visRep & cRepCellBit)) {
+    if((I->visRep & cRepCellBit)) {
       if(I->Symmetry) {
         if(I->Symmetry->Crystal) {
           CGOFree(I->UnitCellCGO);
@@ -11084,15 +11085,15 @@ static void ObjectMoleculeUpdate(ObjectM
   } /* end block */
 
   PRINTFD(G, FB_ObjectMolecule)
-    " ObjectMolecule: updates complete for object %s.\n", I->Obj.Name ENDFD;
+    " ObjectMolecule: updates complete for object %s.\n", I->Name ENDFD;
 }
 
 /*========================================================================*/
 void ObjectMoleculeInvalidate(ObjectMolecule * I, int rep, int level, int state)
 {
   int a;
-  PRINTFD(I->Obj.G, FB_ObjectMolecule)
-    " ObjectMoleculeInvalidate: entered. rep: %d level: %d\n", rep, level ENDFD;
+  PRINTFD(I->G, FB_ObjectMolecule)
+    " %s: entered. rep: %d level: %d\n", __func__, rep, level ENDFD;
 
   if(level >= cRepInvVisib) {
     I->RepVisCacheValid = false;
@@ -11106,11 +11107,11 @@ void ObjectMoleculeInvalidate(ObjectMole
     }
     ObjectMoleculeUpdateNonbonded(I);
     if(level >= cRepInvAtoms) {
-      SelectorUpdateObjectSele(I->Obj.G, I);
+      SelectorUpdateObjectSele(I->G, I);
     }
   }
-  PRINTFD(I->Obj.G, FB_ObjectMolecule)
-    " ObjectMoleculeInvalidate: invalidating representations...\n" ENDFD;
+  PRINTFD(I->G, FB_ObjectMolecule)
+    " %s: invalidating representations...\n", __func__ ENDFD;
 
   if ( level >= cRepInvColor ) { 
     /* after label, this gets called, so we shouldn't invalidate types b/c PYMOL-317
@@ -11136,8 +11137,8 @@ void ObjectMoleculeInvalidate(ObjectMole
     }
   }
   
-  PRINTFD(I->Obj.G, FB_ObjectMolecule)
-    " ObjectMoleculeInvalidate: leaving...\n" ENDFD;
+  PRINTFD(I->G, FB_ObjectMolecule)
+    " %s: leaving...\n", __func__ ENDFD;
 
 }
 
@@ -11167,7 +11168,7 @@ int ObjectMoleculeMoveAtom(ObjectMolecul
                            int log)
 {
   int result = 0;
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   CoordSet *cs;
   if(!(I->AtomInfo[index].protekted == 1)) {
     if(state < 0)
@@ -11175,7 +11176,7 @@ int ObjectMoleculeMoveAtom(ObjectMolecul
     if(I->NCSet == 1)
       state = 0;
     state = state % I->NCSet;
-    if((!I->CSet[state]) && (SettingGet_b(G, I->Obj.Setting, NULL, cSetting_all_states)))
+    if((!I->CSet[state]) && (SettingGet_b(G, I->Setting, NULL, cSetting_all_states)))
       state = 0;
     cs = I->CSet[state];
     if(cs) {
@@ -11209,7 +11210,7 @@ int ObjectMoleculeMoveAtomLabel(ObjectMo
       state = 0;
     state = state % I->NCSet;
     if((!I->CSet[state])
-       && (SettingGet_b(I->Obj.G, I->Obj.Setting, NULL, cSetting_all_states)))
+       && (SettingGet_b(I->G, I->Setting, NULL, cSetting_all_states)))
       state = 0;
     cs = I->CSet[state];
     if(cs) {
@@ -11225,8 +11226,8 @@ int ObjectMoleculeMoveAtomLabel(ObjectMo
 int ObjectMoleculeInitBondPath(ObjectMolecule * I, ObjectMoleculeBPRec * bp)
 {
   int a;
-  bp->dist = Alloc(int, I->NAtom);
-  bp->list = Alloc(int, I->NAtom);
+  bp->dist = pymol::malloc<int>(I->NAtom);
+  bp->list = pymol::malloc<int>(I->NAtom);
   for(a = 0; a < I->NAtom; a++)
     bp->dist[a] = -1;
   bp->n_atom = 0;
@@ -11421,14 +11422,14 @@ int ObjectMoleculeGetAtomVertex(ObjectMo
 {
   int result = 0;
   if(state < 0)
-    state = SettingGet_i(I->Obj.G, NULL, I->Obj.Setting, cSetting_state) - 1;
+    state = SettingGet_i(I->G, NULL, I->Setting, cSetting_state) - 1;
   if(state < 0)
-    state = SceneGetState(I->Obj.G);
+    state = SceneGetState(I->G);
   if(I->NCSet == 1)
     state = 0;                  /* static singletons always active here it seems */
   state = state % I->NCSet;
   if((!I->CSet[state])
-     && (SettingGet_b(I->Obj.G, I->Obj.Setting, NULL, cSetting_all_states)))
+     && (SettingGet_b(I->G, I->Setting, NULL, cSetting_all_states)))
     state = 0;
   if(I->CSet[state])
     result = CoordSetGetAtomVertex(I->CSet[state], index, v);
@@ -11446,17 +11447,17 @@ int ObjectMoleculeGetAtomTxfVertex(Objec
     cs = I->DiscreteCSet[index];
   }
   if(state < 0){
-    state = SettingGet_i(I->Obj.G, NULL, I->Obj.Setting, cSetting_state) - 1;
+    state = SettingGet_i(I->G, NULL, I->Setting, cSetting_state) - 1;
   }
   if(state < 0)
-    state = SceneGetState(I->Obj.G);
+    state = SceneGetState(I->G);
   if(I->NCSet == 1)
     state = 0;                  /* static singletons always active here it seems */
   state = state % I->NCSet;
   {
     if (!cs)
       cs = I->CSet[state];
-    if((!cs) && (SettingGet_b(I->Obj.G, I->Obj.Setting, NULL, cSetting_all_states))) {
+    if((!cs) && (SettingGet_b(I->G, I->Setting, NULL, cSetting_all_states))) {
       state = 0;
       cs = I->CSet[state];
     }
@@ -11472,14 +11473,14 @@ int ObjectMoleculeSetAtomVertex(ObjectMo
 {
   int result = 0;
   if(state < 0)
-    state = SettingGet_i(I->Obj.G, NULL, I->Obj.Setting, cSetting_state) - 1;
+    state = SettingGet_i(I->G, NULL, I->Setting, cSetting_state) - 1;
   if(state < 0)
-    state = SceneGetState(I->Obj.G);
+    state = SceneGetState(I->G);
   if(I->NCSet == 1)
     state = 0;
   state = state % I->NCSet;
   if((!I->CSet[state])
-     && (SettingGet_b(I->Obj.G, I->Obj.Setting, NULL, cSetting_all_states)))
+     && (SettingGet_b(I->G, I->Setting, NULL, cSetting_all_states)))
     state = 0;
   if(I->CSet[state])
     result = CoordSetSetAtomVertex(I->CSet[state], index, v);
@@ -11490,25 +11491,25 @@ int ObjectMoleculeSetAtomVertex(ObjectMo
 /*========================================================================*/
 static void ObjectMoleculeRender(ObjectMolecule * I, RenderInfo * info)
 {
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   int state = info->state;
   CRay *ray = info->ray;
   auto pick = info->pick;
   int pass = info->pass;
   CoordSet *cs;
   int pop_matrix = false;
-  int use_matrices = SettingGet_i(I->Obj.G, I->Obj.Setting, NULL, cSetting_matrix_mode);
+  int use_matrices = SettingGet_i(I->G, I->Setting, NULL, cSetting_matrix_mode);
   if(use_matrices<0) use_matrices = 0;
-  PRINTFD(I->Obj.G, FB_ObjectMolecule)
-    " ObjectMolecule: rendering %s pass %d...\n", I->Obj.Name, pass ENDFD;
+  PRINTFD(I->G, FB_ObjectMolecule)
+    " ObjectMolecule: rendering %s pass %d...\n", I->Name, pass ENDFD;
 
-  ObjectPrepareContext(&I->Obj, info);
+  ObjectPrepareContext(I, info);
 
-  if(I->UnitCellCGO && (I->Obj.visRep & cRepCellBit)) {
+  if(I->UnitCellCGO && (I->visRep & cRepCellBit)) {
     if(ray) {
       /* need to apply object state matrix here */
-      int ok = CGORenderRay(I->UnitCellCGO, ray, info, ColorGet(I->Obj.G, I->Obj.Color),
-			    NULL, I->Obj.Setting, NULL);
+      int ok = CGORenderRay(I->UnitCellCGO, ray, info, ColorGet(I->G, I->Color),
+			    NULL, I->Setting, NULL);
       if (!ok){
 	CGOFree(I->UnitCellCGO);
       }
@@ -11516,14 +11517,14 @@ static void ObjectMoleculeRender(ObjectM
       if(pick) {
       } else {
         /* need to apply object state matrix here */
-        ObjectUseColor(&I->Obj);
-        CGORenderGL(I->UnitCellCGO, ColorGet(I->Obj.G, I->Obj.Color),
-                    I->Obj.Setting, NULL, info, NULL);
+        ObjectUseColor(I);
+        CGORenderGL(I->UnitCellCGO, ColorGet(I->G, I->Color),
+                    I->Setting, NULL, info, NULL);
       }
     }
   }
 
-  for(StateIterator iter(G, I->Obj.Setting, state, I->NCSet); iter.next();) {
+  for(StateIterator iter(G, I->Setting, state, I->NCSet); iter.next();) {
     cs = I->CSet[iter.state];
     if(cs) {
       if(use_matrices)
@@ -11533,8 +11534,8 @@ static void ObjectMoleculeRender(ObjectM
         ObjectStatePopMatrix(&cs->State, info);
     }
   }
-  PRINTFD(I->Obj.G, FB_ObjectMolecule)
-    " ObjectMolecule: rendering complete for object %s.\n", I->Obj.Name ENDFD;
+  PRINTFD(I->G, FB_ObjectMolecule)
+    " ObjectMolecule: rendering complete for object %s.\n", I->Name ENDFD;
 }
 
 
@@ -11543,10 +11544,10 @@ void ObjectMoleculeDummyUpdate(ObjectMol
 {
   switch (mode) {
   case cObjectMoleculeDummyOrigin:
-    SceneOriginGet(I->Obj.G, I->CSet[0]->Coord);
+    SceneOriginGet(I->G, I->CSet[0]->Coord);
     break;
   case cObjectMoleculeDummyCenter:
-    SceneGetCenter(I->Obj.G, I->CSet[0]->Coord);
+    SceneGetCenter(I->G, I->CSet[0]->Coord);
     break;
   }
 }
@@ -11638,7 +11639,7 @@ ObjectMolecule *ObjectMoleculeNew(PyMOLG
   if (!ok)
     return NULL;
   ObjectInit(G, (CObject *) I);
-  I->Obj.type = cObjectMolecule;
+  I->type = cObjectMolecule;
   I->CSet = VLACalloc(CoordSet *, 10); /* auto-zero */
   CHECKOK(ok, I->CSet);
   if (!ok){
@@ -11664,20 +11665,20 @@ ObjectMolecule *ObjectMoleculeNew(PyMOLG
     I->DiscreteAtmToIdx = NULL;
     I->DiscreteCSet = NULL;
   }
-  I->Obj.fRender = (void (*)(CObject *, RenderInfo * info)) ObjectMoleculeRender;
-  I->Obj.fFree = (void (*)(CObject *)) ObjectMoleculeFree;
-  I->Obj.fUpdate = (void (*)(CObject *)) ObjectMoleculeUpdate;
-  I->Obj.fGetNFrame = (int (*)(CObject *)) ObjectMoleculeGetNFrames;
-  I->Obj.fInvalidate = (void (*)(CObject *, int rep, int level, int state))
+  I->fRender = (void (*)(CObject *, RenderInfo * info)) ObjectMoleculeRender;
+  I->fFree = (void (*)(CObject *)) ObjectMoleculeFree;
+  I->fUpdate = (void (*)(CObject *)) ObjectMoleculeUpdate;
+  I->fGetNFrame = (int (*)(CObject *)) ObjectMoleculeGetNFrames;
+  I->fInvalidate = (void (*)(CObject *, int rep, int level, int state))
     ObjectMoleculeInvalidate;
-  I->Obj.fDescribeElement = (void (*)(CObject *, int index, char *buffer))
+  I->fDescribeElement = (void (*)(CObject *, int index, char *buffer))
     ObjectMoleculeDescribeElement;
-  I->Obj.fGetSettingHandle = (CSetting ** (*)(CObject *, int state))
+  I->fGetSettingHandle = (CSetting ** (*)(CObject *, int state))
     ObjectMoleculeGetSettingHandle;
-  I->Obj.fGetObjectState = (CObjectState * (*)(CObject *, int state))
+  I->fGetObjectState = (CObjectState * (*)(CObject *, int state))
     ObjectMoleculeGetObjectState;
 
-  I->Obj.fGetCaption = (char *(*)(CObject *, char *, int)) ObjectMoleculeGetCaption;
+  I->fGetCaption = (char *(*)(CObject *, char *, int)) ObjectMoleculeGetCaption;
   I->AtomInfo = pymol::vla<AtomInfoType>(10);
   CHECKOK(ok, I->AtomInfo);
   if (!ok){
@@ -11696,7 +11697,7 @@ ObjectMolecule *ObjectMoleculeNew(PyMOLG
 /*========================================================================*/
 ObjectMolecule *ObjectMoleculeCopy(const ObjectMolecule * obj)
 {
-  PyMOLGlobals * G = const_cast<PyMOLGlobals*>(obj->Obj.G);
+  PyMOLGlobals * G = const_cast<PyMOLGlobals*>(obj->G);
 
   int a;
   BondType *i0, *i1;
@@ -11706,10 +11707,10 @@ ObjectMolecule *ObjectMoleculeCopy(const
   I->UnitCellCGO = NULL;
   I->Neighbor = NULL;
   I->Sculpt = NULL;
-  I->Obj.Setting = NULL;        /* TODO - make a copy */
+  I->Setting = NULL;        /* TODO - make a copy */
 
-  I->Obj.ViewElem = NULL;
-  I->Obj.gridSlotSelIndicatorsCGO = NULL;
+  I->ViewElem = NULL;
+  I->gridSlotSelIndicatorsCGO = NULL;
 
   for(a = 0; a <= cUndoMask; a++)
     I->UndoCoord[a] = NULL;
@@ -11776,7 +11777,7 @@ int ObjectMoleculeSetStateOrder(ObjectMo
 
   return true;
 ok_except1:
-  ErrMessage(I->Obj.G, "ObjectMoleculeSetStateOrder", "failed");
+  ErrMessage(I->G, "ObjectMoleculeSetStateOrder", "failed");
   VLAFreeP(csets);
   return false;
 }
@@ -11785,7 +11786,7 @@ ok_except1:
 void ObjectMoleculeFree(ObjectMolecule * I)
 {
   int a;
-  SelectorPurgeObjectMembers(I->Obj.G, I);
+  SelectorPurgeObjectMembers(I->G, I);
   for(a = 0; a < I->NCSet; a++){
     if(I->CSet[a]) {
       I->CSet[a]->fFree();
@@ -11805,7 +11806,7 @@ void ObjectMoleculeFree(ObjectMolecule *
     AtomInfoType *ai = I->AtomInfo;
 
     for(a = 0; a < nAtom; a++) {
-      AtomInfoPurge(I->Obj.G, ai);
+      AtomInfoPurge(I->G, ai);
       ai++;
     }
     VLAFreeP(I->AtomInfo);
@@ -11815,7 +11816,7 @@ void ObjectMoleculeFree(ObjectMolecule *
     BondType *bi = I->Bond;
 
     for(a = 0; a < nBond; a++) {
-      AtomInfoPurgeBond(I->Obj.G, bi);
+      AtomInfoPurgeBond(I->G, bi);
       bi++;
     }
     VLAFreeP(I->Bond);
@@ -11827,7 +11828,7 @@ void ObjectMoleculeFree(ObjectMolecule *
     SculptFree(I->Sculpt);
   if(I->CSTmpl)
     I->CSTmpl->fFree();
-  ObjectPurge(&I->Obj);
+  ObjectPurge(I);
   OOFreeP(I);
 }
 
@@ -11873,7 +11874,7 @@ ObjectMolecule *ObjectMoleculeReadPDBStr
         isNew = false;
       }
       if(ok && isNew) {
-        I->Obj.Color = AtomInfoUpdateAutoColor(G);
+        I->Color = AtomInfoUpdateAutoColor(G);
 
         if (pdb_info->variant == PDB_VARIANT_VDB ||
             pdb_info->variant == PDB_VARIANT_PQR) {
@@ -11975,10 +11976,10 @@ ObjectMolecule *ObjectMoleculeReadPDBStr
         if(successCnt > 1) {
           if(successCnt == 2) {
             PRINTFB(G, FB_ObjectMolecule, FB_Actions)
-              " ObjectMolReadPDBStr: read MODEL %d\n", 1 ENDFB(G);
+              " %s: read MODEL %d\n", __func__, 1 ENDFB(G);
           }
           PRINTFB(G, FB_ObjectMolecule, FB_Actions)
-            " ObjectMolReadPDBStr: read MODEL %d\n", successCnt ENDFB(G);
+            " %s: read MODEL %d\n", __func__, successCnt ENDFB(G);
         }
       }
     }
@@ -12268,15 +12269,15 @@ int *AtomInfoGetSortedIndex(PyMOLGlobals
   int a;
   CSetting *setting = NULL;
 
-  ok_assert(1, index = Alloc(int, n + 1));
-  ok_assert(1, (*outdex) = Alloc(int, n + 1));
+  ok_assert(1, index = pymol::malloc<int>(n + 1));
+  ok_assert(1, (*outdex) = pymol::malloc<int>(n + 1));
 
   if(obj && obj->DiscreteFlag) {
     for(a = 0; a < n; a++)
       index[a] = a;
   } else {
     if(obj)
-      setting = obj->Obj.Setting;
+      setting = obj->Setting;
 
     UtilSortIndexGlobals(G, n, rec, index, (UtilOrderFnGlobals *) (
         SettingGet_b(G, setting, NULL, cSetting_retain_order) ?
@@ -12366,3 +12367,18 @@ bool ObjectMolecule::updateAtmToIdx() {
 ok_except1:
   return false;
 }
+
+/**
+ * Check if this atom has coordinates in any state
+ */
+bool ObjectMolecule::atomHasAnyCoordinates(size_t atm) const
+{
+  for (size_t i = 0; i < NCSet; ++i) {
+    auto cset = CSet[i];
+    if (cset && cset->atmToIdx(atm) != -1) {
+      return true;
+    }
+  }
+
+  return false;
+}
diff -upNr pymol-open-source-2.3.0/layer2/ObjectMolecule.h pymol-open-source-2.3.3/layer2/ObjectMolecule.h
--- pymol-open-source-2.3.0/layer2/ObjectMolecule.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectMolecule.h	2019-08-22 10:24:47.718595691 +0200
@@ -53,9 +53,7 @@ typedef struct ObjectMoleculeBPRec {
   int n_atom;
 } ObjectMoleculeBPRec;
 
-typedef struct ObjectMolecule {
-	/* base Object class */
-  CObject Obj;
+struct ObjectMolecule : public CObject {
 	/* array of pointers to coordinate sets; one set per state */
   struct CoordSet **CSet;
 	/* number of coordinate sets */
@@ -101,7 +99,8 @@ typedef struct ObjectMolecule {
   int getState() const;
   bool setNDiscrete(int natom);
   bool updateAtmToIdx();
-} ObjectMolecule;
+  bool atomHasAnyCoordinates(size_t atm) const;
+};
 
 /* this is a record that holds information for specific types of Operatations on Molecules, eg. translation/rotation/etc */
 typedef struct ObjectMoleculeOpRec {
@@ -400,7 +399,7 @@ int ObjectMoleculeGetAtomVertex(ObjectMo
 int ObjectMoleculeGetAtomTxfVertex(ObjectMolecule * I, int state, int index, float *v);
 int ObjectMoleculeGetAtomIndex(ObjectMolecule * I, int sele);
 int ObjectMoleculeTransformSelection(ObjectMolecule * I, int state,
-                                     int sele, float *TTT, int log,
+                                     int sele, const float *TTT, int log,
                                      const char *sname, int homogenous, int global);
 int ObjectMoleculeDoesAtomNeighborSele(ObjectMolecule * I, int index, int sele);
 void ObjectMoleculeInferChemFromNeighGeom(ObjectMolecule * I, int state);
@@ -486,7 +485,7 @@ int ObjectMoleculeConvertIDsToIndices(Ob
 ObjectMolecule *ObjectMoleculeDummyNew(PyMOLGlobals * G, int mode);
 void ObjectMoleculeDummyUpdate(ObjectMolecule * I, int mode);
 
-void ObjectMoleculeTransformState44f(ObjectMolecule * I, int state, float *matrix,
+void ObjectMoleculeTransformState44f(ObjectMolecule * I, int state, const float *matrix,
                                      int log_trans, int homogenous, int transformed);
 
 
diff -upNr pymol-open-source-2.3.0/layer2/ObjectSlice.cpp pymol-open-source-2.3.3/layer2/ObjectSlice.cpp
--- pymol-open-source-2.3.0/layer2/ObjectSlice.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectSlice.cpp	2019-08-22 10:24:47.718595691 +0200
@@ -146,7 +146,8 @@ static int ObjectSliceAllStatesFromPyLis
     ok = PyList_Check(list);
   if(ok) {
     for(a = 0; a < I->NState; a++) {
-      ok = ObjectSliceStateFromPyList(I->Obj.G, I->State + a, PyList_GetItem(list, a));
+      auto *val = PyList_GetItem(list, a);
+      ok = ObjectSliceStateFromPyList(I->G, I->State + a, val);
       if(!ok)
         break;
     }
@@ -171,8 +172,10 @@ int ObjectSliceNewFromPyList(PyMOLGlobal
   if(ok)
     ok = (I != NULL);
 
-  if(ok)
-    ok = ObjectFromPyList(G, PyList_GetItem(list, 0), &I->Obj);
+  if(ok){
+    auto *val = PyList_GetItem(list, 0);
+    ok = ObjectFromPyList(G, val, I);
+  }
   if(ok)
     ok = PConvPyIntToInt(PyList_GetItem(list, 1), &I->NState);
   if(ok)
@@ -191,7 +194,7 @@ PyObject *ObjectSliceAsPyList(ObjectSlic
   PyObject *result = NULL;
 
   result = PyList_New(3);
-  PyList_SetItem(result, 0, ObjectAsPyList(&I->Obj));
+  PyList_SetItem(result, 0, ObjectAsPyList(I));
   PyList_SetItem(result, 1, PyInt_FromLong(I->NState));
   PyList_SetItem(result, 2, ObjectSliceAllStatesAsPyList(I));
 
@@ -217,7 +220,7 @@ static void ObjectSliceFree(ObjectSlice
       ObjectSliceStateFree(I->State + a);
   }
   VLAFreeP(I->State);
-  ObjectPurge(&I->Obj);
+  ObjectPurge(I);
 
   OOFreeP(I);
 }
@@ -232,7 +235,7 @@ static void ObjectSliceInvalidate(Object
     if(!once_flag)
       state = a;
     I->State[state].RefreshFlag = true;
-    SceneChanged(I->Obj.G);
+    SceneChanged(I->G);
     if(once_flag)
       break;
   }
@@ -269,14 +272,14 @@ static void ObjectSliceStateUpdate(Objec
   int min[2] = { 0, 0 }, max[2] = {
   0, 0};                        /* limits of the rectangle */
   int need_normals = false;
-  int track_camera = SettingGet_b(I->Obj.G, NULL, I->Obj.Setting, cSetting_slice_track_camera);
-  float grid = SettingGet_f(I->Obj.G, NULL, I->Obj.Setting, cSetting_slice_grid);
+  int track_camera = SettingGet_b(I->G, NULL, I->Setting, cSetting_slice_track_camera);
+  float grid = SettingGet_f(I->G, NULL, I->Setting, cSetting_slice_grid);
   int min_expand = 1;
 
-  if(SettingGet_b(I->Obj.G, NULL, I->Obj.Setting, cSetting_slice_dynamic_grid)) {
-    float resol = SettingGet_f(I->Obj.G, NULL, I->Obj.Setting,
+  if(SettingGet_b(I->G, NULL, I->Setting, cSetting_slice_dynamic_grid)) {
+    float resol = SettingGet_f(I->G, NULL, I->Setting,
                                cSetting_slice_dynamic_grid_resolution);
-    float scale = SceneGetScreenVertexScale(I->Obj.G, oss->origin);
+    float scale = SceneGetScreenVertexScale(I->G, oss->origin);
     oss->last_scale = scale;
     grid = resol * scale;
   }
@@ -422,8 +425,8 @@ static void ObjectSliceStateUpdate(Objec
     }
     if(!(oss->points && oss->values && oss->flags)) {
       ok = false;
-      PRINTFB(I->Obj.G, FB_ObjectSlice, FB_Errors)
-        "ObjectSlice-Error: allocation failed\n" ENDFB(I->Obj.G);
+      PRINTFB(I->G, FB_ObjectSlice, FB_Errors)
+        "ObjectSlice-Error: allocation failed\n" ENDFB(I->G);
     }
 
     if(!oss->strips)            /* this is range-checked during use */
@@ -459,9 +462,9 @@ static void ObjectSliceStateUpdate(Objec
 
   if(ok) {
 
-    if(SettingGet_b(I->Obj.G, NULL, I->Obj.Setting, cSetting_slice_height_map)) {
+    if(SettingGet_b(I->G, NULL, I->Setting, cSetting_slice_height_map)) {
       float height_scale =
-        SettingGet_f(I->Obj.G, NULL, I->Obj.Setting, cSetting_slice_height_scale);
+        SettingGet_f(I->G, NULL, I->Setting, cSetting_slice_height_scale);
       float *value = oss->values;
       float up[3], scaled[3], factor;
       int x, y;
@@ -589,7 +592,7 @@ static void ObjectSliceStateUpdate(Objec
     } else {
       VLACheck(oss->normals, float, oss->n_points * 3); /* note: this is a macro which reassigns the pointer */
     }
-    cnt = Calloc(int, oss->n_points);
+    cnt = pymol::calloc<int>(oss->n_points);
 
     if(cnt && oss->normals) {
       int *strip = oss->strips;
@@ -673,11 +676,11 @@ static void ObjectSliceUpdate(ObjectSlic
   for(a = 0; a < I->NState; a++) {
     oss = I->State + a;
     if(oss && oss->Active) {
-      map = ExecutiveFindObjectMapByName(I->Obj.G, oss->MapName);
+      map = ExecutiveFindObjectMapByName(I->G, oss->MapName);
       if(!map) {
-        PRINTFB(I->Obj.G, FB_ObjectSlice, FB_Errors)
+        PRINTFB(I->G, FB_ObjectSlice, FB_Errors)
           "ObjectSliceUpdate-Error: map '%s' has been deleted.\n", oss->MapName
-          ENDFB(I->Obj.G);
+          ENDFB(I->G);
       }
       if(map) {
         oms = ObjectMapGetState(map, oss->MapState);
@@ -686,15 +689,15 @@ static void ObjectSliceUpdate(ObjectSlic
 
         if(oss->RefreshFlag) {
           oss->RefreshFlag = false;
-          PRINTFB(I->Obj.G, FB_ObjectSlice, FB_Blather)
-            " ObjectSlice: updating \"%s\".\n", I->Obj.Name ENDFB(I->Obj.G);
+          PRINTFB(I->G, FB_ObjectSlice, FB_Blather)
+            " ObjectSlice: updating \"%s\".\n", I->Name ENDFB(I->G);
           if(oms->Field) {
             ObjectSliceStateUpdate(I, oss, oms);
-            ogr = ColorGetRamp(I->Obj.G, I->Obj.Color);
+            ogr = ColorGetRamp(I->G, I->Color);
             if(ogr)
               ObjectSliceStateAssignColors(oss, ogr);
             else {              /* solid color */
-              const float *solid = ColorGet(I->Obj.G, I->Obj.Color);
+              const float *solid = ColorGet(I->G, I->Color);
               float *color = oss->colors;
               for(a = 0; a < oss->n_points; a++) {
                 *(color++) = solid[0];
@@ -705,7 +708,7 @@ static void ObjectSliceUpdate(ObjectSlic
           }
         }
       }
-      SceneInvalidate(I->Obj.G);
+      SceneInvalidate(I->G);
     }
   }
 }
@@ -752,7 +755,7 @@ void ObjectSliceDrag(ObjectSlice * I, in
         multiply33f33f(mat, oss->system, oss->system);
 
         ObjectSliceInvalidate(I, cRepSlice, cRepAll, state);
-        SceneInvalidate(I->Obj.G);
+        SceneInvalidate(I->G);
 
       }
       break;
@@ -769,7 +772,7 @@ void ObjectSliceDrag(ObjectSlice * I, in
         project3f(mov, up, v1);
         add3f(v1, oss->origin, oss->origin);
         ObjectSliceInvalidate(I, cRepSlice, cRepAll, state);
-        SceneInvalidate(I->Obj.G);
+        SceneInvalidate(I->G);
       }
       break;
     case cButModeTorFrag:
@@ -944,17 +947,17 @@ void GenerateOutlineOfSlice(PyMOLGlobals
 static void ObjectSliceRender(ObjectSlice * I, RenderInfo * info)
 {
 
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   int state = info->state;
   CRay *ray = info->ray;
   auto pick = info->pick;
   int pass = info->pass;
   int cur_state = 0;
   float alpha;
-  int track_camera = SettingGet_b(G, NULL, I->Obj.Setting, cSetting_slice_track_camera);
-  int dynamic_grid = SettingGet_b(G, NULL, I->Obj.Setting, cSetting_slice_dynamic_grid);
+  int track_camera = SettingGet_b(G, NULL, I->Setting, cSetting_slice_track_camera);
+  int dynamic_grid = SettingGet_b(G, NULL, I->Setting, cSetting_slice_dynamic_grid);
   ObjectSliceState *oss = NULL;
-  int use_shaders = !track_camera && SettingGet_b(G, NULL, I->Obj.Setting, cSetting_use_shaders);
+  int use_shaders = !track_camera && SettingGet_b(G, NULL, I->Setting, cSetting_use_shaders);
   if (G->ShaderMgr->Get_Current_Shader()){
     // just in case, since slice uses immediate mode, but this should never happen
     G->ShaderMgr->Get_Current_Shader()->Disable();
@@ -1013,8 +1016,8 @@ static void ObjectSliceRender(ObjectSlic
     ObjectSliceUpdate(I);
   }
 
-  ObjectPrepareContext(&I->Obj, info);
-  alpha = SettingGet_f(G, NULL, I->Obj.Setting, cSetting_transparency);
+  ObjectPrepareContext(I, info);
+  alpha = SettingGet_f(G, NULL, I->Setting, cSetting_transparency);
   alpha = 1.0F - alpha;
   if(fabs(alpha - 1.0) < R_SMALL4)
     alpha = 1.0F;
@@ -1038,7 +1041,7 @@ static void ObjectSliceRender(ObjectSlic
         if(ray) {
 
           ray->transparentf(1.0F - alpha);
-          if((I->Obj.visRep & cRepSliceBit)) {
+          if((I->visRep & cRepSliceBit)) {
             float normal[3], *n0, *n1, *n2;
             int *strip = oss->strips;
             float *point = oss->points;
@@ -1108,8 +1111,8 @@ static void ObjectSliceRender(ObjectSlic
           ray->transparentf(0.0);
         } else if(G->HaveGUI && G->ValidContext) {
           if(pick) {
-            if (oss->shaderCGO && (I->Obj.visRep & cRepSliceBit)){
-              CGORenderGLPicking(oss->shaderCGO, info, &I->context, I->Obj.Setting, NULL);
+            if (oss->shaderCGO && (I->visRep & cRepSliceBit)){
+              CGORenderGLPicking(oss->shaderCGO, info, &I->context, I->Setting, NULL);
             } else {
 #ifndef PURE_OPENGL_ES_2
             unsigned int i = pick->begin()->src.index;
@@ -1120,7 +1123,7 @@ static void ObjectSliceRender(ObjectSlic
             p.src.index = state + 1;
             p.src.bond = 0;
 
-            if((I->Obj.visRep & cRepSliceBit)) {
+            if((I->visRep & cRepSliceBit)) {
               int *strip = oss->strips;
               float *point = oss->points;
               int n = oss->n_strips;
@@ -1187,18 +1190,18 @@ static void ObjectSliceRender(ObjectSlic
             if(render_now) {
 	      int already_rendered = false;
 
-		if (oss->shaderCGO){
-		  CGORenderGL(oss->shaderCGO, NULL, NULL, I->Obj.Setting, info, NULL);
-		  already_rendered = true;
-		} else {
+              if (oss->shaderCGO){
+                CGORenderGL(oss->shaderCGO, NULL, NULL, I->Setting, info, NULL);
+                already_rendered = true;
+              } else {
 		  oss->shaderCGO = CGONew(G);
 	      }
 
 	      if (!already_rendered){
 		  SceneResetNormalCGO(G, oss->shaderCGO, false);
-		  ObjectUseColorCGO(oss->shaderCGO, &I->Obj);
+		  ObjectUseColorCGO(oss->shaderCGO, I);
 		
-		  if((I->Obj.visRep & cRepSliceBit)) {
+		  if((I->visRep & cRepSliceBit)) {
 		    int *strip = oss->strips;
 		    float *point = oss->points;
 		    float *color = oss->colors;
@@ -1258,7 +1261,7 @@ static void ObjectSliceRender(ObjectSlic
 		  oss->shaderCGO->use_shader = true;
 		  CGOFree(convertcgo);
                 }
-		  CGORenderGL(oss->shaderCGO, NULL, NULL, I->Obj.Setting, info, NULL);
+                CGORenderGL(oss->shaderCGO, NULL, NULL, I->Setting, info, NULL);
                 SceneInvalidatePicking(G);  // any time cgo is re-generated, needs to invalidate so
                 // pick colors can be re-assigned
 		}
@@ -1308,13 +1311,13 @@ ObjectSlice *ObjectSliceNew(PyMOLGlobals
   I->NState = 0;
   I->State = VLACalloc(ObjectSliceState, 10);  /* autozero important */
 
-  I->Obj.type = cObjectSlice;
+  I->type = cObjectSlice;
 
-  I->Obj.fFree = (void (*)(CObject *)) ObjectSliceFree;
-  I->Obj.fUpdate = (void (*)(CObject *)) ObjectSliceUpdate;
-  I->Obj.fRender = (void (*)(CObject *, RenderInfo *)) ObjectSliceRender;
-  I->Obj.fInvalidate = (void (*)(CObject *, int, int, int)) ObjectSliceInvalidate;
-  I->Obj.fGetNFrame = (int (*)(CObject *)) ObjectSliceGetNStates;
+  I->fFree = (void (*)(CObject *)) ObjectSliceFree;
+  I->fUpdate = (void (*)(CObject *)) ObjectSliceUpdate;
+  I->fRender = (void (*)(CObject *, RenderInfo *)) ObjectSliceRender;
+  I->fInvalidate = (void (*)(CObject *, int, int, int)) ObjectSliceInvalidate;
+  I->fGetNFrame = (int (*)(CObject *)) ObjectSliceGetNStates;
 
   I->context.object = (void *) I;
   I->context.state = 0;
@@ -1405,7 +1408,7 @@ ObjectSlice *ObjectSliceFromMap(PyMOLGlo
     memcpy(oss->Corner, oms->Corner, 24 * sizeof(float));
   }
 
-  strcpy(oss->MapName, map->Obj.Name);
+  strcpy(oss->MapName, map->Name);
   oss->ExtentFlag = true;
 
   /* set the origin of the slice to the center of the map */
@@ -1430,7 +1433,7 @@ ObjectSlice *ObjectSliceFromMap(PyMOLGlo
     ObjectSliceRecomputeExtent(I);
   }
 
-  I->Obj.ExtentFlag = true;
+  I->ExtentFlag = true;
 
   SceneChanged(G);
   SceneCountFrames(G);
@@ -1452,14 +1455,14 @@ void ObjectSliceRecomputeExtent(ObjectSl
       if(ms->ExtentFlag) {
         if(!extent_flag) {
           extent_flag = true;
-          copy3f(ms->ExtentMax, I->Obj.ExtentMax);
-          copy3f(ms->ExtentMin, I->Obj.ExtentMin);
+          copy3f(ms->ExtentMax, I->ExtentMax);
+          copy3f(ms->ExtentMin, I->ExtentMin);
         } else {
-          max3f(ms->ExtentMax, I->Obj.ExtentMax, I->Obj.ExtentMax);
-          min3f(ms->ExtentMin, I->Obj.ExtentMin, I->Obj.ExtentMin);
+          max3f(ms->ExtentMax, I->ExtentMax, I->ExtentMax);
+          min3f(ms->ExtentMin, I->ExtentMin, I->ExtentMin);
         }
       }
     }
   }
-  I->Obj.ExtentFlag = extent_flag;
+  I->ExtentFlag = extent_flag;
 }
diff -upNr pymol-open-source-2.3.0/layer2/ObjectSlice.h pymol-open-source-2.3.3/layer2/ObjectSlice.h
--- pymol-open-source-2.3.0/layer2/ObjectSlice.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectSlice.h	2019-08-22 10:24:47.718595691 +0200
@@ -62,12 +62,11 @@ typedef struct {
   float outline_zaxis[3];
 } ObjectSliceState;
 
-typedef struct ObjectSlice {
-  CObject Obj;
+struct ObjectSlice : public CObject {
   ObjectSliceState *State;
   PickContext context;
   int NState;
-} ObjectSlice;
+};
 
 ObjectSlice *ObjectSliceFromMap(PyMOLGlobals * G, ObjectSlice * obj, ObjectMap * map,
                                 int state, int map_state);
diff -upNr pymol-open-source-2.3.0/layer2/ObjectSurface.cpp pymol-open-source-2.3.3/layer2/ObjectSurface.cpp
--- pymol-open-source-2.3.0/layer2/ObjectSurface.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectSurface.cpp	2019-08-22 10:24:47.718595691 +0200
@@ -171,7 +171,8 @@ static int ObjectSurfaceAllStatesFromPyL
     ok = PyList_Check(list);
   if(ok) {
     for(a = 0; a < I->NState; a++) {
-      ok = ObjectSurfaceStateFromPyList(I->Obj.G, I->State + a, PyList_GetItem(list, a));
+      auto *val = PyList_GetItem(list, a);
+      ok = ObjectSurfaceStateFromPyList(I->G, I->State + a, val);
       if(!ok)
         break;
     }
@@ -194,8 +195,10 @@ int ObjectSurfaceNewFromPyList(PyMOLGlob
   if(ok)
     ok = (I != NULL);
 
-  if(ok)
-    ok = ObjectFromPyList(G, PyList_GetItem(list, 0), &I->Obj);
+  if(ok){
+    auto *val = PyList_GetItem(list, 0);
+    ok = ObjectFromPyList(G, val, I);
+  }
   if(ok)
     ok = PConvPyIntToInt(PyList_GetItem(list, 1), &I->NState);
   if(ok)
@@ -214,7 +217,7 @@ PyObject *ObjectSurfaceAsPyList(ObjectSu
   PyObject *result = NULL;
 
   result = PyList_New(3);
-  PyList_SetItem(result, 0, ObjectAsPyList(&I->Obj));
+  PyList_SetItem(result, 0, ObjectAsPyList(I));
   PyList_SetItem(result, 1, PyInt_FromLong(I->NState));
   PyList_SetItem(result, 2, ObjectSurfaceAllStatesAsPyList(I));
 
@@ -243,7 +246,7 @@ static void ObjectSurfaceFree(ObjectSurf
       ObjectSurfaceStateFree(I->State + a);
   }
   VLAFreeP(I->State);
-  ObjectPurge(&I->Obj);
+  ObjectPurge(I);
 
   OOFreeP(I);
 }
@@ -256,7 +259,7 @@ void ObjectSurfaceDump(ObjectSurface * I
   FILE *f;
   f = fopen(fname, "wb");
   if(!f)
-    ErrMessage(I->Obj.G, "ObjectSurfaceDump", "can't open file for writing");
+    ErrMessage(I->G, "ObjectSurfaceDump", "can't open file for writing");
   else {
     if(state < I->NState) {
       n = I->State[state].N;
@@ -288,8 +291,8 @@ void ObjectSurfaceDump(ObjectSurface * I
         }
     }
     fclose(f);
-    PRINTFB(I->Obj.G, FB_ObjectSurface, FB_Actions)
-      " ObjectSurfaceDump: %s written to %s\n", I->Obj.Name, fname ENDFB(I->Obj.G);
+    PRINTFB(I->G, FB_ObjectSurface, FB_Actions)
+      " ObjectSurfaceDump: %s written to %s\n", I->Name, fname ENDFB(I->G);
   }
 }
 
@@ -298,7 +301,7 @@ static void ObjectSurfaceInvalidate(Obje
   int a;
   int once_flag = true;
   if(level >= cRepInvExtents) {
-    I->Obj.ExtentFlag = false;
+    I->ExtentFlag = false;
   }
   if((rep == cRepSurface) || (rep == cRepMesh) || (rep == cRepAll)) {
     for(a = 0; a < I->NState; a++) {
@@ -313,16 +316,16 @@ static void ObjectSurfaceInvalidate(Obje
 	  CGOFree(I->State[state].shaderCGO);
 	  I->State[state].shaderCGO = 0;
 	}
-        SceneChanged(I->Obj.G);
+        SceneChanged(I->G);
       } else if(level >= cRepInvColor) {
         I->State[state].RecolorFlag = true;
 	if(I->State[state].shaderCGO){
 	  CGOFree(I->State[state].shaderCGO);
 	  I->State[state].shaderCGO = 0;
 	}
-        SceneChanged(I->Obj.G);
+        SceneChanged(I->G);
       } else {
-        SceneInvalidate(I->Obj.G);
+        SceneInvalidate(I->G);
       }
       if(once_flag)
         break;
@@ -353,12 +356,12 @@ static void ObjectSurfaceStateUpdateColo
 {
   int one_color_flag = true;
   int cur_color =
-    SettingGet_color(I->Obj.G, I->Obj.Setting, NULL, cSetting_surface_color);
+    SettingGet_color(I->G, I->Setting, NULL, cSetting_surface_color);
 
   if(cur_color == -1)
-    cur_color = I->Obj.Color;
+    cur_color = I->Color;
 
-  if(ColorCheckRamped(I->Obj.G, cur_color))
+  if(ColorCheckRamped(I->G, cur_color))
     one_color_flag = false;
 
   ms->OneColor = cur_color;
@@ -384,10 +387,10 @@ static void ObjectSurfaceStateUpdateColo
 
         if(!ms->VC) {
           ms->VCsize = n_vert;
-          ms->VC = Alloc(float, n_vert * 3);
+          ms->VC = pymol::malloc<float>(n_vert * 3);
         }
         if(!ms->RC) {
-          ms->RC = Alloc(int, n_vert);
+          ms->RC = pymol::malloc<int>(n_vert);
         }
         rc = ms->RC;
         vc = ms->VC;
@@ -395,7 +398,7 @@ static void ObjectSurfaceStateUpdateColo
         if(vc) {
           for(a = 0; a < n_vert; a++) {
             if(a == base_n_vert) {
-              int new_color = SettingGet_color(I->Obj.G, I->Obj.Setting,
+              int new_color = SettingGet_color(I->G, I->Setting,
                                                NULL, cSetting_surface_negative_color);
               if(new_color == -1)
                 new_color = cur_color;
@@ -404,12 +407,12 @@ static void ObjectSurfaceStateUpdateColo
                 cur_color = new_color;
               }
             }
-            if(ColorCheckRamped(I->Obj.G, cur_color)) {
-              ColorGetRamped(I->Obj.G, cur_color, v, vc, state);
+            if(ColorCheckRamped(I->G, cur_color)) {
+              ColorGetRamped(I->G, cur_color, v, vc, state);
               *rc = cur_color;
               ramped_flag = true;
             } else {
-              const float *col = ColorGet(I->Obj.G, cur_color);
+              const float *col = ColorGet(I->G, cur_color);
               copy3f(col, vc);
             }
             rc++;
@@ -432,17 +435,17 @@ static void ObjectSurfaceStateUpdateColo
 
         if(!ms->VC) {
           ms->VCsize = n_vert;
-          ms->VC = Alloc(float, n_vert * 3);
+          ms->VC = pymol::malloc<float>(n_vert * 3);
         }
         if(!ms->RC) {
-          ms->RC = Alloc(int, n_vert);
+          ms->RC = pymol::malloc<int>(n_vert);
         }
         rc = ms->RC;
         vc = ms->VC;
         if(vc) {
           for(a = 0; a < n_vert; a++) {
             if(a == base_n_vert) {
-              int new_color = SettingGet_color(I->Obj.G, I->Obj.Setting,
+              int new_color = SettingGet_color(I->G, I->Setting,
                                                NULL, cSetting_surface_negative_color);
               if(new_color == -1)
                 new_color = cur_color;
@@ -451,12 +454,12 @@ static void ObjectSurfaceStateUpdateColo
               cur_color = new_color;
             }
 
-            if(ColorCheckRamped(I->Obj.G, cur_color)) {
-              ColorGetRamped(I->Obj.G, cur_color, v, vc, state);
+            if(ColorCheckRamped(I->G, cur_color)) {
+              ColorGetRamped(I->G, cur_color, v, vc, state);
               *rc = cur_color;
               ramped_flag = true;
             } else {
-              const float *col = ColorGet(I->Obj.G, cur_color);
+              const float *col = ColorGet(I->G, cur_color);
               copy3f(col, vc);
             }
             rc++;
@@ -473,7 +476,7 @@ static void ObjectSurfaceStateUpdateColo
       FreeP(ms->RC);
     } else if((!ramped_flag)
               ||
-              (!SettingGet_b(I->Obj.G, NULL, I->Obj.Setting, cSetting_ray_color_ramps))) {
+              (!SettingGet_b(I->G, NULL, I->Setting, cSetting_ray_color_ramps))) {
       FreeP(ms->RC);
     }
   }
@@ -490,11 +493,11 @@ static void ObjectSurfaceUpdate(ObjectSu
     MapType *voxelmap = NULL;     /* this has nothing to do with isosurfaces... */
 
     if(ms->Active) {
-      map = ExecutiveFindObjectMapByName(I->Obj.G, ms->MapName);
+      map = ExecutiveFindObjectMapByName(I->G, ms->MapName);
       if(!map) {
-        PRINTFB(I->Obj.G, FB_ObjectSurface, FB_Errors)
+        PRINTFB(I->G, FB_ObjectSurface, FB_Errors)
           "ObjectSurfaceUpdate-Error: map '%s' has been deleted.\n", ms->MapName
-          ENDFB(I->Obj.G);
+          ENDFB(I->G);
         ms->ResurfaceFlag = false;
       }
       if(map) {
@@ -507,24 +510,24 @@ static void ObjectSurfaceUpdate(ObjectSu
           ObjectStateResetMatrix(&ms->State);
         }
 
-        if(I->Obj.visRep & cRepCellBit){
+        if(I->visRep & cRepCellBit){
           if (!ms->UnitCellCGO || ms->RefreshFlag || ms->ResurfaceFlag) {
-          ms->Crystal = *(oms->Symmetry->Crystal);
-          if((I->Obj.visRep & cRepCellBit)) {
-            CGOFree(ms->UnitCellCGO);
-            ms->UnitCellCGO = CrystalGetUnitCellCGO(&ms->Crystal);
-          }
+            ms->Crystal = *(oms->Symmetry->Crystal);
+            if((I->visRep & cRepCellBit)) {
+              CGOFree(ms->UnitCellCGO);
+              ms->UnitCellCGO = CrystalGetUnitCellCGO(&ms->Crystal);
+            }
           }
           ms->RefreshFlag = false;
         }
       }
-      if(map && ms && oms && ms->N && ms->V && (I->Obj.visRep & cRepSurfaceBit)) {
+      if(map && ms && oms && ms->N && ms->V && (I->visRep & cRepSurfaceBit)) {
         if(ms->ResurfaceFlag) {
           ms->ResurfaceFlag = false;
           ms->RecolorFlag = true;
           if(!ms->quiet) {
-            PRINTFB(I->Obj.G, FB_ObjectSurface, FB_Details)
-              " ObjectSurface: updating \"%s\".\n", I->Obj.Name ENDFB(I->Obj.G);
+            PRINTFB(I->G, FB_ObjectSurface, FB_Details)
+              " ObjectSurface: updating \"%s\".\n", I->Name ENDFB(I->G);
           }
 
           CGOFree(ms->shaderCGO);
@@ -544,7 +547,7 @@ static void ObjectSurfaceUpdate(ObjectSu
                 max_ext = ms->ExtentMax;
               }
 
-              TetsurfGetRange(I->Obj.G, oms->Field, oms->Symmetry->Crystal,
+              TetsurfGetRange(I->G, oms->Field, oms->Symmetry->Crystal,
                               min_ext, max_ext, ms->Range);
             }
 
@@ -554,13 +557,13 @@ static void ObjectSurfaceUpdate(ObjectSu
                 carve_buffer = -carve_buffer;
               }
 
-              voxelmap = MapNew(I->Obj.G, -carve_buffer, ms->AtomVertex,
+              voxelmap = MapNew(I->G, -carve_buffer, ms->AtomVertex,
                                 VLAGetSize(ms->AtomVertex) / 3, NULL);
               if(voxelmap)
                 MapSetupExpress(voxelmap);
             }
 
-            ms->nT = TetsurfVolume(I->Obj.G, oms->Field,
+            ms->nT = TetsurfVolume(I->G, oms->Field,
                                    ms->Level,
                                    &ms->N, &ms->V,
                                    ms->Range,
@@ -568,7 +571,7 @@ static void ObjectSurfaceUpdate(ObjectSu
                                    voxelmap, ms->AtomVertex, ms->CarveBuffer, ms->Side);
 
             if(!SettingGet_b
-               (I->Obj.G, I->Obj.Setting, NULL, cSetting_surface_negative_visible)) {
+               (I->G, I->Setting, NULL, cSetting_surface_negative_visible)) {
               ms->base_n_V = VLAGetSize(ms->V);
             } else {
               /* do we want the negative surface too? */
@@ -577,7 +580,7 @@ static void ObjectSurfaceUpdate(ObjectSu
               int *N2 = VLAlloc(int, 10000);
               float *V2 = VLAlloc(float, 10000);
 
-              nT2 = TetsurfVolume(I->Obj.G, oms->Field,
+              nT2 = TetsurfVolume(I->G, oms->Field,
                                   -ms->Level,
                                   &N2, &V2,
                                   ms->Range,
@@ -676,10 +679,10 @@ static void ObjectSurfaceUpdate(ObjectSu
       }
     }
   }
-  if(!I->Obj.ExtentFlag) {
+  if(!I->ExtentFlag) {
     ObjectSurfaceRecomputeExtent(I);
   }
-  SceneInvalidate(I->Obj.G);
+  SceneInvalidate(I->G);
 }
 
 static void ObjectSurfaceRenderGlobalTransparency(PyMOLGlobals * G,
@@ -822,28 +825,28 @@ static void ObjectSurfaceRenderRay(PyMOL
   float *vc = ms->VC;
   int *rc;
   int c, *n = ms->N;
-  float alpha = 1.0F - SettingGet_f(G, NULL, I->Obj.Setting, cSetting_transparency);
+  float alpha = 1.0F - SettingGet_f(G, NULL, I->Setting, cSetting_transparency);
   if(fabs(alpha - 1.0) < R_SMALL4)
     alpha = 1.0F;
 
 
   CRay *ray = info->ray;
-  if(ms->UnitCellCGO && (I->Obj.visRep & cRepCellBit)){
-    int rayok = CGORenderRay(ms->UnitCellCGO, ray, info, ColorGet(G, I->Obj.Color),
-                             NULL, I->Obj.Setting, NULL);
+  if(ms->UnitCellCGO && (I->visRep & cRepCellBit)){
+    int rayok = CGORenderRay(ms->UnitCellCGO, ray, info, ColorGet(G, I->Color),
+                             NULL, I->Setting, NULL);
     if (!rayok){
       CGOFree(ms->UnitCellCGO);
     }
   }
   
   ray->transparentf(1.0F - alpha);
-  ms->Radius = SettingGet_f(G, I->Obj.Setting, NULL, cSetting_mesh_radius);
+  ms->Radius = SettingGet_f(G, I->Setting, NULL, cSetting_mesh_radius);
   if(ms->Radius == 0.0F) {
     ms->Radius = ray->PixelRadius *
-      SettingGet_f(I->Obj.G, I->Obj.Setting, NULL, cSetting_mesh_width) / 2.0F;
+      SettingGet_f(I->G, I->Setting, NULL, cSetting_mesh_width) / 2.0F;
   }
   
-  if(n && v && (I->Obj.visRep & cRepSurfaceBit)) {
+  if(n && v && (I->visRep & cRepSurfaceBit)) {
     float cc[3];
     float colA[3], colB[3], colC[3];
     ColorGetEncoded(G, ms->OneColor, cc);
@@ -926,7 +929,7 @@ static void ObjectSurfaceRenderRay(PyMOL
 static void ObjectSurfaceRenderCell(PyMOLGlobals *G, ObjectSurface * I,
     RenderInfo * info, ObjectSurfaceState *ms, short use_shader)
 {
-  const float *color = ColorGet(G, I->Obj.Color);
+  const float *color = ColorGet(G, I->Color);
   if (use_shader != ms->UnitCellCGO->has_draw_buffers){
     if (use_shader){
       CGO *convertcgo = CGOOptimizeToVBONotIndexed(ms->UnitCellCGO, 0);
@@ -939,12 +942,12 @@ static void ObjectSurfaceRenderCell(PyMO
     }
   }
   CGORenderGL(ms->UnitCellCGO, color,
-              I->Obj.Setting, NULL, info, NULL);
+              I->Setting, NULL, info, NULL);
 }
 
 static void ObjectSurfaceRender(ObjectSurface * I, RenderInfo * info)
 {
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   int state = info->state;
   CRay *ray = info->ray;
   auto pick = info->pick;
@@ -952,13 +955,13 @@ static void ObjectSurfaceRender(ObjectSu
   const float *col;
   ObjectSurfaceState *ms = NULL;
   float alpha;
-  ObjectPrepareContext(&I->Obj, info);
+  ObjectPrepareContext(I, info);
 
-  alpha = 1.0F - SettingGet_f(G, NULL, I->Obj.Setting, cSetting_transparency);
+  alpha = 1.0F - SettingGet_f(G, NULL, I->Setting, cSetting_transparency);
   if(fabs(alpha - 1.0) < R_SMALL4)
     alpha = 1.0F;
 
-  StateIterator iter(G, I->Obj.Setting, state, I->NState);
+  StateIterator iter(G, I->Setting, state, I->NState);
   while(iter.next()) {
     ms = I->State + iter.state;
     if(ms && ms->Active && ms->V && ms->N) {
@@ -980,7 +983,7 @@ static void ObjectSurfaceRender(ObjectSu
             render_now = (pass == 1);
           }
 
-          if((I->Obj.visRep & cRepCellBit) && ms->UnitCellCGO && (pass == 1)){
+          if((I->visRep & cRepCellBit) && ms->UnitCellCGO && (pass == 1)){
             ObjectSurfaceRenderCell(G, I, info, ms, use_shader);
           }
 
@@ -1006,7 +1009,7 @@ static void ObjectSurfaceRender(ObjectSu
             }
             CGOColorv(ms->shaderCGO, col);
             
-            if(I->Obj.visRep & cRepSurfaceBit) {
+            if(I->visRep & cRepSurfaceBit) {
               if((ms->Mode > 1) && (alpha != 1.0)) {        /* transparent */
                 if(info->alpha_cgo) {     /* global transparency */
                   ObjectSurfaceRenderGlobalTransparency(G, info, ms, col, alpha);
@@ -1068,13 +1071,13 @@ ObjectSurface *ObjectSurfaceNew(PyMOLGlo
   I->NState = 0;
   I->State = VLACalloc(ObjectSurfaceState, 10);        /* autozero important */
 
-  I->Obj.type = cObjectSurface;
+  I->type = cObjectSurface;
 
-  I->Obj.fFree = (void (*)(CObject *)) ObjectSurfaceFree;
-  I->Obj.fUpdate = (void (*)(CObject *)) ObjectSurfaceUpdate;
-  I->Obj.fRender = (void (*)(CObject *, RenderInfo * info)) ObjectSurfaceRender;
-  I->Obj.fInvalidate = (void (*)(CObject *, int, int, int)) ObjectSurfaceInvalidate;
-  I->Obj.fGetNFrame = (int (*)(CObject *)) ObjectSurfaceGetNStates;
+  I->fFree = (void (*)(CObject *)) ObjectSurfaceFree;
+  I->fUpdate = (void (*)(CObject *)) ObjectSurfaceUpdate;
+  I->fRender = (void (*)(CObject *, RenderInfo * info)) ObjectSurfaceRender;
+  I->fInvalidate = (void (*)(CObject *, int, int, int)) ObjectSurfaceInvalidate;
+  I->fGetNFrame = (int (*)(CObject *)) ObjectSurfaceGetNStates;
   return (I);
 }
 
@@ -1139,7 +1142,7 @@ ObjectSurface *ObjectSurfaceFromBox(PyMO
   ms = I->State + state;
   ObjectSurfaceStateInit(G, ms);
 
-  strcpy(ms->MapName, map->Obj.Name);
+  strcpy(ms->MapName, map->Name);
   ms->MapState = map_state;
   oms = ObjectMapGetState(map, map_state);
 
@@ -1197,7 +1200,7 @@ ObjectSurface *ObjectSurfaceFromBox(PyMO
   if(I) {
     ObjectSurfaceRecomputeExtent(I);
   }
-  I->Obj.ExtentFlag = true;
+  I->ExtentFlag = true;
   /*  printf("Brick %d %d %d %d %d %d\n",I->Range[0],I->Range[1],I->Range[2],I->Range[3],I->Range[4],I->Range[5]); */
   SceneChanged(G);
   SceneCountFrames(G);
@@ -1269,25 +1272,25 @@ void ObjectSurfaceRecomputeExtent(Object
       if(ms->ExtentFlag) {
         if(!extent_flag) {
           extent_flag = true;
-          copy3f(ms->ExtentMax, I->Obj.ExtentMax);
-          copy3f(ms->ExtentMin, I->Obj.ExtentMin);
+          copy3f(ms->ExtentMax, I->ExtentMax);
+          copy3f(ms->ExtentMin, I->ExtentMin);
         } else {
-          max3f(ms->ExtentMax, I->Obj.ExtentMax, I->Obj.ExtentMax);
-          min3f(ms->ExtentMin, I->Obj.ExtentMin, I->Obj.ExtentMin);
+          max3f(ms->ExtentMax, I->ExtentMax, I->ExtentMax);
+          min3f(ms->ExtentMin, I->ExtentMin, I->ExtentMin);
         }
       }
     }
   }
-  I->Obj.ExtentFlag = extent_flag;
+  I->ExtentFlag = extent_flag;
 
-  if(I->Obj.TTTFlag && I->Obj.ExtentFlag) {
+  if(I->TTTFlag && I->ExtentFlag) {
     const float *ttt;
     double tttd[16];
-    if(ObjectGetTTT(&I->Obj, &ttt, -1)) {
+    if(ObjectGetTTT(I, &ttt, -1)) {
       convertTTTfR44d(ttt, tttd);
       MatrixTransformExtentsR44d3f(tttd,
-                                   I->Obj.ExtentMin, I->Obj.ExtentMax,
-                                   I->Obj.ExtentMin, I->Obj.ExtentMax);
+                                   I->ExtentMin, I->ExtentMax,
+                                   I->ExtentMin, I->ExtentMax);
     }
   }
 }
diff -upNr pymol-open-source-2.3.0/layer2/ObjectSurface.h pymol-open-source-2.3.3/layer2/ObjectSurface.h
--- pymol-open-source-2.3.0/layer2/ObjectSurface.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectSurface.h	2019-08-22 10:24:47.718595691 +0200
@@ -54,11 +54,10 @@ typedef struct {
   float **c_buf; // colors
 } ObjectSurfaceState;
 
-typedef struct ObjectSurface {
-  CObject Obj;
+struct ObjectSurface : public CObject {
   ObjectSurfaceState *State;
   int NState;
-} ObjectSurface;
+};
 
 ObjectSurface *ObjectSurfaceFromBox(PyMOLGlobals * G, ObjectSurface * obj,
                                     ObjectMap * map, int map_state, int state, float *mn,
diff -upNr pymol-open-source-2.3.0/layer2/ObjectVolume.cpp pymol-open-source-2.3.3/layer2/ObjectVolume.cpp
--- pymol-open-source-2.3.0/layer2/ObjectVolume.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectVolume.cpp	2019-08-22 10:24:47.722596342 +0200
@@ -246,7 +246,8 @@ static int ObjectVolumeAllStatesFromPyLi
     ok = PyList_Check(list);
   if(ok) {
     for(a = 0; a < I->NState; a++) {
-      ok = ObjectVolumeStateFromPyList(I->Obj.G, I->State + a, PyList_GetItem(list, a));
+      auto *val = PyList_GetItem(list, a);
+      ok = ObjectVolumeStateFromPyList(I->G, I->State + a, val);
       if(!ok)
         break;
     }
@@ -268,8 +269,10 @@ int ObjectVolumeNewFromPyList(PyMOLGloba
   I = ObjectVolumeNew(G);
   if(ok)
     ok = (I != NULL);
-  if(ok)
-    ok = ObjectFromPyList(G, PyList_GetItem(list, 0), &I->Obj);
+  if(ok){
+    auto *val = PyList_GetItem(list, 0);
+    ok = ObjectFromPyList(G, val, I);
+  }
   if(ok)
     ok = PConvPyIntToInt(PyList_GetItem(list, 1), &I->NState);
   if(ok)
@@ -288,7 +291,7 @@ PyObject *ObjectVolumeAsPyList(ObjectVol
   PyObject *result = NULL;
 
   result = PyList_New(3);
-  PyList_SetItem(result, 0, ObjectAsPyList(&I->Obj));
+  PyList_SetItem(result, 0, ObjectAsPyList(I));
   PyList_SetItem(result, 1, PyInt_FromLong(I->NState));
   PyList_SetItem(result, 2, ObjectVolumeAllStatesAsPyList(I));
   return (PConvAutoNone(result));
@@ -325,7 +328,7 @@ static void ObjectVolumeFree(ObjectVolum
     ObjectVolumeStateFree(I->State + a);
   }
   VLAFreeP(I->State);
-  ObjectPurge(&I->Obj);
+  ObjectPurge(I);
 
   OOFreeP(I);
 }
@@ -354,12 +357,12 @@ static void ObjectVolumeInvalidate(Objec
   int a;
   int once_flag = true;
   if(level >= cRepInvExtents) {
-    I->Obj.ExtentFlag = false;
+    I->ExtentFlag = false;
   }
 
-  PRINTFB(I->Obj.G, FB_ObjectVolume, FB_Blather)
+  PRINTFB(I->G, FB_ObjectVolume, FB_Blather)
     "ObjectVolumeInvalidate-Msg: %d states.\n", I->NState
-    ENDFB(I->Obj.G);
+    ENDFB(I->G);
 
   if((rep == cRepVolume) || (rep == cRepAll) || (rep == cRepExtent)) {
     for(a = 0; a < I->NState; a++) {
@@ -374,7 +377,7 @@ static void ObjectVolumeInvalidate(Objec
         I->State[state].ResurfaceFlag = true;
         I->State[state].RefreshFlag = true;
       }
-      SceneChanged(I->Obj.G);
+      SceneChanged(I->G);
       if(once_flag)
         break;
     }
@@ -423,7 +426,7 @@ static void ObjectVolumeUpdate(ObjectVol
   int i, j;
   float range;
   MapType *voxelmap;            /* this has nothing to do with isosurfaces... */
-  PyMOLGlobals * G = I->Obj.G;
+  PyMOLGlobals * G = I->G;
 
   for(a = 0; a < I->NState; a++) {
     vs = I->State + a;
@@ -449,8 +452,8 @@ static void ObjectVolumeUpdate(ObjectVol
       }
 
       // data min/max/mean/stdev
-      range = SettingGet_f(I->Obj.G, I->Obj.Setting, NULL, cSetting_volume_data_range);
-      ObjectMapStateGetHistogram(I->Obj.G, oms, 0, range, vs->min_max_mean_stdev, 0.f, 0.f);
+      range = SettingGet_f(I->G, I->Setting, NULL, cSetting_volume_data_range);
+      ObjectMapStateGetHistogram(I->G, oms, 0, range, vs->min_max_mean_stdev, 0.f, 0.f);
     }
 
     // handle legacy or default color ramp
@@ -479,13 +482,13 @@ static void ObjectVolumeUpdate(ObjectVol
           };
           vs->RecolorFlag = true;
           vs->RampSize = 3;
-          vs->Ramp = Alloc(float, 5 * vs->RampSize);
+          vs->Ramp = pymol::malloc<float>(5 * vs->RampSize);
           memcpy(vs->Ramp, defaultramp, 5 * vs->RampSize * sizeof(float));
         }
       }
     }
 
-    if((I->Obj.visRep & cRepVolumeBit) && vs->ResurfaceFlag) {
+    if((I->visRep & cRepVolumeBit) && vs->ResurfaceFlag) {
       Isofield *field = NULL;
       vs->ResurfaceFlag = false;
       if(vs->Field) {
@@ -519,7 +522,7 @@ static void ObjectVolumeUpdate(ObjectVol
         }
 
         // cull my friend, cull */ 
-        voxelmap = MapNew(I->Obj.G,
+        voxelmap = MapNew(I->G,
             -carve_buffer, vs->AtomVertex,
             VLAGetSize(vs->AtomVertex) / 3, NULL);
         if(voxelmap) {
@@ -570,12 +573,12 @@ static void ObjectVolumeUpdate(ObjectVol
       }
     }
     vs->isUpdated = true;
-    SceneInvalidate(I->Obj.G);
+    SceneInvalidate(I->G);
   }
-  if(!I->Obj.ExtentFlag) {
+  if(!I->ExtentFlag) {
     ObjectVolumeRecomputeExtent(I);
-    if(I->Obj.ExtentFlag)
-      SceneInvalidate(I->Obj.G);
+    if(I->ExtentFlag)
+      SceneInvalidate(I->G);
   }
 }
 
@@ -607,7 +610,7 @@ static float * ObjectVolumeStateGetColor
   r_min -= stdev * 0.5;
   range += stdev;
 
-  colors = Calloc(float, 4 * count);
+  colors = pymol::calloc<float>(4 * count);
   ok_assert(1, colors);
 
   for (i = 0; i < ovs->RampSize; i++) {
@@ -687,9 +690,9 @@ static size_t createColorTexture(PyMOLGl
 static size_t createPreintegrationTexture(PyMOLGlobals * G, const float *Table, const int count)
 {
   float factor, tmp1[4];
-  Vector4f *sat = Alloc(Vector4f, count + 1);
+  Vector4f *sat = pymol::malloc<Vector4f>(count + 1);
   int i, sb, sf, lookupindex = 0;
-  GLfloat *lookupImg = Alloc(GLfloat, count * count * 4);
+  GLfloat *lookupImg = pymol::malloc<GLfloat>(count * count * 4);
 
   memset(sat[0], 0, sizeof(sat[0]));
 
@@ -745,12 +748,12 @@ static size_t createPreintegrationTextur
 static void ObjectVolumeRender(ObjectVolume * I, RenderInfo * info)
 {
 #ifndef PURE_OPENGL_ES_2
-  PyMOLGlobals *G = I->Obj.G;
+  PyMOLGlobals *G = I->G;
   int state = info->state;
   int pass = info->pass;
   int a = 0;
   ObjectVolumeState *vs = NULL;
-  float volume_layers =  SettingGet_f(I->Obj.G, I->Obj.Setting, NULL, cSetting_volume_layers);
+  float volume_layers =  SettingGet_f(I->G, I->Setting, NULL, cSetting_volume_layers);
   short volume_mode = SettingGetGlobal_i(G, cSetting_volume_mode);
   short ortho = SettingGetGlobal_i(G, cSetting_ortho);
   /* make this a setting? */
@@ -782,7 +785,7 @@ static void ObjectVolumeRender(ObjectVol
   }
 
   // ViewElem/TTT Matrix
-  ObjectPrepareContext(&I->Obj, info);
+  ObjectPrepareContext(I, info);
 
   for(a = 0; a < I->NState; ++a) {
 
@@ -797,19 +800,19 @@ static void ObjectVolumeRender(ObjectVol
     if(!vs || !vs->Active)
       continue;
 
-    PRINTFB(I->Obj.G, FB_ObjectVolume, FB_Blather)
+    PRINTFB(I->G, FB_ObjectVolume, FB_Blather)
       "ObjectVolumeRender-Msg: state=%d, pass=%d, refresh=%d, recolor=%d.\n",
-      a, pass, vs->RefreshFlag, vs->RecolorFlag ENDFB(I->Obj.G); 
+      a, pass, vs->RefreshFlag, vs->RecolorFlag ENDFB(I->G); 
 
     corner = vs->Corner;
 
-    SceneResetNormal(I->Obj.G, false);
+    SceneResetNormal(I->G, false);
 
     // render bounding box
-    if((I->Obj.visRep & cRepExtentBit)) {
+    if((I->visRep & cRepExtentBit)) {
       if(!info->line_lighting)
         glDisable(GL_LIGHTING);
-      ObjectUseColor(&I->Obj);
+      ObjectUseColor(I);
       ExtentRender(corner);
     }
 
@@ -851,7 +854,7 @@ static void ObjectVolumeRender(ObjectVol
         return;
       }
 
-      int volume_bit_val = SettingGet_i(G, I->Obj.Setting, NULL, cSetting_volume_bit_depth);
+      int volume_bit_val = SettingGet_i(G, I->Setting, NULL, cSetting_volume_bit_depth);
       volume_bit_depth = (volume_bit_val < 17) ? tex::data_type::HALF_FLOAT : tex::data_type::FLOAT;
 
 /* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in "os_proprietary.h") */
@@ -912,7 +915,7 @@ static void ObjectVolumeRender(ObjectVol
     }
 
     // render volume
-    if((I->Obj.visRep & cRepVolumeBit)) {
+    if((I->visRep & cRepVolumeBit)) {
       int i, j;
 
       glDisable(GL_LIGHTING);
@@ -934,7 +937,7 @@ static void ObjectVolumeRender(ObjectVol
       }
 
       // TTT (movie object motions)
-      if(ObjectGetTTT(&I->Obj, &ttt, -1))
+      if(ObjectGetTTT(I, &ttt, -1))
         MatrixTransformC44fAs33f3f(ttt, zaxis, zaxis);
 
       // determine number of slices based on max extent
@@ -1125,13 +1128,13 @@ ObjectVolume *ObjectVolumeNew(PyMOLGloba
   I->NState = 0;
   I->State = VLACalloc(ObjectVolumeState, 10);   /* autozero important */
 
-  I->Obj.type = cObjectVolume;
+  I->type = cObjectVolume;
 
-  I->Obj.fFree = (void (*)(CObject *)) ObjectVolumeFree;
-  I->Obj.fUpdate = (void (*)(CObject *)) ObjectVolumeUpdate;
-  I->Obj.fRender = (void (*)(CObject *, RenderInfo *)) ObjectVolumeRender;
-  I->Obj.fInvalidate = (void (*)(CObject *, int, int, int)) ObjectVolumeInvalidate;
-  I->Obj.fGetNFrame = (int (*)(CObject *)) ObjectVolumeGetNStates;
+  I->fFree = (void (*)(CObject *)) ObjectVolumeFree;
+  I->fUpdate = (void (*)(CObject *)) ObjectVolumeUpdate;
+  I->fRender = (void (*)(CObject *, RenderInfo *)) ObjectVolumeRender;
+  I->fInvalidate = (void (*)(CObject *, int, int, int)) ObjectVolumeInvalidate;
+  I->fGetNFrame = (int (*)(CObject *)) ObjectVolumeGetNStates;
   return (I);
 }
 
@@ -1197,7 +1200,7 @@ ObjectVolume *ObjectVolumeFromXtalSym(Py
   vs = I->State + state;
   ObjectVolumeStateInit(G, vs);
 
-  strcpy(vs->MapName, map->Obj.Name);
+  strcpy(vs->MapName, map->Name);
   vs->MapState = map_state;
   oms = ObjectMapGetState(map, map_state);
 
@@ -1241,7 +1244,7 @@ ObjectVolume *ObjectVolumeFromXtalSym(Py
           fdim[0] = eff_range[3] - eff_range[0];
           fdim[1] = eff_range[4] - eff_range[1];
           fdim[2] = eff_range[5] - eff_range[2];
-          vs->Field = IsosurfFieldAlloc(I->Obj.G, fdim);
+          vs->Field = IsosurfFieldAlloc(I->G, fdim);
 
           expand_result =
             IsosurfExpand(oms->Field, vs->Field, oms->Symmetry->Crystal, sym, eff_range);
@@ -1267,7 +1270,7 @@ ObjectVolume *ObjectVolumeFromXtalSym(Py
   vs->CarveBuffer = carve;
   vs->AtomVertex = vert_vla;
 
-  I->Obj.ExtentFlag = false;
+  I->ExtentFlag = false;
 
   SceneChanged(G);
   SceneCountFrames(G);
@@ -1301,26 +1304,26 @@ void ObjectVolumeRecomputeExtent(ObjectV
       if(vs->ExtentFlag) {
         if(!extent_flag) {
           extent_flag = true;
-          copy3f(vs->ExtentMax, I->Obj.ExtentMax);
-          copy3f(vs->ExtentMin, I->Obj.ExtentMin);
+          copy3f(vs->ExtentMax, I->ExtentMax);
+          copy3f(vs->ExtentMin, I->ExtentMin);
         } else {
-          max3f(vs->ExtentMax, I->Obj.ExtentMax, I->Obj.ExtentMax);
-          min3f(vs->ExtentMin, I->Obj.ExtentMin, I->Obj.ExtentMin);
+          max3f(vs->ExtentMax, I->ExtentMax, I->ExtentMax);
+          min3f(vs->ExtentMin, I->ExtentMin, I->ExtentMin);
         }
       }
     }
   }
 
-  I->Obj.ExtentFlag = extent_flag;
+  I->ExtentFlag = extent_flag;
 
-  if(I->Obj.TTTFlag && I->Obj.ExtentFlag) {
+  if(I->TTTFlag && I->ExtentFlag) {
     const float *ttt;
     double tttd[16];
-    if(ObjectGetTTT(&I->Obj, &ttt, -1)) {
+    if(ObjectGetTTT(I, &ttt, -1)) {
       convertTTTfR44d(ttt, tttd);
       MatrixTransformExtentsR44d3f(tttd,
-                                   I->Obj.ExtentMin, I->Obj.ExtentMax,
-                                   I->Obj.ExtentMin, I->Obj.ExtentMax);
+                                   I->ExtentMin, I->ExtentMax,
+                                   I->ExtentMin, I->ExtentMax);
     }
   }
 }
@@ -1356,11 +1359,11 @@ int ObjectVolumeSetRamp(ObjectVolume * I
   ovs->RampSize = list_size / 5;
   ovs->RecolorFlag = true;
 
-  SceneChanged(I->Obj.G);
+  SceneChanged(I->G);
 
   return true;
 ok_except1:
-  PRINTFB(I->Obj.G, FB_ObjectVolume, FB_Errors)
-    "ObjectVolumeSetRamp failed" ENDFB(I->Obj.G);
+  PRINTFB(I->G, FB_ObjectVolume, FB_Errors)
+    "ObjectVolumeSetRamp failed" ENDFB(I->G);
   return false;
 }
diff -upNr pymol-open-source-2.3.0/layer2/ObjectVolume.h pymol-open-source-2.3.3/layer2/ObjectVolume.h
--- pymol-open-source-2.3.0/layer2/ObjectVolume.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/ObjectVolume.h	2019-08-22 10:24:47.722596342 +0200
@@ -50,11 +50,10 @@ typedef struct {
   int isUpdated; 
 } ObjectVolumeState;
 
-typedef struct ObjectVolume {
-  CObject Obj;
+struct ObjectVolume : public CObject {
   ObjectVolumeState *State;
   int NState;
-} ObjectVolume;
+};
 
 ObjectVolume *ObjectVolumeFromBox(PyMOLGlobals * G, ObjectVolume * obj, ObjectMap * map,
                               int map_state,
diff -upNr pymol-open-source-2.3.0/layer2/RepAngle.cpp pymol-open-source-2.3.3/layer2/RepAngle.cpp
--- pymol-open-source-2.3.0/layer2/RepAngle.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/RepAngle.cpp	2019-08-22 10:24:47.722596342 +0200
@@ -66,11 +66,11 @@ static int RepAngleCGOGenerate(RepAngle
   CGO *convertcgo = NULL;
   int dash_as_cylinders = SettingGetGlobal_b(G, cSetting_render_as_cylinders) && SettingGetGlobal_b(G, cSetting_dash_as_cylinders);
   int color =
-    SettingGet_color(G, NULL, I->ds->Obj->Obj.Setting, cSetting_angle_color);
+    SettingGet_color(G, NULL, I->ds->Obj->Setting, cSetting_angle_color);
   I->linewidth = line_width = 
-    SettingGet_f(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dash_width);
+    SettingGet_f(G, NULL, I->ds->Obj->Setting, cSetting_dash_width);
   I->radius =
-    SettingGet_f(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dash_radius);
+    SettingGet_f(G, NULL, I->ds->Obj->Setting, cSetting_dash_radius);
   line_width = SceneGetDynamicLineWidth(info, line_width);
   ok &= CGOSpecial(I->shaderCGO, LINEWIDTH_DYNAMIC_WITH_SCALE_DASH);
   if (ok)
@@ -163,9 +163,9 @@ static void RepAngleRenderImmediate(RepA
   int c = I->N;
   float line_width;
   bool t_mode_3 =
-    SettingGet_i(G, NULL, I->ds->Obj->Obj.Setting, cSetting_transparency_mode) == 3;
+    SettingGet_i(G, NULL, I->ds->Obj->Setting, cSetting_transparency_mode) == 3;
   line_width = 
-    SettingGet_f(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dash_width);
+    SettingGet_f(G, NULL, I->ds->Obj->Setting, cSetting_dash_width);
   line_width = SceneGetDynamicLineWidth(info, line_width);
 
   if(info->width_scale_flag) {
@@ -214,18 +214,18 @@ static void RepAngleRender(RepAngle * I,
   float dash_transparency;
   short dash_transparency_enabled;
   int color =
-    SettingGet_color(G, NULL, I->ds->Obj->Obj.Setting, cSetting_angle_color);
+    SettingGet_color(G, NULL, I->ds->Obj->Setting, cSetting_angle_color);
   if(color < 0)
     color = I->Obj->Color;
   I->linewidth = line_width = 
-    SettingGet_f(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dash_width);
+    SettingGet_f(G, NULL, I->ds->Obj->Setting, cSetting_dash_width);
   I->radius =
-    SettingGet_f(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dash_radius);
+    SettingGet_f(G, NULL, I->ds->Obj->Setting, cSetting_dash_radius);
   round_ends =
-    SettingGet_b(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dash_round_ends);
+    SettingGet_b(G, NULL, I->ds->Obj->Setting, cSetting_dash_round_ends);
   line_width = SceneGetDynamicLineWidth(info, line_width);
   dash_transparency =
-    SettingGet_f(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dash_transparency);
+    SettingGet_f(G, NULL, I->ds->Obj->Setting, cSetting_dash_transparency);
   dash_transparency = (dash_transparency < 0.f ? 0.f : (dash_transparency > 1.f ? 1.f : dash_transparency));
   dash_transparency_enabled = (dash_transparency > 0.f);
 
@@ -314,7 +314,7 @@ Rep *RepAngleNew(DistSet * ds, int state
   int ok = true;
   float dash_transparency;
   dash_transparency =
-    SettingGet_f(G, NULL, ds->Obj->Obj.Setting, cSetting_dash_transparency);
+    SettingGet_f(G, NULL, ds->Obj->Setting, cSetting_dash_transparency);
   dash_transparency = (dash_transparency < 0.f ? 0.f : (dash_transparency > 1.f ? 1.f : dash_transparency));
 
   OOAlloc(G, RepAngle);
@@ -332,10 +332,10 @@ Rep *RepAngleNew(DistSet * ds, int state
   I->R.fRender = (void (*)(struct Rep *, RenderInfo * info)) RepAngleRender;
   I->R.fFree = (void (*)(struct Rep *)) RepAngleFree;
   I->R.fRecolor = NULL;
-  I->R.obj = &ds->Obj->Obj;
+  I->R.obj = ds->Obj;
 
-  dash_len = SettingGet_f(G, NULL, ds->Obj->Obj.Setting, cSetting_dash_length);
-  dash_gap = SettingGet_f(G, NULL, ds->Obj->Obj.Setting, cSetting_dash_gap);
+  dash_len = SettingGet_f(G, NULL, ds->Obj->Setting, cSetting_dash_length);
+  dash_gap = SettingGet_f(G, NULL, ds->Obj->Setting, cSetting_dash_gap);
   dash_sum = dash_len + dash_gap;
   if(dash_sum < R_SMALL4)
     dash_sum = 0.1F;
@@ -366,7 +366,7 @@ Rep *RepAngleNew(DistSet * ds, int state
         radius = l2;
       else
         radius = l1;
-      radius *= SettingGet_f(G, NULL, ds->Obj->Obj.Setting, cSetting_angle_size);
+      radius *= SettingGet_f(G, NULL, ds->Obj->Setting, cSetting_angle_size);
 
       angle = get_angle3f(d1, d2);
 
diff -upNr pymol-open-source-2.3.0/layer2/RepCartoon.cpp pymol-open-source-2.3.3/layer2/RepCartoon.cpp
--- pymol-open-source-2.3.0/layer2/RepCartoon.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/RepCartoon.cpp	2019-08-22 10:24:47.722596342 +0200
@@ -1669,7 +1669,7 @@ int GenerateRepCartoonProcessCylindrical
   float helix_radius;
   CGOPickColor(cgo, 0, cPickableNoPick);
   helix_radius =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_helix_radius);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_helix_radius);
 
     /* this is confusing because we're borrowing Extrude's arrays 
      * for convenient storage, but not actually calling Extrude */
@@ -1909,8 +1909,8 @@ int GenerateRepCartoonDrawRings(PyMOLGlo
   int mem[8];
   int nbr[7];
   int *neighbor;
-  int *marked = Calloc(int, obj->NAtom);
-  float *moved = Calloc(float, obj->NAtom * 3);
+  int *marked = pymol::calloc<int>(obj->NAtom);
+  float *moved = pymol::calloc<float>(obj->NAtom * 3);
   int ring_color;
   int ok = true;
   int escape_count;
@@ -1920,25 +1920,25 @@ int GenerateRepCartoonDrawRings(PyMOLGlo
   int cartoon_side_chain_helper;
   float ring_alpha;
   ring_alpha =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_ring_transparency);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_ring_transparency);
   if(ring_alpha < 0.0F)
     ring_alpha = alpha;
   else
     ring_alpha = 1.0F - ring_alpha;
   cartoon_side_chain_helper =
-    SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_side_chain_helper);
+    SettingGet_b(G, cs->Setting, obj->Setting, cSetting_cartoon_side_chain_helper);
   ladder_mode =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_ladder_mode);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_ladder_mode);
   ladder_radius =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_ladder_radius);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_ladder_radius);
   ladder_color =
-    SettingGet_color(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_ladder_color);
+    SettingGet_color(G, cs->Setting, obj->Setting, cSetting_cartoon_ladder_color);
   ring_radius =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_ring_radius);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_ring_radius);
   if(ladder_color == -1)
     ladder_color = cartoon_color;
   ring_color =
-    SettingGet_color(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_ring_color);
+    SettingGet_color(G, cs->Setting, obj->Setting, cSetting_cartoon_ring_color);
   if(ring_color == -1)
     ring_color = cartoon_color;
 
@@ -2294,12 +2294,12 @@ int CartoonExtrudePutty(PyMOLGlobals *G,
     ExtrudeBuildNormals1f(ex);
   if (ok)
     ok &= ExtrudeComputePuttyScaleFactors(ex, obj,
-                                          SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_putty_transform),
+                                          SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_putty_transform),
                                           putty_vals[0], putty_vals[1], putty_vals[2], putty_vals[3],
-                                          SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_putty_scale_power),
-                                          SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_putty_range),
-                                          SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_putty_scale_min),
-                                          SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_putty_scale_max),
+                                          SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_putty_scale_power),
+                                          SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_putty_range),
+                                          SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_putty_scale_min),
+                                          SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_putty_scale_max),
                                           sampling / 2);
   if (ok)
     ok &= ExtrudeCGOSurfaceVariableTube(ex, cgo, 1);
@@ -2446,7 +2446,7 @@ int CartoonExtrudeDumbbell(PyMOLGlobals
  */
 static int GetCartoonQuality(CoordSet * cs, int setting, int v1, int v2, int v3, int v4, int min_=3) {
   int quality =
-    SettingGet_i(cs->State.G, cs->Setting, cs->Obj->Obj.Setting, setting);
+    SettingGet_i(cs->State.G, cs->Setting, cs->Obj->Setting, setting);
 
   if (quality == -1) {
     int natom = cs->NIndex;
@@ -2513,37 +2513,37 @@ CGO *GenerateRepCartoonCGO(CoordSet *cs,
   };
 
   cartoon_color =
-    SettingGet_color(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_color);
+    SettingGet_color(G, cs->Setting, obj->Setting, cSetting_cartoon_color);
   ring_width =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_ring_width);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_ring_width);
   if(ring_width < 0.0F) {
     ring_width =
-      fabs(SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_stick_radius)) * 0.5F;
+      fabs(SettingGet_f(G, cs->Setting, obj->Setting, cSetting_stick_radius)) * 0.5F;
   }
-  length = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_rect_length);
-  width = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_rect_width);
+  length = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_rect_length);
+  width = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_rect_width);
   oval_length =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_oval_length);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_oval_length);
   dumbbell_length =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_dumbbell_length);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_dumbbell_length);
   oval_width =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_oval_width);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_oval_width);
   dumbbell_width =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_dumbbell_width);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_dumbbell_width);
   dumbbell_radius =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_dumbbell_radius);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_dumbbell_radius);
   if(dumbbell_radius < 0.01F)
     dumbbell_radius = 0.01F;
 
-  tube_cap = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_tube_cap);
-  loop_cap = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_loop_cap);
+  tube_cap = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_tube_cap);
+  loop_cap = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_loop_cap);
 
   tube_radius =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_tube_radius);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_tube_radius);
   if(tube_radius < 0.01F)
     tube_radius = 0.01F;
   putty_radius =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_putty_radius);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_putty_radius);
   /* WLD removed: if(putty_radius<0.01F) putty_radius=0.01F; --
      should not constrain what is effectively a scale factor */
 
@@ -2561,29 +2561,29 @@ CGO *GenerateRepCartoonCGO(CoordSet *cs,
   if(SettingGetGlobal_i(G, cSetting_ray_trace_mode) > 0)
     if(loop_quality < 12)
       loop_quality *= 2;
-  refine = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_refine);
-  power_a = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_power);
-  power_b = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_power_b);
-  throw_ = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_throw);
+  refine = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_refine);
+  power_a = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_power);
+  power_b = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_power_b);
+  throw_ = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_throw);
   loop_radius =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_loop_radius);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_loop_radius);
   if(loop_radius < 0.01F)
     loop_radius = 0.01F;
   discrete_colors =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_discrete_colors);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_discrete_colors);
   nucleic_color =
-    SettingGet_color(G, cs->Setting, obj->Obj.Setting,
+    SettingGet_color(G, cs->Setting, obj->Setting,
                      cSetting_cartoon_nucleic_acid_color);
   if(nucleic_color == -1)
     nucleic_color = cartoon_color;
   highlight_color =
-    SettingGet_color(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_highlight_color);
+    SettingGet_color(G, cs->Setting, obj->Setting, cSetting_cartoon_highlight_color);
 
   cylindrical_helices =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_cylindrical_helices);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_cylindrical_helices);
 
-  sampling_tmp = Alloc(float, sampling * 3);
-  cartoon_debug = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_debug);
+  sampling_tmp = pymol::malloc<float>(sampling * 3);
+  cartoon_debug = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_debug);
 
   cgo = CGONew(G);
   if(alpha != 1.0F)
@@ -2852,19 +2852,19 @@ void RepCartoonGeneratePASS1(PyMOLGlobal
 
   // settings
   fancy_sheets =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_fancy_sheets);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_fancy_sheets);
   fancy_helices =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_fancy_helices);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_fancy_helices);
   cylindrical_helices =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_cylindrical_helices);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_cylindrical_helices);
   cartoon_side_chain_helper =
-    SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_side_chain_helper);
+    SettingGet_b(G, cs->Setting, obj->Setting, cSetting_cartoon_side_chain_helper);
   int trace_ostate =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_trace_atoms);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_trace_atoms);
   trace_mode =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_trace_atoms_mode);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_trace_atoms_mode);
   auto gap_cutoff =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_gap_cutoff);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_gap_cutoff);
 
   // iterate over (sorted) atoms
   for(CoordSetAtomIterator iter(cs); iter.next();) {
@@ -3354,7 +3354,7 @@ void RepCartoonRefineNormals(PyMOLGlobal
                              nuc_acid_data *ndata, int nAt, int *seg, float *tv, float *pvo, 
                              float *pva, int *sstype, float *nv){
   int refine_normals =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_refine_normals);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_refine_normals);
   if(refine_normals < 0) {
     if(obj->NCSet > 1) {
       int i, n_set = 0;
@@ -3502,7 +3502,7 @@ void RepCartoonFlattenSheets(PyMOLGlobal
   int flat_cycles;
   float t0[3];
   flat_cycles =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_flat_cycles);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_flat_cycles);
 
   last = 0;
   first = -1;
@@ -3581,7 +3581,7 @@ void RepCartoonFlattenSheetsRefineTips(P
   float refine_tips;
   float t0[3];
   refine_tips =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_refine_tips);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_refine_tips);
   sptr = seg + 1;
   ss = sstype + 1;
   v2 = tv + 3;            /* normal */
@@ -3609,11 +3609,11 @@ void RepCartoonSmoothLoops(PyMOLGlobals
   float t0[3];
   int smooth_first, smooth_last, smooth_cycles;
   smooth_first =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_smooth_first);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_smooth_first);
   smooth_last =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_smooth_last);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_smooth_last);
   smooth_cycles =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_smooth_cycles);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_smooth_cycles);
 
   sptr = seg;
   ss = sstype;
@@ -3732,20 +3732,20 @@ Rep *RepCartoonNew(CoordSet * cs, int st
   RepInit(G, &I->R);
 
   alpha =
-    1.0F - SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_transparency);
+    1.0F - SettingGet_f(G, cs->Setting, obj->Setting, cSetting_cartoon_transparency);
   round_helices =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_round_helices);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_round_helices);
   na_mode =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_nucleic_acid_mode);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_nucleic_acid_mode);
   ladder_mode =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_ladder_mode);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_ladder_mode);
 
   I->R.fRender = (void (*)(struct Rep *, RenderInfo *)) RepCartoonRender;
   I->R.fSameVis = (int (*)(struct Rep *, struct CoordSet *)) RepCartoonSameVis;
   I->R.fFree = (void (*)(struct Rep *)) RepCartoonFree;
   I->R.fInvalidate = RepCartoonInvalidate;
   I->R.fRecolor = NULL;
-  I->R.obj = &obj->Obj;
+  I->R.obj = obj;
   I->R.cs = cs;
   I->ray = NULL;
   I->std = NULL;
@@ -3755,21 +3755,21 @@ Rep *RepCartoonNew(CoordSet * cs, int st
 
   /* find all of the CA points */
 
-  at = Alloc(int, cs->NAtIndex);        /* cs index pointers */
-  pv = Alloc(float, cs->NAtIndex * 3);
-  tmp = Alloc(float, cs->NAtIndex * 3);
-  pvo = Alloc(float, cs->NAtIndex * 3); /* orientation vector */
-  pva = Alloc(float, cs->NAtIndex * 6); /* alternative orientation vectors, two per atom */
-  seg = Alloc(int, cs->NAtIndex);
-  car = Calloc(CCInOut, cs->NAtIndex);       /* cartoon type for each atom */
-  sstype = Alloc(int, cs->NAtIndex);
-  flag_tmp = Calloc(int, cs->NAtIndex);
-  nuc_flag = Calloc(int, cs->NAtIndex);
+  at = pymol::malloc<int>(cs->NAtIndex);        /* cs index pointers */
+  pv = pymol::malloc<float>(cs->NAtIndex * 3);
+  tmp = pymol::malloc<float>(cs->NAtIndex * 3);
+  pvo = pymol::malloc<float>(cs->NAtIndex * 3); /* orientation vector */
+  pva = pymol::malloc<float>(cs->NAtIndex * 6); /* alternative orientation vectors, two per atom */
+  seg = pymol::malloc<int>(cs->NAtIndex);
+  car = pymol::calloc<CCInOut>(cs->NAtIndex);       /* cartoon type for each atom */
+  sstype = pymol::malloc<int>(cs->NAtIndex);
+  flag_tmp = pymol::calloc<int>(cs->NAtIndex);
+  nuc_flag = pymol::calloc<int>(cs->NAtIndex);
 
-  I->LastVisib = Calloc(char, cs->NAtIndex);
+  I->LastVisib = pymol::calloc<char>(cs->NAtIndex);
   
   auto cartoon_all_alt =
-    SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_all_alt);
+    SettingGet_b(G, cs->Setting, obj->Setting, cSetting_cartoon_all_alt);
 
   ndata.next_alt = 0;
 
@@ -3801,9 +3801,9 @@ Rep *RepCartoonNew(CoordSet * cs, int st
   ndata.fp = flag_tmp;
   ndata.vptr = pv;
   ndata.voptr = pvo;
-  ndata.ring_mode = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_ring_mode);
+  ndata.ring_mode = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_ring_mode);
   ndata.ring_finder =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_ring_finder);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_ring_finder);
   ndata.ring_finder_eff = ndata.ring_finder;
   if((!ndata.ring_mode) || (ndata.ring_finder == 2))
     ndata.ring_finder_eff = 1;
@@ -3823,13 +3823,13 @@ Rep *RepCartoonNew(CoordSet * cs, int st
     " RepCartoon-Debug: path outlined, interpolating... nAt=%d\n", nAt ENDFD;
 
   if(nAt) {
-    dv = Alloc(float, nAt * 3);  /* differences between next and current 3f */
-    nv = Alloc(float, nAt * 3);  /* normal */
-    dl = Alloc(float, nAt);      /* length (i.e., normal * length = difference) */
+    dv = pymol::malloc<float>(nAt * 3);  /* differences between next and current 3f */
+    nv = pymol::malloc<float>(nAt * 3);  /* normal */
+    dl = pymol::malloc<float>(nAt);      /* length (i.e., normal * length = difference) */
     RepCartoonComputeDifferencesAndNormals(G, nAt, seg, pv, dv, nv, dl, true);
 
     /* compute tangents */
-    tv = Alloc(float, nAt * 3 + 6);
+    tv = pymol::malloc<float>(nAt * 3 + 6);
     RepCartoonComputeTangents(nAt, seg, nv, tv);
 
     PRINTFD(G, FB_RepCartoon)
@@ -3843,8 +3843,8 @@ Rep *RepCartoonNew(CoordSet * cs, int st
     RepCartoonRefineNormals(G, I, obj, cs, &ndata, nAt, seg, tv, pvo, pva, sstype, nv);
 
     {
-      int smooth_loops = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_smooth_loops);
-      bool cartoon_flat_sheets = SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_flat_sheets);
+      int smooth_loops = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_smooth_loops);
+      bool cartoon_flat_sheets = SettingGet_b(G, cs->Setting, obj->Setting, cSetting_cartoon_flat_sheets);
       if(smooth_loops || cartoon_flat_sheets) {
         if(cartoon_flat_sheets) {
           RepCartoonFlattenSheets(G, obj, cs, &ndata, nAt, seg, car, pv, pvo, sstype, tv, tmp, flag_tmp);
diff -upNr pymol-open-source-2.3.0/layer2/RepCylBond.cpp pymol-open-source-2.3.3/layer2/RepCylBond.cpp
--- pymol-open-source-2.3.0/layer2/RepCylBond.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/RepCylBond.cpp	2019-08-22 10:24:47.722596342 +0200
@@ -596,31 +596,31 @@ Rep *RepCylBondNew(CoordSet * cs, int st
     return (NULL);              /* skip if no sticks are visible */
   }
 
-  capdrawn = Calloc(float, obj->NAtom); // max radius of caps
-  marked = Calloc(bool, obj->NAtom);
+  capdrawn = pymol::calloc<float>(obj->NAtom); // max radius of caps
+  marked = pymol::calloc<bool>(obj->NAtom);
   CHECKOK(ok, marked);
   if (!ok){
     RepCylBondFree(I);
     return NULL;
   }
 
-  valence = SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_valence);
+  valence = SettingGet_b(G, cs->Setting, obj->Setting, cSetting_valence);
   valence_flag = (valence != 0.0F);
 
   alpha =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_stick_transparency);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_stick_transparency);
   alpha = 1.0F - alpha;
   if(fabs(alpha - 1.0) < R_SMALL4)
     alpha = 1.0F;
 
-  stick_color = SettingGet_color(G, cs->Setting, obj->Obj.Setting, cSetting_stick_color);
-  cartoon_side_chain_helper = SettingGet_b(G, cs->Setting, obj->Obj.Setting,
+  stick_color = SettingGet_color(G, cs->Setting, obj->Setting, cSetting_stick_color);
+  cartoon_side_chain_helper = SettingGet_b(G, cs->Setting, obj->Setting,
                                            cSetting_cartoon_side_chain_helper);
-  ribbon_side_chain_helper = SettingGet_b(G, cs->Setting, obj->Obj.Setting,
+  ribbon_side_chain_helper = SettingGet_b(G, cs->Setting, obj->Setting,
                                           cSetting_ribbon_side_chain_helper);
 
-  transp = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_stick_transparency);
-  hide_long = SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_hide_long_bonds);
+  transp = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_stick_transparency);
+  hide_long = SettingGet_b(G, cs->Setting, obj->Setting, cSetting_hide_long_bonds);
 
   std::set<int> all_zero_order_bond_atoms;
   b = obj->Bond;
@@ -653,17 +653,17 @@ Rep *RepCylBondNew(CoordSet * cs, int st
     b++;
     ok &= !G->Interrupt;
   }
-  radius = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_stick_radius);
-  half_bonds = SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_half_bonds);
+  radius = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_stick_radius);
+  half_bonds = SettingGet_b(G, cs->Setting, obj->Setting, cSetting_half_bonds);
   na_mode =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_nucleic_acid_mode);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_nucleic_acid_mode);
   int na_mode_ribbon =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_ribbon_nucleic_acid_mode);
-  h_scale = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_stick_h_scale);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_ribbon_nucleic_acid_mode);
+  h_scale = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_stick_h_scale);
   auto valence_zero_scale =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_valence_zero_scale);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_valence_zero_scale);
   auto valence_zero_mode =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_valence_zero_mode);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_valence_zero_mode);
 
   RepInit(G, &I->R);
   I->R.fRender = (void (*)(struct Rep *, RenderInfo *)) RepCylBondRender;
@@ -680,7 +680,7 @@ Rep *RepCylBondNew(CoordSet * cs, int st
     CGOAlpha(I->primitiveCGO, alpha);
   }
   if(ok && obj->NBond) {
-    stick_ball = SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_stick_ball);
+    stick_ball = SettingGet_b(G, cs->Setting, obj->Setting, cSetting_stick_ball);
 
     shader_mode = SettingGetGlobal_b(G, cSetting_use_shaders) && SettingGetGlobal_b(G, cSetting_stick_as_cylinders) 
       && SettingGetGlobal_b(G, cSetting_render_as_cylinders) && SettingGetGlobal_b(G, cSetting_stick_use_shader);
@@ -695,14 +695,14 @@ Rep *RepCylBondNew(CoordSet * cs, int st
       other = ObjectMoleculeGetPrioritizedOtherIndexList(obj, cs);
       CHECKOK(ok, other);
       if (ok){
-        fixed_radius = SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_stick_fixed_radius);
-        scale_r = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_stick_valence_scale);
+        fixed_radius = SettingGet_b(G, cs->Setting, obj->Setting, cSetting_stick_fixed_radius);
+        scale_r = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_stick_valence_scale);
       }
     }
 
     /* spheres for stick & balls */
-    stick_ball_ratio = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_stick_ball_ratio);
-    stick_ball_color = SettingGet_color(G, cs->Setting, obj->Obj.Setting, cSetting_stick_ball_color);
+    stick_ball_ratio = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_stick_ball_ratio);
+    stick_ball_color = SettingGet_color(G, cs->Setting, obj->Setting, cSetting_stick_ball_color);
 
     b = obj->Bond;
     for(a = 0; ok && a < obj->NBond; ++a, ++b) {
@@ -750,7 +750,7 @@ Rep *RepCylBondNew(CoordSet * cs, int st
 
         if(bd_stick_color < 0) {
           if(bd_stick_color == cColorObject) {
-            c1 = (c2 = obj->Obj.Color);
+            c1 = (c2 = obj->Color);
           } else if(ColorCheckRamped(G, bd_stick_color)) {
             c1 = (c2 = bd_stick_color);
           } else {
@@ -974,7 +974,7 @@ static void RepCylinderImmediate(float *
 
   if (dir){
     if (!*dir){
-      *dir = Alloc(float, 3);
+      *dir = pymol::malloc<float>(3);
       (*dir)[0] = d[0]; (*dir)[1] = d[1]; (*dir)[2] = d[2];
     } else {
       if (get_angle3f(d, *dir)>=(cPI/2.)){
@@ -1115,12 +1115,12 @@ void RepCylBondRenderImmediate(CoordSet
   else {
     int active = false;
     ObjectMolecule *obj = cs->Obj;
-    int nEdge = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_stick_quality);
+    int nEdge = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_stick_quality);
     float radius =
-      fabs(SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_stick_radius));
+      fabs(SettingGet_f(G, cs->Setting, obj->Setting, cSetting_stick_radius));
     float overlap =
-      SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_stick_overlap);
-    float nub = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_stick_nub);
+      SettingGet_f(G, cs->Setting, obj->Setting, cSetting_stick_overlap);
+    float nub = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_stick_nub);
     float overlap_r = radius * overlap;
     float nub_r = radius * nub;
 
diff -upNr pymol-open-source-2.3.0/layer2/RepDihedral.cpp pymol-open-source-2.3.3/layer2/RepDihedral.cpp
--- pymol-open-source-2.3.0/layer2/RepDihedral.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/RepDihedral.cpp	2019-08-22 10:24:47.722596342 +0200
@@ -66,11 +66,11 @@ static int RepDihedralCGOGenerate(RepDih
   CGO *convertcgo = NULL;
   short dash_as_cylinders = 0;
   int color =
-    SettingGet_color(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dihedral_color);
+    SettingGet_color(G, NULL, I->ds->Obj->Setting, cSetting_dihedral_color);
   I->linewidth = line_width =
-    SettingGet_f(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dash_width);
+    SettingGet_f(G, NULL, I->ds->Obj->Setting, cSetting_dash_width);
   I->radius =
-    SettingGet_f(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dash_radius);
+    SettingGet_f(G, NULL, I->ds->Obj->Setting, cSetting_dash_radius);
 
   line_width = SceneGetDynamicLineWidth(info, line_width);
 
@@ -173,11 +173,11 @@ static void RepDihedralRender(RepDihedra
   int round_ends;
   int ok = true;
   int color =
-    SettingGet_color(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dihedral_color);
+    SettingGet_color(G, NULL, I->ds->Obj->Setting, cSetting_dihedral_color);
   float dash_transparency =
-    SettingGet_f(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dash_transparency);
+    SettingGet_f(G, NULL, I->ds->Obj->Setting, cSetting_dash_transparency);
   bool t_mode_3 =
-    SettingGet_i(G, NULL, I->ds->Obj->Obj.Setting, cSetting_transparency_mode) == 3;
+    SettingGet_i(G, NULL, I->ds->Obj->Setting, cSetting_transparency_mode) == 3;
   short dash_transparency_enabled;
   if(color < 0)
     color = I->Obj->Color;
@@ -188,11 +188,11 @@ static void RepDihedralRender(RepDihedra
     return;
 
   I->linewidth = line_width =
-    SettingGet_f(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dash_width);
+    SettingGet_f(G, NULL, I->ds->Obj->Setting, cSetting_dash_width);
   I->radius =
-    SettingGet_f(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dash_radius);
+    SettingGet_f(G, NULL, I->ds->Obj->Setting, cSetting_dash_radius);
   round_ends =
-    SettingGet_b(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dash_round_ends);
+    SettingGet_b(G, NULL, I->ds->Obj->Setting, cSetting_dash_round_ends);
 
   line_width = SceneGetDynamicLineWidth(info, line_width);
 
@@ -334,13 +334,13 @@ Rep *RepDihedralNew(DistSet * ds, int st
   I->R.fRender = (void (*)(struct Rep *, RenderInfo * info)) RepDihedralRender;
   I->R.fFree = (void (*)(struct Rep *)) RepDihedralFree;
   I->R.fRecolor = NULL;
-  I->R.obj = &ds->Obj->Obj;
+  I->R.obj = ds->Obj;
   I->R.cs = NULL;
   if (ds && ds->Rep && ds->Rep[cRepDihedral])
     I->R.cs = ds->Rep[cRepDihedral]->cs;
 
-  dash_len = SettingGet_f(G, NULL, ds->Obj->Obj.Setting, cSetting_dash_length);
-  dash_gap = SettingGet_f(G, NULL, ds->Obj->Obj.Setting, cSetting_dash_gap);
+  dash_len = SettingGet_f(G, NULL, ds->Obj->Setting, cSetting_dash_length);
+  dash_gap = SettingGet_f(G, NULL, ds->Obj->Setting, cSetting_dash_gap);
   dash_sum = dash_len + dash_gap;
   if(dash_sum < R_SMALL4)
     dash_sum = 0.5;
@@ -366,7 +366,7 @@ Rep *RepDihedralNew(DistSet * ds, int st
     float d3[3], n1[3], n3[3], x[3], y[3];
     float radius, length, angle, phase, pos;
     float dihedral_size =
-      SettingGet_f(G, NULL, ds->Obj->Obj.Setting, cSetting_dihedral_size);
+      SettingGet_f(G, NULL, ds->Obj->Setting, cSetting_dihedral_size);
 
     I->V = VLAlloc(float, ds->NDihedralIndex * 10);
     CHECKOK(ok, I->V);
diff -upNr pymol-open-source-2.3.0/layer2/RepDistDash.cpp pymol-open-source-2.3.3/layer2/RepDistDash.cpp
--- pymol-open-source-2.3.0/layer2/RepDistDash.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/RepDistDash.cpp	2019-08-22 10:24:47.722596342 +0200
@@ -68,7 +68,7 @@ static void RepDistDashCGOGenerate(RepDi
   float *v = I->V;
   int c = I->N;
   int color =
-    SettingGet_color(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dash_color);
+    SettingGet_color(G, NULL, I->ds->Obj->Setting, cSetting_dash_color);
   short dash_as_cylinders = 0;
 
   dash_as_cylinders = SettingGetGlobal_b(G, cSetting_render_as_cylinders) && SettingGetGlobal_b(G, cSetting_dash_as_cylinders);
@@ -124,13 +124,13 @@ static void RepDistDashRender(RepDistDas
   int round_ends;
   int ok = true;
   int color =
-    SettingGet_color(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dash_color);
+    SettingGet_color(G, NULL, I->ds->Obj->Setting, cSetting_dash_color);
   float line_width =
-    SettingGet_f(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dash_width);
+    SettingGet_f(G, NULL, I->ds->Obj->Setting, cSetting_dash_width);
   float dash_transparency =
-    SettingGet_f(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dash_transparency);
+    SettingGet_f(G, NULL, I->ds->Obj->Setting, cSetting_dash_transparency);
   bool t_mode_3 =
-    SettingGet_i(G, NULL, I->ds->Obj->Obj.Setting, cSetting_transparency_mode) == 3;
+    SettingGet_i(G, NULL, I->ds->Obj->Setting, cSetting_transparency_mode) == 3;
   short dash_transparency_enabled;
   dash_transparency = (dash_transparency < 0.f ? 0.f : (dash_transparency > 1.f ? 1.f : dash_transparency));
   dash_transparency_enabled = (dash_transparency > 0.f);
@@ -142,9 +142,9 @@ static void RepDistDashRender(RepDistDas
     color = I->Obj->Color;
 
   I->radius =
-    SettingGet_f(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dash_radius);
+    SettingGet_f(G, NULL, I->ds->Obj->Setting, cSetting_dash_radius);
   round_ends =
-    SettingGet_b(G, NULL, I->ds->Obj->Obj.Setting, cSetting_dash_round_ends);
+    SettingGet_b(G, NULL, I->ds->Obj->Setting, cSetting_dash_round_ends);
   line_width = SceneGetDynamicLineWidth(info, line_width);
 
   if(ray) {
@@ -352,10 +352,10 @@ Rep *RepDistDashNew(DistSet * ds, int st
   I->R.fRender = (void (*)(struct Rep *, RenderInfo *)) RepDistDashRender;
   I->R.fFree = (void (*)(struct Rep *)) RepDistDashFree;
   I->R.fRecolor = NULL;
-  I->R.obj = &ds->Obj->Obj;
+  I->R.obj = ds->Obj;
   I->R.context.state = state;
-  dash_len = SettingGet_f(G, NULL, ds->Obj->Obj.Setting, cSetting_dash_length);
-  dash_gap = SettingGet_f(G, NULL, ds->Obj->Obj.Setting, cSetting_dash_gap);
+  dash_len = SettingGet_f(G, NULL, ds->Obj->Setting, cSetting_dash_length);
+  dash_gap = SettingGet_f(G, NULL, ds->Obj->Setting, cSetting_dash_gap);
   dash_sum = dash_len + dash_gap;
   if(dash_sum < R_SMALL4)
     dash_sum = 0.5;
diff -upNr pymol-open-source-2.3.0/layer2/RepDistLabel.cpp pymol-open-source-2.3.3/layer2/RepDistLabel.cpp
--- pymol-open-source-2.3.0/layer2/RepDistLabel.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/RepDistLabel.cpp	2019-08-22 10:24:47.726596993 +0200
@@ -238,9 +238,9 @@ Rep *RepDistLabelNew(DistSet * ds, int s
   float *v, *v1, *v2, *v3, d[3], di;
   char buffer[255];
   const float *lab_pos =
-    SettingGet_3fv(G, NULL, ds->Obj->Obj.Setting, cSetting_label_position);
+    SettingGet_3fv(G, NULL, ds->Obj->Setting, cSetting_label_position);
   int default_digits =
-    SettingGet_i(G, NULL, ds->Obj->Obj.Setting, cSetting_label_digits);
+    SettingGet_i(G, NULL, ds->Obj->Setting, cSetting_label_digits);
   Pickable *rp = NULL;
   int ok = true;
 
@@ -297,8 +297,8 @@ Rep *RepDistLabelNew(DistSet * ds, int s
       CHECKOK(ok, ds->LabPos);
     }
 
-    if(ok && SettingGet_b(G, NULL, ds->Obj->Obj.Setting, cSetting_pickable)) {
-      I->R.P = Alloc(Pickable, ds->NLabel + 1);
+    if(ok && SettingGet_b(G, NULL, ds->Obj->Setting, cSetting_pickable)) {
+      I->R.P = pymol::malloc<Pickable>(ds->NLabel + 1);
       CHECKOK(ok, I->R.P);
       if (ok)
 	rp = I->R.P + 1;          /* skip first record! */
@@ -315,7 +315,7 @@ Rep *RepDistLabelNew(DistSet * ds, int s
     lc = ds->LabCoord;
 
     if(ds->NIndex) {
-      int digits = SettingGet_i(G, NULL, ds->Obj->Obj.Setting,
+      int digits = SettingGet_i(G, NULL, ds->Obj->Setting,
                                 cSetting_label_distance_digits);
       WordType format;
       if(digits < 0)
@@ -376,7 +376,7 @@ Rep *RepDistLabelNew(DistSet * ds, int s
 
       float l1, l2;
       float radius;
-      int digits = SettingGet_i(G, NULL, ds->Obj->Obj.Setting,
+      int digits = SettingGet_i(G, NULL, ds->Obj->Setting,
                                 cSetting_label_angle_digits);
       WordType format;
       if(digits < 0)
@@ -405,9 +405,9 @@ Rep *RepDistLabelNew(DistSet * ds, int s
         else
           radius = l1;
         radius *=
-          SettingGet_f(G, NULL, ds->Obj->Obj.Setting,
+          SettingGet_f(G, NULL, ds->Obj->Setting,
                        cSetting_angle_size) * SettingGet_f(G, NULL,
-                                                           ds->Obj->Obj.Setting,
+                                                           ds->Obj->Setting,
                                                            cSetting_angle_label_position);
 
         normalize3f(avg);
@@ -465,13 +465,13 @@ Rep *RepDistLabelNew(DistSet * ds, int s
       float l1, l2;
       float radius;
       float dihedral_size =
-        SettingGet_f(G, NULL, ds->Obj->Obj.Setting, cSetting_dihedral_size);
-      float dihedral_label_position = SettingGet_f(G, NULL, ds->Obj->Obj.Setting,
+        SettingGet_f(G, NULL, ds->Obj->Setting, cSetting_dihedral_size);
+      float dihedral_label_position = SettingGet_f(G, NULL, ds->Obj->Setting,
                                                    cSetting_dihedral_label_position);
 
       float *v4;
       float avg[3];
-      int digits = SettingGet_i(G, NULL, ds->Obj->Obj.Setting,
+      int digits = SettingGet_i(G, NULL, ds->Obj->Setting,
                                 cSetting_label_dihedral_digits);
       WordType format;
       if(digits < 0)
diff -upNr pymol-open-source-2.3.0/layer2/RepDot.cpp pymol-open-source-2.3.3/layer2/RepDot.cpp
--- pymol-open-source-2.3.0/layer2/RepDot.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/RepDot.cpp	2019-08-22 10:24:47.726596993 +0200
@@ -310,7 +310,7 @@ Rep *RepDotDoNew(CoordSet * cs, int mode
 
   RepInit(G, &I->R);
 
-  I->dotSize = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_dot_radius);
+  I->dotSize = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_dot_radius);
 
   I->A = NULL;
   I->T = NULL;
@@ -322,17 +322,17 @@ Rep *RepDotDoNew(CoordSet * cs, int mode
   I->R.fRecolor = NULL;
   I->shaderCGO = 0;
 
-  I->Width = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_dot_width);
-  cullByFlag = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_trim_dots);      /* are we using flags 24 & 25 */
+  I->Width = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_dot_width);
+  cullByFlag = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_trim_dots);      /* are we using flags 24 & 25 */
 
-  dot_color = SettingGet_color(G, cs->Setting, obj->Obj.Setting, cSetting_dot_color);   /* are we using flags 24 & 25 */
-  inclH = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_dot_hydrogens);       /* are we ignoring hydrogens? */
-  if(SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_dot_solvent)) {    /* are we generating a solvent surface? */
-    solv_rad = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_solvent_radius); /* if so, get solvent radius */
+  dot_color = SettingGet_color(G, cs->Setting, obj->Setting, cSetting_dot_color);   /* are we using flags 24 & 25 */
+  inclH = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_dot_hydrogens);       /* are we ignoring hydrogens? */
+  if(SettingGet_b(G, cs->Setting, obj->Setting, cSetting_dot_solvent)) {    /* are we generating a solvent surface? */
+    solv_rad = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_solvent_radius); /* if so, get solvent radius */
   }
 
   /* get current dot sampling */
-  ds = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_dot_density);
+  ds = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_dot_density);
 
   max_vdw += solv_rad;
 
@@ -349,25 +349,25 @@ Rep *RepDotDoNew(CoordSet * cs, int mode
   I->R.obj = (CObject *) obj;
   I->R.cs = cs;
 
-  I->V = (float *) mmalloc(sizeof(float) * cs->NIndex * sp->nDot * 10);
+  I->V = pymol::malloc<float>(cs->NIndex * sp->nDot * 10);
   CHECKOK(ok, I->V);
 
   if(ok && mode == cRepDotAreaType) { /* in area mode, we need to export save addl. info 
                                  * such as the normal vectors, the partial area, 
                                  * the originating atom, etc. */
-    I->A = Alloc(float, cs->NIndex * sp->nDot);
+    I->A = pymol::malloc<float>(cs->NIndex * sp->nDot);
     CHECKOK(ok, I->A);
     if (ok)
-      I->T = Alloc(int, cs->NIndex * sp->nDot);
+      I->T = pymol::malloc<int>(cs->NIndex * sp->nDot);
     CHECKOK(ok, I->T);
     if (ok)
-      I->F = Alloc(int, cs->NIndex * sp->nDot);
+      I->F = pymol::malloc<int>(cs->NIndex * sp->nDot);
     CHECKOK(ok, I->F);
     if (ok)
-      I->VN = Alloc(float, cs->NIndex * sp->nDot * 3);
+      I->VN = pymol::malloc<float>(cs->NIndex * sp->nDot * 3);
     CHECKOK(ok, I->VN);
     if (ok)
-      I->Atom = Alloc(int, cs->NIndex * sp->nDot);
+      I->Atom = pymol::malloc<int>(cs->NIndex * sp->nDot);
     CHECKOK(ok, I->Atom);
     if (ok){
       aa = I->A;
diff -upNr pymol-open-source-2.3.0/layer2/RepEllipsoid.cpp pymol-open-source-2.3.3/layer2/RepEllipsoid.cpp
--- pymol-open-source-2.3.0/layer2/RepEllipsoid.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/RepEllipsoid.cpp	2019-08-22 10:24:47.726596993 +0200
@@ -171,25 +171,25 @@ Rep *RepEllipsoidNew(CoordSet * cs, int
   /*  I->R.fSameVis=(int (*)(struct Rep*, struct CoordSet*))RepEllipsoidSameVis; */
 
   {
-    int ellipsoid_color = SettingGet_color(G, cs->Setting, obj->Obj.Setting,
+    int ellipsoid_color = SettingGet_color(G, cs->Setting, obj->Setting,
                                            cSetting_ellipsoid_color);
 
-    int cartoon_side_chain_helper = SettingGet_b(G, cs->Setting, obj->Obj.Setting,
+    int cartoon_side_chain_helper = SettingGet_b(G, cs->Setting, obj->Setting,
                                                  cSetting_cartoon_side_chain_helper);
 
-    int ribbon_side_chain_helper = SettingGet_b(G, cs->Setting, obj->Obj.Setting,
+    int ribbon_side_chain_helper = SettingGet_b(G, cs->Setting, obj->Setting,
                                                 cSetting_ribbon_side_chain_helper);
 
-    float ellipsoid_scale = SettingGet_f(G, cs->Setting, obj->Obj.Setting,
+    float ellipsoid_scale = SettingGet_f(G, cs->Setting, obj->Setting,
                                          cSetting_ellipsoid_scale);
 
-    float transp = SettingGet_f(G, cs->Setting, obj->Obj.Setting,
+    float transp = SettingGet_f(G, cs->Setting, obj->Setting,
                                 cSetting_ellipsoid_transparency);
 
-    int pickable = SettingGet_b(G, cs->Setting, obj->Obj.Setting,
+    int pickable = SettingGet_b(G, cs->Setting, obj->Setting,
                                 cSetting_pickable);
 
-    float prob = SettingGet_f(G, cs->Setting, obj->Obj.Setting,
+    float prob = SettingGet_f(G, cs->Setting, obj->Setting,
                               cSetting_ellipsoid_probability);
     double matrix_factor = 0.0F;
     float pradius = 0.0F;
@@ -211,7 +211,7 @@ Rep *RepEllipsoidNew(CoordSet * cs, int
       AtomInfoType *ai;
       float last_alpha = 1.0F;
 
-      double *csmatrix = SettingGet_i(G, cs->Setting, obj->Obj.Setting,
+      double *csmatrix = SettingGet_i(G, cs->Setting, obj->Setting,
             cSetting_matrix_mode) > 0 ? NULL : cs->State.Matrix;
 
       for(a = 0; a < cs->NIndex; a++) {
diff -upNr pymol-open-source-2.3.0/layer2/RepLabel.cpp pymol-open-source-2.3.3/layer2/RepLabel.cpp
--- pymol-open-source-2.3.0/layer2/RepLabel.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/RepLabel.cpp	2019-08-22 10:24:47.726596993 +0200
@@ -1524,7 +1524,7 @@ Rep *RepLabelNew(CoordSet * cs, int stat
   RepLabelInit(I);
   obj = cs->Obj;
 
-  label_color = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_label_color);
+  label_color = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_label_color);
   RepInit(G, &I->R);
 
   I->R.fRender = (void (*)(struct Rep *, RenderInfo *)) RepLabelRender;
@@ -1537,16 +1537,16 @@ Rep *RepLabelNew(CoordSet * cs, int stat
 
   /* raytracing primitives */
 
-  I->L = Calloc(lexidx_t, cs->NIndex);
+  I->L = pymol::calloc<lexidx_t>(cs->NIndex);
   ErrChkPtr(G, I->L);
-  I->V = Calloc(float, cs->NIndex * 28);
+  I->V = pymol::calloc<float>(cs->NIndex * 28);
   ErrChkPtr(G, I->V);
 
   I->OutlineColor =
-    SettingGet_color(G, cs->Setting, obj->Obj.Setting, cSetting_label_outline_color);
+    SettingGet_color(G, cs->Setting, obj->Setting, cSetting_label_outline_color);
 
-  if(SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_pickable)) {
-    I->R.P = Alloc(Pickable, cs->NIndex + 1);
+  if(SettingGet_b(G, cs->Setting, obj->Setting, cSetting_pickable)) {
+    I->R.P = pymol::malloc<Pickable>(cs->NIndex + 1);
     ErrChkPtr(G, I->R.P);
     rp = I->R.P + 1;            /* skip first record! */
   }
diff -upNr pymol-open-source-2.3.0/layer2/RepMesh.cpp pymol-open-source-2.3.3/layer2/RepMesh.cpp
--- pymol-open-source-2.3.0/layer2/RepMesh.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/RepMesh.cpp	2019-08-22 10:24:47.726596993 +0200
@@ -580,16 +580,16 @@ void RepMeshColor(RepMesh * I, CoordSet
 
   obj = cs->Obj;
 
-  probe_radius = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_solvent_radius);
-  mesh_color = SettingGet_color(G, cs->Setting, obj->Obj.Setting, cSetting_mesh_color);
-  mesh_mode = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_mesh_mode);
+  probe_radius = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_solvent_radius);
+  mesh_color = SettingGet_color(G, cs->Setting, obj->Setting, cSetting_mesh_color);
+  mesh_mode = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_mesh_mode);
   cullByFlag = (mesh_mode == cRepMesh_by_flags);
   inclH = !(mesh_mode == cRepMesh_heavy_atoms);
 
   if(!I->LastVisib)
-    I->LastVisib = Alloc(int, cs->NIndex);
+    I->LastVisib = pymol::malloc<int>(cs->NIndex);
   if(!I->LastColor)
-    I->LastColor = Alloc(int, cs->NIndex);
+    I->LastColor = pymol::malloc<int>(cs->NIndex);
   lv = I->LastVisib;
   lc = I->LastColor;
   for(a = 0; a < cs->NIndex; a++) {
@@ -599,11 +599,11 @@ void RepMeshColor(RepMesh * I, CoordSet
   }
 
   if(I->mesh_type != 1) {
-    I->Width = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_mesh_width);
-    I->Radius = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_mesh_radius);
+    I->Width = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_mesh_width);
+    I->Radius = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_mesh_radius);
   } else {
-    I->Width = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_dot_width);
-    I->Radius = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_dot_radius);
+    I->Width = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_dot_width);
+    I->Radius = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_dot_radius);
   }
 
   if(I->NTot) {
@@ -615,7 +615,7 @@ void RepMeshColor(RepMesh * I, CoordSet
     }
     first_color = -1;
     if(!I->VC)
-      I->VC = Alloc(float, 3 * I->NTot);
+      I->VC = pymol::malloc<float>(3 * I->NTot);
     vc = I->VC;
     /* now, assign colors to each point */
     map = MapNew(G, I->max_vdw + probe_radius, cs->Coord, cs->NIndex, NULL);
@@ -624,7 +624,7 @@ void RepMeshColor(RepMesh * I, CoordSet
       for(a = 0; a < I->NTot; a++) {
         AtomInfoType *ai0 = NULL;
         c1 = 1;
-        minDist = MAXFLOAT;
+        minDist = FLT_MAX;
         i0 = -1;
         v0 = I->V + 3 * a;
         MapLocus(map, v0, &h, &k, &l);
@@ -742,13 +742,13 @@ Rep *RepMeshNew(CoordSet * cs, int state
     I->R.context.state = state;
   }
   if (ok){
-    probe_radius = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_solvent_radius);
+    probe_radius = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_solvent_radius);
     probe_radius2 = probe_radius * probe_radius;
-    solv_acc = (SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_mesh_solvent));
-    mesh_type = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_mesh_type);
-    mesh_skip = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_mesh_skip);
+    solv_acc = (SettingGet_i(G, cs->Setting, obj->Setting, cSetting_mesh_solvent));
+    mesh_type = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_mesh_type);
+    mesh_skip = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_mesh_skip);
     
-    mesh_mode = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_mesh_mode);
+    mesh_mode = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_mesh_mode);
     cullByFlag = (mesh_mode == cRepMesh_by_flags);
     inclH = !(mesh_mode == cRepMesh_heavy_atoms);
   }
@@ -773,7 +773,7 @@ Rep *RepMeshNew(CoordSet * cs, int state
 
   RepInit(G, &I->R);
 
-  min_spacing = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_min_mesh_spacing);
+  min_spacing = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_min_mesh_spacing);
 
   I->N = NULL;
   I->NTot = 0;
@@ -790,14 +790,14 @@ Rep *RepMeshNew(CoordSet * cs, int state
   I->LastVisib = NULL;
   I->LastColor = NULL;
   I->mesh_type = mesh_type;
-  I->Radius = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_mesh_radius);
+  I->Radius = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_mesh_radius);
   I->shaderCGO = 0;
 
   meshFlag = true;
 
   if(meshFlag) {
     float trim_cutoff =
-      SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_mesh_cutoff);
+      SettingGet_f(G, cs->Setting, obj->Setting, cSetting_mesh_cutoff);
     int trim_flag = false;
     float *trim_vla = NULL;
     MapType *trim_map = NULL;
@@ -805,7 +805,7 @@ Rep *RepMeshNew(CoordSet * cs, int state
     int carve_state = 0;
     int carve_flag = false;
     float carve_cutoff =
-      SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_mesh_carve_cutoff);
+      SettingGet_f(G, cs->Setting, obj->Setting, cSetting_mesh_carve_cutoff);
     const char *carve_selection = NULL;
     float *carve_vla = NULL;
     MapType *carve_map = NULL;
@@ -813,12 +813,12 @@ Rep *RepMeshNew(CoordSet * cs, int state
     int clear_state = 0;
     int clear_flag = false;
     float clear_cutoff =
-      SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_mesh_clear_cutoff);
+      SettingGet_f(G, cs->Setting, obj->Setting, cSetting_mesh_clear_cutoff);
     const char *clear_selection = NULL;
     float *clear_vla = NULL;
     MapType *clear_map = NULL;
 
-    int mesh_max = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_mesh_grid_max);
+    int mesh_max = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_mesh_grid_max);
     if(mesh_max < 1)
       mesh_max = 1;
 
@@ -860,9 +860,9 @@ Rep *RepMeshNew(CoordSet * cs, int state
 
     if(ok && carve_cutoff > 0.0F) {
       carve_state =
-        SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_mesh_carve_state) - 1;
+        SettingGet_i(G, cs->Setting, obj->Setting, cSetting_mesh_carve_state) - 1;
       carve_selection =
-        SettingGet_s(G, cs->Setting, obj->Obj.Setting, cSetting_mesh_carve_selection);
+        SettingGet_s(G, cs->Setting, obj->Setting, cSetting_mesh_carve_selection);
       if(carve_selection)
         carve_map = SelectorGetSpacialMapFromSeleCoord(G,
                                                        SelectorIndexByName(G,
@@ -876,9 +876,9 @@ Rep *RepMeshNew(CoordSet * cs, int state
     }
     if(ok && clear_cutoff > 0.0F) {
       clear_state =
-        SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_mesh_clear_state) - 1;
+        SettingGet_i(G, cs->Setting, obj->Setting, cSetting_mesh_clear_state) - 1;
       clear_selection =
-        SettingGet_s(G, cs->Setting, obj->Obj.Setting, cSetting_mesh_clear_selection);
+        SettingGet_s(G, cs->Setting, obj->Setting, cSetting_mesh_clear_selection);
       if(clear_selection)
         clear_map = SelectorGetSpacialMapFromSeleCoord(G,
                                                        SelectorIndexByName(G,
@@ -902,8 +902,8 @@ Rep *RepMeshNew(CoordSet * cs, int state
 
     if (ok){
       for(c = 0; c < 3; c++) {
-	minE[c] = MAXFLOAT;
-	maxE[c] = -(MAXFLOAT);
+	minE[c] = FLT_MAX;
+	maxE[c] = -FLT_MAX;
       }
       for(b = 0; b < obj->NCSet; b++) {
 	ccs = obj->CSet[b];
@@ -979,8 +979,8 @@ Rep *RepMeshNew(CoordSet * cs, int state
             point[2] = minE[2] + c * gridSize;
             copy3f(point, F3Ptr(field->points, a, b, c));
             aNear = -1;
-            bestDist = MAXFLOAT;
-            aLen = MAXFLOAT;
+            bestDist = FLT_MAX;
+            aLen = FLT_MAX;
             MapLocus(map, point, &h, &k, &l);
             d = *(MapEStart(map, h, k, l));
             if(d) {
@@ -1008,7 +1008,7 @@ Rep *RepMeshNew(CoordSet * cs, int state
                 inSolvFlag = false;
                 /* this point lies within a water radius of the atom, so
                    lets see if it is actually near a water */
-                aLen = MAXFLOAT;
+                aLen = FLT_MAX;
 
                 MapLocus(smap, point, &h, &k, &l);
                 d = *(MapEStart(smap, h, k, l));
@@ -1209,7 +1209,7 @@ int RepMeshGetSolventDots(RepMesh * I, C
   int cnt;
   int inclH, mesh_mode, cullByFlag;
   AtomInfoType *ai1, *ai2;
-  int ds = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_mesh_quality);
+  int ds = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_mesh_quality);
 
   if(ds < 0)
     ds = 0;
@@ -1217,13 +1217,13 @@ int RepMeshGetSolventDots(RepMesh * I, C
     ds = 4;
   sp = G->Sphere->Sphere[ds];
 
-  cavity_cull = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cavity_cull);
+  cavity_cull = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cavity_cull);
 
-  mesh_mode = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_mesh_mode);
+  mesh_mode = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_mesh_mode);
   cullByFlag = (mesh_mode == cRepMesh_by_flags);
   inclH = !(mesh_mode == cRepMesh_heavy_atoms);
 
-  I->Dot = (float *) mmalloc(sizeof(float) * cs->NIndex * 3 * sp->nDot);
+  I->Dot = pymol::malloc<float>(cs->NIndex * 3 * sp->nDot);
   ErrChkPtr(G, I->Dot);
 
   probe_radius_plus = probe_radius * 1.5F;
@@ -1301,7 +1301,7 @@ int RepMeshGetSolventDots(RepMesh * I, C
   }
 
   if(ok && (cavity_cull > 0)) {
-    dot_flag = Alloc(int, I->NDot);
+    dot_flag = pymol::malloc<int>(I->NDot);
     ErrChkPtr(G, dot_flag);
     for(a = 0; a < I->NDot; a++) {
       dot_flag[a] = 0;
diff -upNr pymol-open-source-2.3.0/layer2/RepNonbonded.cpp pymol-open-source-2.3.3/layer2/RepNonbonded.cpp
--- pymol-open-source-2.3.0/layer2/RepNonbonded.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/RepNonbonded.cpp	2019-08-22 10:24:47.726596993 +0200
@@ -56,9 +56,9 @@ void RepNonbondedRenderImmediate(CoordSe
     int active = false;
     ObjectMolecule *obj = cs->Obj;
     float line_width =
-      SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_line_width);
+      SettingGet_f(G, cs->Setting, obj->Setting, cSetting_line_width);
     float nonbonded_size =
-      SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_nonbonded_size);
+      SettingGet_f(G, cs->Setting, obj->Setting, cSetting_nonbonded_size);
 
     if(info->width_scale_flag)
       glLineWidth(line_width * info->width_scale);
@@ -200,7 +200,7 @@ static void RepNonbondedRender(RepNonbon
     alpha = 1.0F;
   if(ray) {
 #ifndef _PYMOL_NO_RAY
-    CGORenderRay(I->primitiveCGO, ray, info, NULL, NULL, I->R.cs->Setting, I->R.cs->Obj->Obj.Setting);
+    CGORenderRay(I->primitiveCGO, ray, info, NULL, NULL, I->R.cs->Setting, I->R.cs->Obj->Setting);
     ray->transparentf(0.0);
 #endif
   } else if(G->HaveGUI && G->ValidContext) {
diff -upNr pymol-open-source-2.3.0/layer2/RepNonbondedSphere.cpp pymol-open-source-2.3.3/layer2/RepNonbondedSphere.cpp
--- pymol-open-source-2.3.0/layer2/RepNonbondedSphere.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/RepNonbondedSphere.cpp	2019-08-22 10:24:47.726596993 +0200
@@ -115,14 +115,14 @@ Rep *RepNonbondedSphereNew(CoordSet * cs
   unsigned char *active = NULL;
   int nSphere = 0;
   float transp =
-    1.f - SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_nonbonded_transparency);
+    1.f - SettingGet_f(G, cs->Setting, obj->Setting, cSetting_nonbonded_transparency);
   int ok = true;
 
   OOAlloc(G, RepNonbondedSphere);
   CHECKOK(ok, I);
 
   if (ok)
-    active = Alloc(unsigned char, cs->NIndex);
+    active = pymol::malloc<unsigned char>(cs->NIndex);
   CHECKOK(ok, active);
 
   if((obj->RepVisCache & cRepNonbondedSphereBit)){
@@ -139,7 +139,7 @@ Rep *RepNonbondedSphereNew(CoordSet * cs
     return (NULL);
   }
   float nb_spheres_size =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_nb_spheres_size);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_nb_spheres_size);
 
   RepInit(G, &I->R);
   I->R.fRender = (void (*)(struct Rep *, RenderInfo *)) RepNonbondedSphereRender;
@@ -187,7 +187,7 @@ Rep *RepNonbondedSphereNew(CoordSet * cs
     ok &= !G->Interrupt;
   }
   CGOStop(I->primitiveCGO);
-  I->primitiveCGO->sphere_quality = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_nb_spheres_quality);
+  I->primitiveCGO->sphere_quality = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_nb_spheres_quality);
   if (ok){
     I->R.context.object = (void *) obj;
     I->R.context.state = state;
diff -upNr pymol-open-source-2.3.0/layer2/RepRibbon.cpp pymol-open-source-2.3.3/layer2/RepRibbon.cpp
--- pymol-open-source-2.3.0/layer2/RepRibbon.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/RepRibbon.cpp	2019-08-22 10:24:47.726596993 +0200
@@ -174,35 +174,35 @@ Rep *RepRibbonNew(CoordSet * cs, int sta
   obj = cs->Obj;
 
   RepInit(G, &I->R);
-  power_a = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_ribbon_power);
-  power_b = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_ribbon_power_b);
-  throw_ = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_ribbon_throw);
-  int trace_ostate = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_ribbon_trace_atoms);
-  trace_mode = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_trace_atoms_mode);
+  power_a = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_ribbon_power);
+  power_b = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_ribbon_power_b);
+  throw_ = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_ribbon_throw);
+  int trace_ostate = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_ribbon_trace_atoms);
+  trace_mode = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_trace_atoms_mode);
   na_mode =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_ribbon_nucleic_acid_mode);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_ribbon_nucleic_acid_mode);
 
   ribbon_color =
-    SettingGet_color(G, cs->Setting, obj->Obj.Setting, cSetting_ribbon_color);
+    SettingGet_color(G, cs->Setting, obj->Setting, cSetting_ribbon_color);
 
-  sampling = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_ribbon_sampling);
+  sampling = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_ribbon_sampling);
   if(sampling < 1)
     sampling = 1;
-  I->radius = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_ribbon_radius);
+  I->radius = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_ribbon_radius);
   I->R.fRender = (void (*)(struct Rep *, RenderInfo *)) RepRibbonRender;
   I->R.fFree = (void (*)(struct Rep *)) RepRibbonFree;
   I->R.fRecolor = NULL;
   I->R.obj = (CObject *) obj;
   I->R.cs = cs;
-  I->ribbon_width = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_ribbon_width);
+  I->ribbon_width = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_ribbon_width);
   I->R.context.object = (void *) obj;
   I->R.context.state = state;
 
   /* find all of the CA points */
 
-  at = Alloc(int, cs->NAtIndex * 2);
-  pv = Alloc(float, cs->NAtIndex * 6);
-  seg = Alloc(int, cs->NAtIndex * 2);
+  at = pymol::malloc<int>(cs->NAtIndex * 2);
+  pv = pymol::malloc<float>(cs->NAtIndex * 6);
+  seg = pymol::malloc<int>(cs->NAtIndex * 2);
 
   i = at;
   v = pv;
@@ -353,9 +353,9 @@ Rep *RepRibbonNew(CoordSet * cs, int sta
     s = seg;
     v = pv;
 
-    dv = Alloc(float, nAt * 6);
-    nv = Alloc(float, nAt * 6);
-    dl = Alloc(float, nAt * 2);
+    dv = pymol::malloc<float>(nAt * 6);
+    nv = pymol::malloc<float>(nAt * 6);
+    dl = pymol::malloc<float>(nAt * 2);
     v1 = dv;
     v2 = nv;
     d = dl;
@@ -386,7 +386,7 @@ Rep *RepRibbonNew(CoordSet * cs, int sta
     s = seg;
     v = nv;
 
-    tv = Alloc(float, nAt * 6 + 6);
+    tv = pymol::malloc<float>(nAt * 6 + 6);
     v1 = tv;
 
     *(v1++) = *(v++);           /* first segment */
@@ -574,13 +574,13 @@ void RepRibbonRenderImmediate(CoordSet *
     AtomInfoType *obj_AtomInfo = obj->AtomInfo;
     AtomInfoType *ai, *last_ai = NULL;
     int trace, trace_ostate =
-      SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_ribbon_trace_atoms);
+      SettingGet_i(G, cs->Setting, obj->Setting, cSetting_ribbon_trace_atoms);
     int trace_mode =
-      SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_trace_atoms_mode);
+      SettingGet_i(G, cs->Setting, obj->Setting, cSetting_trace_atoms_mode);
     int na_mode =
-      SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_ribbon_nucleic_acid_mode);
+      SettingGet_i(G, cs->Setting, obj->Setting, cSetting_ribbon_nucleic_acid_mode);
     float ribbon_width =
-      SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_ribbon_width);
+      SettingGet_f(G, cs->Setting, obj->Setting, cSetting_ribbon_width);
     int a1, a2 = -1;
     int color, last_color = -9;
 
diff -upNr pymol-open-source-2.3.0/layer2/RepSphere.cpp pymol-open-source-2.3.3/layer2/RepSphere.cpp
--- pymol-open-source-2.3.0/layer2/RepSphere.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/RepSphere.cpp	2019-08-22 10:24:47.726596993 +0200
@@ -350,7 +350,7 @@ static float SphereComputeCutMultiplier(
  *
  */
 static void RepSphereCGOSetSphereColorAndPick(ObjectMolecule *obj, CoordSet * cs, CGO *cgo, int idx, int state, float transp, int sphere_color){
-  PyMOLGlobals *G = obj->Obj.G;
+  PyMOLGlobals *G = obj->G;
   int a1 = cs->IdxToAtm[idx];
   float at_transp;
   AtomInfoType *ati1 = obj->AtomInfo + a1;
@@ -384,12 +384,12 @@ CGO *RepSphereGeneratespheroidCGO(Object
   int *q, *s;
   bool ok = true;
   float spheroid_scale =
-    SettingGet_f(I->Obj.G, cs->Setting, I->Obj.Setting, cSetting_spheroid_scale);
+    SettingGet_f(I->G, cs->Setting, I->Setting, cSetting_spheroid_scale);
   int sphere_color =
-    SettingGet_color(I->Obj.G, cs->Setting, I->Obj.Setting, cSetting_sphere_color);
-  float transp = SettingGet_f(I->Obj.G, cs->Setting, I->Obj.Setting, cSetting_sphere_transparency);
+    SettingGet_color(I->G, cs->Setting, I->Setting, cSetting_sphere_color);
+  float transp = SettingGet_f(I->G, cs->Setting, I->Setting, cSetting_sphere_transparency);
 
-  CGO *cgo = CGONew(I->Obj.G);
+  CGO *cgo = CGONew(I->G);
   for(idx = 0; idx < cs->NIndex; idx++) {
     float *v0 = &cs->Coord[3 * idx];
     a = cs->IdxToAtm[idx];
@@ -412,7 +412,7 @@ CGO *RepSphereGeneratespheroidCGO(Object
       }
       CGOEnd(cgo);
       s++;
-      ok &= !I->Obj.G->Interrupt;
+      ok &= !I->G->Interrupt;
     }
   }
   CGOStop(cgo);
@@ -512,7 +512,7 @@ Rep *RepSphereNew(CoordSet * cs, int sta
     return NULL;
   obj = cs->Obj;
 
-  marked = Calloc(bool, obj->NAtom);
+  marked = pymol::calloc<bool>(obj->NAtom);
   CHECKOK(ok, marked);
   if (ok)
     RepInit(G, &I->R);
@@ -522,20 +522,20 @@ Rep *RepSphereNew(CoordSet * cs, int sta
     I->spheroidCGO = RepSphereGeneratespheroidCGO(obj, cs, G->Sphere->Sphere[1], state);
 
   if (ok){
-    sphere_mode = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_sphere_mode);
+    sphere_mode = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_sphere_mode);
     if (!use_shader && (sphere_mode == 5 || sphere_mode == 9)){
       sphere_mode = 0;
     }
   }
   if (ok){
     sphere_color =
-      SettingGet_color(G, cs->Setting, obj->Obj.Setting, cSetting_sphere_color);
+      SettingGet_color(G, cs->Setting, obj->Setting, cSetting_sphere_color);
     cartoon_side_chain_helper =
-      SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_side_chain_helper);
+      SettingGet_b(G, cs->Setting, obj->Setting, cSetting_cartoon_side_chain_helper);
     ribbon_side_chain_helper =
-      SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_ribbon_side_chain_helper);
-    transp = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sphere_transparency);
-    sphere_scale = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sphere_scale);
+      SettingGet_b(G, cs->Setting, obj->Setting, cSetting_ribbon_side_chain_helper);
+    transp = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sphere_transparency);
+    sphere_scale = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sphere_scale);
   }
 
   if (ok){
@@ -550,12 +550,12 @@ Rep *RepSphereNew(CoordSet * cs, int sta
   /* raytracing primitives */
 
   if (ok){
-    if(SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_sphere_solvent)) { /* are we generating a solvent surface? */
-      sphere_add = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_solvent_radius);       /* if so, get solvent radius */
+    if(SettingGet_i(G, cs->Setting, obj->Setting, cSetting_sphere_solvent)) { /* are we generating a solvent surface? */
+      sphere_add = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_solvent_radius);       /* if so, get solvent radius */
     }
     
-    if(SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_pickable)) {
-      I->R.P = Alloc(Pickable, cs->NIndex + 1);
+    if(SettingGet_b(G, cs->Setting, obj->Setting, cSetting_pickable)) {
+      I->R.P = pymol::malloc<Pickable>(cs->NIndex + 1);
       CHECKOK(ok, I->R.P);
     }
   }
@@ -584,7 +584,7 @@ Rep *RepSphereNew(CoordSet * cs, int sta
     float cut_mult = SphereComputeCutMultiplier(G->Sphere->Sphere[1]);
     float *dot = G->Sphere->Sphere[1]->dot[0];
     int n_dot = G->Sphere->Sphere[1]->nDot;
-    int *active = Alloc(int, 2 * n_dot);
+    int *active = pymol::malloc<int>(2 * n_dot);
 
 	ok &= MapSetupExpress(map);
     for(a = 0; ok && a < cs->NIndex; a++) {
@@ -618,10 +618,10 @@ Rep *RepSphereNew(CoordSet * cs, int sta
 
   if(ok) {
     if(!I->LastVisib)
-      I->LastVisib = Alloc(bool, cs->NIndex);
+      I->LastVisib = pymol::malloc<bool>(cs->NIndex);
     CHECKOK(ok, I->LastVisib);
     if(ok && !I->LastColor)
-      I->LastColor = Alloc(int, cs->NIndex);
+      I->LastColor = pymol::malloc<int>(cs->NIndex);
     CHECKOK(ok, I->LastColor);
     if (ok){
       lv = I->LastVisib;
diff -upNr pymol-open-source-2.3.0/layer2/RepSphereImmediate.cpp pymol-open-source-2.3.3/layer2/RepSphereImmediate.cpp
--- pymol-open-source-2.3.0/layer2/RepSphereImmediate.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/RepSphereImmediate.cpp	2019-08-22 10:24:47.726596993 +0200
@@ -106,7 +106,7 @@ static void RenderSphereMode_Immediate_T
                                                  float sphere_scale) {
   /* triangle-based spheres */
   int ds =
-      SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_sphere_quality);
+      SettingGet_i(G, cs->Setting, obj->Setting, cSetting_sphere_quality);
   if (ds < 0) ds = 0;
   if (ds > 4) ds = 4;
   SphereRec *sp = G->Sphere->Sphere[ds];
@@ -164,7 +164,7 @@ static void RenderSphereMode_Immediate_1
                                              int *repActive, float pixel_scale,
                                              int sphere_mode) {
   /* sphere_mode is 1, 2, or 3 */
-  float max_radius = SettingGet_f(G, cs->Setting, obj->Obj.Setting,
+  float max_radius = SettingGet_f(G, cs->Setting, obj->Setting,
                                   cSetting_sphere_point_max_size) *
                      3 * pixel_scale;
   int clamp_size_flag = (max_radius >= 0.0F);
@@ -258,7 +258,7 @@ void RenderImmediate_DoPreGL(PyMOLGlobal
       glHint(GL_POINT_SMOOTH_HINT, GL_FASTEST);
       glDisable(GL_POINT_SMOOTH);
       glDisable(GL_ALPHA_TEST);
-      glPointSize(SettingGet_f(G, cs->Setting, obj->Obj.Setting,
+      glPointSize(SettingGet_f(G, cs->Setting, obj->Setting,
                                cSetting_sphere_point_size));
       break;
   }
@@ -274,9 +274,9 @@ void RepSphereRenderImmediate(CoordSet *
     int repActive = false;
     ObjectMolecule *obj = cs->Obj;
     int sphere_mode =
-        SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_sphere_mode);
+        SettingGet_i(G, cs->Setting, obj->Setting, cSetting_sphere_mode);
     float sphere_scale =
-        SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sphere_scale);
+        SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sphere_scale);
 
     if (sphere_mode > 0) { /* point-based modees */
       float pixel_scale = 1.0F / info->vertex_scale;
diff -upNr pymol-open-source-2.3.0/layer2/RepSurface.cpp pymol-open-source-2.3.3/layer2/RepSurface.cpp
--- pymol-open-source-2.3.0/layer2/RepSurface.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/RepSurface.cpp	2019-08-22 10:24:47.730597645 +0200
@@ -566,17 +566,17 @@ static int RepSurfaceCGOGenerate(RepSurf
             glGetFloatv(GL_MODELVIEW_MATRIX, matrix);
 
             if(I->oneColorFlag) {
-              t_buf = Alloc(float *, I->NT * 6);
+	  t_buf = pymol::malloc<float *>(I->NT * 6);
             } else {
-              t_buf = Alloc(float *, I->NT * 12);
+	  t_buf = pymol::malloc<float *>(I->NT * 12);
             }
 	    CHECKOK(ok, t_buf);
 	    if (ok){
-	      z_value = Alloc(float, I->NT);
+	  z_value = pymol::malloc<float>(I->NT);
 	      CHECKOK(ok, z_value);
 	    }
 	    if (ok){
-	      ix = Alloc(int, I->NT);
+	  ix = pymol::malloc<int>(I->NT);
 	      CHECKOK(ok, ix);
 	    }
             zv = z_value;
@@ -1588,7 +1588,7 @@ static void RepSurfaceRender(RepSurface
       float radius;
       int t0, t1, t2;
       int spacing = 10;
-      int *cache = Calloc(int, spacing * (I->N + 1));
+      int *cache = pymol::calloc<int>(spacing * (I->N + 1));
       CHECKOK(ok, cache);
 
       radius = SettingGet_f(G, I->R.cs->Setting, I->R.obj->Setting, cSetting_mesh_radius);
@@ -1780,17 +1780,17 @@ static void RepSurfaceRender(RepSurface
             glGetFloatv(GL_MODELVIEW_MATRIX, matrix);
 
             if(I->oneColorFlag) {
-              t_buf = Alloc(float *, I->NT * 6);
+              t_buf = pymol::malloc<float *>(I->NT * 6);
             } else {
-              t_buf = Alloc(float *, I->NT * 12);
+              t_buf = pymol::malloc<float *>(I->NT * 12);
             }
 	    CHECKOK(ok, t_buf);
 	    if (ok){
-	      z_value = Alloc(float, I->NT);
+	      z_value = pymol::malloc<float>(I->NT);
 	      CHECKOK(ok, z_value);
 	    }
 	    if (ok){
-	      ix = Alloc(int, I->NT);
+	      ix = pymol::malloc<int>(I->NT);
 	      CHECKOK(ok, ix);
 	    }
             zv = z_value;
@@ -2236,35 +2236,35 @@ void RepSurfaceColor(RepSurface * I, Coo
   AtomInfoType *ai2 = NULL, *ai1;
 
   obj = cs->Obj;
-  ambient_occlusion_mode = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_ambient_occlusion_mode);
-  surface_mode = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_surface_mode);
+  ambient_occlusion_mode = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_ambient_occlusion_mode);
+  surface_mode = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_surface_mode);
   ramp_above =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_surface_ramp_above_mode);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_surface_ramp_above_mode);
   surface_color =
-    SettingGet_color(G, cs->Setting, obj->Obj.Setting, cSetting_surface_color);
+    SettingGet_color(G, cs->Setting, obj->Setting, cSetting_surface_color);
   cullByFlag = (surface_mode == cRepSurface_by_flags);
   inclH = !((surface_mode == cRepSurface_heavy_atoms)
             || (surface_mode == cRepSurface_vis_heavy_only));
   inclInvis = !((surface_mode == cRepSurface_vis_only)
                 || (surface_mode == cRepSurface_vis_heavy_only));
-  probe_radius = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_solvent_radius);
+  probe_radius = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_solvent_radius);
   I->proximity =
-    SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_surface_proximity);
+    SettingGet_b(G, cs->Setting, obj->Setting, cSetting_surface_proximity);
   carve_cutoff =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_surface_carve_cutoff);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_surface_carve_cutoff);
   clear_cutoff =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_surface_clear_cutoff);
-  transp = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_transparency);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_surface_clear_cutoff);
+  transp = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_transparency);
   carve_normal_cutoff =
-    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_surface_carve_normal_cutoff);
+    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_surface_carve_normal_cutoff);
   carve_normal_flag = carve_normal_cutoff > (-1.0F);
 
   cutoff = I->max_vdw + 2 * probe_radius;
 
   if(!I->LastVisib)
-    I->LastVisib = Alloc(char, cs->NIndex);
+    I->LastVisib = pymol::malloc<char>(cs->NIndex);
   if(!I->LastColor)
-    I->LastColor = Alloc(int, cs->NIndex);
+    I->LastColor = pymol::malloc<int>(cs->NIndex);
   lv = I->LastVisib;
   lc = I->LastColor;
   for(a = 0; a < cs->NIndex; a++) {
@@ -2276,9 +2276,9 @@ void RepSurfaceColor(RepSurface * I, Coo
   if(I->N) {
     if(carve_cutoff > 0.0F) {
       carve_state =
-        SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_surface_carve_state) - 1;
+        SettingGet_i(G, cs->Setting, obj->Setting, cSetting_surface_carve_state) - 1;
       carve_selection =
-        SettingGet_s(G, cs->Setting, obj->Obj.Setting, cSetting_surface_carve_selection);
+        SettingGet_s(G, cs->Setting, obj->Setting, cSetting_surface_carve_selection);
       if(carve_selection)
         carve_map = SelectorGetSpacialMapFromSeleCoord(G,
                                                        SelectorIndexByName(G,
@@ -2292,9 +2292,9 @@ void RepSurfaceColor(RepSurface * I, Coo
 
     if(clear_cutoff > 0.0F) {
       clear_state =
-        SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_surface_clear_state) - 1;
+        SettingGet_i(G, cs->Setting, obj->Setting, cSetting_surface_clear_state) - 1;
       clear_selection =
-        SettingGet_s(G, cs->Setting, obj->Obj.Setting, cSetting_surface_clear_selection);
+        SettingGet_s(G, cs->Setting, obj->Setting, cSetting_surface_clear_selection);
       if(clear_selection)
         clear_map = SelectorGetSpacialMapFromSeleCoord(G,
                                                        SelectorIndexByName(G,
@@ -2307,16 +2307,16 @@ void RepSurfaceColor(RepSurface * I, Coo
     }
 
     if(!I->VC)
-      I->VC = Alloc(float, 3 * I->N);
+      I->VC = pymol::malloc<float>(3 * I->N);
     vc = I->VC;
     if(!I->VA)
-      I->VA = Alloc(float, I->N);
+      I->VA = pymol::malloc<float>(I->N);
     va = I->VA;
     if(!I->RC)
-      I->RC = Alloc(int, I->N);
+      I->RC = pymol::malloc<int>(I->N);
     rc = I->RC;
     if(!I->Vis)
-      I->Vis = Alloc(int, I->N);
+      I->Vis = pymol::malloc<int>(I->N);
     if(ColorCheckRamped(G, surface_color)) {
       I->oneColorFlag = false;
     } else {
@@ -2324,7 +2324,7 @@ void RepSurfaceColor(RepSurface * I, Coo
     }
     first_color = -1;
 
-    present = Alloc(int, cs->NIndex);
+    present = pymol::malloc<int>(cs->NIndex);
     {
       int *ap = present;
       for(a = 0; a < cs->NIndex; a++) {
@@ -2413,8 +2413,8 @@ void RepSurfaceColor(RepSurface * I, Coo
 
       if (ambient_occlusion_mode==3){
 	/* per atom */
-	float *VAO = Alloc(float, cs->NIndex);
-	short *nVAO = Alloc(short, cs->NIndex);
+	float *VAO = pymol::malloc<float>(cs->NIndex);
+	short *nVAO = pymol::malloc<short>(cs->NIndex);
 	memset(VAO, 0, sizeof(float)*cs->NIndex);
 	memset(nVAO, 0, sizeof(short)*cs->NIndex);
 
@@ -2424,7 +2424,7 @@ void RepSurfaceColor(RepSurface * I, Coo
 	  unsigned long bits = 0L, bit;
 	  float d[3], *vn0, v0mod[3];
 	  int closeA = -1;
-	  float closeDist = MAXFLOAT;
+	  float closeDist = FLT_MAX;
 	  has = 0;
 	  
 	  v0 = I->V + 3 * a;
@@ -2569,9 +2569,9 @@ void RepSurfaceColor(RepSurface * I, Coo
       }
       {
 	int ambient_occlusion_smooth = 
-	  SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_ambient_occlusion_smooth);
+	  SettingGet_i(G, cs->Setting, obj->Setting, cSetting_ambient_occlusion_smooth);
 	int surface_quality = 
-	  SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_surface_quality);
+	  SettingGet_i(G, cs->Setting, obj->Setting, cSetting_surface_quality);
 	float min_max_diff = level_max - level_min;
 	if (surface_quality>0)
 	  ambient_occlusion_smooth *= surface_quality;
@@ -2590,8 +2590,8 @@ void RepSurfaceColor(RepSurface * I, Coo
 	if (ambient_occlusion_smooth && I->T){
 	  int i, j, pt1, pt2, pt3;
 	  float ave;
-	  float *tmpVAO = Alloc(float, I->N);
-	  int *nVAO = Alloc(int, I->N), c, *t;
+	  float *tmpVAO = pymol::malloc<float>(I->N);
+	  int *nVAO = pymol::malloc<int>(I->N), c, *t;
 	  
 	  for (j=0; j<ambient_occlusion_smooth; j++){
 	    memset(nVAO, 0, sizeof(int)*I->N);
@@ -2649,7 +2649,7 @@ void RepSurfaceColor(RepSurface * I, Coo
         float at_transp = transp;
 
         AtomInfoType *ai0 = NULL;
-        float minDist = MAXFLOAT, minDist2 = MAXFLOAT, distDiff = MAXFLOAT;
+        float minDist = FLT_MAX, minDist2 = FLT_MAX, distDiff = FLT_MAX;
 	int pi = -1, catm = -1; /* variables for color smoothing */
         AtomInfoType *pai = NULL, *pai2 = NULL; /* variables for color smoothing */
         c1 = 1;
@@ -2709,7 +2709,7 @@ void RepSurfaceColor(RepSurface * I, Coo
 
           if(at_surface_color != -1) {
             c1 = at_surface_color;
-            distDiff = MAXFLOAT;
+            distDiff = FLT_MAX;
           } else {
             c1 = ai0->color;
           }
@@ -2873,7 +2873,7 @@ void RepSurfaceColor(RepSurface * I, Coo
     MapFree(clear_map);
   VLAFreeP(clear_vla);
   if((!ramped_flag)
-     || (!SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_ray_color_ramps)))
+     || (!SettingGet_b(G, cs->Setting, obj->Setting, cSetting_ray_color_ramps)))
     FreeP(I->RC);
   I->ColorInvalidated = false;
   FreeP(present);
@@ -3215,7 +3215,7 @@ static int SurfaceJobEliminateCloseDots(
   int ok = true;
   if(I->N) {
     int repeat_flag = true;
-    int *dot_flag = Alloc(int, I->N);
+    int *dot_flag = pymol::malloc<int>(I->N);
     CHECKOK(ok, dot_flag);
     while(ok && repeat_flag) {
       repeat_flag = false;
@@ -3290,7 +3290,7 @@ static int SurfaceJobEliminateTroublesom
     int repeat_flag = true;
     float point_sep = I->pointSep;
     float neighborhood = trim_factor * point_sep;
-    int *dot_flag = Alloc(int, I->N);
+    int *dot_flag = pymol::malloc<int>(I->N);
     CHECKOK(ok, dot_flag);
     if(ok && I->surfaceType == 6) {       /* emprical tweaks */
       trim_factor *= 2.5;
@@ -3672,7 +3672,7 @@ static int SurfaceJobRun(PyMOLGlobals *
 	    ok &= !G->Interrupt;
 	    ok &= map->EList && solv_map->EList;
             if(sol_dot->nDot && ok) {
-              Vector3f *dot = Alloc(Vector3f, sp->nDot);
+              Vector3f *dot = pymol::malloc<Vector3f>(sp->nDot);
               float *v0, *n0;
 	      CHECKOK(ok, dot);
               if (ok){
@@ -3769,7 +3769,7 @@ static int SurfaceJobRun(PyMOLGlobals *
 
         if(ok && I->N && (surface_type == 0) && (circumscribe)) {
           /* combine scribing with an atom proximity cleanup pass */
-          int *dot_flag = Calloc(int, I->N);
+          int *dot_flag = pymol::calloc<int>(I->N);
 	  CHECKOK(ok, dot_flag);
 	  ok &= SurfaceJobAtomProximityCleanupPass(G, I, dot_flag, present_vla, probe_radius);
 	  /* purge unused dots */
@@ -3831,7 +3831,7 @@ static void RepSurfaceSetSettings(PyMOLG
     int *sphere_idx, int *solv_sph_idx, int *circumscribe)
 {
   if(surface_quality >= 4) {        /* totally impractical */
-    *point_sep = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_surface_best) / 4.f;
+    *point_sep = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_surface_best) / 4.f;
     *sphere_idx = 4;
     *solv_sph_idx = 4;
     if(*circumscribe < 0)
@@ -3839,7 +3839,7 @@ static void RepSurfaceSetSettings(PyMOLG
   } else {
     switch (surface_quality) {
     case 3:                /* nearly impractical */
-      *point_sep = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_surface_best) / 3.f;
+      *point_sep = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_surface_best) / 3.f;
       *sphere_idx = 4;
       *solv_sph_idx = 3;
       if(*circumscribe < 0)
@@ -3847,7 +3847,7 @@ static void RepSurfaceSetSettings(PyMOLG
       break;
     case 2:
       /* nearly perfect */
-      *point_sep = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_surface_best) / 2.f;
+      *point_sep = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_surface_best) / 2.f;
       *sphere_idx = 3;
       *solv_sph_idx = 3;
       if(*circumscribe < 0)
@@ -3855,7 +3855,7 @@ static void RepSurfaceSetSettings(PyMOLG
       break;
     case 1:
       /* good */
-      *point_sep = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_surface_best);
+      *point_sep = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_surface_best);
       *sphere_idx = 2;
       *solv_sph_idx = 3;
       if((*circumscribe < 0) && (surface_type == 6))
@@ -3863,7 +3863,7 @@ static void RepSurfaceSetSettings(PyMOLG
       break;
     case 0:
       /* 0 - normal */
-      *point_sep = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_surface_normal);
+      *point_sep = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_surface_normal);
       *sphere_idx = 1;
       *solv_sph_idx = 2;
       if((*circumscribe < 0) && (surface_type == 6))
@@ -3871,7 +3871,7 @@ static void RepSurfaceSetSettings(PyMOLG
       break;
     case -1:
       /* -1 */
-      *point_sep = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_surface_poor);
+      *point_sep = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_surface_poor);
       *sphere_idx = 1;
       *solv_sph_idx = 2;
       if((*circumscribe < 0) && (surface_type == 6))
@@ -3879,25 +3879,25 @@ static void RepSurfaceSetSettings(PyMOLG
       break;
     case -2:
       /* -2 god awful */
-      *point_sep = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_surface_poor) * 1.5F;
+      *point_sep = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_surface_poor) * 1.5F;
       *sphere_idx = 1;
       *solv_sph_idx = 1;
       break;
     case -3:
       /* -3 miserable */
-      *point_sep = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_surface_miserable);
+      *point_sep = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_surface_miserable);
       *sphere_idx = 1;
       *solv_sph_idx = 1;
       break;
     default:
-      *point_sep = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_surface_miserable) * 1.18F;
+      *point_sep = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_surface_miserable) * 1.18F;
       *sphere_idx = 0;
       *solv_sph_idx = 1;
     }
   }
   /* Fixed problem with surface holes when surface_quality>2, it seems like circumscribe can only be
      used with surface_solvent */
-  if((*circumscribe < 0) || (!SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_surface_solvent)))
+  if((*circumscribe < 0) || (!SettingGet_b(G, cs->Setting, obj->Setting, cSetting_surface_solvent)))
     *circumscribe = 0;
 }
 
@@ -3959,19 +3959,19 @@ static int RepSurfacePrepareSurfaceJob(P
     surf_job->probeRadius = probe_radius;
     surf_job->pointSep = point_sep;
     
-    surf_job->trimCutoff = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_surface_trim_cutoff);
-    surf_job->trimFactor = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_surface_trim_factor);
+    surf_job->trimCutoff = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_surface_trim_cutoff);
+    surf_job->trimFactor = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_surface_trim_factor);
     
-    surf_job->cavityMode = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_surface_cavity_mode);
-    surf_job->cavityRadius = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_surface_cavity_radius);
-    surf_job->cavityCutoff = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_surface_cavity_cutoff);
+    surf_job->cavityMode = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_surface_cavity_mode);
+    surf_job->cavityRadius = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_surface_cavity_radius);
+    surf_job->cavityCutoff = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_surface_cavity_cutoff);
     if(carve_vla)
       surf_job->carveVla = VLACopy(carve_vla, float);
     surf_job->carveCutoff = carve_cutoff;
-    surf_job->surfaceMode = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_surface_mode);
-    surf_job->surfaceSolvent = SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_surface_solvent);
+    surf_job->surfaceMode = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_surface_mode);
+    surf_job->surfaceSolvent = SettingGet_b(G, cs->Setting, obj->Setting, cSetting_surface_solvent);
     surf_job->cavityCull = SettingGet_i(G, cs->Setting,
-					obj->Obj.Setting, cSetting_cavity_cull);
+					obj->Setting, cSetting_cavity_cull);
   }
   return ok;
 }
@@ -3979,7 +3979,7 @@ static int RepSurfacePrepareSurfaceJob(P
 #ifndef _PYMOL_NOPY
 static
 void RepSurfaceConvertSurfaceJobToPyObject(PyMOLGlobals *G, SurfaceJob *surf_job, CoordSet *cs, ObjectMolecule *obj, PyObject **entry, PyObject **input, PyObject **output, int *found){
-  int cache_mode = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cache_mode);
+  int cache_mode = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cache_mode);
   
   if(cache_mode > 0) {
     int blocked = PAutoBlock(G);
@@ -4106,7 +4106,7 @@ Rep *RepSurfaceNew(CoordSet * cs, int st
   I->ColorInvalidated = false;
   {
     int surface_mode =
-      SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_surface_mode);
+      SettingGet_i(G, cs->Setting, obj->Setting, cSetting_surface_mode);
     int cullByFlag = (surface_mode == cRepSurface_by_flags);
     int inclH = !((surface_mode == cRepSurface_heavy_atoms)
                   || (surface_mode == cRepSurface_vis_heavy_only));
@@ -4135,11 +4135,11 @@ Rep *RepSurfaceNew(CoordSet * cs, int st
 
     {
       int surface_flag = false;
-      int surface_type = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_surface_type);        
-      int surface_quality = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_surface_quality);
-      float probe_radius = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_solvent_radius);
-      int optimize = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_surface_optimize_subsets);
-      int circumscribe = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_surface_circumscribe);
+      int surface_type = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_surface_type);        
+      int surface_quality = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_surface_quality);
+      float probe_radius = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_solvent_radius);
+      int optimize = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_surface_optimize_subsets);
+      int circumscribe = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_surface_circumscribe);
       int sphere_idx = 0, solv_sph_idx = 0;
       MapType *map = NULL;
       float point_sep;
@@ -4151,7 +4151,7 @@ Rep *RepSurfaceNew(CoordSet * cs, int st
       const char *carve_selection = NULL;
       float *carve_vla = NULL;
       MapType *carve_map = NULL;
-      bool smooth_edges = SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_surface_smooth_edges);
+      bool smooth_edges = SettingGet_b(G, cs->Setting, obj->Setting, cSetting_surface_smooth_edges);
 
       I->Type = surface_type;
 
@@ -4215,15 +4215,15 @@ Rep *RepSurfaceNew(CoordSet * cs, int st
 	if (ok){
 	  n_present = cs->NIndex;
 	  carve_selection =
-	    SettingGet_s(G, cs->Setting, obj->Obj.Setting,
+	    SettingGet_s(G, cs->Setting, obj->Setting,
 			 cSetting_surface_carve_selection);
 	  carve_cutoff =
-	    SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_surface_carve_cutoff);
+	    SettingGet_f(G, cs->Setting, obj->Setting, cSetting_surface_carve_cutoff);
 	  if((!carve_selection) || (!carve_selection[0]))
 	    carve_cutoff = 0.0F;
 	  if(carve_cutoff > 0.0F) {
 	    carve_state =
-	      SettingGet_i(G, cs->Setting, obj->Obj.Setting,
+	      SettingGet_i(G, cs->Setting, obj->Setting,
 			   cSetting_surface_carve_state) - 1;
 	    carve_cutoff += 2 * I->max_vdw + probe_radius;
 	    
@@ -4293,7 +4293,7 @@ Rep *RepSurfaceNew(CoordSet * cs, int st
             PyObject *entry = NULL;
             PyObject *output = NULL;
             PyObject *input = NULL;
-	    int cache_mode = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cache_mode);
+	    int cache_mode = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cache_mode);
 	    RepSurfaceConvertSurfaceJobToPyObject(G, surf_job, cs, obj, &entry, &input, &output, &found);
 #endif
             if(ok && !found) {
@@ -4900,7 +4900,7 @@ static SolventDot *SolventDotNew(PyMOLGl
       MapFree(map);
     }
     {
-      int *dot_flag = Calloc(int, I->nDot);
+      int *dot_flag = pymol::calloc<int>(I->nDot);
       ErrChkPtr(G, dot_flag);
       {
         MapType *map = MapNew(G, cavity_cutoff, cavityDot, nCavityDot, NULL);
@@ -4918,7 +4918,7 @@ static SolventDot *SolventDotNew(PyMOLGl
 
   if(ok && (cavity_mode != 1) && (cavity_cull > 0) && 
      (probe_radius > 0.75F) && (!surface_solvent)) {
-    int *dot_flag = Calloc(int, I->nDot);
+    int *dot_flag = pymol::calloc<int>(I->nDot);
     float probe_radius_plus;
     probe_radius_plus = probe_radius * 1.5F;
 
diff -upNr pymol-open-source-2.3.0/layer2/RepWireBond.cpp pymol-open-source-2.3.3/layer2/RepWireBond.cpp
--- pymol-open-source-2.3.0/layer2/RepWireBond.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/RepWireBond.cpp	2019-08-22 10:24:47.730597645 +0200
@@ -261,7 +261,7 @@ void RepWireBondRenderImmediate(CoordSet
     int active = false;
     ObjectMolecule *obj = cs->Obj;
     float line_width, line_width_setting =
-      SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_line_width);
+      SettingGet_f(G, cs->Setting, obj->Setting, cSetting_line_width);
     line_width = SceneGetDynamicLineWidth(info, line_width_setting);
 
     if(info->width_scale_flag)
@@ -412,7 +412,7 @@ static void RepWireBondRender(RepWireBon
 
   if(ray) {
 #ifndef _PYMOL_NO_RAY
-    CGORenderRay(I->primitiveCGO, ray, info, NULL, NULL, I->R.cs->Setting, I->R.cs->Obj->Obj.Setting);
+    CGORenderRay(I->primitiveCGO, ray, info, NULL, NULL, I->R.cs->Setting, I->R.cs->Obj->Setting);
     ray->transparentf(0.0);
 #endif
   } else if(G->HaveGUI && G->ValidContext) {
@@ -625,36 +625,36 @@ Rep *RepWireBondNew(CoordSet * cs, int s
     OOFreeP(I);
     return (NULL);              /* skip if no dots are visible */
   }
-  marked = Calloc(bool, obj->NAtom);
+  marked = pymol::calloc<bool>(obj->NAtom);
   CHECKOK(ok, marked);
   if (!ok){
     OOFreeP(I);
     return (NULL);
   }
   
-  valence_flag = SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_valence);
-  valence = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_valence_size);
-  cartoon_side_chain_helper = SettingGet_b(G, cs->Setting, obj->Obj.Setting,
+  valence_flag = SettingGet_b(G, cs->Setting, obj->Setting, cSetting_valence);
+  valence = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_valence_size);
+  cartoon_side_chain_helper = SettingGet_b(G, cs->Setting, obj->Setting,
 					   cSetting_cartoon_side_chain_helper);
-  ribbon_side_chain_helper = SettingGet_b(G, cs->Setting, obj->Obj.Setting,
+  ribbon_side_chain_helper = SettingGet_b(G, cs->Setting, obj->Setting,
 					  cSetting_ribbon_side_chain_helper);
-  line_stick_helper = SettingGet_b(G, cs->Setting, obj->Obj.Setting,
+  line_stick_helper = SettingGet_b(G, cs->Setting, obj->Setting,
 				   cSetting_line_stick_helper);
-  line_color = SettingGet_color(G, cs->Setting, obj->Obj.Setting, cSetting_line_color);
-  line_width = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_line_width);
+  line_color = SettingGet_color(G, cs->Setting, obj->Setting, cSetting_line_color);
+  line_width = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_line_width);
   
-  if(line_stick_helper && (SettingGet_f(G, cs->Setting, obj->Obj.Setting,
+  if(line_stick_helper && (SettingGet_f(G, cs->Setting, obj->Setting,
 					cSetting_stick_transparency) > R_SMALL4))
     line_stick_helper = false;
-  half_bonds = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_half_bonds);
-  hide_long = SettingGet_b(G, cs->Setting, obj->Obj.Setting, cSetting_hide_long_bonds);
+  half_bonds = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_half_bonds);
+  hide_long = SettingGet_b(G, cs->Setting, obj->Setting, cSetting_hide_long_bonds);
   na_mode =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_cartoon_nucleic_acid_mode);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_cartoon_nucleic_acid_mode);
   int na_mode_ribbon =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_ribbon_nucleic_acid_mode);
-  fancy = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_valence_mode) == 1;
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_ribbon_nucleic_acid_mode);
+  fancy = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_valence_mode) == 1;
   auto valence_zero_mode =
-    SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_valence_zero_mode);
+    SettingGet_i(G, cs->Setting, obj->Setting, cSetting_valence_zero_mode);
   
   b = obj->Bond;
   
@@ -794,7 +794,7 @@ Rep *RepWireBondNew(CoordSet * cs, int s
 
           if(bd_line_color < 0) {
             if(bd_line_color == cColorObject) {
-              c1 = (c2 = obj->Obj.Color);
+              c1 = (c2 = obj->Color);
             } else if(ColorCheckRamped(G, bd_line_color)) {
               c1 = (c2 = bd_line_color);
             } else {
diff -upNr pymol-open-source-2.3.0/layer2/SculptCache.cpp pymol-open-source-2.3.3/layer2/SculptCache.cpp
--- pymol-open-source-2.3.0/layer2/SculptCache.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/SculptCache.cpp	2019-08-22 10:24:47.730597645 +0200
@@ -34,14 +34,14 @@ static void SculptCacheCheck(PyMOLGlobal
 {
   CSculptCache *I = G->SculptCache;
   if(!I->Hash) {
-    I->Hash = Calloc(int, CACHE_HASH_SIZE);
+    I->Hash = pymol::calloc<int>(CACHE_HASH_SIZE);
   }
 }
 
 int SculptCacheInit(PyMOLGlobals * G)
 {
   CSculptCache *I = NULL;
-  if((I = (G->SculptCache = Calloc(CSculptCache, 1)))) {
+  if((I = (G->SculptCache = pymol::calloc<CSculptCache>(1)))) {
     I->Hash = NULL;             /* don't allocate until we need it */
     I->List = VLAlloc(SculptCacheEntry, 16);
     I->NCached = 1;
diff -upNr pymol-open-source-2.3.0/layer2/Sculpt.cpp pymol-open-source-2.3.3/layer2/Sculpt.cpp
--- pymol-open-source-2.3.0/layer2/Sculpt.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/Sculpt.cpp	2019-08-22 10:24:47.730597645 +0200
@@ -70,9 +70,6 @@ Z* -------------------------------------
 (((((a)^((a)>>5)))&0x00FF)|\
  (((    ((b)<<5)))&0xFF00))
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static float ShakerDoDist(float target, float *v0, float *v1, float *d0to1, float *d1to0,
                           float wt)
 {
@@ -104,9 +101,6 @@ static float ShakerDoDist(float target,
   return result;
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static float ShakerDoTors(int type, float *v0, float *v1, float *v2, float *v3,
                           float *p0, float *p1, float *p2, float *p3, float tole,
                           float wt)
@@ -193,9 +187,6 @@ static float ShakerDoTors(int type, floa
 
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static float ShakerDoDistLimit(float target, float *v0, float *v1, float *d0to1,
                                float *d1to0, float wt)
 {
@@ -217,9 +208,6 @@ static float ShakerDoDistLimit(float tar
   }
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static float ShakerDoDistMinim(float target, float *v0, float *v1, float *d0to1,
                                float *d1to0, float wt)
 {
@@ -248,9 +236,9 @@ CSculpt *SculptNew(PyMOLGlobals * G)
   I->G = G;
   I->Shaker = ShakerNew(G);
   I->NBList = VLAlloc(int, 150000);
-  I->NBHash = Calloc(int, NB_HASH_SIZE);
+  I->NBHash = pymol::calloc<int>(NB_HASH_SIZE);
   I->EXList = VLAlloc(int, 100000);
-  I->EXHash = Calloc(int, EX_HASH_SIZE);
+  I->EXHash = pymol::calloc<int>(EX_HASH_SIZE);
   I->Don = VLAlloc(int, 1000);
   I->Acc = VLAlloc(int, 1000);
   {
@@ -413,7 +401,7 @@ void SculptMeasureObject(CSculpt * I, Ob
   if(match_state < 0)
     match_state = state;
   if(state < 0)
-    state = ObjectGetCurrentState(&obj->Obj, true);
+    state = ObjectGetCurrentState(obj, true);
 
   ShakerReset(I->Shaker);
 
@@ -438,15 +426,15 @@ void SculptMeasureObject(CSculpt * I, Ob
 
     cs = obj->CSet[state];
 
-    use_cache = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_memory);
+    use_cache = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_sculpt_memory);
     if(obj->NBond) {
       int *neighbor = obj->Neighbor;
       int n_atom = obj->NAtom;
 
-      planar = Alloc(int, n_atom);
-      linear = Alloc(int, n_atom);
-      single = Alloc(int, n_atom);
-      crdidx = Alloc(int, n_atom);
+      planar = pymol::malloc<int>(n_atom);
+      linear = pymol::malloc<int>(n_atom);
+      single = pymol::malloc<int>(n_atom);
+      crdidx = pymol::malloc<int>(n_atom);
       ai = obj_atomInfo;
 
       for(a = 0; a < n_atom; a++) {
@@ -670,10 +658,10 @@ void SculptMeasureObject(CSculpt * I, Ob
         }
         atl.coord = cs->Coord;
         atl.neighbor = neighbor;
-        atl.min = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_tri_min);
-        atl.max = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_tri_max);
+        atl.min = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_sculpt_tri_min);
+        atl.max = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_sculpt_tri_max);
         atl.mode =
-          SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_tri_mode);
+          SettingGet_i(G, cs->Setting, obj->Setting, cSetting_sculpt_tri_mode);
 
         for(a = 0; a < n_atom; a++) {
 
@@ -701,16 +689,16 @@ void SculptMeasureObject(CSculpt * I, Ob
         int n_site = 0;
         if(cs2) {
           float minim_min =
-            SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_min_min);
+            SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_min_min);
           float minim_max =
-            SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_min_max);
+            SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_min_max);
           float maxim_min =
-            SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_max_min);
+            SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_max_min);
           float maxim_max =
-            SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_max_max);
+            SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_max_max);
 
-          int *site = Calloc(int, n_atom);
-          float *weight = Calloc(float, n_atom);
+          int *site = pymol::calloc<int>(n_atom);
+          float *weight = pymol::calloc<float>(n_atom);
           /* first, find candidate atoms with sufficient connectivity */
           CountCall cnt;
 
@@ -1341,9 +1329,9 @@ void SculptMeasureObject(CSculpt * I, Ob
         /* longer-range exclusions (1-5,1-6,1-7,1-8,1-9) -- only locate & store when needed */
 
         int mask =
-          SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_field_mask);
+          SettingGet_i(G, cs->Setting, obj->Setting, cSetting_sculpt_field_mask);
         int max_excl =
-          SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_avd_excl);
+          SettingGet_i(G, cs->Setting, obj->Setting, cSetting_sculpt_avd_excl);
         if(max_excl > 9)
           max_excl = 9;
 
@@ -1417,9 +1405,6 @@ void SculptMeasureObject(CSculpt * I, Ob
 
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int SculptCheckBump(float *v1, float *v2, float *diff, float *dist, float cutoff)
 {
   float d2;
@@ -1440,9 +1425,6 @@ static int SculptCheckBump(float *v1, fl
   return (false);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int SculptCGOBump(float *v1, float *v2,
                          float vdw1, float vdw2,
                          float cutoff,
@@ -1552,9 +1534,6 @@ static int SculptCGOBump(float *v1, floa
   }
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int SculptDoBump(float target, float actual, float *d,
                         float *d0to1, float *d1to0, float wt, float *strain)
 {
@@ -1579,9 +1558,6 @@ static int SculptDoBump(float target, fl
   return 0;
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int SculptCheckAvoid(float *v1, float *v2, float *diff,
                             float *dist, float avoid, float range)
 {
@@ -1607,9 +1583,6 @@ static int SculptCheckAvoid(float *v1, f
   return (false);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int SculptDoAvoid(float avoid, float range, float actual, float *d,
                          float *d0to1, float *d1to0, float wt, float *strain)
 {
@@ -1703,11 +1676,11 @@ float SculptIterateObject(CSculpt * I, O
 
   if((state < obj->NCSet) && obj->CSet[state] && n_cycle) {
 
-    disp = Alloc(float, 3 * obj->NAtom);
-    atm2idx = Alloc(int, obj->NAtom);
-    cnt = Alloc(int, obj->NAtom);
-    active = Alloc(int, obj->NAtom);
-    exclude = Calloc(int, obj->NAtom);
+    disp = pymol::malloc<float>(3 * obj->NAtom);
+    atm2idx = pymol::malloc<int>(obj->NAtom);
+    cnt = pymol::malloc<int>(obj->NAtom);
+    active = pymol::malloc<int>(obj->NAtom);
+    exclude = pymol::calloc<int>(obj->NAtom);
     shk = I->Shaker;
 
     PRINTFD(G, FB_Sculpt)
@@ -1716,43 +1689,43 @@ float SculptIterateObject(CSculpt * I, O
     cs = obj->CSet[state];
     cs_coord = cs->Coord;
 
-    vdw = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_vdw_scale);
-    vdw14 = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_vdw_scale14);
-    vdw_wt = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_vdw_weight);
+    vdw = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_vdw_scale);
+    vdw14 = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_vdw_scale14);
+    vdw_wt = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_vdw_weight);
     vdw_wt14 =
-      SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_vdw_weight14);
-    bond_wt = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_bond_weight);
-    angl_wt = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_angl_weight);
-    pyra_wt = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_pyra_weight);
+      SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_vdw_weight14);
+    bond_wt = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_bond_weight);
+    angl_wt = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_angl_weight);
+    pyra_wt = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_pyra_weight);
     pyra_inv_wt =
-      SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_pyra_inv_weight);
-    plan_wt = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_plan_weight);
-    line_wt = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_line_weight);
-    tri_wt = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_tri_weight);
-    tri_sc = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_tri_scale);
-
-    min_wt = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_min_weight);
-    min_sc = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_min_scale);
-    max_wt = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_max_weight);
-    max_sc = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_max_scale);
+      SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_pyra_inv_weight);
+    plan_wt = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_plan_weight);
+    line_wt = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_line_weight);
+    tri_wt = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_tri_weight);
+    tri_sc = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_tri_scale);
+
+    min_wt = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_min_weight);
+    min_sc = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_min_scale);
+    max_wt = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_max_weight);
+    max_sc = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_max_scale);
 
-    mask = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_field_mask);
+    mask = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_sculpt_field_mask);
     hb_overlap =
-      SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_hb_overlap);
+      SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_hb_overlap);
     hb_overlap_base =
-      SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_hb_overlap_base);
+      SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_hb_overlap_base);
     tors_tole =
-      SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_tors_tolerance);
-    tors_wt = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_tors_weight);
+      SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_tors_tolerance);
+    tors_wt = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_tors_weight);
     vdw_vis_mode =
-      SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_vdw_vis_mode);
+      SettingGet_i(G, cs->Setting, obj->Setting, cSetting_sculpt_vdw_vis_mode);
     solvent_radius =
-      SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_solvent_radius);
+      SettingGet_f(G, cs->Setting, obj->Setting, cSetting_solvent_radius);
 
-    avd_wt = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_avd_weight);
-    avd_gp = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_avd_gap);
-    avd_rg = SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_avd_range);
-    avd_ex = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_avd_excl);
+    avd_wt = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_avd_weight);
+    avd_gp = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_avd_gap);
+    avd_rg = SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_avd_range);
+    avd_ex = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_sculpt_avd_excl);
     if(avd_gp < 0.0F)
       avd_gp = 1.5F * solvent_radius;
     if(avd_rg < 0.0F)
@@ -1760,11 +1733,11 @@ float SculptIterateObject(CSculpt * I, O
 
     if(vdw_vis_mode) {
       vdw_vis_min =
-        SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_vdw_vis_min);
+        SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_vdw_vis_min);
       vdw_vis_mid =
-        SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_vdw_vis_mid);
+        SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_vdw_vis_mid);
       vdw_vis_max =
-        SettingGet_f(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_vdw_vis_max);
+        SettingGet_f(G, cs->Setting, obj->Setting, cSetting_sculpt_vdw_vis_max);
 
       if(!cs->SculptCGO)
         cs->SculptCGO = CGONew(G);
@@ -1775,7 +1748,7 @@ float SculptIterateObject(CSculpt * I, O
     }
     cgo = cs->SculptCGO;
 
-    nb_skip = SettingGet_i(G, cs->Setting, obj->Obj.Setting, cSetting_sculpt_nb_interval);
+    nb_skip = SettingGet_i(G, cs->Setting, obj->Setting, cSetting_sculpt_nb_interval);
     if(nb_skip > n_cycle)
       nb_skip = n_cycle;
     if(nb_skip < 0)
diff -upNr pymol-open-source-2.3.0/layer2/SideChainHelper.cpp pymol-open-source-2.3.3/layer2/SideChainHelper.cpp
--- pymol-open-source-2.3.0/layer2/SideChainHelper.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/SideChainHelper.cpp	2019-08-22 10:24:47.730597645 +0200
@@ -20,7 +20,7 @@ void SideChainHelperMarkNonCartoonBonded
     bool cartoon_side_chain_helper,
     bool ribbon_side_chain_helper)
 {
-  auto G = obj->Obj.G;
+  auto G = obj->G;
   int a1, a2;
 
   auto b = obj->Bond;
diff -upNr pymol-open-source-2.3.0/layer2/VFont.cpp pymol-open-source-2.3.3/layer2/VFont.cpp
--- pymol-open-source-2.3.0/layer2/VFont.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer2/VFont.cpp	2019-08-22 10:24:47.730597645 +0200
@@ -264,7 +264,7 @@ static void VFontRecFree(PyMOLGlobals *
 int VFontInit(PyMOLGlobals * G)
 {
   CVFont *I = NULL;
-  if((I = (G->VFont = Calloc(CVFont, 1)))) {
+  if((I = (G->VFont = pymol::calloc<CVFont>(1)))) {
 
     CVFont *I = G->VFont;
     I->Font = VLAlloc(VFontRec *, 10);
diff -upNr pymol-open-source-2.3.0/layer3/Editor.cpp pymol-open-source-2.3.3/layer3/Editor.cpp
--- pymol-open-source-2.3.0/layer3/Editor.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer3/Editor.cpp	2019-08-22 10:24:47.734598297 +0200
@@ -313,7 +313,7 @@ static int EditorGetEffectiveState(PyMOL
     
     if(objMol) {
       if((objMol->NCSet == 1) && (state > 0))
-        if(SettingGet_i(G, NULL, objMol->Obj.Setting, cSetting_static_singletons))
+        if(SettingGet_i(G, NULL, objMol->Setting, cSetting_static_singletons))
           return 0;
     }
   }
@@ -1593,7 +1593,7 @@ void EditorRender(PyMOLGlobals * G, int
 
         if(obj1) {
 	  /* if the user froze a state, use it instead of the global */
-	  if((frozen = SettingGetIfDefined_i(obj1->Obj.G, obj1->Obj.Setting, cSetting_state, &st))) {
+	  if((frozen = SettingGetIfDefined_i(obj1->G, obj1->Setting, cSetting_state, &st))) {
 	    state = st-1;
 	  }
           if(ObjectMoleculeGetAtomTxfVertex(obj1, state, index1, vv)) {
@@ -1603,7 +1603,7 @@ void EditorRender(PyMOLGlobals * G, int
         }
 
         if(obj2) {
-	  if((frozen = SettingGetIfDefined_i(obj2->Obj.G, obj2->Obj.Setting, cSetting_state, &st))) {
+	  if((frozen = SettingGetIfDefined_i(obj2->G, obj2->Setting, cSetting_state, &st))) {
 	    state = st-1;
 	  }
           if(ObjectMoleculeGetAtomTxfVertex(obj2, state, index2, vv)) {
@@ -1613,7 +1613,7 @@ void EditorRender(PyMOLGlobals * G, int
         }
 
         if(obj3) {
-	  if((frozen = SettingGetIfDefined_i(obj3->Obj.G, obj3->Obj.Setting, cSetting_state, &st))) {
+	  if((frozen = SettingGetIfDefined_i(obj3->G, obj3->Setting, cSetting_state, &st))) {
 	    state = st-1;
 	  }
           if(ObjectMoleculeGetAtomTxfVertex(obj3, state, index3, vv)) {
@@ -1623,7 +1623,7 @@ void EditorRender(PyMOLGlobals * G, int
         }
 
         if(obj4) {
-	  if((frozen = SettingGetIfDefined_i(obj4->Obj.G, obj4->Obj.Setting, cSetting_state, &st))) {
+	  if((frozen = SettingGetIfDefined_i(obj4->G, obj4->Setting, cSetting_state, &st))) {
 	    state = st-1;
 	  }
           if(ObjectMoleculeGetAtomTxfVertex(obj4, state, index4, vv)) {
@@ -2358,7 +2358,7 @@ void EditorDrag(PyMOLGlobals * G, CObjec
 int EditorInit(PyMOLGlobals * G)
 {
   CEditor *I = NULL;
-  if((I = (G->Editor = Calloc(CEditor, 1)))) {
+  if((I = (G->Editor = pymol::calloc<CEditor>(1)))) {
 
     I->DihedObject = NULL;
     I->NFrag = 0;
diff -upNr pymol-open-source-2.3.0/layer3/Executive.cpp pymol-open-source-2.3.3/layer3/Executive.cpp
--- pymol-open-source-2.3.0/layer3/Executive.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer3/Executive.cpp	2019-08-22 10:24:47.738598948 +0200
@@ -83,7 +83,6 @@
 
 #include"ShaderMgr.h"
 #include"File.h"
-#include"MacPyMOL.h"
 
 #include "MovieScene.h"
 #include "Texture.h"
@@ -293,7 +292,7 @@ int ExecutiveGroupMotion(PyMOLGlobals *G
   return result;
 }
 
-int ExecutiveGroupCombineTTT(PyMOLGlobals *G, CObject *group, float *ttt, int reverse_order, int store)
+int ExecutiveGroupCombineTTT(PyMOLGlobals *G, CObject *group, const float *ttt, int reverse_order, int store)
 {
   CExecutive *I = G->Executive;
   int result = true;
@@ -1025,11 +1024,11 @@ int ExecutiveIsomeshEtc(PyMOLGlobals * G
 
         symm = NULL;
         if(sele_obj &&  ObjectMapValidXtal(mapObj, state)) {
-          if(SettingGet_b(G, NULL, sele_obj->Obj.Setting, cSetting_map_auto_expand_sym)
+          if(SettingGet_b(G, NULL, sele_obj->Setting, cSetting_map_auto_expand_sym)
               && (sele_obj->Symmetry)) {
             // legacy default: take symmetry from molecular object
             symm = sele_obj->Symmetry;
-          } else if(SettingGet_b(G, NULL, mapObj->Obj.Setting, cSetting_map_auto_expand_sym)) {
+          } else if(SettingGet_b(G, NULL, mapObj->Setting, cSetting_map_auto_expand_sym)) {
             // fallback: take symmetry from map state
             symm = ms->Symmetry;
           }
@@ -1273,11 +1272,11 @@ int ExecutiveVolume(PyMOLGlobals * G, co
 
         symm = NULL;
         if(sele_obj && ObjectMapValidXtal(mapObj, state)) {
-          if(SettingGet_b(G, NULL, sele_obj->Obj.Setting, cSetting_map_auto_expand_sym)
+          if(SettingGet_b(G, NULL, sele_obj->Setting, cSetting_map_auto_expand_sym)
               && (sele_obj->Symmetry)) {
             // legacy default: take symmetry from molecular object
             symm = sele_obj->Symmetry;
-          } else if(SettingGet_b(G, NULL, mapObj->Obj.Setting, cSetting_map_auto_expand_sym)) {
+          } else if(SettingGet_b(G, NULL, mapObj->Setting, cSetting_map_auto_expand_sym)) {
             // fallback: take symmetry from map state
             symm = ms->Symmetry;
           }
@@ -1387,7 +1386,7 @@ int ExecutivePseudoatom(PyMOLGlobals * G
       /* new object */
       is_new = true;
       obj = ObjectMoleculeNew(G, false);
-      ObjectSetName(&obj->Obj, object_name);
+      ObjectSetName(obj, object_name);
       if(!obj)
         ok = false;
     }
@@ -1399,9 +1398,13 @@ int ExecutivePseudoatom(PyMOLGlobals * G
                                    state, mode, quiet)) {
       if(is_new) {
         ExecutiveDelete(G, object_name);        /* just in case */
-        ExecutiveManageObject(G, &obj->Obj, false, true);
+        ExecutiveManageObject(G, obj, false, true);
+#ifndef _PYMOL_NO_UNDO
+#endif
       } else {
-        ExecutiveUpdateObjectSelection(G, &obj->Obj);
+        ExecutiveUpdateObjectSelection(G, obj);
+#ifndef _PYMOL_NO_UNDO
+#endif
       }
     }
   }
@@ -1580,7 +1583,7 @@ static void ExecutiveInvalidateSceneMemb
   I->ValidSceneMembers = false;
 }
 
-static void ExecutiveUpdateSceneMembers(PyMOLGlobals * G)
+void ExecutiveUpdateSceneMembers(PyMOLGlobals * G)
 {
   CExecutive *I = G->Executive;
   ExecutiveUpdateGroups(G, false);
@@ -1960,7 +1963,7 @@ void ExecutiveUpdateCoordDepends(PyMOLGl
   SpecRec *rec = NULL;
   ObjectGadget *gadget;
   int done_inv_all = false;
-  int dynamic_measures = SettingGet_b(G, mol ? mol->Obj.Setting : NULL, NULL,
+  int dynamic_measures = SettingGet_b(G, mol ? mol->Setting : NULL, NULL,
       cSetting_dynamic_measures);
 
   while(ListIterate(I->Spec, rec, next)) {
@@ -3077,10 +3080,10 @@ int ExecutiveOrder(PyMOLGlobals * G, con
     int n_sel;
     int source_row = -1;
     int min_row = -1;
-    list = Alloc(SpecRec *, n_names);
-    subset = Calloc(SpecRec *, n_names);
-    sorted = Calloc(SpecRec *, n_names);
-    index = Alloc(int, n_names);
+    list = pymol::malloc<SpecRec *>(n_names);
+    subset = pymol::calloc<SpecRec *>(n_names);
+    sorted = pymol::calloc<SpecRec *>(n_names);
+    index = pymol::malloc<int>(n_names);
     if(list && subset) {
       /* create an array of current names */
       {
@@ -3290,7 +3293,7 @@ int ExecutiveSetDrag(PyMOLGlobals * G, c
             if(objMol) {
               if(mode>0) 
                 sele = -1; /* force drag by matrix */
-              EditorSetDrag(G, &objMol->Obj, sele, quiet, SceneGetState(G));
+              EditorSetDrag(G, objMol, sele, quiet, SceneGetState(G));
               set_flag = true;
             } else {
               PRINTFB(G, FB_Executive, FB_Errors)
@@ -3566,7 +3569,12 @@ int ExecutiveSetName(PyMOLGlobals * G, c
 
   ObjectNameType name;
   UtilNCopy(name, new_name, sizeof(ObjectNameType));
-  ObjectMakeValidName(name);
+
+  if (ObjectMakeValidName(name)) {
+    PRINTFB(G, FB_Executive, FB_Warnings)
+      " Warning: Invalid characters in '%s' have been replaced or stripped\n",
+      name ENDFB(G);
+  }
 
   if(!name[0]) {
     PRINTFB(G, FB_Executive, FB_Errors)
@@ -3743,7 +3751,7 @@ int ExecutiveLoad(PyMOLGlobals * G,
       return false;
     } else {
       PRINTFB(G, FB_Executive, FB_Blather)
-        " ExecutiveLoad: Loading from %s.\n", fname ENDFB(G);
+        " %s: Loading from %s.\n", __func__, fname ENDFB(G);
     }
 
     break;
@@ -4328,7 +4336,7 @@ int ExecutiveProcessPDBFile(PyMOLGlobals
         M4XAnnoType *m4x = &current->m4x;
 
         if(m4x->annotated_flag && m4x->align) {
-          if(WordMatchExact(G, current->obj->Obj.Name, m4x->align->target, true)) {
+          if(WordMatchExact(G, current->obj->Name, m4x->align->target, true)) {
             target_rec = current;
             break;
           }
@@ -4415,7 +4423,7 @@ int ExecutiveProcessPDBFile(PyMOLGlobals
                                                          pairwise.n_pair);
 
                   sprintf(align_name, "%s_%s_alignment",
-                          pairwise.trg_obj->Obj.Name, pairwise.mbl_obj->Obj.Name);
+                          pairwise.trg_obj->Name, pairwise.mbl_obj->Name);
 
                   ExecutiveRMS(G, mbl_sele, trg_sele, 2, 0.0F, 0, 0,
                                align_name, 0, 0, true, 0, NULL);
@@ -4602,7 +4610,7 @@ int ExecutiveSetVisFromPyDict(PyMOLGloba
     ExecutiveInvalidateSceneMembers(G);
 
     // stack for putative visible records
-    recstack = Calloc(SpecRec*, PyDict_Size(dict) + 1);
+    recstack = pymol::calloc<SpecRec*>(PyDict_Size(dict) + 1);
 
     while(PyDict_Next(dict, &pos, &key, &list)) {
       if(!PConvPyStrToStr(key, name, sizeof(WordType))) {
@@ -4724,7 +4732,7 @@ float * ExecutiveGetHistogram(PyMOLGloba
   }
 
   if(oms) {
-    float *hist = Calloc(float, n_points + 4);
+    float *hist = pymol::calloc<float>(n_points + 4);
     float range = SettingGet_f(G, obj->Setting, NULL, cSetting_volume_data_range);
     ObjectMapStateGetHistogram(G, oms, n_points, range, hist, min_val, max_val);
     return hist;
@@ -4833,7 +4841,7 @@ int ExecutiveSpectrum(PyMOLGlobals * G,
 
     n_color = abs(first - last) + 1;
     if(n_color) {
-      color_index = Alloc(int, n_color);
+      color_index = pymol::malloc<int>(n_color);
       for(a = 0; a < n_color; a++) {
         b = first + ((last - first) * a) / (n_color - 1);
         sprintf(at, pat, b);
@@ -4850,7 +4858,7 @@ int ExecutiveSpectrum(PyMOLGlobals * G,
       }
 
       if(n_atom) {
-        value = Calloc(float, n_atom);
+        value = pymol::calloc<float>(n_atom);
 
         if(WordMatchExact(G, "count", expr, true)) {
           for(a = 0; a < n_atom; a++) {
@@ -5013,7 +5021,7 @@ const char **ExecutiveGetChains(PyMOLGlo
     UtilSortInPlace(G, result, chains.size(), sizeof(char *),
         (UtilOrderFn *) fStrOrderFn);
   } else {
-    ErrMessage(G, "ExecutiveGetChains", "Bad selection.");
+    ErrMessage(G, __func__, "Bad selection.");
   }
   return (result);
 }
@@ -5083,7 +5091,7 @@ int ExecutiveRampNew(PyMOLGlobals * G, c
         }
       } else {
         PRINTFB(G, FB_Executive, FB_Errors)
-          "ExecutiveRampNew: Error: object '%s' not found.\n", src_name ENDFB(G);
+          " %s: Error: object '%s' not found.\n", __func__, src_name ENDFB(G);
         return false;
       }
     }
@@ -6354,7 +6362,7 @@ int ExecutiveSymmetryCopy(PyMOLGlobals *
       /* Invalidate cRepCell */
       /* if the unit cell is shown for molecule, redraw it */
       if(tmp_mol) {
-	if((tmp_mol->Obj.visRep & cRepCellBit)) {
+	if((tmp_mol->visRep & cRepCellBit)) {
 	  if(tmp_mol->Symmetry) {
 	    if(tmp_mol->Symmetry->Crystal) {
 	      if(tmp_mol->UnitCellCGO)
@@ -6402,7 +6410,7 @@ int ExecutiveSmooth(PyMOLGlobals * G, co
   /*  WordType all = "_all"; */
 
   PRINTFD(G, FB_Executive)
-    " ExecutiveSmooth: entered %s,%d,%d,%d,%d,%d\n", name, cycles, first, last, window,
+    " %s: entered %s,%d,%d,%d,%d,%d\n", __func__, name, cycles, first, last, window,
     ends ENDFD;
 
   /* given a valid selection */
@@ -6457,7 +6465,7 @@ int ExecutiveSmooth(PyMOLGlobals * G, co
     }
 
     PRINTFD(G, FB_Executive)
-      " ExecutiveSmooth: first %d last %d n_state %d backward %d forward %d range %d\n",
+      " %s: first %d last %d n_state %d backward %d forward %d range %d\n", __func__,
       first, last, n_state, backward, forward, range ENDFD;
 
     if(n_state >= window) {
@@ -6470,10 +6478,10 @@ int ExecutiveSmooth(PyMOLGlobals * G, co
       n_atom = op.i1;
       if(n_atom) {
         /* allocate storage */
-        coord0 = Alloc(float, 3 * n_atom * n_state);
-        coord1 = Alloc(float, 3 * n_atom * n_state);
-        flag0 = Alloc(int, n_atom * n_state);
-        flag1 = Alloc(int, n_atom * n_state);
+        coord0 = pymol::malloc<float>(3 * n_atom * n_state);
+        coord1 = pymol::malloc<float>(3 * n_atom * n_state);
+        flag0 = pymol::malloc<int>(n_atom * n_state);
+        flag1 = pymol::malloc<int>(n_atom * n_state);
 
         /* clear the arrays */
 
@@ -6496,7 +6504,7 @@ int ExecutiveSmooth(PyMOLGlobals * G, co
         ExecutiveObjMolSeleOp(G, sele, &op);
 
         PRINTFD(G, FB_Executive)
-          " ExecutiveSmooth: got %d %d\n", op.i2, op.nvv1 ENDFD;
+          " %s: got %d %d\n", __func__, op.i2, op.nvv1 ENDFD;
 
         UtilZeroMem(coord1, sizeof(float) * 3 * n_atom * n_state);
         UtilZeroMem(flag1, sizeof(int) * n_atom * n_state);
@@ -6582,7 +6590,7 @@ int ExecutiveSmooth(PyMOLGlobals * G, co
 
         ExecutiveObjMolSeleOp(G, sele, &op);
         PRINTFD(G, FB_Executive)
-          " ExecutiveSmooth: put %d %d\n", op.i2, op.nvv1 ENDFD;
+          " %s: put %d %d\n", __func__, op.i2, op.nvv1 ENDFD;
 
         FreeP(coord0);
         FreeP(coord1);
@@ -6863,10 +6871,10 @@ int ExecutiveMapSet(PyMOLGlobals * G, co
         int iter_id = TrackerNewIter(I_Tracker, 0, list_id);
         int n_pnt = (ms->Field->points->size / ms->Field->points->base_size) / 3;
         float *pnt = (float *) ms->Field->points->data;
-        float *r_value = Alloc(float, n_pnt);
-        float *l_value = Calloc(float, n_pnt);
-        int *present = Calloc(int, n_pnt);
-        int *inside = Alloc(int, n_pnt);
+        float *r_value = pymol::malloc<float>(n_pnt);
+        float *l_value = pymol::calloc<float>(n_pnt);
+        int *present = pymol::calloc<int>(n_pnt);
+        int *inside = pymol::malloc<int>(n_pnt);
         SpecRec *rec;
 
         while(TrackerIterNextCandInList(I_Tracker, iter_id,
@@ -7045,9 +7053,9 @@ int ExecutiveMapSet(PyMOLGlobals * G, co
   if(target) {
     ObjectMapUpdateExtents(target);
     if(isNew) {
-      ExecutiveManageObject(G, &target->Obj, -1, quiet);
+      ExecutiveManageObject(G, target, -1, quiet);
     } else {
-      ExecutiveDoZoom(G, &target->Obj, false, zoom, true);
+      ExecutiveDoZoom(G, target, false, zoom, true);
     }
     SceneChanged(G);
   }
@@ -7266,7 +7274,7 @@ int ExecutiveSculptIterateAll(PyMOLGloba
       if(rec->type == cExecObject) {
         if(rec->obj->type == cObjectMolecule) {
           objMol = (ObjectMolecule *) rec->obj;
-          if(SettingGet_b(G, NULL, objMol->Obj.Setting, cSetting_sculpting)) {
+          if(SettingGet_b(G, NULL, objMol->Setting, cSetting_sculpting)) {
             int state = ObjectGetCurrentState(rec->obj, true);
             if(state<0)
               state = SceneGetState(G);
@@ -7277,7 +7285,7 @@ int ExecutiveSculptIterateAll(PyMOLGloba
               }
             }
             ObjectMoleculeSculptIterate(objMol, state,
-                                        SettingGet_i(G, NULL, objMol->Obj.Setting,
+                                        SettingGet_i(G, NULL, objMol->Setting,
                                                      cSetting_sculpting_cycles), center);
             active = true;
           }
@@ -7453,7 +7461,7 @@ int ExecutiveMapSetBorder(PyMOLGlobals *
           result = ObjectMapSetBorder(obj, level, state);
 
           if(result) {
-            ExecutiveInvalidateMapDependents(G, obj->Obj.Name);
+            ExecutiveInvalidateMapDependents(G, obj->Name);
           }
         }
         break;
@@ -7483,7 +7491,7 @@ int ExecutiveMapDouble(PyMOLGlobals * G,
           ObjectMap *obj = (ObjectMap *) rec->obj;
           result = ObjectMapDouble(obj, state);
           if(result) {
-            ExecutiveInvalidateMapDependents(G, obj->Obj.Name);
+            ExecutiveInvalidateMapDependents(G, obj->Name);
           }
           if(result && rec->visible)
             SceneChanged(G);
@@ -7515,7 +7523,7 @@ int ExecutiveMapHalve(PyMOLGlobals * G,
           ObjectMap *obj = (ObjectMap *) rec->obj;
           result = ObjectMapHalve(obj, state, smooth);
           if(result) {
-            ExecutiveInvalidateMapDependents(G, obj->Obj.Name);
+            ExecutiveInvalidateMapDependents(G, obj->Name);
           }
           if(result && rec->visible)
             SceneChanged(G);
@@ -7563,7 +7571,7 @@ int ExecutiveMapTrim(PyMOLGlobals * G, c
             ObjectMap *obj = (ObjectMap *) rec->obj;
             result = result && ObjectMapTrim(obj, map_state, mn, mx, quiet);
             if(result)
-              ExecutiveInvalidateMapDependents(G, obj->Obj.Name);
+              ExecutiveInvalidateMapDependents(G, obj->Name);
             if(result && rec->visible)
               SceneChanged(G);
           }
@@ -7738,7 +7746,7 @@ int ExecutiveTranslateAtom(PyMOLGlobals
   return (ok);
 }
 
-int ExecutiveCombineObjectTTT(PyMOLGlobals * G, const char *name, float *ttt, int reverse_order, int store)
+int ExecutiveCombineObjectTTT(PyMOLGlobals * G, const char *name, const float *ttt, int reverse_order, int store)
 {
   int ok = true;
   CExecutive *I = G->Executive;
@@ -8140,7 +8148,7 @@ int ExecutiveAlign(PyMOLGlobals * G, con
                 int mode = 2;
                 if(!quiet) {
                   PRINTFB(G, FB_Executive, FB_Actions)
-                    " ExecutiveAlign: %d atoms aligned.\n", c ENDFB(G);
+                    " %s: %d atoms aligned.\n", __func__, c ENDFB(G);
                 }
                 if(oname && oname[0] && reset)
                   ExecutiveDelete(G, oname);
@@ -8187,7 +8195,7 @@ int ExecutivePairIndices(PyMOLGlobals *
     result = SelectorGetPairIndices(G, sele1, state1, sele2, state2,
                                     mode, cutoff, h_angle, indexVLA, objVLA);
   } else {
-    ErrMessage(G, "ExecutivePairIndices", "One or more bad selections.");
+    ErrMessage(G, __func__, "One or more bad selections.");
   }
   return (result);
 }
@@ -8397,7 +8405,7 @@ PyObject *ExecutiveGetSettingTuple(PyMOL
   CObject *obj = NULL;
   int ok = true;
   PRINTFD(G, FB_Executive)
-    " ExecutiveGetSettingTuple: object %p state %d\n", object, state ENDFD;
+    " %s: object %p state %d\n", __func__, object, state ENDFD;
 
   if(object[0] == 0)            /* global */
     result = SettingGetTuple(G, NULL, NULL, index);
@@ -8536,7 +8544,7 @@ void ExecutiveInvalidateSelectionIndicat
 
 static void ExecutiveRegenerateTextureForSelector(PyMOLGlobals *G, int round_points, int *widths_arg){
   CExecutive *I = G->Executive;
-  unsigned char *temp_buffer = Alloc(unsigned char, widths_arg[0] * widths_arg[0] * 4);
+  unsigned char *temp_buffer = pymol::malloc<unsigned char>(widths_arg[0] * widths_arg[0] * 4);
   int a, b;
   float mid_point, disty, distx, dist, wminusd;
   float widths[] = { widths_arg[0]/2.f, widths_arg[1]/2.f, widths_arg[2]/2.f };
@@ -9407,7 +9415,7 @@ void ExecutiveFuse(PyMOLGlobals * G, con
           op.i2 = 0;
           op.i3 = recolor;
           if(recolor)
-            op.i4 = obj1->Obj.Color;
+            op.i4 = obj1->Color;
           ExecutiveObjMolSeleOp(G, sele2, &op);
         }
         SelectorDelete(G, tmp_fuse_sele);
@@ -9653,13 +9661,13 @@ void ExecutiveRemoveAtoms(PyMOLGlobals *
             if(!quiet) {
               PRINTFD(G, FB_Editor)
                 " ExecutiveRemove-Debug: purging %i of %i atoms in %s\n",
-                op.i1, obj->NAtom, obj->Obj.Name ENDFD;
+                op.i1, obj->NAtom, obj->Name ENDFD;
             }
             ObjectMoleculePurge(obj);
             if(!quiet) {
               PRINTFB(G, FB_Editor, FB_Actions)
                 " Remove: eliminated %d atoms in model \"%s\".\n",
-                op.i1, obj->Obj.Name ENDFB(G);
+                op.i1, obj->Name ENDFB(G);
             }
           }
         }
@@ -10046,9 +10054,9 @@ int ExecutiveBond(PyMOLGlobals * G, cons
 
     ok = true;
   } else if(sele1 < 0) {
-    ok = ErrMessage(G, "ExecutiveBond", "The first selection contains no atoms.");
+    ok = ErrMessage(G, __func__, "The first selection contains no atoms.");
   } else if(sele2 < 0) {
-    ok = ErrMessage(G, "ExecutiveBond", "The second selection contains no atoms.");
+    ok = ErrMessage(G, __func__, "The second selection contains no atoms.");
   }
 
 ok_except1:
@@ -10091,7 +10099,7 @@ int ExecutiveAngle(PyMOLGlobals * G, flo
                                      state1, state2, state3);
     if(!obj) {
       if(!quiet)
-        ErrMessage(G, "ExecutiveAngle", "No angles found.");
+        ErrMessage(G, __func__, "No angles found.");
     } else {
       *result = rad_to_deg(*result);
       if(!anyObj) {
@@ -10104,13 +10112,13 @@ int ExecutiveAngle(PyMOLGlobals * G, flo
     }
   } else if(sele1 < 0) {
     if(!quiet)
-      ErrMessage(G, "ExecutiveAngle", "The first selection contains no atoms.");
+      ErrMessage(G, __func__, "The first selection contains no atoms.");
   } else if(sele2 < 0) {
     if(!quiet)
-      ErrMessage(G, "ExecutiveAngle", "The second selection contains no atoms.");
+      ErrMessage(G, __func__, "The second selection contains no atoms.");
   } else if(sele3 < 0) {
     if(!quiet)
-      ErrMessage(G, "ExecutiveAngle", "The third selection contains no atoms.");
+      ErrMessage(G, __func__, "The third selection contains no atoms.");
   }
   return (1);
 }
@@ -10148,7 +10156,7 @@ int ExecutiveDihedral(PyMOLGlobals * G,
                                         mode, labels, result, reset, state);
     if(!obj) {
       if(!quiet)
-        ErrMessage(G, "ExecutiveDihedral", "No angles found.");
+        ErrMessage(G, __func__, "No angles found.");
     } else {
       *result = rad_to_deg(*result);
       if(!anyObj) {
@@ -10161,16 +10169,16 @@ int ExecutiveDihedral(PyMOLGlobals * G,
     }
   } else if(sele1 < 0) {
     if(!quiet)
-      ErrMessage(G, "ExecutiveDihedral", "The first selection contains no atoms.");
+      ErrMessage(G, __func__, "The first selection contains no atoms.");
   } else if(sele2 < 0) {
     if(!quiet)
-      ErrMessage(G, "ExecutiveDihedral", "The second selection contains no atoms.");
+      ErrMessage(G, __func__, "The second selection contains no atoms.");
   } else if(sele3 < 0) {
     if(!quiet)
-      ErrMessage(G, "ExecutiveDihedral", "The third selection contains no atoms.");
+      ErrMessage(G, __func__, "The third selection contains no atoms.");
   } else if(sele4 < 0) {
     if(!quiet)
-      ErrMessage(G, "ExecutiveDihedral", "The fourth selection contains no atoms.");
+      ErrMessage(G, __func__, "The fourth selection contains no atoms.");
   }
 
   return 1;
@@ -10363,10 +10371,10 @@ int ExecutiveSeleToObject(PyMOLGlobals *
            object's state matrix (if any) */
 
         if(old_obj && new_obj) {
-          ExecutiveMatrixCopy(G, old_obj->Obj.Name, new_obj->Obj.Name, 1, 1,    /* TTT mode */
+          ExecutiveMatrixCopy(G, old_obj->Name, new_obj->Name, 1, 1,    /* TTT mode */
                               source, target, false, 0, quiet);
 
-          ExecutiveMatrixCopy(G, old_obj->Obj.Name, new_obj->Obj.Name, 2, 2,    /* Object state mode */
+          ExecutiveMatrixCopy(G, old_obj->Name, new_obj->Name, 2, 2,    /* Object state mode */
                               source, target, false, 0, quiet);
 
           ExecutiveDoZoom(G, (CObject *) new_obj, !exists, zoom, true);
@@ -10393,11 +10401,11 @@ void ExecutiveCopy(PyMOLGlobals * G, con
     oSrc = (ObjectMolecule *) os;
     oDst = ObjectMoleculeCopy(oSrc);
     if(oDst) {
-      strcpy(oDst->Obj.Name, dst);
+      strcpy(oDst->Name, dst);
       ExecutiveManageObject(G, (CObject *) oDst, zoom, false);
 
       PRINTFB(G, FB_Executive, FB_Actions)
-        " Executive: object %s created.\n", oDst->Obj.Name ENDFB(G);
+        " Executive: object %s created.\n", oDst->Name ENDFB(G);
     }
   }
   SceneChanged(G);
@@ -10591,10 +10599,15 @@ int ExecutiveIterate(PyMOLGlobals * G, c
           " Iterate: iterated over %i atoms.\n", op1.i1 ENDFB(G);
       }
     }
+    if (!read_only) {
+      SeqChanged(G);
+    }
+#ifndef _PYMOL_NO_UNDO
+#endif
   } else {
     if(!quiet) {
       PRINTFB(G, FB_Executive, FB_Warnings)
-        "ExecutiveIterate: No atoms selected.\n" ENDFB(G);
+        " %s: No atoms selected.\n", __func__ ENDFB(G);
     }
   }
   return (op1.i1);
@@ -10620,7 +10633,7 @@ int ExecutiveSelectList(PyMOLGlobals * G
     if(state == -2)
       state = SceneGetState(G);
     if(state == -3)
-      state = ObjectGetCurrentState(&obj->Obj, true);
+      state = ObjectGetCurrentState(obj, true);
     if(state >= 0) {
       cs = ObjectMoleculeGetCoordSet(obj, state);
     } else
@@ -11056,8 +11069,8 @@ int ExecutiveRMS(PyMOLGlobals * G, const
 
       if(ok && op1.nvv1 && op2.nvv1 && (matchmaker > 0)) {
         /* matchmaker 0 is the default... by internal atom ordering only */
-        int *idx1 = Alloc(int, op1.nvv1);
-        int *idx2 = Alloc(int, op2.nvv1);
+        int *idx1 = pymol::malloc<int>(op1.nvv1);
+        int *idx2 = pymol::malloc<int>(op2.nvv1);
         int sort_flag = false;
         if(!(idx1 && idx2))
           ok = false;
@@ -11310,7 +11323,7 @@ int ExecutiveRMS(PyMOLGlobals * G, const
               PRINTFB(G, FB_Executive, FB_Warnings)
                 "Executive-Warning: Ordering requested but not well defined.\n" ENDFB(G);
             } else {
-              FitVertexRec *vert = Alloc(FitVertexRec, n_pair);
+              FitVertexRec *vert = pymol::malloc<FitVertexRec>(n_pair);
 
               if(sort_flag1) {
                 float *src, *dst;
@@ -11378,7 +11391,7 @@ int ExecutiveRMS(PyMOLGlobals * G, const
               int n_next = n_pair;
               AtomInfoType **ai1, **ai2;
 
-              flag = Alloc(int, n_pair);
+              flag = pymol::malloc<int>(n_pair);
 
               if(flag) {
                 for(a = 0; a < n_pair; a++) {
@@ -11410,7 +11423,7 @@ int ExecutiveRMS(PyMOLGlobals * G, const
                 }
                 if(!quiet && (n_next != n_pair)) {
                   PRINTFB(G, FB_Executive, FB_Actions)
-                    " ExecutiveRMS: %d atoms rejected during cycle %d (RMSD=%0.2f).\n",
+                    " %s: %d atoms rejected during cycle %d (RMSD=%0.2f).\n", __func__,
                     n_pair - n_next, b, rms ENDFB(G);
                 }
                 n_pair = n_next;
@@ -11485,7 +11498,7 @@ int ExecutiveRMS(PyMOLGlobals * G, const
                 obj =
                   ObjectAlignmentDefine(G, obj, align_vla, align_state, true, trg_obj,
                                         mobile_obj);
-                obj->Obj.Color = ColorGetIndex(G, "yellow");
+                obj->Color = ColorGetIndex(G, "yellow");
                 ObjectSetName((CObject *) obj, oname);
                 ExecutiveManageObject(G, (CObject *) obj, 0, quiet);
                 align_to_update = obj;
@@ -11506,24 +11519,24 @@ int ExecutiveRMS(PyMOLGlobals * G, const
                object's state matrix (if any) */
 
             if(src_obj && trg_obj) {
-              ExecutiveMatrixCopy(G, trg_obj->Obj.Name, src_obj->Obj.Name, 1, 1,        /* TTT mode */
+              ExecutiveMatrixCopy(G, trg_obj->Name, src_obj->Name, 1, 1,        /* TTT mode */
                                   state2, state1, false, 0, quiet);
 
-              ExecutiveMatrixCopy(G, trg_obj->Obj.Name, src_obj->Obj.Name, 2, 2,        /* Object state mode */
+              ExecutiveMatrixCopy(G, trg_obj->Name, src_obj->Name, 2, 2,        /* Object state mode */
                                   state2, state1, false, 0, quiet);
 
               switch (matrix_mode) {
               case 1:          /* TTTs */
-                ExecutiveCombineObjectTTT(G, src_obj->Obj.Name, op2.ttt, true, -1);
+                ExecutiveCombineObjectTTT(G, src_obj->Name, op2.ttt, true, -1);
                 break;
               case 2:
                 {
                   double homo[16], *src_homo;
                   convertTTTfR44d(op2.ttt, homo);
                   if(ExecutiveGetObjectMatrix
-                     (G, src_obj->Obj.Name, state1, &src_homo, false)) {
+                     (G, src_obj->Name, state1, &src_homo, false)) {
                     left_multiply44d44d(src_homo, homo);
-                    ExecutiveSetObjectMatrix(G, src_obj->Obj.Name, state1, homo);
+                    ExecutiveSetObjectMatrix(G, src_obj->Name, state1, homo);
                   }
                 }
                 break;
@@ -11539,7 +11552,8 @@ int ExecutiveRMS(PyMOLGlobals * G, const
         }
       }
     } else {
-      ErrMessage(G, "ExecutiveRMS", "No atoms selected.");
+      ErrMessage(G, __func__, "No atoms selected.");
+      ok = false;
     }
   }
 
@@ -11691,7 +11705,7 @@ float ExecutiveRMSPairs(PyMOLGlobals * G
 {
   int sele1, sele2;
   int a, c;
-  float rms = 0.0, inv, *f;
+  float rms = -1.0, inv, *f;
   OrthoLineType buffer;
 
   ObjectMoleculeOpRec op1;
@@ -11750,7 +11764,7 @@ float ExecutiveRMSPairs(PyMOLGlobals * G
     if(op1.nvv1 != op2.nvv1) {
       sprintf(buffer, "Atom counts between selection sets don't match (%d != %d).",
               op1.nvv1, op2.nvv1);
-      ErrMessage(G, "ExecutiveRMS", buffer);
+      ErrMessage(G, __func__, buffer);
     } else if(op1.nvv1) {
       if(mode != 0)
         rms = MatrixFitRMSTTTf(G, op1.nvv1, op1.vv1, op2.vv1, NULL, op2.ttt);
@@ -11759,7 +11773,7 @@ float ExecutiveRMSPairs(PyMOLGlobals * G
 
       if (!quiet)
       PRINTFB(G, FB_Executive, FB_Results)
-        " ExecutiveRMS: RMSD = %8.3f (%d to %d atoms)\n", rms, op1.nvv1, op2.nvv1 ENDFB(G);
+        " %s: RMSD = %8.3f (%d to %d atoms)\n", __func__, rms, op1.nvv1, op2.nvv1 ENDFB(G);
 
       op2.code = OMOP_TTTF;
       SelectorGetTmp(G, combi, s1);
@@ -11767,7 +11781,7 @@ float ExecutiveRMSPairs(PyMOLGlobals * G
       ExecutiveObjMolSeleOp(G, sele1, &op2);
       SelectorFreeTmp(G, s1);
     } else {
-      ErrMessage(G, "ExecutiveRMS", "No atoms selected.");
+      ErrMessage(G, __func__, "No atoms selected.");
     }
   }
   VLAFreeP(op1.vv1);
@@ -12001,7 +12015,7 @@ int ExecutiveSetBondSettingFromString(Py
   float float_storage[3];
   int value_type = 0;
   PRINTFD(G, FB_Executive)
-    " ExecutiveSetBondSettingFromString: entered. '%s' '%s'\n", s1, s2 ENDFD;
+    " %s: entered. '%s' '%s'\n", __func__, s1, s2 ENDFD;
   sele1 = SelectorIndexByName(G, s1);
   sele2 = SelectorIndexByName(G, s2);
   value_ptr = &value_storage[0];
@@ -12099,7 +12113,7 @@ int ExecutiveSetBondSettingFromString(Py
               SettingGetName(G, index, name);
               PRINTF
                 " Setting: %s set for %d bonds in object \"%s\".\n",
-                name, nSet, obj->Obj.Name ENDF(G);
+                name, nSet, obj->Name ENDF(G);
             }
           }
         }
@@ -12130,7 +12144,7 @@ PyObject *ExecutiveGetBondSetting(PyMOLG
   PyObject *result = PyList_New(0);
 
   PRINTFD(G, FB_Executive)
-    " ExecutiveGetBondSetting: entered. '%s' '%s'\n", s1, s2 ENDFD;
+    " %s: entered. '%s' '%s'\n", __func__, s1, s2 ENDFD;
   unblock = PAutoBlock(G);
   sele1 = SelectorIndexByName(G, s1);
   sele2 = SelectorIndexByName(G, s2);
@@ -12160,7 +12174,7 @@ PyObject *ExecutiveGetBondSetting(PyMOLG
 	      if (!pyObjList){
 		pyObjList = PyList_New(2);
 		pyBondList = PyList_New(0);
-		PyList_SetItem(pyObjList, 0, PyString_FromString(obj->Obj.Name));
+		PyList_SetItem(pyObjList, 0, PyString_FromString(obj->Name));
 		PyList_SetItem(pyObjList, 1, pyBondList);
 		PyList_Append(result, pyObjList);
 		Py_DECREF(pyObjList);
@@ -12182,14 +12196,14 @@ PyObject *ExecutiveGetBondSetting(PyMOLG
 	    SettingGetName(G, index, name);
 	    PRINTF
 	      " Getting: %s for %d bonds in object \"%s\".\n",
-	      name, nSet, obj->Obj.Name ENDF(G);
+	      name, nSet, obj->Name ENDF(G);
 	  }
 	}
       }
     }
   }
   PRINTFD(G, FB_Executive)
-    " ExecutiveGetBondSetting: end. '%s' '%s'\n", s1, s2 ENDFD;
+    " %s: end. '%s' '%s'\n", __func__, s1, s2 ENDFD;
   PAutoUnblock(G, unblock);
   return result;
 #endif
@@ -12214,7 +12228,7 @@ int ExecutiveSetBondSetting(PyMOLGlobals
   int value_type = 0;
 
   PRINTFD(G, FB_Executive)
-    " ExecutiveSetBondSetting: entered. '%s' '%s'\n", s1, s2 ENDFD;
+    " %s: entered. '%s' '%s'\n", __func__, s1, s2 ENDFD;
   unblock = PAutoBlock(G);
   sele1 = SelectorIndexByName(G, s1);
   sele2 = SelectorIndexByName(G, s2);
@@ -12284,7 +12298,7 @@ int ExecutiveSetBondSetting(PyMOLGlobals
                 SettingGetName(G, index, name);
                 PRINTF
                   " Setting: %s set for %d bonds in object \"%s\".\n",
-                  name, nSet, obj->Obj.Name ENDF(G);
+                  name, nSet, obj->Name ENDF(G);
               }
             }
           }
@@ -12325,7 +12339,7 @@ int ExecutiveUnsetBondSetting(PyMOLGloba
   int side_effects = false;
   int sele1, sele2;
   PRINTFD(G, FB_Executive)
-    " ExecutiveUnsetBondSetting: entered. sele '%s' '%s'\n", s1, s2 ENDFD;
+    " %s: entered. sele '%s' '%s'\n", __func__, s1, s2 ENDFD;
   /* unblock = PAutoBlock(G); */
   sele1 = SelectorIndexByName(G, s1);
   sele2 = SelectorIndexByName(G, s2);
@@ -12396,7 +12410,7 @@ int ExecutiveSetSetting(PyMOLGlobals * G
   int ok = true;
 
   PRINTFD(G, FB_Executive)
-    " ExecutiveSetSetting: entered. sele \"%s\" updates=%d index=%d\n", sele, updates, index ENDFD;
+    " %s: entered. sele \"%s\" updates=%d index=%d\n", __func__, sele, updates, index ENDFD;
 
   if(!quiet) {
     SettingGetName(G, index, name);
@@ -12624,7 +12638,7 @@ int ExecutiveGetSettingFromString(PyMOLG
     }
   if(!ok) {
     PRINTFB(G, FB_Executive, FB_Errors)
-      " ExecutiveGetSettingFromString-Error: sele \"%s\" not found.\n", sele ENDFB(G);
+      " %s-Error: sele \"%s\" not found.\n", __func__, sele ENDFB(G);
     ok = false;
   } else if(obj) {
     handle = obj->fGetSettingHandle(obj, -1);
@@ -12636,7 +12650,7 @@ int ExecutiveGetSettingFromString(PyMOLG
         set_ptr2 = *handle;
       else {
         PRINTFB(G, FB_Executive, FB_Errors)
-          " ExecutiveGetSettingFromString-Error: sele \"%s\" lacks state %d.\n", sele, state + 1
+          " %s-Error: sele \"%s\" lacks state %d.\n", __func__, sele, state + 1
           ENDFB(G);
         ok = false;
       }
@@ -12711,7 +12725,7 @@ int ExecutiveSetSettingFromString(PyMOLG
   int ok = true;
 
   PRINTFD(G, FB_Executive)
-    " ExecutiveSetSettingFromString: entered. sele \"%s\"\n", sele ENDFD;
+    " %s: entered. sele \"%s\"\n", __func__, sele ENDFD;
   if(sele[0] == 0) {            /* global setting */
     ok = SettingSetFromString(G, NULL, index, value);
     if(ok) {
@@ -12917,7 +12931,7 @@ int ExecutiveUnsetSetting(PyMOLGlobals *
   int ok = true;
 
   PRINTFD(G, FB_Executive)
-    " ExecutiveUnsetSetting: entered. sele \"%s\"\n", sele ENDFD;
+    " %s: entered. sele \"%s\"\n", __func__, sele ENDFD;
   unblock = PAutoBlock(G);
   if(sele[0] == 0) {
     // Set global setting to an "off" value.
@@ -13272,7 +13286,7 @@ int ExecutiveGetCameraExtent(PyMOLGlobal
     state = SceneGetState(G);
 
   PRINTFD(G, FB_Executive)
-    " ExecutiveGetCameraExtent: name %s state %d\n", name, state ENDFD;
+    " %s: name %s state %d\n", __func__, name, state ENDFD;
 
   sele = SelectorIndexByName(G, name);
 
@@ -13297,7 +13311,7 @@ int ExecutiveGetCameraExtent(PyMOLGlobal
     ExecutiveObjMolSeleOp(G, sele, &op);
 
     PRINTFD(G, FB_Executive)
-      " ExecutiveGetCameraExtent: minmax over %d vertices\n", op.i1 ENDFD;
+      " %s: minmax over %d vertices\n", __func__, op.i1 ENDFD;
     if(op.i1)
       flag = true;
   }
@@ -13305,7 +13319,7 @@ int ExecutiveGetCameraExtent(PyMOLGlobal
   copy3f(op.v2, mx);
 
   PRINTFD(G, FB_Executive)
-    " ExecutiveGetCameraExtent: returning %d\n", flag ENDFD;
+    " %s: returning %d\n", __func__, flag ENDFD;
 
   return (flag);
 }
@@ -13336,7 +13350,7 @@ int ExecutiveGetExtent(PyMOLGlobals * G,
   }
 
   PRINTFD(G, FB_Executive)
-    " ExecutiveGetExtent: name %s state %d\n", name, state ENDFD;
+    " %s: name %s state %d\n", __func__, name, state ENDFD;
 
   ObjectMoleculeOpRecInit(&op);
   ObjectMoleculeOpRecInit(&op2);
@@ -13409,7 +13423,7 @@ int ExecutiveGetExtent(PyMOLGlobals * G,
                 have_atoms_flag = true;
               }
               PRINTFD(G, FB_Executive)
-                " ExecutiveGetExtent: minmax over %d vertices\n", op.i1 ENDFD;
+                " %s: minmax over %d vertices\n", __func__, op.i1 ENDFD;
             }
 
             if(weighted) {
@@ -13542,7 +13556,7 @@ int ExecutiveGetExtent(PyMOLGlobals * G,
   }
 
   PRINTFD(G, FB_Executive)
-    " ExecutiveGetExtent: returning %d\n", result ENDFD;
+    " %s: returning %d\n", __func__, result ENDFD;
 
   return result;
 }
@@ -13564,7 +13578,7 @@ static int ExecutiveGetMaxDistance(PyMOL
     state = SceneGetState(G);
 
   PRINTFD(G, FB_Executive)
-    " ExecutiveGetExtent: name %s state %d\n", name, state ENDFD;
+    " %s: name %s state %d\n", __func__, name, state ENDFD;
 
   ObjectMoleculeOpRecInit(&op);
   ObjectMoleculeOpRecInit(&op2);
@@ -13721,9 +13735,9 @@ int ExecutiveWindowZoom(PyMOLGlobals * G
     if(radius < MAX_VDW)
       radius = MAX_VDW;
     PRINTFD(G, FB_Executive)
-      " ExecutiveWindowZoom: zooming with radius %8.3f...state %d\n", radius, state ENDFD;
+      " %s: zooming with radius %8.3f...state %d\n", __func__, radius, state ENDFD;
     PRINTFD(G, FB_Executive)
-      " ExecutiveWindowZoom: on center %8.3f %8.3f %8.3f...\n", center[0],
+      " %s: on center %8.3f %8.3f %8.3f...\n", __func__, center[0],
       center[1], center[2]
       ENDFD;
     if(animate < 0.0F) {
@@ -13758,7 +13772,7 @@ int ExecutiveWindowZoom(PyMOLGlobals * G
       SceneSetDefaultView(G);
       SceneInvalidate(G);
     } else {
-      ErrMessage(G, "ExecutiveWindowZoom", "selection or object unknown.");
+      ErrMessage(G, __func__, "selection or object unknown.");
       ok = false;
     }
   }
@@ -13780,9 +13794,9 @@ int ExecutiveCenter(PyMOLGlobals * G, co
     average3f(mn, mx, center);
     have_center = true;
     PRINTFD(G, FB_Executive)
-      " ExecutiveCenter: centering state %d\n", state ENDFD;
+      " %s: centering state %d\n", __func__, state ENDFD;
     PRINTFD(G, FB_Executive)
-      " ExecutiveCenter: on center %8.3f %8.3f %8.3f...\n", center[0],
+      " %s: on center %8.3f %8.3f %8.3f...\n", __func__, center[0],
       center[1], center[2]
       ENDFD;
   } else if(pos) {
@@ -13818,7 +13832,7 @@ int ExecutiveCenter(PyMOLGlobals * G, co
       SceneSetDefaultView(G);
       SceneInvalidate(G);
     } else {
-      ErrMessage(G, "ExecutiveCenter", "selection or object unknown.");
+      ErrMessage(G, __func__, "selection or object unknown.");
       ok = false;
     }
   }
@@ -13856,12 +13870,12 @@ int ExecutiveOrigin(PyMOLGlobals * G, co
     if(obj) {
       ObjectSetTTTOrigin(obj, center);
       PRINTFB(G, FB_Executive, FB_Blather)
-        " ExecutiveCenter: origin for %s set to %8.3f %8.3f %8.3f\n",
+        " %s: origin for %s set to %8.3f %8.3f %8.3f\n", __func__,
         oname, center[0], center[1], center[2]
         ENDFB(G);
     } else {
       PRINTFB(G, FB_Executive, FB_Blather)
-        " ExecutiveCenter: scene origin set to %8.3f %8.3f %8.3f\n",
+        " %s: scene origin set to %8.3f %8.3f %8.3f\n", __func__,
         center[0], center[1], center[2]
         ENDFB(G);
       SceneOriginSet(G, center, preserve);
@@ -14047,14 +14061,12 @@ bool ExecutiveIsFullScreen(PyMOLGlobals
 
   int flag = -1;
 
-#ifdef _MACPYMOL_XCODE
-  flag = MacPyMOL_fullScreenActive();
-#elif defined(GLUT_FULL_SCREEN)
+#if defined(GLUT_FULL_SCREEN)
   flag = glutGet(GLUT_FULL_SCREEN);
 #endif
 
   PRINTFD(G, FB_Executive)
-    " ExecutiveIsFullScreen: flag=%d fallback=%d.\n",
+    " %s: flag=%d fallback=%d.\n", __func__,
     flag, _is_full_screen ENDFD;
 
   if (flag > -1)
@@ -14144,7 +14156,7 @@ int ExecutiveToggleRepVisib(PyMOLGlobals
       ExecutiveSetObjVisib(G, name, !tRec->visible, 0);
     } else {
       PRINTFB(G, FB_Executive, FB_Errors)
-        " ExecutiveToggleRepVisib-Error: '%s' not found\n", name ENDFB(G);
+        " %s-Error: '%s' not found\n", __func__, name ENDFB(G);
     }
   } else if(tRec && tRec->type == cExecObject &&
       tRec->obj->type != cObjectMolecule) {
@@ -14293,7 +14305,7 @@ static void ExecutiveSetAllRepVisMask(Py
         switch (rec->obj->type) {
         case cObjectMolecule:
           obj = (ObjectMolecule *) rec->obj;
-          sele = SelectorIndexByName(G, obj->Obj.Name);
+          sele = SelectorIndexByName(G, obj->Name);
           ObjectMoleculeOpRecInit(&op);
 
           op.code = OMOP_VISI;
@@ -14574,13 +14586,13 @@ void ExecutiveSymExp(PyMOLGlobals * G, c
   if(ob->type == cObjectMolecule)
     obj = (ObjectMolecule *) ob;
   if(!(obj && sele)) {
-    ErrMessage(G, "ExecutiveSymExp", "Invalid object");
+    ErrMessage(G, __func__, "Invalid object");
   } else if(!obj->Symmetry) {
-    ErrMessage(G, "ExecutiveSymExp", "No symmetry loaded!");
+    ErrMessage(G, __func__, "No symmetry loaded!");
   } else if(!SymmetryAttemptGeneration(obj->Symmetry)) {
     // unknown space group
   } else if(obj->Symmetry->getNSymMat() < 1) {
-    ErrMessage(G, "ExecutiveSymExp", "No symmetry matrices!");
+    ErrMessage(G, __func__, "No symmetry matrices!");
   } else {
     if(!quiet) {
       PRINTFB(G, FB_Executive, FB_Actions)
@@ -14619,7 +14631,7 @@ void ExecutiveSymExp(PyMOLGlobals * G, c
 
 		/* op.nvv1 is the number of atom coordinates we copied in the previous step */
     if(!op.nvv1) {
-      ErrMessage(G, "ExecutiveSymExp", "No atoms indicated!");
+      ErrMessage(G, __func__, "No atoms indicated!");
     } else {
       int nsymmat = obj->Symmetry->getNSymMat();
       map = MapNew(G, -cutoff, op.vv1, op.nvv1, NULL);
@@ -14720,7 +14732,7 @@ void ExecutiveSymExp(PyMOLGlobals * G, c
                     new_name, name, (int)a, x, y, z ENDFB(G);
 
                   ObjectSetName((CObject *) new_obj, new_name);
-                  ExecutiveDelete(G, new_obj->Obj.Name);
+                  ExecutiveDelete(G, new_obj->Name);
                   ExecutiveManageObject(G, (CObject *) new_obj, -1, quiet);
                   SceneChanged(G);
 									
@@ -14793,23 +14805,6 @@ static void ExecutivePurgeSpec(PyMOLGlob
 
     CGOFree(rec->gridSlotSelIndicatorsCGO);
 
-  if(rec->group_name[0]) {
-    /* cascade group members up to the surrounding group */
-    SpecRec *rec2 = NULL;
-    while(ListIterate(I->Spec, rec2, next)) {
-      if((rec2->group == rec) || WordMatchExact(G, rec->name, rec2->group_name, true)) {
-        strcpy(rec2->group_name, rec->group_name);
-      }
-    }
-  } else if((rec->type == cExecObject) && (rec->obj->type == cObjectGroup)) {
-    /* and/or delete their group membership */
-    SpecRec *rec2 = NULL;
-    while(ListIterate(I->Spec, rec2, next)) {
-      if((rec2->group == rec) || WordMatchExact(G, rec->name, rec2->group_name, true)) {
-        rec2->group_name[0] = 0;
-      }
-    }
-  }
   ExecutiveInvalidateGroups(G, false);
   ExecutiveInvalidatePanelList(G);
   switch (rec->type) {
@@ -14913,10 +14908,10 @@ void ExecutiveDump(PyMOLGlobals * G, con
     } else if(rec->obj->type == cObjectSurface) {
       ObjectSurfaceDump((ObjectSurface *) rec->obj, fname, 0);
     } else {
-      ErrMessage(G, "ExecutiveDump", "Invalid object type for this operation.");
+      ErrMessage(G, __func__, "Invalid object type for this operation.");
     }
   } else {
-    ErrMessage(G, "ExecutiveDump", "Object not found.");
+    ErrMessage(G, __func__, "Object not found.");
   }
 
 }
diff -upNr pymol-open-source-2.3.0/layer3/Executive.h pymol-open-source-2.3.3/layer3/Executive.h
--- pymol-open-source-2.3.0/layer3/Executive.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer3/Executive.h	2019-08-22 10:24:47.738598948 +0200
@@ -167,6 +167,7 @@ int ExecutiveScrollTo(PyMOLGlobals * G,
 
 void ExecutiveInvalidateGroups(PyMOLGlobals * G, int force);
 void ExecutiveUpdateGroups(PyMOLGlobals * G, int force);
+void ExecutiveUpdateSceneMembers(PyMOLGlobals*);
 
 int *ExecutiveGetG3d(PyMOLGlobals * G);
 int ExecutiveOrder(PyMOLGlobals * G, const char *s1, int sort, int location);
@@ -420,7 +421,7 @@ int ExecutiveMapHalve(PyMOLGlobals * G,
 int ExecutiveIdentifyObjects(PyMOLGlobals * G, const char *s1, int mode, int **indexVLA,
                              ObjectMolecule *** objVLA);
 int ExecutiveTranslateObjectTTT(PyMOLGlobals * G, const char *name, float *trans, int store, int quiet);
-int ExecutiveCombineObjectTTT(PyMOLGlobals * G, const char *name, float *ttt,
+int ExecutiveCombineObjectTTT(PyMOLGlobals * G, const char *name, const float *ttt,
                               int reverse_order, int store);
 int ExecutiveSetObjectTTT(PyMOLGlobals * G, const char *name, const float *ttt, int state, int quiet, int store);
 int ExecutiveGetObjectTTT(PyMOLGlobals * G, const char *name, const float **ttt, int state,
@@ -560,7 +561,7 @@ int ExecutiveGroupMotion(PyMOLGlobals *G
                          int last, float power, float bias,
                          int simple, float linear, int wrap,
                          int hand, int window, int cycles, int state, int quiet);
-int ExecutiveGroupCombineTTT(PyMOLGlobals *G, CObject *group, float *ttt, int reverse_order, int store);
+int ExecutiveGroupCombineTTT(PyMOLGlobals *G, CObject *group, const float *ttt, int reverse_order, int store);
 int ExecutiveGroupTranslateTTT(PyMOLGlobals *G, CObject *group, float *v, int store);
 void ExecutiveMotionClick(PyMOLGlobals * G, BlockRect *rect, int mode, int expected, int x, int y, int nearest);
 void ExecutiveMotionTrim(PyMOLGlobals * G);
diff -upNr pymol-open-source-2.3.0/layer3/ExecutivePython.cpp pymol-open-source-2.3.3/layer3/ExecutivePython.cpp
--- pymol-open-source-2.3.0/layer3/ExecutivePython.cpp	1970-01-01 01:00:00.000000000 +0100
+++ pymol-open-source-2.3.3/layer3/ExecutivePython.cpp	2019-08-22 10:24:47.738598948 +0200
@@ -0,0 +1,149 @@
+#include "ExecutivePython.h"
+#include "ObjectCGO.h"
+#include "ObjectCallback.h"
+#include "P.h"
+
+void ExecutiveLoadObject(PyMOLGlobals* G, const char* oname, PyObject* model,
+    int frame, int type, int finish, int discrete, int quiet, int zoom)
+{
+  ObjectNameType valid_name = "";
+  CObject *origObj = NULL, *obj;
+  OrthoLineType buf;
+  buf[0] = 0;
+  ExecutiveProcessObjectName(G, oname, valid_name);
+
+  origObj = ExecutiveFindObjectByName(G, valid_name);
+
+  /* TODO check for existing object of wrong type */
+
+  switch (type) {
+  case cLoadTypeChemPyModel: {
+    if (origObj) {
+      if (origObj->type != cObjectMolecule) {
+        ExecutiveDelete(G, valid_name);
+        origObj = NULL;
+      } else {
+        discrete = 1;
+      }
+    }
+    PBlock(G); /*PBlockAndUnlockAPI(); */
+#ifndef _PYMOL_NO_UNDO
+#endif
+    obj = (CObject*) ObjectMoleculeLoadChemPyModel(
+        G, (ObjectMolecule*) origObj, model, frame, discrete);
+    PUnblock(G); /*PLockAPIAndUnblock(); */
+    if (!origObj) {
+      if (obj) {
+        ObjectSetName(obj, valid_name);
+#ifndef _PYMOL_NO_UNDO
+#endif
+        ExecutiveManageObject(G, obj, zoom, quiet);
+        if (frame < 0)
+          frame = ((ObjectMolecule*) obj)->NCSet - 1;
+        sprintf(buf,
+            " CmdLoad: ChemPy-model loaded into object \"%s\", state %d.\n",
+            valid_name, frame + 1);
+      }
+    } else if (origObj) {
+      if (finish)
+        ExecutiveUpdateObjectSelection(G, origObj);
+      if (frame < 0)
+        frame = ((ObjectMolecule*) origObj)->NCSet - 1;
+      sprintf(buf,
+          " CmdLoad: ChemPy-model appended into object \"%s\", state %d.\n",
+          valid_name, frame + 1);
+    }
+    break;
+  }
+  case cLoadTypeChemPyBrick:
+    if (origObj)
+      if (origObj->type != cObjectMap) {
+        ExecutiveDelete(G, valid_name);
+        origObj = NULL;
+      }
+    PBlock(G); /*PBlockAndUnlockAPI(); */
+    obj = (CObject*) ObjectMapLoadChemPyBrick(
+        G, (ObjectMap*) origObj, model, frame, discrete, quiet);
+    PUnblock(G); /*PLockAPIAndUnblock(); */
+    if (!origObj) {
+      if (obj) {
+        ObjectSetName(obj, valid_name);
+        ExecutiveManageObject(G, obj, zoom, quiet);
+        sprintf(buf, " CmdLoad: chempy.brick loaded into object \"%s\"\n",
+            valid_name);
+      }
+    } else if (origObj) {
+      sprintf(buf, " CmdLoad: chempy.brick appended into object \"%s\"\n",
+          valid_name);
+    }
+    break;
+  case cLoadTypeChemPyMap:
+    if (origObj)
+      if (origObj->type != cObjectMap) {
+        ExecutiveDelete(G, valid_name);
+        origObj = NULL;
+      }
+    PBlock(G); /*PBlockAndUnlockAPI(); */
+    obj = (CObject*) ObjectMapLoadChemPyMap(
+        G, (ObjectMap*) origObj, model, frame, discrete, quiet);
+    PUnblock(G); /*PLockAPIAndUnblock(); */
+    if (!origObj) {
+      if (obj) {
+        ObjectSetName(obj, valid_name);
+        ExecutiveManageObject(G, obj, zoom, quiet);
+        sprintf(buf, " CmdLoad: chempy.map loaded into object \"%s\"\n",
+            valid_name);
+      }
+    } else if (origObj) {
+      sprintf(buf, " CmdLoad: chempy.map appended into object \"%s\"\n",
+          valid_name);
+    }
+    break;
+  case cLoadTypeCallback:
+    if (origObj)
+      if (origObj->type != cObjectCallback) {
+        ExecutiveDelete(G, valid_name);
+        origObj = NULL;
+      }
+    PBlock(G); /*PBlockAndUnlockAPI(); */
+    obj = (CObject*) ObjectCallbackDefine(
+        G, (ObjectCallback*) origObj, model, frame);
+    PUnblock(G); /*PLockAPIAndUnblock(); */
+    if (!origObj) {
+      if (obj) {
+        ObjectSetName(obj, valid_name);
+        ExecutiveManageObject(G, obj, zoom, quiet);
+        sprintf(buf, " CmdLoad: pymol.callback loaded into object \"%s\"\n",
+            valid_name);
+      }
+    } else if (origObj) {
+      sprintf(buf, " CmdLoad: pymol.callback appended into object \"%s\"\n",
+          valid_name);
+    }
+    break;
+  case cLoadTypeCGO:
+    if (origObj)
+      if (origObj->type != cObjectCGO) {
+        ExecutiveDelete(G, valid_name);
+        origObj = NULL;
+      }
+    PBlock(G); /*PBlockAndUnlockAPI(); */
+    obj = (CObject*) ObjectCGODefine(G, (ObjectCGO*) origObj, model, frame);
+    PUnblock(G); /*PLockAPIAndUnblock(); */
+    if (!origObj) {
+      if (obj) {
+        ObjectSetName(obj, valid_name);
+        ExecutiveManageObject(G, obj, zoom, quiet);
+        sprintf(buf, " CmdLoad: CGO loaded into object \"%s\"\n", valid_name);
+      }
+    } else if (origObj) {
+      sprintf(buf, " CmdLoad: CGO appended into object \"%s\"\n", valid_name);
+    }
+    break;
+  }
+  if (origObj && !quiet) {
+    PRINTFB(G, FB_Executive, FB_Actions)
+    "%s", buf ENDFB(G);
+    OrthoRestorePrompt(G);
+  }
+}
diff -upNr pymol-open-source-2.3.0/layer3/ExecutivePython.h pymol-open-source-2.3.3/layer3/ExecutivePython.h
--- pymol-open-source-2.3.0/layer3/ExecutivePython.h	1970-01-01 01:00:00.000000000 +0100
+++ pymol-open-source-2.3.3/layer3/ExecutivePython.h	2019-08-22 10:24:47.738598948 +0200
@@ -0,0 +1,10 @@
+#pragma once
+
+#include "Executive.h"
+
+#ifndef _PYMOL_NO_PY
+
+void ExecutiveLoadObject(PyMOLGlobals* G, const char* oname, PyObject* model,
+    int frame, int type, int finish, int discrete, int quiet, int zoom);
+
+#endif //_PYMOL_NO_PY
diff -upNr pymol-open-source-2.3.0/layer3/MaeExportHelpers.cpp pymol-open-source-2.3.3/layer3/MaeExportHelpers.cpp
--- pymol-open-source-2.3.0/layer3/MaeExportHelpers.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer3/MaeExportHelpers.cpp	2019-08-22 10:24:47.738598948 +0200
@@ -20,7 +20,7 @@
  */
 template <typename V>
 V SettingGet(PyMOLGlobals * G, const SeleCoordIterator& iter, int index) {
-  V value = SettingGet<V>(G, iter.cs->Setting, iter.obj->Obj.Setting, index);
+  V value = SettingGet<V>(G, iter.cs->Setting, iter.obj->Setting, index);
   return AtomSettingGetWD(G, iter.getAtomInfo(), index, value);
 }
 
@@ -197,3 +197,39 @@ std::string MaeExportGetSubGroupId(PyMOL
 
   return subgroupid;
 }
+
+/*
+ * Get parsable string representation, with quotes and escaped
+ * quotes/backslashes if needed.
+ */
+std::string MaeExportStrRepr(const char * text)
+{
+  if (text[0] /* not empty string */) {
+    bool needquotes = false;
+
+    // check accepted ascii characters
+    for (const char * p = text; *p; ++p) {
+      if (*p < '$' || *p > 'z' || *p == '\\') {
+        needquotes = true;
+        break;
+      }
+    }
+
+    if (!needquotes) {
+      return text;
+    }
+  }
+
+  std::string quoted_text;
+  quoted_text.reserve(strlen(text) + 2);
+  quoted_text += '"';
+
+  for (const char * p = text; *p; ++p) {
+    if (*p == '"' || *p == '\\')
+      quoted_text += '\\';
+    quoted_text += *p;
+  }
+
+  quoted_text += '"';
+  return quoted_text;
+}
diff -upNr pymol-open-source-2.3.0/layer3/MaeExportHelpers.h pymol-open-source-2.3.3/layer3/MaeExportHelpers.h
--- pymol-open-source-2.3.0/layer3/MaeExportHelpers.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer3/MaeExportHelpers.h	2019-08-22 10:24:47.738598948 +0200
@@ -31,4 +31,6 @@ std::string MaeExportGetLabelUserText(Py
 std::string MaeExportGetSubGroupId(PyMOLGlobals * G,
     const CObject * obj);
 
+std::string MaeExportStrRepr(const char * text);
+
 // vi:sw=2:expandtab
diff -upNr pymol-open-source-2.3.0/layer3/MoleculeExporter.cpp pymol-open-source-2.3.3/layer3/MoleculeExporter.cpp
--- pymol-open-source-2.3.0/layer3/MoleculeExporter.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer3/MoleculeExporter.cpp	2019-08-22 10:24:47.738598948 +0200
@@ -217,7 +217,7 @@ protected:
   const char * getTitleOrName() {
     if (!m_iter.cs)
       return "untitled";
-    return m_iter.cs->Name[0] ? m_iter.cs->Name : m_iter.obj->Obj.Name;
+    return m_iter.cs->Name[0] ? m_iter.cs->Name : m_iter.obj->Name;
   }
 
 public:
@@ -536,10 +536,10 @@ struct MoleculeExporterPDB : public Mole
   void beginObject() override {
     MoleculeExporter::beginObject();
 
-    m_conect_all = SettingGet_b(G, m_iter.obj->Obj.Setting, nullptr, cSetting_pdb_conect_all);
+    m_conect_all = SettingGet_b(G, m_iter.obj->Setting, nullptr, cSetting_pdb_conect_all);
 
     if (m_multi == cMolExportByObject) {
-      m_offset += VLAprintf(m_buffer, m_offset, "HEADER    %.40s\n", m_iter.obj->Obj.Name);
+      m_offset += VLAprintf(m_buffer, m_offset, "HEADER    %.40s\n", m_iter.obj->Name);
       writeCryst1();
     }
   }
@@ -646,7 +646,7 @@ struct MoleculeExporterCIF : public Mole
     MoleculeExporter::beginMolecule();
 
     switch (m_multi) {
-      case cMolExportByObject:   m_molecule_name = m_iter.obj->Obj.Name; break;
+      case cMolExportByObject:   m_molecule_name = m_iter.obj->Name; break;
       case cMolExportByCoordSet: m_molecule_name = getTitleOrName(); break;
     }
 
@@ -1063,6 +1063,55 @@ struct MoleculeExporterMAE : public Mole
   int m_n_atoms_offset;
   int m_n_arom_bonds;
   std::map<int, const AtomInfoType *> m_atoms;
+  bool m_has_anisou;
+
+#ifdef _PYMOL_MAE_PROP_EXPORT
+#endif
+
+  /* Check if current object has any ANISOU data
+   */
+  bool currentObjectHasAnisou() const {
+    for (auto i = 0; i < m_iter.obj->NAtom; ++i) {
+      if (m_iter.obj->AtomInfo[i].has_anisou()) {
+        return true;
+      }
+    }
+
+    return false;
+  }
+
+  /* Write a single string value to the output buffer
+   */
+  void writeMaeValue(const char * s) {
+    auto s_quoted = MaeExportStrRepr(s);
+    m_offset += VLAprintf(m_buffer, m_offset, "%s\n", s_quoted.c_str());
+  }
+
+  /* Write the given keys to the output buffer.
+   * Add type prefix and make key unique if necessary.
+   */
+  void writeMaeKeys(const std::vector<std::string> &keys) {
+    std::set<std::string> unique_keys;
+
+    for (auto key : keys) {
+      // check for "<type>_" prefix or add one
+      if (key.size() < 2 || key[1] != '_' || !strchr("irsb", key[0])) {
+        key = "s_pymol_" + key;
+      }
+
+      auto key_size = key.size();
+
+      // make key unique (append numbers)
+      for (unsigned i = 1; unique_keys.count(key); ++i) {
+        key.resize(key_size);
+        key += std::to_string(i);
+      }
+
+      unique_keys.insert(key);
+
+      writeMaeValue(key.c_str());
+    }
+  }
 
   // quasi constructor
   void init(PyMOLGlobals * G_) override {
@@ -1089,43 +1138,91 @@ struct MoleculeExporterMAE : public Mole
 
     m_offset += VLAprintf(m_buffer, m_offset,
         "\nf_m_ct {\n"
-        "s_m_subgroupid\n"
-        "s_m_title\n"
+        );
+
+    std::vector<std::string> keys {
+      "s_m_title",
+    };
+
+    if (!groupid.empty()) {
+      keys.emplace_back("s_m_subgroupid");
+    }
+
+#ifdef _PYMOL_MAE_PROP_EXPORT
+#endif
+
+    writeMaeKeys(keys);
+
+    m_offset += VLAprintf(m_buffer, m_offset,
         ":::\n"
-        "\"%s\"\n"
-        "\"%s\"\n",
-        groupid.c_str(),
-        getTitleOrName());
+        );
+
+    // title may contain spaces or quotes
+    writeMaeValue(getTitleOrName());
+
+    if (!groupid.empty()) {
+      m_offset += VLAprintf(m_buffer, m_offset, "\"%s\"\n", groupid.c_str());
+    }
+
+#ifdef _PYMOL_MAE_PROP_EXPORT
+#endif
 
     // defer until number of atoms known
     m_n_atoms_offset = m_offset;
 
+    keys = {
+      "i_m_mmod_type",
+      "r_m_x_coord",
+      "r_m_y_coord",
+      "r_m_z_coord",
+      "i_m_residue_number",
+      "s_m_insertion_code",
+      "s_m_chain_name",
+      "s_m_pdb_residue_name",
+      "s_m_pdb_atom_name",
+      "i_m_atomic_number",
+      "i_m_formal_charge",
+      "s_m_color_rgb",
+      "i_m_secondary_structure",
+      "r_m_pdb_occupancy",
+      "i_pdb_PDB_serial",
+
+      "r_m_pdb_tfactor",
+      "r_m_charge1",
+
+      "i_m_visibility",
+      "i_m_representation",
+      "i_m_ribbon_style",
+      "i_m_ribbon_color",
+      "s_m_ribbon_color_rgb",
+      "s_m_label_format",
+      "i_m_label_color",
+      "s_m_label_user_text",
+    };
+
+    // ANISOU
+    if ((m_has_anisou = currentObjectHasAnisou())) {
+      keys.insert(keys.end(), {
+        "i_pdb_anisou_u11",
+        "i_pdb_anisou_u22",
+        "i_pdb_anisou_u33",
+        "i_pdb_anisou_u12",
+        "i_pdb_anisou_u13",
+        "i_pdb_anisou_u23",
+      });
+    }
+
     m_offset += VLAprintf(m_buffer, m_offset,
         "m_atom[X]            {\n" // place holder
         "# First column is atom index #\n"
-        "i_m_mmod_type\n"
-        "r_m_x_coord\n"
-        "r_m_y_coord\n"
-        "r_m_z_coord\n"
-        "i_m_residue_number\n"
-        "s_m_insertion_code\n"
-        "s_m_chain_name\n"
-        "s_m_pdb_residue_name\n"
-        "s_m_pdb_atom_name\n"
-        "i_m_atomic_number\n"
-        "i_m_formal_charge\n"
-        "s_m_color_rgb\n"
-        "i_m_secondary_structure\n"
-        "r_m_pdb_occupancy\n"
-        "i_pdb_PDB_serial\n"
-        "i_m_visibility\n"
-        "i_m_representation\n"
-        "i_m_ribbon_style\n"
-        "i_m_ribbon_color\n"
-        "s_m_ribbon_color_rgb\n"
-        "s_m_label_format\n"
-        "i_m_label_color\n"
-        "s_m_label_user_text\n"
+        );
+
+#ifdef _PYMOL_MAE_PROP_EXPORT
+#endif
+
+    writeMaeKeys(keys);
+
+    m_offset += VLAprintf(m_buffer, m_offset,
         ":::\n");
 
     m_n_atoms = 0;
@@ -1152,16 +1249,25 @@ struct MoleculeExporterMAE : public Mole
     if (ai->name)
       AtomInfoGetAlignedPDBAtomName(G, ai, resn, name);
 
+    // 4-letter padding for atom name
+    for (auto i = strlen(name); i < 4; ++i) {
+      name[i] = ' ';
+    }
+    name[4] = '\0';
+
+    // 1-letter padding for chain
+    const char* chain = ai->chain ? LexStr(G, ai->chain) : " ";
+
     m_offset += VLAprintf(m_buffer, m_offset,
-        "%d %d %.3f %.3f %.3f %d %s %s \"%-4s\" \"%-4s\" %d %d %02X%02X%02X %d %.2f %d\n",
+        "%d %d %.3f %.3f %.3f %d %s %s \"%-4s\" %s %d %d %02X%02X%02X %d %.2f %d\n",
         getTmpID(),
         getMacroModelAtomType(ai),
         m_coord[0], m_coord[1], m_coord[2],
         ai->resv,
         inscode,
-        ai->chain ? LexStr(G, ai->chain) : "\" \"",
+        MaeExportStrRepr(chain).c_str(),
         resn,
-        name,
+        MaeExportStrRepr(name).c_str(),
         ai->protons,
         ai->formalCharge,
         int(rgb[0] * 255),
@@ -1171,6 +1277,11 @@ struct MoleculeExporterMAE : public Mole
         ai->q,
         ai->id);
 
+    m_offset += VLAprintf(m_buffer, m_offset,
+        "%.2f %.2f ",
+        ai->b,
+        ai->partialCharge);
+
     char ribbon_color_rgb[7] = "<>";
     MaeExportGetRibbonColor(G, m_iter, ribbon_color_rgb);
     std::string label_user_text = MaeExportGetLabelUserText(G, ai);
@@ -1185,6 +1296,28 @@ struct MoleculeExporterMAE : public Mole
         label_user_text.empty() ? "" : "%UT",
         label_user_text.c_str());
 
+    // ANISOU
+    if (m_has_anisou) {
+      if (ai->has_anisou()) {
+        float anisou[6];
+        std::copy_n(ai->get_anisou(), 6, anisou);
+
+        if (m_mat_full.ptr) {
+          RotateU(m_mat_full.ptr, anisou);
+        }
+
+        m_offset += VLAprintf(m_buffer, m_offset,
+            "%.0f %.0f %.0f %.0f %.0f %.0f\n",
+            anisou[0] * 1e4, anisou[1] * 1e4, anisou[2] * 1e4,
+            anisou[3] * 1e4, anisou[4] * 1e4, anisou[5] * 1e4);
+      } else {
+        m_offset += VLAprintf(m_buffer, m_offset, "<> <> <> <> <> <>\n");
+      }
+    }
+
+#ifdef _PYMOL_MAE_PROP_EXPORT
+#endif
+
     m_atoms[getTmpID()] = ai;
 
     ++m_n_atoms;
@@ -1357,6 +1490,11 @@ public:
     m_raw.occupancyList.emplace_back(ai->q);
     m_raw.altLocList.emplace_back(ai->alt[0]);
 
+    // don't assign to 'm_retain_ids', it messes up bonds
+    if (SettingGetGlobal_b(G, cSetting_pdb_retain_ids)) {
+      m_raw.atomIdList.emplace_back(ai->id);
+    }
+
     m_last_ai = ai;
   }
 
diff -upNr pymol-open-source-2.3.0/layer3/MovieScene.cpp pymol-open-source-2.3.3/layer3/MovieScene.cpp
--- pymol-open-source-2.3.0/layer3/MovieScene.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer3/MovieScene.cpp	2019-08-22 10:24:47.738598948 +0200
@@ -228,23 +228,27 @@ static bool MovieSceneStore(PyMOLGlobals
     bool store_active,
     bool store_rep,
     bool store_frame,
-    const char * sele)
+    const char * sele,
+    size_t stack)
 {
-  auto scenes = G->scenes;
+  const bool is_defaultstack = stack == cMovieSceneStackDefault;
+  auto scenes = G->scenes + stack;
   std::string key(name);
 
-  // new key?
-  if (key.empty() || key == "new") {
-    key = scenes->getUniqueKey();
-    scenes->order.push_back(key);
-  } else if (scenes->dict.find(key) == scenes->dict.end()) {
-    scenes->order.push_back(key);
-  }
+  if (is_defaultstack) {
+    // new key?
+    if (key.empty() || key == "new") {
+      key = scenes->getUniqueKey();
+      scenes->order.push_back(key);
+    } else if (scenes->dict.find(key) == scenes->dict.end()) {
+      scenes->order.push_back(key);
+    }
 
-  SceneSetNames(G, scenes->order);
+    SceneSetNames(G, scenes->order);
 
-  // set scene_current_name
-  SettingSetGlobal_s(G, cSetting_scene_current_name, key.c_str());
+    // set scene_current_name
+    SettingSetGlobal_s(G, cSetting_scene_current_name, key.c_str());
+  }
 
   MovieScene &scene = scenes->dict[key];
 
@@ -272,7 +276,7 @@ static bool MovieSceneStore(PyMOLGlobals
     for (SeleAtomIterator iter(G, sele); iter.next();) {
 
       // don't store atom data for disabled objects
-      if (!((CObject*)iter.obj)->Enabled)
+      if (!((CObject*)iter.obj)->Enabled && is_defaultstack)
         continue;
 
       AtomInfoType * ai = iter.getAtomInfo();
@@ -297,8 +301,10 @@ static bool MovieSceneStore(PyMOLGlobals
     SET_BIT_TO(sceneobj.visRep, 0, rec->visible);
   }
 
-  PRINTFB(G, FB_Scene, FB_Details)
+  if (is_defaultstack) {
+    PRINTFB(G, FB_Scene, FB_Details)
     " scene: scene stored as \"%s\".\n", key.c_str() ENDFB(G);
+  }
 
   return true;
 }
@@ -375,9 +381,10 @@ bool MovieSceneRecall(PyMOLGlobals * G,
     bool recall_active,
     bool recall_rep,
     bool recall_frame,
-    const char * sele)
+    const char * sele,
+    size_t stack)
 {
-  auto scenes = G->scenes;
+  auto scenes = G->scenes + stack;
   auto it = scenes->dict.find(name);
 
   if (it == scenes->dict.end()) {
@@ -387,8 +394,10 @@ bool MovieSceneRecall(PyMOLGlobals * G,
     return false;
   }
 
-  // set scene_current_name
-  SettingSetGlobal_s(G, cSetting_scene_current_name, name);
+  if (stack == cMovieSceneStackDefault) {
+    // set scene_current_name
+    SettingSetGlobal_s(G, cSetting_scene_current_name, name);
+  }
 
   MovieScene &scene = it->second;
 
@@ -559,6 +568,20 @@ static bool MovieSceneRename(PyMOLGlobal
   return false;
 }
 
+/**
+ * Delete a scene
+ *
+ * @param name scene name or "*" to delete all scenes (for default stack)
+ */
+bool MovieSceneDelete(PyMOLGlobals* G, const char* name, size_t stack) {
+  if (stack != cMovieSceneStackDefault) {
+    return G->scenes[stack].dict.erase(name) != 0;
+  }
+
+  // takes also care of scene order and name="*"
+  return MovieSceneRename(G, name, nullptr);
+}
+
 /*
  * Print current scene order
  */
@@ -655,9 +678,10 @@ bool MovieSceneFunc(PyMOLGlobals * G, co
     float animate,
     const char * new_key,
     bool hand,
-    const char * sele)
+    const char * sele,
+    size_t stack)
 {
-  auto scenes = G->scenes;
+  auto scenes = G->scenes + stack;
   std::string prev_name;
   short beforeafter = 0;
   bool status = false;
@@ -703,19 +727,19 @@ bool MovieSceneFunc(PyMOLGlobals * G, co
       MovieSceneRecallMessage(G, "");
     } else {
       status = MovieSceneRecall(G, key, animate, store_view, store_color,
-          store_active, store_rep, store_frame, sele);
+          store_active, store_rep, store_frame, sele, stack);
     }
 
   } else if (strcmp(action, "store") == 0) {
     status = MovieSceneStore(G, key, message, store_view, store_color,
-        store_active, store_rep, store_frame, sele);
+        store_active, store_rep, store_frame, sele, stack);
 
     // insert_before, insert_after
     if (status && beforeafter)
       status = MovieSceneOrderBeforeAfter(G, prev_name.c_str(), beforeafter == 1);
 
   } else if (strcmp(action, "delete") == 0) {
-    status = MovieSceneRename(G, key, nullptr);
+    status = MovieSceneDelete(G, key, stack);
   } else if (strcmp(action, "rename") == 0) {
     status = MovieSceneRename(G, key, new_key);
   } else if (strcmp(action, "order") == 0) {
@@ -747,12 +771,12 @@ ok_exceptNOSCENES:
 
 void MovieScenesInit(PyMOLGlobals * G) {
   MovieScenesFree(G);
-  G->scenes = new CMovieScenes;
+  G->scenes = new CMovieScenes[cMovieSceneStack_SIZE];
 }
 
 void MovieScenesFree(PyMOLGlobals * G) {
   if (G->scenes) {
-    delete G->scenes;
+    delete[] G->scenes;
     G->scenes = nullptr;
   }
 }
diff -upNr pymol-open-source-2.3.0/layer3/MovieScene.h pymol-open-source-2.3.3/layer3/MovieScene.h
--- pymol-open-source-2.3.0/layer3/MovieScene.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer3/MovieScene.h	2019-08-22 10:24:47.742599599 +0200
@@ -14,6 +14,11 @@
 #include <vector>
 #include <string>
 
+enum {
+  cMovieSceneStackDefault = 0,
+  cMovieSceneStack_SIZE
+};
+
 bool MovieSceneFunc(PyMOLGlobals * G, const char * name,
     const char * action,
     const char * message = "",
@@ -25,7 +30,8 @@ bool MovieSceneFunc(PyMOLGlobals * G, co
     float animate = -1.0,
     const char * new_key = "",
     bool hand = true,
-    const char * sele = "all");
+    const char * sele = "all",
+    size_t stack = cMovieSceneStackDefault);
 
 bool MovieSceneRecall(PyMOLGlobals * G, const char * name, float animate = -1.0,
     bool recall_view = true,
@@ -33,7 +39,11 @@ bool MovieSceneRecall(PyMOLGlobals * G,
     bool recall_active = true,
     bool recall_rep = true,
     bool recall_frame = true,
-    const char * sele = "all");
+    const char * sele = "all",
+    size_t stack = cMovieSceneStackDefault);
+
+bool MovieSceneDelete(PyMOLGlobals * G, const char * name,
+    size_t stack = cMovieSceneStackDefault);
 
 bool MovieSceneOrder(PyMOLGlobals * G, const char * names,
     bool sort = false,
diff -upNr pymol-open-source-2.3.0/layer3/PlugIOManager.cpp pymol-open-source-2.3.3/layer3/PlugIOManager.cpp
--- pymol-open-source-2.3.0/layer3/PlugIOManager.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer3/PlugIOManager.cpp	2019-08-22 10:24:47.742599599 +0200
@@ -105,7 +105,7 @@ int PlugIOManagerInitAll(PyMOLGlobals *
 int PlugIOManagerInit(PyMOLGlobals * G)
 {
   CPlugIOManager *I = NULL;
-  if((I = (G->PlugIOManager = Calloc(CPlugIOManager, 1)))) {
+  if((I = (G->PlugIOManager = pymol::calloc<CPlugIOManager>(1)))) {
     I->NPlugin = 0;
     I->PluginVLA = VLAlloc(molfile_plugin_t *, 10);
     return PlugIOManagerInitAll(G);
@@ -302,7 +302,7 @@ int PlugIOManagerLoadTraj(PyMOLGlobals *
         SceneCountFrames(G);
         if(zoom_flag)
           if(SettingGetGlobal_i(G, cSetting_auto_zoom)) {
-            ExecutiveWindowZoom(G, obj->Obj.Name, 0.0, -1, 0, 0, quiet);        /* auto zoom (all states) */
+            ExecutiveWindowZoom(G, obj->Name, 0.0, -1, 0, 0, quiet);        /* auto zoom (all states) */
           }
   }
   return true;
@@ -364,7 +364,7 @@ ObjectMap *PlugIOManagerLoadVol(PyMOLGlo
             continue;
           }
 
-          ok_assert(1, datablock = Alloc(float, size));
+          ok_assert(1, datablock = pymol::malloc<float>(size));
 
           if(plugin->read_volumetric_data(file_handle, i, datablock, NULL) != MOLFILE_SUCCESS) {
             PRINTFB(G, FB_ObjectMolecule, FB_Errors)
@@ -385,17 +385,17 @@ ObjectMap *PlugIOManagerLoadVol(PyMOLGlo
               obj->NState = state + 1;
             }
             ms = &obj->State[state];
-            ObjectMapStateInit(obj->Obj.G, ms);
+            ObjectMapStateInit(obj->G, ms);
 
             ms->FDim[0] = v->xsize;
             ms->FDim[1] = v->ysize;
             ms->FDim[2] = v->zsize;
             ms->FDim[3] = 3;
 
-            ms->Grid = Alloc(float, 3);
-            ms->Dim = Alloc(int, 3);
-            ms->Origin = Calloc(float, 3);
-            ms->Range = Alloc(float, 3);
+            ms->Grid = pymol::malloc<float>(3);
+            ms->Dim = pymol::malloc<int>(3);
+            ms->Origin = pymol::calloc<float>(3);
+            ms->Range = pymol::malloc<float>(3);
 
             // special case: orthogonal & cartesian-aligned
             // -> don't use State.Matrix which causes trouble for e.g. CCP4 export
@@ -413,7 +413,7 @@ ObjectMap *PlugIOManagerLoadVol(PyMOLGlo
               double m44d[16];
 
               if(!ms->State.Matrix)
-                ms->State.Matrix = Alloc(double, 16);
+                ms->State.Matrix = pymol::malloc<double>(16);
 
               // state matrix transformation
               identity44d(m44d);
@@ -576,7 +576,7 @@ ObjectMolecule *PlugIOManagerLoadMol(PyM
   }
 
   // read atoms
-  atoms = Calloc(molfile_atom_t, natoms);
+  atoms = pymol::calloc<molfile_atom_t>(natoms);
   if (plugin->read_structure(file_handle, &optflags, atoms) != MOLFILE_SUCCESS) {
     PRINTFB(G, FB_ObjectMolecule, FB_Errors)
       " ObjectMolecule: plugin '%s' failed to read atoms.\n", plugin_type ENDFB(G);
@@ -585,7 +585,7 @@ ObjectMolecule *PlugIOManagerLoadMol(PyM
 
   // Create ObjectMolecule
   ok_assert(1, I = ObjectMoleculeNew(G, false));
-  I->Obj.Color = AtomInfoUpdateAutoColor(G);
+  I->Color = AtomInfoUpdateAutoColor(G);
   VLASize(I->AtomInfo, AtomInfoType, natoms);
   I->NAtom = natoms;
 
diff -upNr pymol-open-source-2.3.0/layer3/Seeker.cpp pymol-open-source-2.3.3/layer3/Seeker.cpp
--- pymol-open-source-2.3.0/layer3/Seeker.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer3/Seeker.cpp	2019-08-22 10:24:47.742599599 +0200
@@ -426,7 +426,7 @@ static CSeqRow *SeekerClick(PyMOLGlobals
           SeekerSelectionCenter(G, 0);
         I->handler.box_active = true;
         if(col->state && (obj = ExecutiveFindObjectMoleculeByName(G, row->name))) {
-          SettingSetSmart_i(G, obj->Obj.Setting, NULL, cSetting_state, col->state);
+          SettingSetSmart_i(G, obj->Setting, NULL, cSetting_state, col->state);
           SceneChanged(G);
         }
       }
@@ -439,9 +439,9 @@ static CSeqRow *SeekerClick(PyMOLGlobals
         if(mod & cOrthoCTRL) {
           center = 2;
         }
-        int codes = SettingGet_i(G, row->obj->Obj.Setting, NULL, cSetting_seq_view_format);
+        int codes = SettingGet_i(G, row->obj->Setting, NULL, cSetting_seq_view_format);
         if(row->obj->DiscreteFlag && SettingGet_b(G,
-                                           row->obj->Obj.Setting,
+                                           row->obj->Setting,
                                            NULL, cSetting_seq_view_discrete_by_state))
           codes = 4;
         if (codes != 4 || row->obj->DiscreteFlag) { // keep only non-discrete states selectable
@@ -481,7 +481,7 @@ static CSeqRow *SeekerClick(PyMOLGlobals
           SeekerSelectionCenter(G, 2);
 
         if(col->state && (obj = ExecutiveFindObjectMoleculeByName(G, row->name))) {
-          SettingSetSmart_i(G, obj->Obj.Setting, NULL, cSetting_state, col->state);
+          SettingSetSmart_i(G, obj->Setting, NULL, cSetting_state, col->state);
           SceneChanged(G);
         }
       }
@@ -1045,8 +1045,8 @@ void SeekerUpdate(PyMOLGlobals * G)
   align_sele = ExecutiveGetActiveAlignmentSele(G);
 
   while(ExecutiveIterateObjectMolecule(G, &obj, &hidden)) {
-    if(obj->Obj.Enabled && (SettingGet_b(G, obj->Obj.Setting, NULL, cSetting_seq_view)) &&
-       (obj->Obj.Name[0] != '_')) {
+    if(obj->Enabled && (SettingGet_b(G, obj->Setting, NULL, cSetting_seq_view)) &&
+       (obj->Name[0] != '_')) {
       int a;
       AtomInfoType *last = NULL, *last_segi = NULL, *last_chain = NULL;
       CoordSet *last_disc = NULL;
@@ -1058,23 +1058,23 @@ void SeekerUpdate(PyMOLGlobals * G)
       int est_col = obj->NAtom / 5 + 1;
       int est_char = obj->NAtom * 4;
       int first_atom_in_label;
-      int missing_color = SettingGet_i(G, obj->Obj.Setting, NULL, cSetting_seq_view_fill_color);
+      int missing_color = SettingGet_i(G, obj->Setting, NULL, cSetting_seq_view_fill_color);
       CoordSet *cs = obj->DiscreteFlag ? NULL : ObjectMoleculeGetCoordSet(obj, std::max(0, obj->getState()));
       bool atom_in_state;
 
-      int gapMode = SettingGet_i(G, obj->Obj.Setting, nullptr, cSetting_seq_view_gap_mode);
+      int gapMode = SettingGet_i(G, obj->Setting, nullptr, cSetting_seq_view_gap_mode);
       int min_pad = -1;
       CSeqCol *r1 = NULL, *l1 = NULL;   /* *col */
 
       if(nRow >= max_row)
         break;
 
-      codes = SettingGet_i(G, obj->Obj.Setting, NULL, cSetting_seq_view_format);
+      codes = SettingGet_i(G, obj->Setting, NULL, cSetting_seq_view_format);
       if(obj->DiscreteFlag && SettingGet_b(G,
-                                           obj->Obj.Setting,
+                                           obj->Setting,
                                            NULL, cSetting_seq_view_discrete_by_state))
         codes = 4;
-      default_color = SettingGet_i(G, obj->Obj.Setting, NULL, cSetting_seq_view_color);
+      default_color = SettingGet_i(G, obj->Setting, NULL, cSetting_seq_view_color);
 
       /* allocate a row for labels, if present
          the text for the labels and the residues will line up exactly 
@@ -1102,8 +1102,8 @@ void SeekerUpdate(PyMOLGlobals * G)
       row->atom_lists[0] = -1;  /* terminate the blank listQ (IMPORTANT!) */
       row->char2col = VLACalloc(int, est_char);
       row->obj = obj;
-      strcpy(row->name, obj->Obj.Name);
-      row->color = obj->Obj.Color;
+      strcpy(row->name, obj->Name);
+      row->color = obj->Color;
       ai = obj->AtomInfo;
 
       /* copy object name onto label row */
@@ -1117,7 +1117,7 @@ void SeekerUpdate(PyMOLGlobals * G)
         l1 = lab->col + nCol;
         l1->start = lab->len;
         UtilConcatVLA(&lab->txt, &lab->len, "/");
-        UtilConcatVLA(&lab->txt, &lab->len, obj->Obj.Name);
+        UtilConcatVLA(&lab->txt, &lab->len, obj->Name);
         l1->stop = lab->len;
         st_len = l1->stop - l1->start;
 
@@ -1140,7 +1140,7 @@ void SeekerUpdate(PyMOLGlobals * G)
         r1 = row->col + nCol;
         r1->start = row->len;
         UtilConcatVLA(&row->txt, &row->len, "/");
-        UtilConcatVLA(&row->txt, &row->len, obj->Obj.Name);
+        UtilConcatVLA(&row->txt, &row->len, obj->Name);
         r1->stop = row->len;
         r1->spacer = true;
         row->column_label_flag = true;
@@ -1483,7 +1483,7 @@ void SeekerUpdate(PyMOLGlobals * G)
             if((cs = obj->DiscreteCSet[a]) != last_disc) {
               last_disc = cs;
               if(cs) {
-                default_color = SettingGet_i(G, cs->Setting, obj->Obj.Setting,
+                default_color = SettingGet_i(G, cs->Setting, obj->Setting,
                                              cSetting_seq_view_color);
                 VLACheck(row->col, CSeqCol, nCol);
                 r1 = row->col + nCol;
@@ -1515,7 +1515,7 @@ void SeekerUpdate(PyMOLGlobals * G)
               for(b = 0; b < obj->NCSet; b++) {
                 cs = obj->CSet[b];
                 if(cs) {
-                  default_color = SettingGet_i(G, cs->Setting, obj->Obj.Setting,
+                  default_color = SettingGet_i(G, cs->Setting, obj->Setting,
                                                cSetting_seq_view_color);
 
                   VLACheck(row->col, CSeqCol, nCol);
@@ -1897,8 +1897,8 @@ void SeekerUpdate(PyMOLGlobals * G)
         row = lab + 1;
         nCol = row->nCol;
         obj = row->obj;
-        div = SettingGet_i(G, obj->Obj.Setting, NULL, cSetting_seq_view_label_spacing);
-        sub = SettingGet_i(G, obj->Obj.Setting, NULL, cSetting_seq_view_label_start);
+        div = SettingGet_i(G, obj->Setting, NULL, cSetting_seq_view_label_spacing);
+        sub = SettingGet_i(G, obj->Setting, NULL, cSetting_seq_view_label_start);
 
         for(b = 0; b < nCol; b++) {
           CSeqCol *r1 = row->col + b;
@@ -2013,7 +2013,7 @@ void SeekerUpdate(PyMOLGlobals * G)
 int SeekerInit(PyMOLGlobals * G)
 {
   CSeeker *I = NULL;
-  if((I = (G->Seeker = Calloc(CSeeker, 1)))) {
+  if((I = (G->Seeker = pymol::calloc<CSeeker>(1)))) {
 
     UtilZeroMem(I, sizeof(CSeeker));
     I->drag_row = -1;
diff -upNr pymol-open-source-2.3.0/layer3/Selector.cpp pymol-open-source-2.3.3/layer3/Selector.cpp
--- pymol-open-source-2.3.0/layer3/Selector.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer3/Selector.cpp	2019-08-22 12:53:42.844979968 +0200
@@ -14,6 +14,8 @@ I* Additional authors of this source fil
 Z* -------------------------------------------------------------------
 */
 
+#include <algorithm>
+#include <string>
 #include <vector>
 
 #include"os_python.h"
@@ -65,37 +67,6 @@ Z* -------------------------------------
 /* special selections, unknown to executive */
 #define cColorectionFormat "_!c_%s_%d"
 
-#if 0
-// A lot of PyMOL's utility code used to select with lower case atomic
-// identifiers, making the code dependent on "ignore_case=1". The default
-// for this setting was changed to "0 (off)", which required to fix all
-// affected scripts (e.g. mutagenesis wizard, PYMOL-2487).
-// This is a debug/helper function to identify use of lower case
-// identifiers in selection expressions. Remove before the next official
-// release.
-void WARN_IF_LOWERCASE(PyMOLGlobals * G, const char * label, const char * text) {
-  if (!*text)
-    return;
-  for (const char * p = text; *p; ++p)
-    if (isupper(*p))
-      return;
-  PRINTFB(G, FB_Selector, FB_Warnings)
-    "SELECTOR-LOWER-WARNING: %s '%s'\n", label, text
-    ENDFB(G);
-}
-#else
-#define WARN_IF_LOWERCASE(G, a, b)
-#endif
-
-// Count how often `c` occurs in `s`
-static int strchrcount(const char *s, char c) {
-  int i = 0;
-  while(*s)
-    if(*(s++) == c)
-      i++;
-  return i;
-}
-
 static WordKeyValue rep_names[] = {
   {"spheres", cRepSphereBit},
   {"sticks", cRepCylBit},
@@ -125,13 +96,32 @@ static const char *backbone_names[] = {
   ""
 };
 
-typedef struct {
+/// Helper type which replaces `int*` return types
+typedef std::unique_ptr<int[]> sele_array_t;
+inline void sele_array_calloc(sele_array_t& sele, size_t count)
+{
+  sele.reset(new int[count]());
+}
+
+struct EvalElem {
   int level, imp_op_level;
   int type;                     /* 0 = value 1 = operation 2 = pre-operation */
   unsigned int code;
-  SelectorWordType text;
-  int *sele;
-} EvalElem;
+  std::string m_text;
+  sele_array_t sele;
+
+  // Helpers for refactoring `sele` type
+  int* sele_data() { return sele.get(); }
+  void sele_free() { sele.reset(); }
+  void sele_calloc(size_t count) { sele_array_calloc(sele, count); }
+
+  // TODO replace with pymol::Error handling
+  void sele_check_ok(int& ok) { CHECKOK(ok, sele_data()); }
+  void sele_err_chk_ptr(PyMOLGlobals* G) { ErrChkPtr(G, sele_data()); }
+
+  /// read-only access to text
+  const char* text() const { return m_text.c_str(); }
+};
 
 typedef struct {
   int depth1;
@@ -142,12 +132,10 @@ typedef struct {
   int frag;
 } WalkDepthRec;
 
-static int *SelectorSelect(PyMOLGlobals * G, const char *sele, int state, int domain, int quiet);
+static sele_array_t SelectorSelect(PyMOLGlobals * G, const char *sele, int state, int domain, int quiet);
 static int SelectorGetInterstateVLA(PyMOLGlobals * G, int sele1, int state1, int sele2,
                                     int state2, float cutoff, int **vla);
 
-static int SelectorGetArrayNCSet(PyMOLGlobals * G, int *array, int no_dummies);
-
 static int SelectorModulate1(PyMOLGlobals * G, EvalElem * base, int state);
 static int SelectorSelect0(PyMOLGlobals * G, EvalElem * base);
 static int SelectorSelect1(PyMOLGlobals * G, EvalElem * base, int quiet);
@@ -155,20 +143,19 @@ static int SelectorSelect2(PyMOLGlobals
 static int SelectorLogic1(PyMOLGlobals * G, EvalElem * base, int state);
 static int SelectorLogic2(PyMOLGlobals * G, EvalElem * base);
 static int SelectorOperator22(PyMOLGlobals * G, EvalElem * base, int state);
-static int *SelectorEvaluate(PyMOLGlobals * G, SelectorWordType * word, int state, int quiet);
-static SelectorWordType *SelectorParse(PyMOLGlobals * G, const char *s);
+static sele_array_t SelectorEvaluate(PyMOLGlobals* G, std::vector<std::string>& word, int state, int quiet);
+static std::vector<std::string> SelectorParse(PyMOLGlobals * G, const char *s);
 static void SelectorPurgeMembers(PyMOLGlobals * G, int sele);
-static int SelectorEmbedSelection(PyMOLGlobals * G, int *atom, const char *name,
+static int SelectorEmbedSelection(PyMOLGlobals * G, const int *atom, const char *name,
                                   ObjectMolecule * obj, int no_dummies, int exec_manage);
 static int *SelectorGetIndexVLA(PyMOLGlobals * G, int sele);
 static int *SelectorGetIndexVLAImpl(PyMOLGlobals * G, CSelector *I, int sele);
 static void SelectorClean(PyMOLGlobals * G);
 static void SelectorCleanImpl(PyMOLGlobals * G, CSelector *I);
-static int *SelectorApplyMultipick(PyMOLGlobals * G, Multipick * mp);
 static int SelectorCheckNeighbors(PyMOLGlobals * G, int maxDepth, ObjectMolecule * obj,
                                   int at1, int at2, int *zero, int *scratch);
 
-static int *SelectorUpdateTableSingleObject(PyMOLGlobals * G, ObjectMolecule * obj,
+static sele_array_t SelectorUpdateTableSingleObject(PyMOLGlobals * G, ObjectMolecule * obj,
                                             int req_state,
                                             int no_dummies, int *idx,
                                             int n_idx, int numbered_tags);
@@ -670,6 +657,8 @@ static WordKeyValue Keyword[] = {
   {"sidechain", SELE_SC_z},
   {"sc.", SELE_SC_z},
 
+  {"p.", SELE_PROP},
+
   {"x", SELE_XVLx},
   {"y", SELE_YVLx},
   {"z", SELE_ZVLx},
@@ -718,7 +707,7 @@ int SelectorRenameObjectAtoms(PyMOLGloba
     SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
   }
   if(obj_nAtom) {
-    int *flag = Calloc(int, obj_nAtom);
+    int *flag = pymol::calloc<int>(obj_nAtom);
     if(!flag) {
       result = -1;
     } else {
@@ -752,9 +741,9 @@ int SelectorResidueVLAsTo3DMatchScores(P
   CSelector *I = G->Selector;
   int a, b, *vla;
   int n_max = (n1 > n2) ? n1 : n2;
-  float *inter1 = Calloc(float, cINTER_ENTRIES * n1);
-  float *inter2 = Calloc(float, cINTER_ENTRIES * n2);
-  float *v_ca = Calloc(float, 3 * n_max);
+  float *inter1 = pymol::calloc<float>(cINTER_ENTRIES * n1);
+  float *inter2 = pymol::calloc<float>(cINTER_ENTRIES * n2);
+  float *v_ca = pymol::calloc<float>(3 * n_max);
   if(inter1 && inter2 && v_ca) {
     int pass;
 
@@ -1061,7 +1050,7 @@ static int SelectorIsSelectionDiscrete(P
   return (result);
 }
 
-static int *SelectorUpdateTableMultiObjectIdxTag(PyMOLGlobals * G,
+static sele_array_t SelectorUpdateTableMultiObjectIdxTag(PyMOLGlobals * G,
                                                  ObjectMolecule ** obj_list,
                                                  int no_dummies,
                                                  int **idx_list, int *n_idx_list,
@@ -1071,7 +1060,7 @@ static int *SelectorUpdateTableMultiObje
   int b;
   int c = 0;
   int modelCnt;
-  int *result = NULL;
+  sele_array_t result{};
   CSelector *I = G->Selector;
   ObjectMolecule *obj = NULL;
   int *idx, n_idx;
@@ -1097,10 +1086,10 @@ static int *SelectorUpdateTableMultiObje
       I->NCSet = obj->NCSet;
     modelCnt++;
   }
-  result = Calloc(int, c);
-  I->Table = Calloc(TableRec, c);
+  sele_array_calloc(result, c);
+  I->Table = pymol::calloc<TableRec>(c);
   ErrChkPtr(G, I->Table);
-  I->Obj = Calloc(ObjectMolecule *, modelCnt);
+  I->Obj = pymol::calloc<ObjectMolecule *>(modelCnt);
   ErrChkPtr(G, I->Obj);
   if(no_dummies) {
     modelCnt = 0;
@@ -1136,11 +1125,11 @@ static int *SelectorUpdateTableMultiObje
     I->NModel = modelCnt;
   }
   I->NAtom = c;
-  I->Flag1 = Alloc(int, c);
+  I->Flag1 = pymol::malloc<int>(c);
   ErrChkPtr(G, I->Flag1);
-  I->Flag2 = Alloc(int, c);
+  I->Flag2 = pymol::malloc<int>(c);
   ErrChkPtr(G, I->Flag2);
-  I->Vertex = Alloc(float, c * 3);
+  I->Vertex = pymol::malloc<float>(c * 3);
   ErrChkPtr(G, I->Vertex);
 
   PRINTFD(G, FB_Selector)
@@ -1499,8 +1488,8 @@ void SelectorComputeFragPos(PyMOLGlobals
   int *cnt;
   SelectorUpdateTableSingleObject(G, obj, cSelectorUpdateTableAllStates, true, NULL, 0,
                                   false);
-  sele = Alloc(int, n_frag);
-  cnt = Calloc(int, n_frag);
+  sele = pymol::malloc<int>(n_frag);
+  cnt = pymol::calloc<int>(n_frag);
   VLACheck(*vla, float, n_frag * 3 + 2);
   {
     int a;
@@ -1684,7 +1673,7 @@ void SelectorSelectByID(PyMOLGlobals * G
 
   SelectorUpdateTableSingleObject(G, obj, cSelectorUpdateTableAllStates, true, NULL, 0,
                                   false);
-  atom = Calloc(int, I->NAtom);
+  atom = pymol::calloc<int>(I->NAtom);
   if(I->NAtom) {
 
     /* determine range */
@@ -1709,7 +1698,7 @@ void SelectorSelectByID(PyMOLGlobals * G
       int a, offset;
 
       range = max_id - min_id + 1;
-      lookup = Calloc(int, range);
+      lookup = pymol::calloc<int>(range);
       for(a = 0; a < obj->NAtom; a++) {
         offset = obj->AtomInfo[a].id - min_id;
         if(lookup[offset])
@@ -1763,7 +1752,7 @@ void SelectorDefragment(PyMOLGlobals * G
     m = I->Member[m].next;
   }
   if(n_free) {
-    list = Alloc(int, n_free);
+    list = pymol::malloc<int>(n_free);
     l = list;
     m = I->FreeMember;
     while(m) {
@@ -2030,7 +2019,7 @@ int SelectorAssignSS(PyMOLGlobals * G, i
                 if(!quiet) {
                   PRINTFB(G, FB_Selector, FB_Warnings)
                     " AssignSS-Warning: Ignoring incomplete residue /%s/%s/%s/%d%c ...\n",
-                    obj->Obj.Name, LexStr(G, ai->segi), LexStr(G, ai->chain), ai->resv, ai->getInscode(true) ENDFB(G);
+                    obj->Name, LexStr(G, ai->segi), LexStr(G, ai->chain), ai->resv, ai->getInscode(true) ENDFB(G);
                 }
               }
             }
@@ -2192,8 +2181,8 @@ int SelectorAssignSS(PyMOLGlobals * G, i
             lastObj = obj;
           }
         }
-        zero = Calloc(int, max_n_atom);
-        scratch = Alloc(int, max_n_atom);
+        zero = pymol::calloc<int>(max_n_atom);
+        scratch = pymol::malloc<int>(max_n_atom);
       }
 
       for(a = 0; a < n_res; a++) {
@@ -2356,7 +2345,7 @@ int SelectorAssignSS(PyMOLGlobals * G, i
         MapFree(map);
 	if (too_many_atoms){
 	  PRINTFB(G, FB_Selector, FB_Errors)
-	    " SelectorAssignSS: ERROR: Unreasonable number of neighbors for dss, cannot assign secondary structure.\n" ENDFB(G);
+	    " %s: ERROR: Unreasonable number of neighbors for dss, cannot assign secondary structure.\n", __func__ ENDFB(G);
 	}
       }
       FreeP(zero);
@@ -3344,7 +3333,7 @@ PyObject *SelectorAsPyList(PyMOLGlobals
         PyList_SetItem(tag_pyobj, b, PyInt_FromLong(vla_list[a][b].tag));
       }
       VLAFreeP(vla_list[a]);
-      PyList_SetItem(obj_pyobj, 0, PyString_FromString(obj_list[a]->Obj.Name));
+      PyList_SetItem(obj_pyobj, 0, PyString_FromString(obj_list[a]->Name));
       PyList_SetItem(obj_pyobj, 1, idx_pyobj);
       PyList_SetItem(obj_pyobj, 2, tag_pyobj);
       PyList_SetItem(result, a, obj_pyobj);
@@ -3512,7 +3501,7 @@ int SelectorVdwFit(PyMOLGlobals * G, int
   c =
     SelectorGetInterstateVLA(G, sele1, state1, sele2, state2, 2 * MAX_VDW + buffer, &vla);
   if(c) {
-    adj = Calloc(float, 2 * c);
+    adj = pymol::calloc<float>(2 * c);
     for(a = 0; a < c; a++) {
       a1 = vla[a * 2];
       a2 = vla[a * 2 + 1];
@@ -3710,15 +3699,15 @@ int SelectorCreateAlignments(PyMOLGlobal
   ObjectMolecule *obj1, *obj2;
   int cmp;
   PRINTFD(G, FB_Selector)
-    " SelectorCreateAlignments-DEBUG: entry.\n" ENDFD cnt = 0;
+    " %s-DEBUG: entry.\n", __func__ ENDFD cnt = 0;
   /* number of pairs of atoms */
   np = VLAGetSize(pair) / 2;
   if(np) {
 
     SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);  /* unnecessary? */
     /* flags initialized to false */
-    flag1 = Calloc(int, I->NAtom);
-    flag2 = Calloc(int, I->NAtom);
+    flag1 = pymol::calloc<int>(I->NAtom);
+    flag2 = pymol::calloc<int>(I->NAtom);
 
     /* we need to create two selection arrays: for the matched 
      * atoms in the original selections */
@@ -3809,7 +3798,7 @@ int SelectorCreateAlignments(PyMOLGlobal
     FreeP(flag2);
   }
   PRINTFD(G, FB_Selector)
-    " SelectorCreateAlignments-DEBUG: exit, cnt = %d.\n", cnt ENDFD return cnt;
+    " %s-DEBUG: exit, cnt = %d.\n", __func__, cnt ENDFD return cnt;
 }
 
 
@@ -3830,8 +3819,8 @@ int SelectorCountStates(PyMOLGlobals * G
       if(obj != last) {
         at1 = I->Table[a].atom;
         if(SelectorIsMember(G, obj->AtomInfo[at1].selEntry, sele)) {
-          if(obj->Obj.fGetNFrame) {
-            n_frame = obj->Obj.fGetNFrame((CObject *) obj);
+          if(obj->fGetNFrame) {
+            n_frame = obj->fGetNFrame((CObject *) obj);
             if(result < n_frame)
               result = n_frame;
           }
@@ -3930,7 +3919,7 @@ int *SelectorGetResidueVLA(PyMOLGlobals
 
   r = result;
   PRINTFD(G, FB_Selector)
-    " SelectorGetResidueVLA-DEBUG: entry, sele = %d\n", sele ENDFD;
+    " %s-DEBUG: entry, sele = %d\n", __func__, sele ENDFD;
 
   for(SeleAtomIterator iter(G, sele); iter.next();) {
     if(iter.obj == exclude)
@@ -3962,7 +3951,7 @@ int *SelectorGetResidueVLA(PyMOLGlobals
     VLASize(result, int, (ov_size) (r - result));
   }
   PRINTFD(G, FB_Selector)
-    " SelectorGetResidueVLA-DEBUG: exit, result = %p, size = %d\n",
+    " %s-DEBUG: exit, result = %p, size = %d\n", __func__,
     (void *) result, (unsigned int) VLAGetSize(result)
     ENDFD;
 
@@ -4001,9 +3990,9 @@ static int *SelectorGetIndexVLAImpl(PyMO
 /*========================================================================*/
 void SelectorUpdateObjectSele(PyMOLGlobals * G, ObjectMolecule * obj)
 {
-  if(obj->Obj.Name[0]) {
-    SelectorDelete(G, obj->Obj.Name);
-    SelectorCreate(G, obj->Obj.Name, NULL, obj, true, NULL);    
+  if(obj->Name[0]) {
+    SelectorDelete(G, obj->Name);
+    SelectorCreate(G, obj->Name, NULL, obj, true, NULL);    
     /* create a selection with same name */
     if(SettingGetGlobal_b(G, cSetting_auto_classify_atoms))
     {
@@ -4080,7 +4069,7 @@ void SelectorLogSele(PyMOLGlobals * G, c
           if(robust)
             ObjectMoleculeGetAtomSeleFast(obj, at1, buf1);
           else
-            sprintf(buf1, "%s`%d", obj->Obj.Name, at1 + 1);
+            sprintf(buf1, "%s`%d", obj->Name, at1 + 1);
           strcat(line, buf1);
           append = 1;
           cnt++;
@@ -4687,10 +4676,10 @@ int SelectorSubdivide(PyMOLGlobals * G,
 
     SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
 
-    comp = Calloc(int, I->NAtom);
-    atom = Alloc(int, I->NAtom);
-    toDo = Alloc(int, I->NAtom);
-    pkset = Calloc(int, I->NAtom);
+    comp = pymol::calloc<int>(I->NAtom);
+    atom = pymol::malloc<int>(I->NAtom);
+    toDo = pymol::malloc<int>(I->NAtom);
+    pkset = pymol::calloc<int>(I->NAtom);
 
     /* NOTE: SeleBase only safe with cSelectorUpdateTableAllStates!  */
 
@@ -5113,8 +5102,10 @@ int SelectorGetSeleNCSet(PyMOLGlobals *
 
 
 /*========================================================================*/
-int SelectorGetArrayNCSet(PyMOLGlobals * G, int *array, int no_dummies)
+static int SelectorGetArrayNCSet(
+    PyMOLGlobals* G, const sele_array_t& uptr, int no_dummies)
 {
+  const int* array = uptr.get();
   CSelector *I = G->Selector;
   int a;
   ObjectMolecule *obj;
@@ -5708,11 +5699,11 @@ int SelectorMapGaussian(PyMOLGlobals * G
       }
     }
   }
-  point = Alloc(float, 3 * n1);
-  sfidx = Alloc(int, n1);
-  b_factor = Alloc(float, n1);
-  occup = Alloc(float, n1);
-  atom_sf = Alloc(AtomSF, n1);
+  point = pymol::malloc<float>(3 * n1);
+  sfidx = pymol::malloc<int>(n1);
+  b_factor = pymol::malloc<float>(n1);
+  occup = pymol::malloc<float>(n1);
+  atom_sf = pymol::malloc<AtomSF>(n1);
 
   if(!quiet) {
     PRINTFB(G, FB_ObjectMap, FB_Details)
@@ -6010,7 +6001,7 @@ int SelectorMapCoulomb(PyMOLGlobals * G,
   }
 
   PRINTFB(G, FB_Selector, FB_Details)
-    " SelectorMapCoulomb: Total charge is %0.3f for %d points (%d atoms).\n", tot_charge,
+    " %s: Total charge is %0.3f for %d points (%d atoms).\n", __func__, tot_charge,
     n_point, n_at ENDFB(G);
 
   if(neutral && (fabs(tot_charge) > R_SMALL4)) {
@@ -6023,7 +6014,7 @@ int SelectorMapCoulomb(PyMOLGlobals * G,
     }
 
     PRINTFB(G, FB_Selector, FB_Details)
-      " SelectorMapCoulomb: Setting net charge to zero...\n" ENDFB(G);
+      " %s: Setting net charge to zero...\n", __func__ ENDFB(G);
 
   }
 
@@ -6043,11 +6034,11 @@ int SelectorMapCoulomb(PyMOLGlobals * G,
     if(cutoff > 0.0F) {         /* we are using a cutoff */
       if(shift) {
         PRINTFB(G, FB_Selector, FB_Details)
-          " SelectorMapCoulomb: Evaluating local Coulomb potential for grid (shift=%0.2f)...\n",
+          " %s: Evaluating local Coulomb potential for grid (shift=%0.2f)...\n", __func__,
           cutoff ENDFB(G);
       } else {
         PRINTFB(G, FB_Selector, FB_Details)
-          " SelectorMapCoulomb: Evaluating Coulomb potential for grid (cutoff=%0.2f)...\n",
+          " %s: Evaluating Coulomb potential for grid (cutoff=%0.2f)...\n", __func__,
           cutoff ENDFB(G);
       }
 
@@ -6123,7 +6114,7 @@ int SelectorMapCoulomb(PyMOLGlobals * G,
     } else {
       float *v1;
       PRINTFB(G, FB_Selector, FB_Details)
-        " SelectorMapCoulomb: Evaluating Coulomb potential for grid (no cutoff)...\n"
+        " %s: Evaluating Coulomb potential for grid (no cutoff)...\n", __func__
         ENDFB(G);
 
       for(a = min[0]; a <= max[0]; a++) {
@@ -6263,7 +6254,7 @@ PyObject *SelectorGetCoordsAsNumPy(PyMOL
 
     if(mat_cs != iter.cs) {
       /* compute the effective matrix for output coordinates */
-      matrix_ptr = ObjectGetTotalMatrix(&iter.obj->Obj, state, false, matrix) ? matrix : NULL;
+      matrix_ptr = ObjectGetTotalMatrix(iter.obj, state, false, matrix) ? matrix : NULL;
       mat_cs = iter.cs;
     }
 
@@ -6379,7 +6370,7 @@ int SelectorLoadCoords(PyMOLGlobals * G,
     // coord set specific stuff
     if(mat_cs != iter.cs) {
       // update matrix
-      matrix_ptr = ObjectGetTotalMatrix(&iter.obj->Obj, state, false, matrix) ? matrix : NULL;
+      matrix_ptr = ObjectGetTotalMatrix(iter.obj, state, false, matrix) ? matrix : NULL;
       mat_cs = iter.cs;
 
       // invalidate reps
@@ -6428,7 +6419,7 @@ void SelectorUpdateCmd(PyMOLGlobals * G,
   bool ignore_case_chain = SettingGetGlobal_b(G, cSetting_ignore_case_chain);
 
   PRINTFD(G, FB_Selector)
-    " SelectorUpdateCmd-Debug: entered sta0 %d sta1 %d", sta0, sta1 ENDFD;
+    " %s-Debug: entered sta0 %d sta1 %d", __func__, sta0, sta1 ENDFD;
 
   // either both or none must be "all states"
   if (sta0 != sta1) {
@@ -6584,8 +6575,8 @@ void SelectorUpdateCmd(PyMOLGlobals * G,
       if(matched_flag) {        /* atom matched, so copy coordinates */
         ccc++;
 
-        StateIterator iter0(G, obj0->Obj.Setting, sta0, obj0->NCSet);
-        StateIterator iter1(G, obj1->Obj.Setting, sta1, obj1->NCSet);
+        StateIterator iter0(G, obj0->Setting, sta0, obj0->NCSet);
+        StateIterator iter1(G, obj1->Setting, sta1, obj1->NCSet);
 
         while (iter0.next() && iter1.next()) {
           cs0 = obj0->CSet[iter0.state];
@@ -6678,7 +6669,7 @@ int SelectorCreateObjectMolecule(PyMOLGl
         }
       }
       if(singleObj)
-        targ->Obj.Color = singleObj->Obj.Color;
+        targ->Color = singleObj->Color;
       /* should also consider copying lots of other stuff from the source object ... */
     }
   } else {
@@ -6947,7 +6938,7 @@ static void SelectorPurgeMembers(PyMOLGl
     int I_FreeMember = I->FreeMember;
 
     while(ExecutiveIterateObjectMolecule(G, &obj, &iterator)) {
-      if(obj->Obj.type == cObjectMolecule) {
+      if(obj->type == cObjectMolecule) {
         AtomInfoType *ai = obj->AtomInfo;
         int a, n_atom = obj->NAtom;
         for(a = 0; a < n_atom; a++) {
@@ -7050,7 +7041,7 @@ int SelectorGetTmp2(PyMOLGlobals * G, co
   /* ASSUMES that store is at least as big as an OrthoLineType */
   CSelector *I = G->Selector;
   PRINTFD(G, FB_Selector)
-    " SelectorGetTmp-Debug: entered with \"%s\".\n", input ENDFD;
+    " %s-Debug: entered with \"%s\".\n", __func__, input ENDFD;
 
   store[0] = 0;
 
@@ -7134,7 +7125,7 @@ int SelectorGetTmp2(PyMOLGlobals * G, co
     }
   }
   PRINTFD(G, FB_Selector)
-    " SelectorGetTmp-Debug: leaving with \"%s\".\n", store ENDFD;
+    " %s-Debug: leaving with \"%s\".\n", __func__, store ENDFD;
   return count;
 
 }
@@ -7194,7 +7185,7 @@ void SelectorFreeTmp(PyMOLGlobals * G, c
 
 
 /*========================================================================*/
-static int SelectorEmbedSelection(PyMOLGlobals * G, int *atom, const char *name,
+static int SelectorEmbedSelection(PyMOLGlobals * G, const int *atom, const char *name,
                                   ObjectMolecule * obj, int no_dummies, int exec_managed)
 {
   /* either atom or obj should be NULL, not both and not neither */
@@ -7330,19 +7321,17 @@ static int SelectorEmbedSelection(PyMOLG
 
 
 /*========================================================================*/
-static int *SelectorApplyMultipick(PyMOLGlobals * G, Multipick * mp)
+static sele_array_t SelectorApplyMultipick(PyMOLGlobals * G, Multipick * mp)
 {
   CSelector *I = G->Selector;
-  int *result;
-  int a, n;
+  sele_array_t result;
+  int n;
   Picking *p;
   ObjectMolecule *obj;
   SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
-  result = Alloc(int, I->NAtom);
+  sele_array_calloc(result, I->NAtom);
   n = mp->picked[0].src.index;
   p = mp->picked + 1;
-  for(a = 0; a < I->NAtom; a++)
-    result[a] = 0;
   while(n--) {                  /* what if this object isn't a molecule object?? */
     obj = (ObjectMolecule *) p->context.object;
     /* NOTE: SeleBase only safe with cSelectorUpdateTableAllStates!  */
@@ -7354,10 +7343,10 @@ static int *SelectorApplyMultipick(PyMOL
 
 
 /*========================================================================*/
-static int *SelectorSelectFromTagDict(PyMOLGlobals * G, OVOneToAny * id2tag)
+static sele_array_t SelectorSelectFromTagDict(PyMOLGlobals * G, OVOneToAny * id2tag)
 {
   CSelector *I = G->Selector;
-  int *result = NULL;
+  sele_array_t result{};
   int a;
   AtomInfoType *ai;
   OVreturn_word ret;
@@ -7367,7 +7356,7 @@ static int *SelectorSelectFromTagDict(Py
     TableRec *i_table = I->Table, *table_a;
     ObjectMolecule **i_obj = I->Obj;
 
-    result = Calloc(int, I->NAtom);
+    sele_array_calloc(result, I->NAtom);
     if(result) {
       table_a = i_table + cNDummyAtoms;
       for(a = cNDummyAtoms; a < I->NAtom; a++) {
@@ -7392,7 +7381,7 @@ static int _SelectorCreate(PyMOLGlobals
                            int n_obj, OVOneToAny * id2tag, int executive_manage,
                            int state, int domain)
 {
-  int *atom = NULL;
+  sele_array_t atom{};
   OrthoLineType name;
   int ok = true;
   int c = 0;
@@ -7449,8 +7438,8 @@ static int _SelectorCreate(PyMOLGlobals
       ok = false;
   }
   if(ok)
-    c = SelectorEmbedSelection(G, atom, name, embed_obj, false, executive_manage);
-  FreeP(atom);
+    c = SelectorEmbedSelection(G, atom.get(), name, embed_obj, false, executive_manage);
+  atom.reset();
   SelectorClean(G);
   /* ignore reporting on quiet */
   if(!quiet) {
@@ -7464,10 +7453,10 @@ static int _SelectorCreate(PyMOLGlobals
   }
   if(ok) {
     PRINTFD(G, FB_Selector)
-      " SelectorCreate: \"%s\" created with %d atoms.\n", name, c ENDFD;
+      " %s: \"%s\" created with %d atoms.\n", __func__, name, c ENDFD;
   } else {
     PRINTFD(G, FB_Selector)
-      " SelectorCreate: \"%s\" not created due to error\n", name ENDFD;
+      " %s: \"%s\" not created due to error\n", __func__, name ENDFD;
   }
   if(!ok)
     c = -1;
@@ -7575,7 +7564,7 @@ static void SelectorCleanImpl(PyMOLGloba
 
 
 /*========================================================================*/
-static int *SelectorUpdateTableSingleObject(PyMOLGlobals * G, ObjectMolecule * obj,
+static sele_array_t SelectorUpdateTableSingleObject(PyMOLGlobals * G, ObjectMolecule * obj,
                                             int req_state,
                                             int no_dummies, int *idx,
                                             int n_idx, int numbered_tags)
@@ -7583,13 +7572,13 @@ static int *SelectorUpdateTableSingleObj
   int a = 0;
   int c = 0;
   int modelCnt;
-  int *result = NULL;
+  sele_array_t result{};
   int tag = true;
   int state = req_state;
   CSelector *I = G->Selector;
 
   PRINTFD(G, FB_Selector)
-    "SelectorUpdateTableSingleObject-Debug: entered for %s...\n", obj->Obj.Name ENDFD;
+    "SelectorUpdateTableSingleObject-Debug: entered for %s...\n", obj->Name ENDFD;
 
   SelectorClean(G);
 
@@ -7598,7 +7587,7 @@ static int *SelectorUpdateTableSingleObj
     state = req_state;
     break;
   case cSelectorUpdateTableEffectiveStates:
-    state = ObjectGetCurrentState(&obj->Obj, true);
+    state = ObjectGetCurrentState(obj, true);
     break;
   case cSelectorUpdateTableCurrentState:
     state = SceneGetState(G);
@@ -7630,9 +7619,9 @@ static int *SelectorUpdateTableSingleObj
   if(I->NCSet < obj->NCSet)
     I->NCSet = obj->NCSet;
   modelCnt++;
-  I->Table = Calloc(TableRec, c);
+  I->Table = pymol::calloc<TableRec>(c);
   ErrChkPtr(G, I->Table);
-  I->Obj = Calloc(ObjectMolecule *, modelCnt);
+  I->Obj = pymol::calloc<ObjectMolecule *>(modelCnt);
   ErrChkPtr(G, I->Obj);
   if(no_dummies) {
     modelCnt = 0;
@@ -7669,7 +7658,7 @@ static int *SelectorUpdateTableSingleObj
   }
 
   if(idx && n_idx) {
-    result = Calloc(int, c);
+    sele_array_calloc(result, c);
     if(n_idx > 0) {
       for(a = 0; a < n_idx; a++) {
         int at = idx[a];
@@ -7698,11 +7687,11 @@ static int *SelectorUpdateTableSingleObj
   modelCnt++;
   I->NModel = modelCnt;
   I->NAtom = c;
-  I->Flag1 = Alloc(int, c);
+  I->Flag1 = pymol::malloc<int>(c);
   ErrChkPtr(G, I->Flag1);
-  I->Flag2 = Alloc(int, c);
+  I->Flag2 = pymol::malloc<int>(c);
   ErrChkPtr(G, I->Flag2);
-  I->Vertex = Alloc(float, c * 3);
+  I->Vertex = pymol::malloc<float>(c * 3);
   ErrChkPtr(G, I->Vertex);
 
   PRINTFD(G, FB_Selector)
@@ -7748,9 +7737,9 @@ int SelectorUpdateTableImpl(PyMOLGlobals
     modelCnt++;
   }
   /* allocate space for each atom, in the record table */
-  I->Table = Calloc(TableRec, c);
+  I->Table = pymol::calloc<TableRec>(c);
   ErrChkPtr(G, I->Table);
-  I->Obj = Calloc(ObjectMolecule *, modelCnt);
+  I->Obj = pymol::calloc<ObjectMolecule *>(modelCnt);
   ErrChkPtr(G, I->Obj);
 
   switch (req_state) {
@@ -7806,7 +7795,7 @@ int SelectorUpdateTableImpl(PyMOLGlobals
         state = SettingGetGlobal_i(G, cSetting_state) - 1;
         break;
       case cSelectorUpdateTableEffectiveStates:
-        state = ObjectGetCurrentState(&obj->Obj, true);
+        state = ObjectGetCurrentState(obj, true);
         break;
       default:                 /* unknown input -- fail safe (all states) */
         state = -1;
@@ -7905,11 +7894,11 @@ int SelectorUpdateTableImpl(PyMOLGlobals
   }
   I->NModel = modelCnt;
   I->NAtom = c;
-  I->Flag1 = Alloc(int, c);
+  I->Flag1 = pymol::malloc<int>(c);
   ErrChkPtr(G, I->Flag1);
-  I->Flag2 = Alloc(int, c);
+  I->Flag2 = pymol::malloc<int>(c);
   ErrChkPtr(G, I->Flag2);
-  I->Vertex = Alloc(float, c * 3);
+  I->Vertex = pymol::malloc<float>(c * 3);
   ErrChkPtr(G, I->Vertex);
   /* printf("selector update table state=%d, natom=%d\n",req_state,c); */
   return (true);
@@ -7917,31 +7906,16 @@ int SelectorUpdateTableImpl(PyMOLGlobals
 
 
 /*========================================================================*/
-static int *SelectorSelect(PyMOLGlobals * G, const char *sele, int state, int domain, int quiet)
+static sele_array_t SelectorSelect(PyMOLGlobals * G, const char *sele, int state, int domain, int quiet)
 {
-  SelectorWordType *parsed;
-  int *result = NULL;
   PRINTFD(G, FB_Selector)
     "SelectorSelect-DEBUG: sele = \"%s\"\n", sele ENDFD;
   SelectorUpdateTable(G, state, domain);
-  parsed = SelectorParse(G, sele);
-  if(parsed) {
-    if(Feedback(G, FB_Selector, FB_Debugging)) {
-      SelectorWordType *a;
-      fprintf(stderr, "SelectorSelect-DEBUG: parsed tokens:\n");
-      a = parsed;
-      while(1) {
-        if(!a[0][0])
-          break;
-        fprintf(stderr, "  \"%s\"\n", (a[0]));
-        a++;
-      }
-      fprintf(stderr, "SelectorSelect-DEBUG: end of tokens.\n");
-    }
-    result = SelectorEvaluate(G, parsed, state, quiet);
-    VLAFreeP(parsed);
+  auto parsed = SelectorParse(G, sele);
+  if (!parsed.empty()) {
+    return SelectorEvaluate(G, parsed, state, quiet);
   }
-  return (result);
+  return {};
 }
 
 
@@ -7971,15 +7945,15 @@ static int SelectorModulate1(PyMOLGlobal
     }
   }
 
-  base[1].sele = base[0].sele;  /* base1 has the mask */
-  base->sele = Calloc(int, I->NAtom);
-  for(a = 0; a < I->NAtom; a++)
-    base[0].sele[a] = false;
-  ErrChkPtr(G, base->sele);
+  base[1].sele = std::move(base[0].sele);  /* base1 has the mask */
+  base->sele_calloc(I->NAtom);
+  base->sele_check_ok(ok);
+  if (!ok)
+    return false;
   switch (base[1].code) {
   case SELE_ARD_:
   case SELE_EXP_:
-    if(!sscanf(base[2].text, "%f", &dist))
+    if(!sscanf(base[2].text(), "%f", &dist))
       ok = ErrMessage(G, "Selector", "Invalid distance.");
     if(ok) {
       for(d = 0; d < I->NCSet; d++) {
@@ -8048,16 +8022,14 @@ static int SelectorModulate1(PyMOLGlobal
     break;
 
   case SELE_EXT_:
-    if(sscanf(base[2].text, "%d", &nbond) != 1)
+    if(sscanf(base[2].text(), "%d", &nbond) != 1)
       ok = ErrMessage(G, "Selector", "Invalid bond count.");
     if(ok) {
       ObjectMolecule *lastObj = NULL;
       int a, n, a0, a1, a2;
-      UtilCopyMem(base[0].sele, base[1].sele, sizeof(int) * I->NAtom);
+      std::copy_n(base[1].sele_data(), I->NAtom, base[0].sele_data());
       while((nbond--) > 0) {
-        int *tmp = base[1].sele;
-        base[1].sele = base[0].sele;
-        base[0].sele = tmp;
+        std::swap(base[1].sele, base[0].sele);
         for(a = cNDummyAtoms; a < I->NAtom; a++) {
           if(base[1].sele[a]) {
             if(I->Obj[I->Table[a].model] != lastObj) {
@@ -8079,12 +8051,12 @@ static int SelectorModulate1(PyMOLGlobal
           }
         }
       }
-      FreeP(base[1].sele);
+      base[1].sele_free();
     }
     break;
 
   case SELE_GAP_:
-    if(!sscanf(base[2].text, "%f", &dist))
+    if(!sscanf(base[2].text(), "%f", &dist))
       ok = ErrMessage(G, "Selector", "Invalid distance.");
     if(ok) {
       for(a = 0; a < I->NAtom; a++) {
@@ -8167,7 +8139,7 @@ static int SelectorModulate1(PyMOLGlobal
     }
     break;
   }
-  FreeP(base[1].sele);
+  base[1].sele_free();
   if(Feedback(G, FB_Selector, FB_Debugging)) {
     c = 0;
     for(a = cNDummyAtoms; a < I->NAtom; a++)
@@ -8194,8 +8166,8 @@ static int SelectorSelect0(PyMOLGlobals
   CoordSet *cs;
 
   base->type = STYP_LIST;
-  base->sele = Calloc(int, I->NAtom);
-  ErrChkPtr(G, base->sele);
+  base->sele_calloc(I->NAtom);
+  base->sele_err_chk_ptr(G);
 
   switch (base->code) {
   case SELE_HBAs:
@@ -8384,7 +8356,7 @@ static int SelectorSelect0(PyMOLGlobals
       for(a = cNDummyAtoms; a < I->NAtom; a++) {
         flag = false;
         obj = i_obj[i_table[a].model];
-        if(obj->Obj.Enabled) {
+        if(obj->Enabled) {
           ai = obj->AtomInfo + i_table[a].atom;
 
           if(last_obj != obj) {
@@ -8403,7 +8375,7 @@ static int SelectorSelect0(PyMOLGlobals
     break;
   case SELE_ENAz:
     for(a = cNDummyAtoms; a < I->NAtom; a++) {
-      flag = (i_obj[i_table[a].model]->Obj.Enabled);
+      flag = (i_obj[i_table[a].model]->Enabled);
       base[0].sele[a] = flag;
       if(flag)
         c++;
@@ -8411,7 +8383,7 @@ static int SelectorSelect0(PyMOLGlobals
     break;
   }
   PRINTFD(G, FB_Selector)
-    " SelectorSelect0: %d atoms selected.\n", c ENDFD;
+    " %s: %d atoms selected.\n", __func__, c ENDFD;
 
   return (1);
 }
@@ -8434,7 +8406,6 @@ static int SelectorSelect1(PyMOLGlobals
   int flag;
   int ok = true;
   int index, state;
-  char *np;
   int rep_mask;
   const char *wildcard = SettingGetGlobal_s(G, cSetting_wildcard);
 
@@ -8442,19 +8413,17 @@ static int SelectorSelect1(PyMOLGlobals
   CoordSet *cs = NULL;
 
   base->type = STYP_LIST;
-  base->sele = Calloc(int, I_NAtom);    /* starting with zeros */
-  PRINTFD(G, FB_Selector)
-    " SelectorSelect1: base: %p sele: %p\n", (void *) base, (void *) base->sele ENDFD;
-  ErrChkPtr(G, base->sele);
+  base->sele_calloc(I_NAtom);    /* starting with zeros */
+  base->sele_err_chk_ptr(G);
   switch (base->code) {
   case SELE_PEPs:
-    if(base[1].text[0]) {
+    if(base[1].text()[0]) {
       AtomInfoType *last_ai0 = NULL, *ai0;
       for(a = cNDummyAtoms; a < I_NAtom; a++) {
         ai0 = i_obj[i_table[a].model]->AtomInfo + i_table[a].atom;
         if(!AtomInfoSameResidueP(G, ai0, last_ai0)) {   /* new starting residue */
           int match_found = false;
-          char *ch = base[1].text;      /* sequence argument */
+          const char *ch = base[1].text();      /* sequence argument */
           AtomInfoType *ai1, *last_ai1 = NULL;
           for(b = a; b < I_NAtom; b++) {
             ai1 = i_obj[i_table[b].model]->AtomInfo + i_table[b].atom;
@@ -8473,7 +8442,7 @@ static int SelectorSelect1(PyMOLGlobals
             }
           }
           if(match_found) {
-            char *ch = base[1].text;    /* sequence argument */
+            const char *ch = base[1].text();    /* sequence argument */
             AtomInfoType *ai1, *last_ai1 = NULL, *ai2;
             for(b = a; b < I_NAtom; b++) {
               ai1 = i_obj[i_table[b].model]->AtomInfo + i_table[b].atom;
@@ -8508,7 +8477,7 @@ static int SelectorSelect1(PyMOLGlobals
 
       WordMatchOptionsConfigInteger(&options);
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8529,7 +8498,7 @@ static int SelectorSelect1(PyMOLGlobals
 
       WordMatchOptionsConfigInteger(&options);
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8554,7 +8523,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8572,7 +8541,6 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_NAMs:
-    WARN_IF_LOWERCASE(G, "name", base[1].text);
     {
       CWordMatchOptions options;
       const char *atom_name_wildcard = SettingGetGlobal_s(G, cSetting_atom_name_wildcard);
@@ -8582,7 +8550,7 @@ static int SelectorSelect1(PyMOLGlobals
 
       WordMatchOptionsConfigAlphaList(&options, atom_name_wildcard[0], ignore_case);
 
-      matcher = WordMatcherNew(G, base[1].text, &options, false);
+      matcher = WordMatcherNew(G, base[1].text(), &options, false);
 
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
@@ -8595,7 +8563,7 @@ static int SelectorSelect1(PyMOLGlobals
              for handling nucleic acid structures that use "*" in atom names */
 
           const char *atom_name_wildcard =
-            SettingGet_s(G, obj->Obj.Setting, NULL, cSetting_atom_name_wildcard);
+            SettingGet_s(G, obj->Setting, NULL, cSetting_atom_name_wildcard);
 
           if(!atom_name_wildcard[0])
             atom_name_wildcard = wildcard;
@@ -8604,9 +8572,9 @@ static int SelectorSelect1(PyMOLGlobals
             options.wildcard = atom_name_wildcard[0];
             if(matcher)
               WordMatcherFree(matcher);
-            matcher = WordMatcherNew(G, base[1].text, &options, false);
+            matcher = WordMatcherNew(G, base[1].text(), &options, false);
             if(!matcher)
-              WordPrimeCommaMatch(G, base[1].text);
+              WordPrimeCommaMatch(G, &base[1].m_text[0] /* replace '+' with ',' */);
           }
           last_obj = obj;
         }
@@ -8617,7 +8585,7 @@ static int SelectorSelect1(PyMOLGlobals
             WordMatcherMatchAlpha(matcher,
                                   name);
         else
-          hit_flag = (WordMatchCommaExact(G, base[1].text,
+          hit_flag = (WordMatchCommaExact(G, base[1].text(),
                                           name,
                                           ignore_case) < 0);
 
@@ -8639,7 +8607,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
 	AtomInfoType * ai;
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
@@ -8660,7 +8628,6 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_ELEs:
-    WARN_IF_LOWERCASE(G, "element", base[1].text);
     {
       CWordMatchOptions options;
 
@@ -8669,7 +8636,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8694,7 +8661,7 @@ static int SelectorSelect1(PyMOLGlobals
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 #ifndef NO_MMLIBS
@@ -8716,9 +8683,9 @@ static int SelectorSelect1(PyMOLGlobals
     break;
   case SELE_REPs:
     rep_mask = 0;
-    WordPrimeCommaMatch(G, base[1].text);
+    WordPrimeCommaMatch(G, &base[1].m_text[0] /* replace '+' with ',' */);
     for(a = 0; rep_names[a].word[0]; a++) {
-      if(WordMatchComma(G, base[1].text, rep_names[a].word, ignore_case) < 0)
+      if(WordMatchComma(G, base[1].text(), rep_names[a].word, ignore_case) < 0)
         rep_mask |= rep_names[a].value;
     }
     for(SelectorAtomIterator iter(I); iter.next();) {
@@ -8731,7 +8698,7 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_COLs:
-    col_idx = ColorGetIndex(G, base[1].text);
+    col_idx = ColorGetIndex(G, base[1].text());
     for(a = cNDummyAtoms; a < I_NAtom; a++) {
       base[0].sele[a] = false;
       if(i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].color == col_idx) {
@@ -8744,7 +8711,7 @@ static int SelectorSelect1(PyMOLGlobals
   case SELE_RCLs:
     // setting index
     index = (base->code == SELE_CCLs) ? cSetting_cartoon_color : cSetting_ribbon_color;
-    col_idx = ColorGetIndex(G, base[1].text);
+    col_idx = ColorGetIndex(G, base[1].text());
     for(a = cNDummyAtoms; a < I_NAtom; a++) {
       base[0].sele[a] = false;
       {
@@ -8789,7 +8756,7 @@ static int SelectorSelect1(PyMOLGlobals
           printf("coding error: missing case\n");
       }
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8808,7 +8775,6 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_SSTs:
-    WARN_IF_LOWERCASE(G, "ss", base[1].text);
     {
       CWordMatchOptions options;
 
@@ -8817,7 +8783,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8835,11 +8801,16 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_STAs:
-    sscanf(base[1].text, "%d", &state);
+    sscanf(base[1].text(), "%d", &state);
     state = state - 1;
     obj = NULL;
 
-    {
+    if (state < 0 && state != cSelectorUpdateTableCurrentState) {
+      PRINTFB(G, FB_Selector, FB_Errors)
+        " Selector-Error: state %d unsupported (must be -1 (current) or >=1)\n",
+        state + 1 ENDFB(G);
+      ok = false;
+    } else {
       auto state_arg = state;
       for(a = cNDummyAtoms; a < I_NAtom; a++) {
         base[0].sele[a] = false;
@@ -8869,7 +8840,6 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_ALTs:
-    WARN_IF_LOWERCASE(G, "alt", base[1].text);
     {
       CWordMatchOptions options;
 
@@ -8878,7 +8848,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8895,7 +8865,7 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_FLGs:
-    sscanf(base[1].text, "%d", &flag);
+    sscanf(base[1].text(), "%d", &flag);
     flag = (1 << flag);
     for(a = cNDummyAtoms; a < I_NAtom; a++) {
       if(i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].flags & flag) {
@@ -8911,7 +8881,7 @@ static int SelectorSelect1(PyMOLGlobals
 
       WordMatchOptionsConfigInteger(&options);
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8938,7 +8908,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8956,7 +8926,6 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_RSNs:
-    WARN_IF_LOWERCASE(G, "resn", base[1].text);
     {
       CWordMatchOptions options;
 
@@ -8965,7 +8934,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8983,7 +8952,8 @@ static int SelectorSelect1(PyMOLGlobals
     break;
   case SELE_SELs:
     {
-      char *word = base[1].text;
+      const char *word = base[1].text();
+      WordType activeselename = "";
       int enabled_only = false;
       CWordMatchOptions options;
 
@@ -9052,7 +9022,16 @@ static int SelectorSelect1(PyMOLGlobals
           ExecutiveFreeGroupList(G, group_list_id);
         }
 
-      } else if((!enabled_only) || ExecutiveGetActiveSeleName(G, word, false, false)) {
+      } else if((!enabled_only) || ExecutiveGetActiveSeleName(G, activeselename, false, false)) {
+        if (activeselename[0]) {
+          // TODO not sure if this is intentional. If the active selection is
+          // "foo", then the expression "??bar" will evaluate to "foo". I assume
+          // the intention was to evaluate to the empty selection if "bar" is
+          // not active, and to "bar" in case it's active.
+          // Used with cmd.select(..., merge=2)
+          base[1].m_text = activeselename;
+          word = base[1].text();
+        }
         sele = SelectGetNameOffset(G, word, 1, ignore_case);
         if(sele >= 0) {
           MemberType *I_Member = I->Member;
@@ -9086,7 +9065,7 @@ static int SelectorSelect1(PyMOLGlobals
                 c++;
             }
             ExecutiveFreeGroupList(G, group_list_id);
-          } else if(base[1].text[0] == '?') {   /* undefined ?sele allowed */
+          } else if(base[1].m_text[0] == '?') {   /* undefined ?sele allowed */
             for(a = cNDummyAtoms; a < I_NAtom; a++)
               base[0].sele[a] = false;
           } else {
@@ -9105,12 +9084,14 @@ static int SelectorSelect1(PyMOLGlobals
     /* first, trim off and record the atom index if one exists */
 
     index = -1;
-    if((np = strstr(base[1].text, "`"))) {
-      *np = 0;
+    auto pos = base[1].m_text.find('`');
+    if (pos != std::string::npos) {
+      const char* np = base[1].text() + pos;
       if(sscanf(np + 1, "%d", &index) != 1)
         index = -1;
       else
         index--;
+      base[1].m_text.resize(pos);
     }
     model = 0;
 
@@ -9118,7 +9099,7 @@ static int SelectorSelect1(PyMOLGlobals
       CWordMatchOptions options;
       WordMatchOptionsConfigAlpha(&options, wildcard[0], ignore_case);
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, false))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, false))) {
 
         int obj_matches = false;
 
@@ -9132,7 +9113,7 @@ static int SelectorSelect1(PyMOLGlobals
           obj = i_obj[table_a->model];
           if(obj != last_obj) {
 
-            obj_matches = WordMatcherMatchAlpha(matcher, i_obj[table_a->model]->Obj.Name);
+            obj_matches = WordMatcherMatchAlpha(matcher, i_obj[table_a->model]->Name);
             last_obj = obj;
           }
           if(obj_matches) {
@@ -9147,7 +9128,7 @@ static int SelectorSelect1(PyMOLGlobals
         WordMatcherFree(matcher);
       } else {
 
-        obj = (ObjectMolecule *) ExecutiveFindObjectByName(G, base[1].text);
+        obj = (ObjectMolecule *) ExecutiveFindObjectByName(G, base[1].text());
         if(obj) {
           for(a = cNDummyModels; a < I->NModel; a++)
             if(i_obj[a] == obj) {
@@ -9156,7 +9137,7 @@ static int SelectorSelect1(PyMOLGlobals
             }
         }
         if(!model)
-          if(sscanf(base[1].text, "%i", &model) == 1) {
+          if(sscanf(base[1].text(), "%i", &model) == 1) {
             if(model <= 0)
               model = 0;
             else if(model > I->NModel)
@@ -9188,7 +9169,7 @@ static int SelectorSelect1(PyMOLGlobals
           }
         } else {
           PRINTFB(G, FB_Selector, FB_Errors)
-            " Selector-Error: invalid model \"%s\".\n", base[1].text ENDFB(G);
+            " Selector-Error: invalid model \"%s\".\n", base[1].text() ENDFB(G);
           ok = false;
         }
       }
@@ -9196,7 +9177,7 @@ static int SelectorSelect1(PyMOLGlobals
     break;
   }
   PRINTFD(G, FB_Selector)
-    " SelectorSelect1:  %d atoms selected.\n", c ENDFD;
+    " %s:  %d atoms selected.\n", __func__, c ENDFD;
   return (ok);
 }
 
@@ -9215,18 +9196,18 @@ static int SelectorSelect2(PyMOLGlobals
   AtomInfoType *at1;
   CSelector *I = G->Selector;
   base->type = STYP_LIST;
-  base->sele = Calloc(int, I->NAtom);
-  ErrChkPtr(G, base->sele);
+  base->sele_calloc(I->NAtom);
+  base->sele_err_chk_ptr(G);
   switch (base->code) {
   case SELE_XVLx:
   case SELE_YVLx:
   case SELE_ZVLx:
-    oper = WordKey(G, AtOper, base[1].text, 4, ignore_case, &exact);
+    oper = WordKey(G, AtOper, base[1].text(), 4, ignore_case, &exact);
     switch (oper) {
     case SCMP_GTHN:
     case SCMP_LTHN:
     case SCMP_EQAL:
-      if(sscanf(base[2].text, "%f", &comp1) != 1)
+      if(sscanf(base[2].text(), "%f", &comp1) != 1)
         ok = ErrMessage(G, "Selector", "Invalid Number");
       break;
     default:
@@ -9278,7 +9259,7 @@ static int SelectorSelect2(PyMOLGlobals
   case SELE_FCHx:
   case SELE_BVLx:
   case SELE_QVLx:
-    oper = WordKey(G, AtOper, base[1].text, 4, ignore_case, &exact);
+    oper = WordKey(G, AtOper, base[1].text(), 4, ignore_case, &exact);
     if(!oper)
       ok = ErrMessage(G, "Selector", "Invalid Operator.");
     if(ok) {
@@ -9286,7 +9267,7 @@ static int SelectorSelect2(PyMOLGlobals
       case SCMP_GTHN:
       case SCMP_LTHN:
       case SCMP_EQAL:
-        if(sscanf(base[2].text, "%f", &comp1) != 1)
+        if(sscanf(base[2].text(), "%f", &comp1) != 1)
           ok = ErrMessage(G, "Selector", "Invalid Number");
         break;
       }
@@ -9443,13 +9424,20 @@ static int SelectorSelect2(PyMOLGlobals
   }
 
   PRINTFD(G, FB_Selector)
-    " SelectorSelect2: %d atoms selected.\n", c ENDFD;
+    " %s: %d atoms selected.\n", __func__, c ENDFD;
   return (ok);
 }
 
 /*========================================================================*/
 static int SelectorSelect3(PyMOLGlobals * G, EvalElem * base, int state)
 {
+  switch (base->code) {
+  case SELE_PROP:
+    ErrMessage(G, "Selector", "properties (p.) not supported in Open-Source PyMOL");
+    return false;
+  }
+  return true;
+ok_except1:
   return false;
 }
 
@@ -9533,15 +9521,14 @@ static int SelectorLogic1(PyMOLGlobals *
   int a0, a1, a2;
   ObjectMolecule *lastObj = NULL;
 
-  base[0].sele = base[1].sele;
-  base[1].sele = NULL;
+  base[0].sele = std::move(base[1].sele);
   base[0].type = STYP_LIST;
   switch (base->code) {
   case SELE_NOT1:
     {
       int *base_0_sele_a;
 
-      base_0_sele_a = base[0].sele;
+      base_0_sele_a = base[0].sele_data();
       for(a = 0; a < n_atom; a++) {
         if((*base_0_sele_a = !*base_0_sele_a))
           c++;
@@ -9551,10 +9538,10 @@ static int SelectorLogic1(PyMOLGlobals *
     break;
   case SELE_RING:
     {
-      std::vector<bool> selemask(base[0].sele, base[0].sele + n_atom);
+      std::vector<bool> selemask(base[0].sele_data(), base[0].sele_data() + n_atom);
       SelectorRingFinder ringfinder(I, base);
 
-      memset(base[0].sele, 0, sizeof(int) * n_atom);
+      std::fill_n(base[0].sele_data(), n_atom, 0);
 
       for (SelectorAtomIterator iter(I); iter.next();) {
         if (selemask[iter.a])
@@ -9563,8 +9550,8 @@ static int SelectorLogic1(PyMOLGlobals *
     }
     break;
   case SELE_NGH1:
-    base[1].sele = base[0].sele;
-    base[0].sele = Calloc(int, n_atom);
+    base[1].sele = std::move(base[0].sele);
+    base[0].sele_calloc(n_atom);
 
     table_a = i_table + cNDummyAtoms;
     for(a = cNDummyAtoms; a < n_atom; a++) {
@@ -9589,11 +9576,11 @@ static int SelectorLogic1(PyMOLGlobals *
       }
       table_a++;
     }
-    FreeP(base[1].sele);
+    base[1].sele_free();
     break;
   case SELE_BON1:
-    base[1].sele = base[0].sele;
-    base[0].sele = Calloc(int, n_atom);
+    base[1].sele = std::move(base[0].sele);
+    base[0].sele_calloc(n_atom);
     table_a = i_table + cNDummyAtoms;
     for(a = cNDummyAtoms; a < n_atom; a++) {
       if((tag = base[1].sele[a])) {
@@ -9617,11 +9604,11 @@ static int SelectorLogic1(PyMOLGlobals *
       }
       table_a++;
     }
-    FreeP(base[1].sele);
+    base[1].sele_free();
     break;
   case SELE_BYO1:
-    base[1].sele = base[0].sele;
-    base[0].sele = Calloc(int, n_atom);
+    base[1].sele = std::move(base[0].sele);
+    base[0].sele_calloc(n_atom);
     for(a = cNDummyAtoms; a < n_atom; a++) {
       if(base[1].sele[a]) {
         if(i_obj[i_table[a].model] != lastObj) {
@@ -9643,12 +9630,12 @@ static int SelectorLogic1(PyMOLGlobals *
         }
       }
     }
-    FreeP(base[1].sele);
+    base[1].sele_free();
     break;
   case SELE_BYR1:              /* ASSUMES atoms are sorted & grouped by residue */
   case SELE_CAS1:
     {
-      int *base_0_sele = base[0].sele;
+      int *base_0_sele = base[0].sele_data();
       int break_atom = -1;
       int last_tag = 0;
       table_a = i_table + cNDummyAtoms;
@@ -9718,7 +9705,7 @@ static int SelectorLogic1(PyMOLGlobals *
     break;
   case SELE_BYC1:              /* ASSUMES atoms are sorted & grouped by chain */
     {
-      int *base_0_sele = base[0].sele;
+      int *base_0_sele = base[0].sele_data();
       int break_atom_high = -1;
       int break_atom_low = 0;
       int last_tag = 0;
@@ -9779,7 +9766,7 @@ static int SelectorLogic1(PyMOLGlobals *
     break;
   case SELE_BYS1:              /* ASSUMES atoms are sorted & grouped by segi */
     {
-      int *base_0_sele = base[0].sele;
+      int *base_0_sele = base[0].sele_data();
       int break_atom_high = -1;
       int break_atom_low = 0;
       int last_tag = 0;
@@ -9841,8 +9828,8 @@ static int SelectorLogic1(PyMOLGlobals *
 
       int n_frag = EditorGetNFrag(G);
 
-      base[1].sele = base[0].sele;
-      base[0].sele = Calloc(int, n_atom);
+      base[1].sele = std::move(base[0].sele);
+      base[0].sele_calloc(n_atom);
 
       if(n_frag) {
         int a, f, at, s;
@@ -9850,7 +9837,7 @@ static int SelectorLogic1(PyMOLGlobals *
         WordType name;
         ObjectMolecule *obj;
 
-        fsele = Alloc(int, n_frag + 1);
+        fsele = pymol::malloc<int>(n_frag + 1);
 
         for(f = 0; f < n_frag; f++) {
           sprintf(name, "%s%1d", cEditorFragPref, f + 1);
@@ -9886,7 +9873,7 @@ static int SelectorLogic1(PyMOLGlobals *
 
         FreeP(fsele);
       }
-      FreeP(base[1].sele);
+      base[1].sele_free();
     }
     break;
   case SELE_BYM1:
@@ -9897,8 +9884,8 @@ static int SelectorLogic1(PyMOLGlobals *
       ObjectMolecule *obj, *lastObj = NULL;
       int *stk;
       int stkDepth = 0;
-      base[1].sele = base[0].sele;
-      base[0].sele = Calloc(int, n_atom);
+      base[1].sele = std::move(base[0].sele);
+      base[0].sele_calloc(n_atom);
 
       stk = VLAlloc(int, 50);
 
@@ -9937,13 +9924,13 @@ static int SelectorLogic1(PyMOLGlobals *
           }
         }
       }
-      FreeP(base[1].sele);
+      base[1].sele_free();
       VLAFreeP(stk);
     }
     break;
   case SELE_BYX1:              /* by cell */
-    base[1].sele = base[0].sele;
-    base[0].sele = Calloc(int, n_atom);
+    base[1].sele = std::move(base[0].sele);
+    base[0].sele_calloc(n_atom);
     {
       ObjectMolecule *obj;
       CoordSet *cs;
@@ -10038,24 +10025,24 @@ static int SelectorLogic1(PyMOLGlobals *
         }
       }
     }
-    FreeP(base[1].sele);
+    base[1].sele_free();
     break;
   case SELE_FST1:
-    base[1].sele = base[0].sele;
-    base[0].sele = Calloc(int, n_atom);
+    base[1].sele = std::move(base[0].sele);
+    base[0].sele_calloc(n_atom);
     for(a = cNDummyAtoms; a < n_atom; a++) {
       if(base[1].sele[a]) {
         base[0].sele[a] = base[1].sele[a];      /* preserve tag */
         break;
       }
     }
-    FreeP(base[1].sele);
+    base[1].sele_free();
     break;
   case SELE_LST1:
     {
       int last = -1;
-      base[1].sele = base[0].sele;
-      base[0].sele = Calloc(int, n_atom);
+      base[1].sele = std::move(base[0].sele);
+      base[0].sele_calloc(n_atom);
       for(a = cNDummyAtoms; a < n_atom; a++) {
         if(base[1].sele[a]) {
           last = a;
@@ -10064,11 +10051,11 @@ static int SelectorLogic1(PyMOLGlobals *
       if(last >= 0)
         base[0].sele[last] = base[1].sele[last];        /* preserve tag */
     }
-    FreeP(base[1].sele);
+    base[1].sele_free();
     break;
   }
   PRINTFD(G, FB_Selector)
-    " SelectorLogic1: %d atoms selected.\n", c ENDFD;
+    " %s: %d atoms selected.\n", __func__, c ENDFD;
   return (1);
 }
 
@@ -10093,8 +10080,8 @@ static int SelectorLogic2(PyMOLGlobals *
   case SELE_OR_2:
   case SELE_IOR2:
     {
-      base_0_sele_a = base[0].sele;
-      base_2_sele_a = base[2].sele;
+      base_0_sele_a = base[0].sele_data();
+      base_2_sele_a = base[2].sele_data();
 
       for(a = 0; a < n_atom; a++) {
         if(((*base_0_sele_a) =
@@ -10110,8 +10097,8 @@ static int SelectorLogic2(PyMOLGlobals *
     break;
   case SELE_AND2:
 
-    base_0_sele_a = base[0].sele;
-    base_2_sele_a = base[2].sele;
+    base_0_sele_a = base[0].sele_data();
+    base_2_sele_a = base[2].sele_data();
 
     for(a = 0; a < n_atom; a++) {
       if((*base_0_sele_a) && (*base_2_sele_a)) {
@@ -10127,8 +10114,8 @@ static int SelectorLogic2(PyMOLGlobals *
     }
     break;
   case SELE_ANT2:
-    base_0_sele_a = base[0].sele;
-    base_2_sele_a = base[2].sele;
+    base_0_sele_a = base[0].sele_data();
+    base_2_sele_a = base[2].sele_data();
 
     for(a = 0; a < n_atom; a++) {
       if((*base_0_sele_a) && !(*base_2_sele_a)) {
@@ -10206,9 +10193,9 @@ static int SelectorLogic2(PyMOLGlobals *
     }
     break;
   }
-  FreeP(base[2].sele);
+  base[2].sele_free();
   PRINTFD(G, FB_Selector)
-    " SelectorLogic2: %d atoms selected.\n", c ENDFD;
+    " %s: %d atoms selected.\n", __func__, c ENDFD;
   return (1);
 }
 
@@ -10244,7 +10231,7 @@ int SelectorOperator22(PyMOLGlobals * G,
   case SELE_WIT_:
   case SELE_BEY_:
   case SELE_NTO_:
-    if(!sscanf(base[2].text, "%f", &dist))
+    if(!sscanf(base[2].text(), "%f", &dist))
       ok = ErrMessage(G, "Selector", "Invalid distance.");
     if(ok) {
       if(dist < 0.0)
@@ -10331,22 +10318,38 @@ int SelectorOperator22(PyMOLGlobals * G,
     }
     break;
   }
-  FreeP(base[4].sele);
+  base[4].sele_free();
   PRINTFD(G, FB_Selector)
-    " SelectorOperator22: %d atoms selected.\n", c ENDFD;
+    " %s: %d atoms selected.\n", __func__, c ENDFD;
   return (1);
 }
 
-static void remove_quotes(char *st)
+/**
+ * Removes matching quotes from a string, at string start as well as after word
+ * list separators ("+" and ","). Does not consider backslash escaping.
+ *
+ * Examples (not sure if all of these are intentional):
+ * @verbatim
+   "foo bar" -> foo bar
+   'foo bar' -> foo bar
+   "foo"+'bar' -> foo+bar
+   "foo bar\" -> foo bar\       # backslash has no escape function
+   "foo" "bar" -> foo "bar"     # second pair of quotes not after separator
+   foo''+''bar -> foo''+bar     # first pair of quotes not after separator
+   "foo"bar" -> foobar"         # third quote unmatched
+   foo'+'bar -> foo'+'bar       # no matching quotes after separator
+   @endverbatim
+ */
+static void remove_quotes(std::string& str)
 {
   /* nasty */
 
-  SelectorWordType store;
+  char *st = &str[0];
   char *p, *q;
   char *quote_start = NULL;
   char active_quote = 0;
   p = st;
-  q = store;
+  q = st;
 
   while(*p) {
     if(((*p) == 34) || ((*p) == 39)) {
@@ -10358,8 +10361,8 @@ static void remove_quotes(char *st)
         q--;
         quote_start = NULL;
         p++;
+        continue;
       } else if(quote_start) {
-        *(q++) = *(p++);
       } else {
         if(p == st) {           /* at start => real quote */
           quote_start = q;
@@ -10368,38 +10371,35 @@ static void remove_quotes(char *st)
           quote_start = q;
           active_quote = *p;
         }
-        *(q++) = *(p++);
       }
-    } else {
-      /* UNWORKABLE -- hopelly getting rid of this kludge will not cause major grief 
-         if((*p=='+')&&(!quote_start))
-         if(!((*(p+1)==0)||(*(p+1)==',')||(*(p+1)=='+')))
-         *p=',';
-       */
-      *(q++) = *(p++);
     }
+    if (q < p) {
+      *q = *p;
+    }
+    ++q;
+    ++p;
+  }
+  if (q < p) {
+    str.resize(q - st);
   }
-  *(q++) = 0;
-  strcpy(st, store);
-
 }
 
 #define STACK_PUSH_VALUE(value) { \
   depth++; \
-  VLACheck(Stack, EvalElem, depth); \
-  e = Stack + depth; \
+  VecCheck(Stack, depth); \
+  e = Stack.data() + depth; \
   e->level = (level << 4) + 1; \
   e->imp_op_level = (imp_op_level << 4) + 1; \
   imp_op_level = level; \
   e->type = STYP_VALU; \
-  strcpy(e->text, value); \
-  remove_quotes(e->text); \
+  e->m_text = value; \
+  remove_quotes(e->m_text); \
 }
 
 #define STACK_PUSH_OPERATION(ocode) { \
   depth++; \
-  VLACheck(Stack, EvalElem, depth); \
-  e = Stack + depth; \
+  VecCheck(Stack, depth); \
+  e = Stack.data() + depth; \
   e->code = ocode; \
   e->level = (level << 4) + ((e->code & 0xF0) >> 4); \
   e->imp_op_level = (imp_op_level << 4) + 1; \
@@ -10408,7 +10408,9 @@ static void remove_quotes(char *st)
 }
 
 /*========================================================================*/
-int *SelectorEvaluate(PyMOLGlobals * G, SelectorWordType * word, int state, int quiet)
+sele_array_t SelectorEvaluate(PyMOLGlobals* G,
+    std::vector<std::string>& word,
+    int state, int quiet)
 {
   int level = 0, imp_op_level = 0;
   int depth = 0;
@@ -10416,29 +10418,21 @@ int *SelectorEvaluate(PyMOLGlobals * G,
   int ok = true;
   unsigned int code = 0;
   int valueFlag = 0;            /* are we expecting? */
-  int *result = NULL;
   int opFlag, maxLevel;
-  char *q;
   int totDepth = 0;
   int exact = 0;
 
   int ignore_case = SettingGetGlobal_b(G, cSetting_ignore_case);
   /* CFGs can efficiently be parsed by stacks; use a clean stack w/space
-   * for 100 elements */
-  EvalElem *Stack = NULL, *e;
-  SelectorWordType tmpKW;
-  Stack = VLAlloc(EvalElem, 100);
-  CHECKOK(ok, Stack);
-  if (!ok)
-    return NULL;
-  UtilZeroMem(Stack, sizeof(EvalElem)); /* blank first entry */
+   * for 10 (was: 100) elements */
+  EvalElem *e;
+  auto Stack = std::vector<EvalElem>(10);
 
   /* converts all keywords into code, adds them into a operation list */
-  while(ok && word[c][0]) {
+  while(ok && c < word.size()) {
     if(word[c][0] == '#') {
       if((!valueFlag) && (!level)) {
-        word[c][0] = 0;         /* terminate selection if we encounter a comment */
-        word[c + 1][0] = 0;
+        word.resize(c);         /* terminate selection if we encounter a comment */
         break;
       }
     }
@@ -10472,28 +10466,34 @@ int *SelectorEvaluate(PyMOLGlobals * G,
         valueFlag--;
       } else if(valueFlag < 0) {        /* operation parameter i.e. around X<-- */
         depth++;
-        VLACheck(Stack, EvalElem, depth);
-        e = Stack + depth;
+        VecCheck(Stack, depth);
+        e = Stack.data() + depth;
         e->level = (level << 4) + 1;
         e->imp_op_level = (imp_op_level << 4) + 1;
         imp_op_level = level;
         e->type = STYP_PVAL;
-        strcpy(e->text, word[c]);
+        e->m_text = word[c];
         valueFlag++;
       } else {                  /* possible keyword... */
-        code = WordKey(G, Keyword, word[c], 4, ignore_case, &exact);
+        code = WordKey(G, Keyword, word[c].c_str(), 4, ignore_case, &exact);
         if(!code) {
-          b = strlen(word[c]) - 1;
+          b = word[c].size() - 1;
           if((b > 2) && (word[c][b] == ';')) {
             /* kludge to accomodate unnec. ';' usage */
-            word[c][b] = 0;
-            code = WordKey(G, Keyword, word[c], 4, ignore_case, &exact);
+            word[c].resize(b);
+            code = WordKey(G, Keyword, word[c].c_str(), 4, ignore_case, &exact);
+          } else if(!word[c].compare(0, 2, "p.")) {
+            // kludge to parse p.propertyname without space after p.
+            code = SELE_PROP;
+            exact = 1;
+            word[c].erase(0, 2);
+            c--;
           }
         }
         PRINTFD(G, FB_Selector)
           " Selector: code %x\n", code ENDFD;
         if((code > 0) && (!exact))
-          if(SelectorIndexByName(G, word[c]) >= 0)
+          if(SelectorIndexByName(G, word[c].c_str()) >= 0)
             code = 0;           /* favor selections over partial keyword matches */
         if(code) {
           /* this is a known operation */
@@ -10525,9 +10525,8 @@ int *SelectorEvaluate(PyMOLGlobals * G,
             break;
           }
         } else {
-          strcpy(tmpKW, word[c]);
-
-          if((a = strchrcount(tmpKW, '/'))) { /* handle slash notation */
+          if((a = std::count(word[c].begin(), word[c].end(),
+                  '/'))) { /* handle slash notation */
             if(a > 5) {
               ok = ErrMessage(G, "Selector", "too many slashes in macro");
               break;
@@ -10540,7 +10539,8 @@ int *SelectorEvaluate(PyMOLGlobals * G,
             int codes[] = {0, 0, 0}; // null-terminated
             char * values[2];
 
-            q = tmpKW;
+            std::string tmpKW = word[c];
+            char* q = &tmpKW[0];
 
             // if macro starts with "/" then read from left, otherwise
             // read from right
@@ -10599,7 +10599,7 @@ int *SelectorEvaluate(PyMOLGlobals * G,
             if(!b)
               STACK_PUSH_OPERATION(SELE_ALLz);
 
-          } else if(strstr(tmpKW, "`")) { /* handle <object`index> syntax */
+          } else if(word[c].find('`') != std::string::npos) { /* handle <object`index> syntax */
             STACK_PUSH_OPERATION(SELE_MODs);
             valueFlag = 1;
             c--;
@@ -10623,11 +10623,6 @@ int *SelectorEvaluate(PyMOLGlobals * G,
     opFlag = true;
     maxLevel = -1;
     for(a = 1; a <= totDepth; a++) {
-      PRINTFD(G, FB_Selector)
-        " Selector initial stack %d-%p lv: %x co: %d type: %x sele %p\n",
-        a, (void *) (Stack + a), Stack[a].level, Stack[a].code,
-        Stack[a].type, (void *) Stack[a].sele ENDFD;
-
       if(Stack[a].level > maxLevel)
         maxLevel = Stack[a].level;
     }
@@ -10644,12 +10639,6 @@ int *SelectorEvaluate(PyMOLGlobals * G,
         depth = 1;
         opFlag = true;
         while(ok && opFlag) {   /* loop through all entries looking for ops at the current level */
-          PRINTFD(G, FB_Selector)
-            " Selector: lvl: %d de:%d-%p slv:%d co: %x typ %x sele %p td: %d\n",
-            level, depth, (void *) (Stack + depth), Stack[depth].level,
-            Stack[depth].code,
-            Stack[depth].type, (void *) Stack[depth].sele, totDepth ENDFD;
-
           opFlag = false;
 
           if(Stack[depth].level >= level) {
@@ -10670,7 +10659,7 @@ int *SelectorEvaluate(PyMOLGlobals * G,
                   opFlag = true;
                   ok = SelectorSelect1(G, &Stack[depth - 1], quiet);
                   for(a = depth + 1; a <= totDepth; a++)
-                    Stack[a - 1] = Stack[a];
+                    Stack[a - 1] = std::move(Stack[a]);
                   totDepth--;
                 } else if(ok && (!opFlag) && (Stack[depth - 1].type == STYP_OPR1)
                           && (Stack[depth].type == STYP_LIST)) {
@@ -10678,7 +10667,7 @@ int *SelectorEvaluate(PyMOLGlobals * G,
                   opFlag = true;
                   ok = SelectorLogic1(G, &Stack[depth - 1], state);
                   for(a = depth + 1; a <= totDepth; a++)
-                    Stack[a - 1] = Stack[a];
+                    Stack[a - 1] = std::move(Stack[a]);
                   totDepth--;
                 } else if((Stack[depth - 1].type == STYP_LIST) &&
                           (Stack[depth].type == STYP_LIST) &&
@@ -10687,15 +10676,14 @@ int *SelectorEvaluate(PyMOLGlobals * G,
                   /* two adjacent lists at zeroth priority level
                      for the scope (lowest nibble of level is
                      zero) is an implicit OR action */
-                  VLACheck(Stack, EvalElem, totDepth);
+                  VecCheck(Stack, totDepth + 1);
                   for(a = totDepth; a >= depth; a--)
-                    Stack[a + 1] = Stack[a];
+                    Stack[a + 1] = std::move(Stack[a]);
                   totDepth++;
                   Stack[depth].type = STYP_OPR2;
                   Stack[depth].code = SELE_IOR2;
                   Stack[depth].level = Stack[depth].imp_op_level;
-                  Stack[depth].sele = NULL;
-                  Stack[depth].text[0] = 0;
+                  Stack[depth].m_text.clear();
                   if(level < Stack[depth].level)
                     level = Stack[depth].level;
                   opFlag = true;
@@ -10713,7 +10701,7 @@ int *SelectorEvaluate(PyMOLGlobals * G,
                   ok = SelectorLogic2(G, &Stack[depth - 2]);
                   opFlag = true;
                   for(a = depth + 1; a <= totDepth; a++)
-                    Stack[a - 2] = Stack[a];
+                    Stack[a - 2] = std::move(Stack[a]);
                   totDepth -= 2;
                 } else if(ok && (!opFlag) && (Stack[depth - 1].type == STYP_PRP1)
                           && (Stack[depth].type == STYP_PVAL)
@@ -10722,7 +10710,7 @@ int *SelectorEvaluate(PyMOLGlobals * G,
                   ok = SelectorModulate1(G, &Stack[depth - 2], state);
                   opFlag = true;
                   for(a = depth + 1; a <= totDepth; a++)
-                    Stack[a - 2] = Stack[a];
+                    Stack[a - 2] = std::move(Stack[a]);
                   totDepth -= 2;
                 }
               }
@@ -10738,7 +10726,7 @@ int *SelectorEvaluate(PyMOLGlobals * G,
                   ok = SelectorSelect2(G, &Stack[depth - 2], state);
                   opFlag = true;
                   for(a = depth + 1; a <= totDepth; a++)
-                    Stack[a - 2] = Stack[a];
+                    Stack[a - 2] = std::move(Stack[a]);
                   totDepth -= 2;
                 }
               }
@@ -10756,7 +10744,7 @@ int *SelectorEvaluate(PyMOLGlobals * G,
                   ok = SelectorSelect3(G, &Stack[depth-3], state);
                   opFlag = true;
                   for(a = depth + 1; a <= totDepth; a++)
-                    Stack[a - 3] = Stack[a];
+                    Stack[a - 3] = std::move(Stack[a]);
                   totDepth -= 3;
                 }
               }
@@ -10776,7 +10764,7 @@ int *SelectorEvaluate(PyMOLGlobals * G,
                   ok = SelectorOperator22(G, &Stack[depth - 4], state);
                   opFlag = true;
                   for(a = depth + 1; a <= totDepth; a++)
-                    Stack[a - 4] = Stack[a];
+                    Stack[a - 4] = std::move(Stack[a]);
                   totDepth -= 4;
                 }
 
@@ -10803,74 +10791,52 @@ int *SelectorEvaluate(PyMOLGlobals * G,
     } else if(Stack[depth].type != STYP_LIST)
 	ok = ErrMessage(G, "Selector", "Invalid selection.");
     else
-      result = Stack[totDepth].sele;    /* return the selection list */
+      return std::move(Stack[totDepth].sele); /* return the selection list */
   }
   if(!ok) {
-    for(a = 1; a <= depth; a++) {
-      PRINTFD(G, FB_Selector)
-        " Selector: releasing %d %x %p\n", a, Stack[a].type, (void *) Stack[a].sele ENDFD;
-      if(Stack[a].type == STYP_LIST)
-        FreeP(Stack[a].sele);
-    }
-    depth = 0;
-    {
-      OrthoLineType line;
-      for(a = 0; a <= c; a++) {
-        q = line;
-        if(a && word[a][0])
-          q = UtilConcat(q, " ");
-        q = UtilConcat(q, word[a]);
-	  PRINTFB(G, FB_Selector, FB_Errors)
-	    "%s", line ENDFB(G);
-      }
-      q = line;
-      q = UtilConcat(q, "<--");
-	PRINTFB(G, FB_Selector, FB_Errors)
-	  "%s\n", line ENDFB(G);
+    for (a = 0; a <= c && a < word.size(); a++) {
+      const char* space = (a && word[a][0]) ? " " : "";
+      PRINTFB(G, FB_Selector, FB_Errors)
+        "%s%s", space, word[a].c_str() ENDFB(G);
     }
+    PRINTFB(G, FB_Selector, FB_Errors)
+      "<--\n" ENDFB(G);
   }
-  VLAFreeP(Stack);
-  if(!ok) {
-    FreeP(result);
-    result = NULL;
-  }
-  return (result);
+  return {};
 }
 
 
 /*========================================================================*/
-SelectorWordType *SelectorParse(PyMOLGlobals * G, const char *s)
+/**
+ * Break a selection down into tokens and return them in a vector.
+ * E.g. "(name CA+CB)" -> {"(", "name", "CA+CB", ")"}.
+ * @param s selection expression to parse
+ * @return tokens
+ */
+std::vector<std::string> SelectorParse(PyMOLGlobals * G, const char *s)
 {
-
-  /* break a selection down into its constituent strings and
-     return them in a SelectorWordType VLA, null string terminated */
-
-  SelectorWordType *r = NULL;
-  int c = 0;
   int w_flag = false;
   int quote_flag = false;
   char quote_char = '"';
   const char *p = s;
-  char *q = NULL, *q_base = NULL;
-  r = VLAlloc(SelectorWordType, 100);
+  std::string* q = nullptr;
+  std::vector<std::string> r;
   while(*p) {
     if(w_flag) {                /* currently in a word, thus q is a valid pointer */
       if(quote_flag) {
         if(*p != quote_char) {
-          *q++ = *p;
+          *q += *p;
         } else {
           quote_flag = false;
-          *q++ = *p;
+          *q += *p;
         }
       } else
         switch (*p) {
         case ' ':
-          *q = 0;
           w_flag = false;
           break;
         case ';':              /* special word terminator */
-          *q++ = *p;
-          *q = 0;
+          *q += *p;
           w_flag = false;
           break;
         case '!':              /* single words */
@@ -10882,31 +10848,18 @@ SelectorWordType *SelectorParse(PyMOLGlo
         case '<':
         case '=':
         case '%':
-          *q = 0;               /* terminate current word */
-          c++;
-          VLACheck(r, SelectorWordType, c);     /* add new word */
-          q = r[c - 1];
-          *q++ = *p;
-          *q = 0;               /* terminate current word */
+          r.emplace_back(1, *p); /* add new word */
+          q = &r.back();
           w_flag = false;
           break;
         case '"':
           quote_flag = true;
-          *q++ = *p;
+          *q += *p;
           break;
         default:
-          *q++ = *p;
+          *q += *p;
           break;
         }
-      if(w_flag) {
-        if((q - q_base) >= sizeof(SelectorWordType)) {
-          q_base[sizeof(SelectorWordType) - 1] = 0;
-          w_flag = false;
-          PRINTFB(G, FB_Selector, FB_Errors)
-            "Selector-Error: Word too long. Truncated:\nSelector-Error: %s...\n", q_base
-            ENDFB(G);
-        }
-      }
     } else {                    /*outside a word -- q is undefined */
 
       switch (*p) {
@@ -10919,11 +10872,8 @@ SelectorWordType *SelectorParse(PyMOLGlo
       case '<':
       case '=':
       case '%':
-        c++;
-        VLACheck(r, SelectorWordType, c);
-        q = r[c - 1];
-        *q++ = (*p);
-        *q = 0;
+        r.emplace_back(1, *p); /* add new word */
+        q = &r.back();
         break;
       case ' ':
         break;
@@ -10931,36 +10881,22 @@ SelectorWordType *SelectorParse(PyMOLGlo
         quote_flag = true;
         quote_char = *p;
         w_flag = true;
-        c++;
-        VLACheck(r, SelectorWordType, c);
-        q = r[c - 1];
-        q_base = q;
-        *q++ = *p;
+        r.emplace_back(1, *p); /* add new word */
+        q = &r.back();
         break;
       default:
         w_flag = true;
-        c++;
-        VLACheck(r, SelectorWordType, c);
-        q = r[c - 1];
-        q_base = q;
-        *q++ = *p;
+        r.emplace_back(1, *p); /* add new word */
+        q = &r.back();
         break;
       }
     }
     p++;
   }
-  /* end current word */
-  if(w_flag)
-    *q = 0;
-
-  /* null strings terminate the list */
-  q = r[c];
-  *q = 0;
+
   if(Feedback(G, FB_Selector, FB_Debugging)) {
-    c = 0;
-    while(r[c][0]) {
-      fprintf(stderr, "word: %s\n", r[c]);
-      c++;
+    for (auto& word : r) {
+      fprintf(stderr, "word: %s\n", word.c_str());
     }
   }
   return (r);
@@ -10977,11 +10913,11 @@ void SelectorFreeImpl(PyMOLGlobals * G,
 {
   SelectorCleanImpl(G, I);
   if(I->Origin)
-    if(I->Origin->Obj.fFree)
-      I->Origin->Obj.fFree((CObject *) I->Origin);
+    if(I->Origin->fFree)
+      I->Origin->fFree((CObject *) I->Origin);
   if(I->Center)
-    if(I->Center->Obj.fFree)
-      I->Center->Obj.fFree((CObject *) I->Center);
+    if(I->Center->fFree)
+      I->Center->fFree((CObject *) I->Center);
   if (init2){
     VLAFreeP(I->Member);
     VLAFreeP(I->Name);
@@ -11078,7 +11014,7 @@ int SelectorInit(PyMOLGlobals * G)
 
 int SelectorInitImpl(PyMOLGlobals * G, CSelector **Iarg, short init2){
   CSelector *I = NULL;
-  ok_assert(1, I = Calloc(CSelector, 1));
+  ok_assert(1, I = pymol::calloc<CSelector>(1));
 
     *Iarg = I;
 
@@ -11206,8 +11142,8 @@ DistSet *SelectorGetDistSet(PyMOLGlobals
       }
     }
     /* prepare these for the next round */
-    zero = Calloc(int, max_n_atom);
-    scratch = Alloc(int, max_n_atom);
+    zero = pymol::calloc<int>(max_n_atom);
+    scratch = pymol::malloc<int>(max_n_atom);
   }
 
   /* if we're hydrogen bonding, setup the cutoff */
@@ -11371,7 +11307,7 @@ DistSet *SelectorGetDistSet(PyMOLGlobals
 
 		/* Insert DistInfo records for updating distances */
 		/* Init/Add the elem to the DistInfo list */
-                atom1Info = Alloc(CMeasureInfo, 1);
+                atom1Info = pymol::malloc<CMeasureInfo>(1);
 
                 // TH
                 atom1Info->id[0] = AtomInfoCheckUniqueID(G, ai1);
@@ -11606,7 +11542,7 @@ DistSet *SelectorGetAngleSet(PyMOLGlobal
 
 				      /* Insert DistInfo records for updating distances */
 				      /* Init/Add the elem to the DistInfo list */
-				      atom1Info = Alloc(CMeasureInfo, 1);
+				      atom1Info = pymol::malloc<CMeasureInfo>(1);
 
                                       // TH
                                       atom1Info->id[0] = AtomInfoCheckUniqueID(G, obj1->AtomInfo + at1);
@@ -11936,7 +11872,7 @@ DistSet *SelectorGetDihedralSet(PyMOLGlo
 
 						  /* Insert DistInfo records for updating distances */
 						  /* Init/Add the elem to the DistInfo list */
-						  atom1Info = Alloc(CMeasureInfo ,1);
+						  atom1Info = pymol::malloc<CMeasureInfo >(1);
 
                                                   // TH
                                                   atom1Info->id[0] = AtomInfoCheckUniqueID(G, obj1->AtomInfo + at1);
diff -upNr pymol-open-source-2.3.0/layer3/Selector.cpp.orig pymol-open-source-2.3.3/layer3/Selector.cpp.orig
--- pymol-open-source-2.3.0/layer3/Selector.cpp.orig	1970-01-01 01:00:00.000000000 +0100
+++ pymol-open-source-2.3.3/layer3/Selector.cpp.orig	2019-08-22 10:24:47.746600251 +0200
@@ -0,0 +1,12033 @@
+/* 
+A* -------------------------------------------------------------------
+B* This file contains source code for the PyMOL computer program
+C* copyright 1998-2004 by Warren Lyford Delano of DeLano Scientific. 
+D* -------------------------------------------------------------------
+E* It is unlawful to modify or remove this copyright notice.
+F* -------------------------------------------------------------------
+G* Please see the accompanying LICENSE file for further information. 
+H* -------------------------------------------------------------------
+I* Additional authors of this source file include:
+-* 
+-* 
+-*
+Z* -------------------------------------------------------------------
+*/
+
+#include <algorithm>
+#include <string>
+#include <vector>
+
+#include"os_python.h"
+#include"os_numpy.h"
+#include"os_std.h"
+
+#include"Base.h"
+#include"Map.h"
+#include"Vector.h"
+#include"Debug.h"
+#include"Err.h"
+#include"Word.h"
+#include"Util.h"
+#include"PConv.h"
+#include"P.h"
+
+#include"MemoryDebug.h"
+#include"Selector.h"
+#include"Executive.h"
+#include"ObjectMolecule.h"
+#include"CoordSet.h"
+#include"DistSet.h"
+#include"Word.h"
+#include"Scene.h"
+#include"CGO.h"
+#include"Seq.h"
+#include"Editor.h"
+#include"Seeker.h"
+#include "Lex.h"
+#include "Mol2Typing.h"
+
+#include"OVContext.h"
+#include"OVLexicon.h"
+#include"OVOneToAny.h"
+#include"Parse.h"
+
+#include"ListMacros.h"
+
+#include "SelectorDef.h"
+
+#define cSelectorTmpPrefix "_sel_tmp_"
+#define cSelectorTmpPrefixLen 9 /* strlen(cSelectorTmpPrefix) */
+#define cSelectorTmpPattern "_sel_tmp_*"
+
+#define cDummyOrigin 0
+#define cDummyCenter 1
+
+
+/* special selections, unknown to executive */
+#define cColorectionFormat "_!c_%s_%d"
+
+static WordKeyValue rep_names[] = {
+  {"spheres", cRepSphereBit},
+  {"sticks", cRepCylBit},
+  {"surface", cRepSurfaceBit},
+  {"labels", cRepLabelBit},
+  {"nb_spheres", cRepNonbondedSphereBit},
+  {"cartoon", cRepCartoonBit},
+  {"ribbon", cRepRibbonBit},
+  {"lines", cRepLineBit},
+  {"dots", cRepDotBit},
+  {"mesh", cRepMeshBit},
+  {"nonbonded", cRepNonbondedBit},
+  {"ellipsoid", cRepEllipsoidBit},
+  {"",},
+};
+
+static const char *backbone_names[] = {
+  // protein
+  "CA", "C", "O", "N", "OXT", "H",
+  // nucleic acid
+  "P", "OP1", "OP2", "OP3", "C1'", "C2'", "O2'",
+  "C3'", "O3'", "C4'", "O4'", "C5'", "O5'",
+  "H1'", "H3'", "H4'",
+  "H2'", "H2''", "H12'", "H22'",
+  "H5'", "H5''", "H15'", "H25'",
+  "HO2'", "HO3'", "HO5'",
+  ""
+};
+
+/// Helper type which replaces `int*` return types
+typedef std::unique_ptr<int[]> sele_array_t;
+inline void sele_array_calloc(sele_array_t& sele, size_t count)
+{
+  sele.reset(new int[count]());
+}
+
+struct EvalElem {
+  int level, imp_op_level;
+  int type;                     /* 0 = value 1 = operation 2 = pre-operation */
+  unsigned int code;
+  std::string m_text;
+  sele_array_t sele;
+
+  // Helpers for refactoring `sele` type
+  int* sele_data() { return sele.get(); }
+  void sele_free() { sele.reset(); }
+  void sele_calloc(size_t count) { sele_array_calloc(sele, count); }
+
+  // TODO replace with pymol::Error handling
+  void sele_check_ok(int& ok) { CHECKOK(ok, sele_data()); }
+  void sele_err_chk_ptr(PyMOLGlobals* G) { ErrChkPtr(G, sele_data()); }
+
+  /// read-only access to text
+  const char* text() const { return m_text.c_str(); }
+};
+
+typedef struct {
+  int depth1;
+  int depth2;
+  int depth3;
+  int depth4;
+  int sum;
+  int frag;
+} WalkDepthRec;
+
+static sele_array_t SelectorSelect(PyMOLGlobals * G, const char *sele, int state, int domain, int quiet);
+static int SelectorGetInterstateVLA(PyMOLGlobals * G, int sele1, int state1, int sele2,
+                                    int state2, float cutoff, int **vla);
+
+static int SelectorModulate1(PyMOLGlobals * G, EvalElem * base, int state);
+static int SelectorSelect0(PyMOLGlobals * G, EvalElem * base);
+static int SelectorSelect1(PyMOLGlobals * G, EvalElem * base, int quiet);
+static int SelectorSelect2(PyMOLGlobals * G, EvalElem * base, int state);
+static int SelectorLogic1(PyMOLGlobals * G, EvalElem * base, int state);
+static int SelectorLogic2(PyMOLGlobals * G, EvalElem * base);
+static int SelectorOperator22(PyMOLGlobals * G, EvalElem * base, int state);
+static sele_array_t SelectorEvaluate(PyMOLGlobals* G, std::vector<std::string>& word, int state, int quiet);
+static std::vector<std::string> SelectorParse(PyMOLGlobals * G, const char *s);
+static void SelectorPurgeMembers(PyMOLGlobals * G, int sele);
+static int SelectorEmbedSelection(PyMOLGlobals * G, const int *atom, const char *name,
+                                  ObjectMolecule * obj, int no_dummies, int exec_manage);
+static int *SelectorGetIndexVLA(PyMOLGlobals * G, int sele);
+static int *SelectorGetIndexVLAImpl(PyMOLGlobals * G, CSelector *I, int sele);
+static void SelectorClean(PyMOLGlobals * G);
+static void SelectorCleanImpl(PyMOLGlobals * G, CSelector *I);
+static int SelectorCheckNeighbors(PyMOLGlobals * G, int maxDepth, ObjectMolecule * obj,
+                                  int at1, int at2, int *zero, int *scratch);
+
+static sele_array_t SelectorUpdateTableSingleObject(PyMOLGlobals * G, ObjectMolecule * obj,
+                                            int req_state,
+                                            int no_dummies, int *idx,
+                                            int n_idx, int numbered_tags);
+
+
+/*========================================================================*/
+/*
+ * Iterator over the selector table (all atoms in universe)
+ *
+ * Selector table must be up-to-date!
+ * Does NOT provide coord or coordset access
+ *
+ * (Implementation in Selector.cpp)
+ */
+class SelectorAtomIterator : public AbstractAtomIterator {
+  CSelector * selector;
+
+public:
+  int a;        // index in selector
+
+  SelectorAtomIterator(CSelector * I) {
+    selector = I;
+
+    // no coord set
+    cs = NULL;
+    idx = -1;
+
+    reset();
+  }
+
+  void reset() override {
+    a = cNDummyAtoms - 1;
+  }
+
+  bool next() override;
+};
+
+bool SelectorAtomIterator::next() {
+  if ((++a) >= selector->NAtom)
+    return false;
+
+  TableRec *table_a = selector->Table + a;
+
+  atm = table_a->atom;
+  obj = selector->Obj[table_a->model];
+
+  return true;
+}
+
+
+/*========================================================================*/
+static int SelectorGetObjAtmOffset(CSelector * I, ObjectMolecule * obj, int offset)
+{
+  if(I->SeleBaseOffsetsValid) {
+    return obj->SeleBase + offset;
+  } else {
+    ov_diff stop_below = obj->SeleBase;
+    ov_diff stop_above = I->NAtom - 1;
+    int result = stop_below;
+    TableRec *i_table = I->Table;
+    ObjectMolecule **i_obj = I->Obj;
+    int step = offset;
+    int cur;
+    int proposed;
+    int prior1 = -1, prior2 = -1;
+
+    /* non-linear hunt to find atom */
+
+    result = stop_below;
+    cur = i_table[result].atom;
+    while(step > 1) {
+      if(cur < offset) {
+        stop_below = result + 1;
+        while(step > 1) {
+          proposed = result + step;
+          if(proposed <= stop_above) {
+            if(i_obj[i_table[proposed].model] == obj) {
+              if(proposed == prior1) {
+                proposed--;
+                step--;         /* guarantee progress (avoid flip flop) */
+              }
+              result = prior1 = proposed;
+              break;
+            } else if(stop_above > proposed) {
+              stop_above = proposed - 1;
+            }
+          }
+          step = (step >> 1);
+        }
+      } else if(cur > offset) {
+        stop_above = result - 1;
+        while(step > 1) {
+          proposed = result - step;
+          if(proposed >= stop_below) {
+            if(i_obj[i_table[proposed].model] == obj) {
+              if(proposed == prior2) {
+                proposed++;
+                step--;         /* guarantee progress (avoid flip flop) */
+              }
+              result = prior2 = proposed;
+              break;
+            }
+          }
+          step = (step >> 1);
+        }
+      } else
+        return result;
+      cur = i_table[result].atom;
+      if(cur == offset)
+        return result;
+    }
+
+    {
+      /* failsafe / linear search */
+      int dir = 1;
+      if(cur > offset)
+        dir = -1;
+      while(1) {                /* TODO: optimize this search algorithm! */
+        if(cur == offset)
+          return result;
+        if(dir > 0) {
+          if(result >= stop_above)
+            break;
+          result++;
+        } else {
+          if(result <= stop_below)
+            break;
+          result--;
+        }
+        if(i_obj[i_table[result].model] != obj)
+          break;
+        cur = i_table[result].atom;
+      }
+    }
+  }
+  return -1;
+}
+
+#define STYP_VALU 0
+#define STYP_OPR1 1
+#define STYP_OPR2 2
+#define STYP_SEL0 3
+#define STYP_SEL1 4
+#define STYP_SEL2 5
+#define STYP_LIST 6
+#define STYP_PRP1 7
+#define STYP_SEL3 8
+#define STYP_PVAL 0
+#define STYP_OP22 9             /* sele oper arg1 arg2 sele */
+
+
+/*                  code   |   type    | priority */
+
+#define SELE_NOT1 ( 0x0100 | STYP_OPR1 | 0x70 )
+#define SELE_BYR1 ( 0x0200 | STYP_OPR1 | 0x20 )
+#define SELE_AND2 ( 0x0300 | STYP_OPR2 | 0x60 )
+#define SELE_OR_2 ( 0x0400 | STYP_OPR2 | 0x40 )
+#define SELE_IN_2 ( 0x0500 | STYP_OPR2 | 0x40 )
+#define SELE_ALLz ( 0x0600 | STYP_SEL0 | 0x90 )
+#define SELE_NONz ( 0x0700 | STYP_SEL0 | 0x90 )
+#define SELE_HETz ( 0x0800 | STYP_SEL0 | 0x80 )
+#define SELE_HYDz ( 0x0900 | STYP_SEL0 | 0x90 )
+#define SELE_VISz ( 0x0A00 | STYP_SEL0 | 0x90 )
+#define SELE_ARD_ ( 0x0B00 | STYP_PRP1 | 0x30 )
+#define SELE_EXP_ ( 0x0C00 | STYP_PRP1 | 0x30 )
+#define SELE_NAMs ( 0x0D00 | STYP_SEL1 | 0x80 )
+#define SELE_ELEs ( 0x0E00 | STYP_SEL1 | 0x80 )
+#define SELE_RSIs ( 0x0F00 | STYP_SEL1 | 0x80 )
+#define SELE_CHNs ( 0x1000 | STYP_SEL1 | 0x80 )
+#define SELE_SEGs ( 0x1100 | STYP_SEL1 | 0x80 )
+#define SELE_MODs ( 0x1200 | STYP_SEL1 | 0x80 )
+#define SELE_IDXs ( 0x1300 | STYP_SEL1 | 0x80 )
+#define SELE_RSNs ( 0x1400 | STYP_SEL1 | 0x80 )
+#define SELE_SELs ( 0x1500 | STYP_SEL1 | 0x80 )
+#define SELE_BVLx ( 0x1600 | STYP_SEL2 | 0x80 )
+#define SELE_ALTs ( 0x1700 | STYP_SEL1 | 0x80 )
+#define SELE_FLGs ( 0x1800 | STYP_SEL1 | 0x80 )
+#define SELE_GAP_ ( 0x1900 | STYP_PRP1 | 0x80 )
+#define SELE_TTYs ( 0x1A00 | STYP_SEL1 | 0x80 )
+#define SELE_NTYs ( 0x1B00 | STYP_SEL1 | 0x80 )
+#define SELE_PCHx ( 0x1C00 | STYP_SEL2 | 0x80 )
+#define SELE_FCHx ( 0x1D00 | STYP_SEL2 | 0x80 )
+#define SELE_ID_s ( 0x1E00 | STYP_SEL1 | 0x80 )
+#define SELE_BNDz ( 0x1F00 | STYP_SEL0 | 0x80 )
+#define SELE_LIK2 ( 0x2000 | STYP_OPR2 | 0x40 )
+#define SELE_NGH1 ( 0x2100 | STYP_OPR1 | 0x20 )
+#define SELE_QVLx ( 0x2200 | STYP_SEL2 | 0x80 )
+#define SELE_BYO1 ( 0x2300 | STYP_OPR1 | 0x20 )
+#define SELE_SSTs ( 0x2400 | STYP_SEL1 | 0x80 )
+#define SELE_STAs ( 0x2500 | STYP_SEL1 | 0x80 )
+#define SELE_PREz ( 0x2500 | STYP_SEL0 | 0x80 )
+#define SELE_WIT_ ( 0x2600 | STYP_OP22 | 0x30 )
+#define SELE_ORIz ( 0x2700 | STYP_SEL0 | 0x90 )
+#define SELE_CENz ( 0x2800 | STYP_SEL0 | 0x90 )
+#define SELE_ENAz ( 0x2900 | STYP_SEL0 | 0x90 )
+#define SELE_REPs ( 0x2A00 | STYP_SEL1 | 0x80 )
+#define SELE_COLs ( 0x2B00 | STYP_SEL1 | 0x80 )
+#define SELE_HBDs ( 0x2C00 | STYP_SEL0 | 0x80 )
+#define SELE_HBAs ( 0x2D00 | STYP_SEL0 | 0x80 )
+#define SELE_BYC1 ( 0x2E00 | STYP_OPR1 | 0x20 )
+#define SELE_BYS1 ( 0x2F00 | STYP_OPR1 | 0x20 )
+#define SELE_BYM1 ( 0x3000 | STYP_OPR1 | 0x20 )
+#define SELE_BYF1 ( 0x3100 | STYP_OPR1 | 0x20 )
+#define SELE_EXT_ ( 0x3200 | STYP_PRP1 | 0x30 )
+#define SELE_BON1 ( 0x3300 | STYP_OPR1 | 0x50 )
+#define SELE_FST1 ( 0x3400 | STYP_OPR1 | 0x30 )
+#define SELE_CAS1 ( 0x3500 | STYP_OPR1 | 0x30 )
+#define SELE_BEY_ ( 0x3600 | STYP_OP22 | 0x30 )
+#define SELE_POLz ( 0x3700 | STYP_SEL0 | 0x90 )
+#define SELE_SOLz ( 0x3800 | STYP_SEL0 | 0x90 )
+#define SELE_ORGz ( 0x3900 | STYP_SEL0 | 0x90 )
+#define SELE_INOz ( 0x3A00 | STYP_SEL0 | 0x90 )
+#define SELE_GIDz ( 0x3B00 | STYP_SEL0 | 0x90 )
+#define SELE_RNKs ( 0x3C00 | STYP_SEL1 | 0x80 )
+#define SELE_PEPs ( 0x3D00 | STYP_SEL1 | 0x80 )
+#define SELE_ACCz ( 0x3E00 | STYP_SEL0 | 0x90 )
+#define SELE_DONz ( 0x3F00 | STYP_SEL0 | 0x90 )
+#define SELE_LST1 ( 0x4000 | STYP_OPR1 | 0x30 )
+#define SELE_NTO_ ( 0x4100 | STYP_OP22 | 0x30 )
+#define SELE_CCLs ( 0x4200 | STYP_SEL1 | 0x80 )
+#define SELE_RCLs ( 0x4300 | STYP_SEL1 | 0x80 )
+#define SELE_PTDz ( 0x4400 | STYP_SEL0 | 0x90 )
+#define SELE_MSKz ( 0x4500 | STYP_SEL0 | 0x90 )
+#define SELE_IOR2 ( 0x4600 | STYP_OPR2 | 0x10 )
+#define SELE_FXDz ( 0x4700 | STYP_SEL0 | 0x90 )
+#define SELE_RSTz ( 0x4800 | STYP_SEL0 | 0x90 )
+#define SELE_ANT2 ( 0x4900 | STYP_OPR2 | 0x60 )
+#define SELE_BYX1 ( 0x4A00 | STYP_OPR1 | 0x20 )
+#define SELE_STRO ( 0x4B00 | STYP_SEL1 | 0x80 )
+#define SELE_METz ( 0x4C00 | STYP_SEL0 | 0x90 )
+#define SELE_BB_z ( 0x4D00 | STYP_SEL0 | 0x90 )
+#define SELE_SC_z ( 0x4E00 | STYP_SEL0 | 0x90 )
+#define SELE_PROP ( 0x4F00 | STYP_SEL3 | 0x80 )
+#define SELE_XVLx ( 0x5000 | STYP_SEL2 | 0x80 )
+#define SELE_YVLx ( 0x5100 | STYP_SEL2 | 0x80 )
+#define SELE_ZVLx ( 0x5200 | STYP_SEL2 | 0x80 )
+#define SELE_CUST ( 0x5300 | STYP_SEL1 | 0x80 )
+#define SELE_RING ( 0x5400 | STYP_OPR1 | 0x20 )
+#define SELE_LABs ( 0x5500 | STYP_SEL1 | 0x80 )
+#define SELE_PROz ( 0x5600 | STYP_SEL0 | 0x90 )
+#define SELE_NUCz ( 0x5700 | STYP_SEL0 | 0x90 )
+
+#define SEL_PREMAX 0x8
+
+static WordKeyValue Keyword[] = {
+  {"not", SELE_NOT1},
+  {"!", SELE_NOT1},
+
+  {"neighbor", SELE_NGH1},
+  {"nbr;", SELE_NGH1},          /* deprecated */
+  {"nbr.", SELE_NGH1},
+
+  {"byfragment", SELE_BYF1},
+  {"byfrag", SELE_BYF1},
+  {"bf.", SELE_BYF1},
+
+  {"byresidue", SELE_BYR1},
+  {"byresi", SELE_BYR1},        /* unofficial */
+  {"byres", SELE_BYR1},
+  {"br;", SELE_BYR1},           /* deprecated */
+  {"br.", SELE_BYR1},
+  {"b;", SELE_BYR1},            /* deprecated */
+
+  {"bychain", SELE_BYC1},
+  {"bc.", SELE_BYC1},
+
+  {"byobject", SELE_BYO1},
+  {"byobj", SELE_BYO1},
+  {"bo;", SELE_BYO1},           /* deprecated */
+  {"bo.", SELE_BYO1},
+
+  {"bound_to", SELE_BON1},
+  {"bto.", SELE_BON1},
+
+  {"bymolecule", SELE_BYM1},
+  {"bymol", SELE_BYM1},
+  {"bm.", SELE_BYM1},
+
+  {"bysegment", SELE_BYS1},
+  {"byseg", SELE_BYS1},
+  {"bysegi", SELE_BYS1},        /* unofficial */
+  {"bs.", SELE_BYS1},
+
+  {"bycalpha", SELE_CAS1},
+  {"bca.", SELE_CAS1},
+
+  {"first", SELE_FST1},
+  {"last", SELE_LST1},
+
+  {"and", SELE_AND2},
+  {"&", SELE_AND2},
+  {"or", SELE_OR_2},
+  {"+", SELE_OR_2},             /* added to mitigate damage caused by the obj1+obj2 parser bug */
+  {"-", SELE_ANT2},             /* added to provide natural complement to the above: an AND NOT or SUBTRACT operation */
+  {"|", SELE_OR_2},
+  {"in", SELE_IN_2},
+
+  {"like", SELE_LIK2},
+  {"l;", SELE_LIK2},
+  {"l.", SELE_LIK2},
+
+  {cKeywordAll, SELE_ALLz},     /* 0 parameter */
+  {"*", SELE_ALLz},             /* 0 parameter */
+
+  {cKeywordNone, SELE_NONz},    /* 0 parameter */
+  {"hetatm", SELE_HETz},        /* 0 parameter */
+  {"het", SELE_HETz},           /* 0 parameter */
+
+  {"hydrogens", SELE_HYDz},     /* 0 parameter */
+  {"hydro", SELE_HYDz},         /* 0 parameter */
+  {"h;", SELE_HYDz},            /* deprecated */
+  {"h.", SELE_HYDz},            /* 0 parameter */
+
+  {"hba.", SELE_HBAs},
+  {"hbd.", SELE_HBDs},
+
+  {"visible", SELE_VISz},       /* 0 parameter */
+  {"v;", SELE_VISz},            /* 0 parameter */
+  {"v.", SELE_VISz},            /* 0 parameter */
+
+  {"around", SELE_ARD_},        /* 1 parameter */
+  {"a;", SELE_ARD_},            /* deprecated */
+  {"a.", SELE_ARD_},            /* 1 parameter */
+
+  {"expand", SELE_EXP_},        /* 1 parameter */
+  {"x;", SELE_EXP_},            /* 1 parameter */
+  {"x.", SELE_EXP_},            /* 1 parameter */
+
+  {"extend", SELE_EXT_},        /* 1 parameter */
+  {"xt.", SELE_EXT_},           /* 1 parameter */
+
+  {"name", SELE_NAMs},
+  {"n;", SELE_NAMs},            /* deprecated */
+  {"n.", SELE_NAMs},
+
+  {"symbol", SELE_ELEs},
+  {"element", SELE_ELEs},
+  {"elem", SELE_ELEs},
+  {"e;", SELE_ELEs},            /* deprecated */
+  {"e.", SELE_ELEs},
+
+  {"enabled", SELE_ENAz},
+
+  {"residue", SELE_RSIs},
+  {"resi", SELE_RSIs},
+  {"resident", SELE_RSIs},
+  {"resid", SELE_RSIs},
+  {"i;", SELE_RSIs},            /* deprecated */
+  {"i.", SELE_RSIs},
+
+  {"rep", SELE_REPs},
+
+  {"color", SELE_COLs},
+  {"cartoon_color", SELE_CCLs},
+  {"ribbon_color", SELE_RCLs},
+
+  {"altloc", SELE_ALTs},
+  {"alt", SELE_ALTs},
+
+  {"flag", SELE_FLGs},
+  {"f;", SELE_FLGs},            /* deprecated */
+  {"f.", SELE_FLGs},
+
+  {"gap", SELE_GAP_},
+
+  {"partial_charge", SELE_PCHx},
+  {"pc;", SELE_PCHx},           /* deprecated */
+  {"pc.", SELE_PCHx},
+
+  {"masked", SELE_MSKz},
+  {"msk.", SELE_MSKz},
+
+  {"protected", SELE_PTDz},
+
+  {"formal_charge", SELE_FCHx},
+  {"fc;", SELE_FCHx},           /* deprecated */
+  {"fc.", SELE_FCHx},
+
+  {"numeric_type", SELE_NTYs},
+  {"nt;", SELE_NTYs},           /* deprecated */
+  {"nt.", SELE_NTYs},
+
+  {"text_type", SELE_TTYs},
+  {"custom", SELE_CUST},
+  {"tt;", SELE_TTYs},           /* deprecated */
+  {"tt.", SELE_TTYs},
+
+  {"chain", SELE_CHNs},
+  {"c;", SELE_CHNs},            /* deprecated */
+  {"c.", SELE_CHNs},
+
+  {cKeywordCenter, SELE_CENz},
+  {"bonded", SELE_BNDz},
+
+  {"segment", SELE_SEGs},
+  {"segid", SELE_SEGs},
+  {"segi", SELE_SEGs},
+  {"s;", SELE_SEGs},            /* deprecated */
+  {"s.", SELE_SEGs},
+
+  {"ss", SELE_SSTs},
+
+  {"state", SELE_STAs},
+
+  {"object", SELE_MODs},
+  {"o.", SELE_MODs},
+
+  {cKeywordOrigin, SELE_ORIz},
+
+  {"model", SELE_MODs},
+  {"m;", SELE_MODs},            /* deprecated */
+  {"m.", SELE_MODs},
+
+  {"index", SELE_IDXs},
+  {"idx.", SELE_IDXs},
+
+  {"id", SELE_ID_s},
+  {"ID", SELE_ID_s},
+  {"rank", SELE_RNKs},
+
+  {"within", SELE_WIT_},
+  {"w.", SELE_WIT_},
+
+  {"near_to", SELE_NTO_},
+  {"nto.", SELE_NTO_},
+
+  {"beyond", SELE_BEY_},
+  {"be.", SELE_BEY_},
+
+  {"donors", SELE_DONz},
+  {"don.", SELE_DONz},
+
+  {"acceptors", SELE_ACCz},
+  {"acc.", SELE_ACCz},
+
+  {"pepseq", SELE_PEPs},
+  {"ps.", SELE_PEPs},
+
+  /*
+     {  "nucseq",  SELE_NUCs },
+     {  "ns.",      SELE_NUCs },
+    */
+
+  {"fixed", SELE_FXDz},
+  {"fxd.", SELE_FXDz},
+
+  {"restrained", SELE_RSTz},
+  {"rst.", SELE_RSTz},
+
+  {"polymer", SELE_POLz},
+  {"pol.", SELE_POLz},
+
+  {"polymer.protein", SELE_PROz},
+  {"polymer.nucleic", SELE_NUCz},
+
+#if 0
+  // User survey winners. Not activated (yet) but ObjectMakeValidName
+  // prints a deprecation warning if these names are used to name
+  // objects or selections.
+  {"protein", SELE_PROz},
+  {"nucleic", SELE_NUCz},
+
+  {"pro.", SELE_PROz},
+  {"nuc.", SELE_NUCz},
+#endif
+
+  {"organic", SELE_ORGz},
+  {"org.", SELE_ORGz},
+
+  {"inorganic", SELE_INOz},
+  {"ino.", SELE_INOz},
+
+  {"solvent", SELE_SOLz},
+  {"sol.", SELE_SOLz},
+
+  {"guide", SELE_GIDz},
+
+  {"present", SELE_PREz},
+  {"pr.", SELE_PREz},
+
+  {"resname", SELE_RSNs},
+  {"resn", SELE_RSNs},
+  {"r;", SELE_RSNs},            /* deprecated */
+  {"r.", SELE_RSNs},
+
+  {"%", SELE_SELs},
+  {"b", SELE_BVLx},             /* 2 operand selection operator */
+  {"q", SELE_QVLx},             /* 2 operand selection operator */
+
+  {"stereo", SELE_STRO},
+
+  {"bycell", SELE_BYX1},
+
+  {"metals", SELE_METz},        /* 0 parameter */
+
+  {"backbone", SELE_BB_z},
+  {"bb.", SELE_BB_z},
+
+  {"sidechain", SELE_SC_z},
+  {"sc.", SELE_SC_z},
+
+  {"p.", SELE_PROP},
+
+  {"x", SELE_XVLx},
+  {"y", SELE_YVLx},
+  {"z", SELE_ZVLx},
+
+  {"byring", SELE_RING},
+  {"label", SELE_LABs},
+
+  {"", 0}
+};
+
+#define SCMP_GTHN 0x01
+#define SCMP_LTHN 0x02
+#define SCMP_RANG 0x03
+#define SCMP_EQAL 0x04
+
+static WordKeyValue AtOper[] = {
+  {">", SCMP_GTHN},
+  {"<", SCMP_LTHN},
+  {"in", SCMP_RANG},
+  {"=", SCMP_EQAL},
+  {"", 0}
+};
+
+static short fcmp(float a, float b, int oper) {
+  switch (oper) {
+  case SCMP_GTHN:
+    return (a > b);
+  case SCMP_LTHN:
+    return (a < b);
+  case SCMP_EQAL:
+    return fabs(a - b) < R_SMALL4;
+  }
+  printf("ERROR: invalid operator %d\n", oper);
+  return false;
+}
+
+#define cINTER_ENTRIES 11
+
+int SelectorRenameObjectAtoms(PyMOLGlobals * G, ObjectMolecule * obj, int sele, int force,
+                              int update_table)
+{
+  int result = 0;
+  int obj_nAtom = obj->NAtom;
+
+  if(update_table) {
+    SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+  }
+  if(obj_nAtom) {
+    int *flag = pymol::calloc<int>(obj_nAtom);
+    if(!flag) {
+      result = -1;
+    } else {
+      AtomInfoType *ai = obj->AtomInfo;
+      int a;
+      for(a = 0; a < obj_nAtom; a++) {
+        if(SelectorIsMember(G, ai->selEntry, sele)) {
+          flag[a] = true;
+          result = true;
+        }
+        ai++;
+      }
+      if (!result && !force) {
+        // nothing selected, no need to continue
+        return 0;
+      }
+      result = ObjectMoleculeRenameAtoms(obj, flag, force);
+    }
+    FreeP(flag);
+  }
+  return result;
+}
+
+int SelectorResidueVLAsTo3DMatchScores(PyMOLGlobals * G, CMatch * match,
+                                       int *vla1, int n1, int state1,
+                                       int *vla2, int n2, int state2,
+                                       float seq_wt,
+                                       float radius, float scale, float base,
+                                       float coord_wt, float rms_exp)
+{
+  CSelector *I = G->Selector;
+  int a, b, *vla;
+  int n_max = (n1 > n2) ? n1 : n2;
+  float *inter1 = pymol::calloc<float>(cINTER_ENTRIES * n1);
+  float *inter2 = pymol::calloc<float>(cINTER_ENTRIES * n2);
+  float *v_ca = pymol::calloc<float>(3 * n_max);
+  if(inter1 && inter2 && v_ca) {
+    int pass;
+
+    for(pass = 0; pass < 2; pass++) {
+      ObjectMolecule *obj;
+      CoordSet *cs;
+      int *neighbor = NULL;
+      AtomInfoType *atomInfo = NULL;
+      ObjectMolecule *last_obj = NULL;
+      float **dist_mat;
+      float *inter;
+      int state;
+      int n;
+      if(!pass) {
+        vla = vla1;
+        state = state1;
+        inter = inter1;
+        n = n1;
+        dist_mat = match->da;
+      } else {
+        vla = vla2;
+        state = state2;
+        inter = inter2;
+        n = n2;
+        dist_mat = match->db;
+      }
+
+      if(state < 0)
+        state = 0;
+      for(a = 0; a < n; a++) {
+        int at_ca1;
+        float *vv_ca = v_ca + a * 3;
+
+        obj = I->Obj[vla[0]];
+        at_ca1 = vla[1];
+        if(obj != last_obj) {
+          ObjectMoleculeUpdateNeighbors(obj);
+          last_obj = obj;
+          neighbor = obj->Neighbor;
+          atomInfo = obj->AtomInfo;
+        }
+
+        if(state < obj->NCSet)
+          cs = obj->CSet[state];
+        else
+          cs = NULL;
+        if(cs && neighbor && atomInfo) {
+          int idx_ca1 = -1;
+          if(obj->DiscreteFlag) {
+            if(cs == obj->DiscreteCSet[at_ca1])
+              idx_ca1 = obj->DiscreteAtmToIdx[at_ca1];
+            else
+              idx_ca1 = -1;
+          } else
+            idx_ca1 = cs->AtmToIdx[at_ca1];
+
+          if(idx_ca1 >= 0) {
+            int mem0, mem1, mem2, mem3, mem4;
+            int nbr0, nbr1, nbr2, nbr3;
+            float *v_ca1 = cs->Coord + 3 * idx_ca1;
+            int idx_cb1 = -1;
+            int cnt = 0;
+
+            copy3f(v_ca1, vv_ca);
+            copy3f(v_ca1, inter + 8);
+
+            /* find attached CB */
+
+            mem0 = at_ca1;
+            nbr0 = neighbor[mem0] + 1;
+            while((mem1 = neighbor[nbr0]) >= 0) {
+              if((atomInfo[mem1].protons == cAN_C) &&
+                 (atomInfo[mem1].name == G->lex_const.CB)) {
+                idx_cb1 = cs->atmToIdx(mem1);
+                break;
+              }
+              nbr0 += 2;
+            }
+
+            /* find remote CA, CB */
+
+            if(idx_cb1 >= 0) {
+              float *v_cb1 = cs->Coord + 3 * idx_cb1;
+
+              mem0 = at_ca1;
+              nbr0 = neighbor[mem0] + 1;
+              while((mem1 = neighbor[nbr0]) >= 0) {
+
+                nbr1 = neighbor[mem1] + 1;
+                while((mem2 = neighbor[nbr1]) >= 0) {
+                  if(mem2 != mem0) {
+                    int idx_ca2 = -1;
+
+                    nbr2 = neighbor[mem2] + 1;
+                    while((mem3 = neighbor[nbr2]) >= 0) {
+                      if((mem3 != mem1) && (mem3 != mem0)) {
+                        if((atomInfo[mem3].protons == cAN_C) &&
+                           (atomInfo[mem3].name == G->lex_const.CA)) {
+                          idx_ca2 = cs->atmToIdx(mem3);
+                          break;
+                        }
+                      }
+                      nbr2 += 2;
+                    }
+                    if(idx_ca2 >= 0) {
+                      float *v_ca2 = cs->Coord + 3 * idx_ca2;
+
+                      nbr2 = neighbor[mem2] + 1;
+                      while((mem3 = neighbor[nbr2]) >= 0) {
+                        if((mem3 != mem1) && (mem3 != mem0)) {
+                          int idx_cb2 = -1;
+                          nbr3 = neighbor[mem3] + 1;
+                          while((mem4 = neighbor[nbr3]) >= 0) {
+                            if((mem4 != mem2) && (mem4 != mem1) && (mem4 != mem0)) {
+                              if((atomInfo[mem4].protons == cAN_C) &&
+                                 (atomInfo[mem4].name == G->lex_const.CB)) {
+                                idx_cb2 = cs->atmToIdx(mem4);
+                                break;
+                              }
+                            }
+                            nbr3 += 2;
+                          }
+
+                          if(idx_cb2 >= 0) {
+                            float *v_cb2 = NULL;
+                            v_cb2 = cs->Coord + 3 * idx_cb2;
+                            {
+                              float angle = get_dihedral3f(v_cb1, v_ca1, v_ca2, v_cb2);
+                              if(idx_cb1 < idx_cb2) {
+                                inter[0] = (float) cos(angle);
+                                inter[1] = (float) sin(angle);
+                              } else {
+                                inter[2] = (float) cos(angle);
+                                inter[3] = (float) sin(angle);
+                              }
+                            }
+                            cnt++;
+                          }
+                        }
+                        nbr2 += 2;
+                      }
+                    }
+                  }
+                  nbr1 += 2;
+                }
+                nbr0 += 2;
+              }
+            }
+          }
+        }
+        vla += 3;
+        inter += cINTER_ENTRIES;
+      }
+      if(dist_mat) {
+        for(a = 0; a < n; a++) {        /* optimize this later */
+          float *vv_ca = v_ca + a * 3;
+          for(b = 0; b < n; b++) {
+            float *vv_cb = v_ca + b * 3;
+            float diff = (float) diff3f(vv_ca, vv_cb);
+            dist_mat[a][b] = diff;
+            dist_mat[b][a] = diff;
+          }
+        }
+      }
+      {
+        MapType *map = MapNew(G, radius, v_ca, n, NULL);
+        if(!pass) {
+          inter = inter1;
+        } else {
+          inter = inter2;
+        }
+        if(map) {
+          int i, h, k, l;
+          MapSetupExpress(map);
+
+          for(a = 0; a < n; a++) {
+            float *v_ca1 = v_ca + 3 * a;
+            float *i_ca1 = inter + cINTER_ENTRIES * a;
+            if(MapExclLocus(map, v_ca1, &h, &k, &l)) {
+              i = *(MapEStart(map, h, k, l));
+              if(i) {
+                b = map->EList[i++];
+                while(b >= 0) {
+                  float *v_ca2 = v_ca + 3 * b;
+                  if(a != b) {
+                    if(within3f(v_ca1, v_ca2, radius)) {
+                      float *i_ca2 = inter + cINTER_ENTRIES * b;
+                      i_ca1[4] += i_ca2[0];     /* add dihedral vectors head-to-tail */
+                      i_ca1[5] += i_ca2[1];
+                      i_ca1[6] += i_ca2[2];
+                      i_ca1[7] += i_ca2[3];
+                    }
+                  }
+                  b = map->EList[i++];
+                }
+              }
+            }
+          }
+          MapFree(map);
+          for(a = 0; a < n; a++) {
+            float nf = (float) sqrt(inter[4] * inter[4] + inter[5] * inter[5]);
+            if(nf > 0.0001F) {
+              inter[4] = inter[4] / nf;
+              inter[5] = inter[5] / nf;
+            }
+            nf = (float) sqrt(inter[6] * inter[6] + inter[7] * inter[7]);
+            if(nf > 0.0001F) {
+
+              inter[6] = inter[6] / nf;
+              inter[7] = inter[7] / nf;
+            }
+            inter += cINTER_ENTRIES;
+          }
+        }
+      }
+    }
+    {
+      const float _0F = 0.0F;
+
+      if((scale != 0.0F) || (seq_wt != 0.0F)) {
+        for(a = 0; a < n1; a++) {
+          float *i1 = inter1 + cINTER_ENTRIES * a;
+          for(b = 0; b < n2; b++) {
+            float *i2 = inter2 + cINTER_ENTRIES * b;
+            float sm[cINTER_ENTRIES], comp1, comp2, comp3 = 1.0F;
+            float score;
+            int c;
+            for(c = 0; c < (cINTER_ENTRIES - 1); c += 2) {
+              if(((i1[c] == _0F) && (i1[c + 1] == _0F))
+                 || ((i2[c] == _0F) && (i2[c + 1] == _0F))) {
+                /* handle glycine case */
+                sm[c] = 1.0F;
+                sm[c + 1] = 1.0F;
+              } else {
+                sm[c] = i1[c] + i2[c];
+                sm[c + 1] = i1[c + 1] + i2[c + 1];
+              }
+            }
+            comp1 = (float)
+              ((sqrt(sm[0] * sm[0] + sm[1] * sm[1]) +
+                sqrt(sm[2] * sm[2] + sm[3] * sm[3])) * 0.25);
+            comp2 = (float)
+              ((sqrt(sm[4] * sm[4] + sm[5] * sm[5]) +
+                sqrt(sm[6] * sm[6] + sm[7] * sm[7])) * 0.25);
+            score = scale * (comp1 * comp2 - base);
+            if(coord_wt != 0.0) {
+              float diff = (float) diff3f(i1 + 8, i2 + 8);
+              comp3 = (float) -log(diff / rms_exp);
+              score = (1 - coord_wt) * score + coord_wt * comp3 * scale;
+            }
+            match->mat[a][b] = seq_wt * match->mat[a][b] + score;
+          }
+        }
+      }
+    }
+  }
+  FreeP(inter1);
+  FreeP(inter2);
+  FreeP(v_ca);
+  return 1;
+}
+
+int SelectorNameIsKeyword(PyMOLGlobals * G, const char *name)
+{
+  CSelector *I = G->Selector;
+  WordType lower_name;
+  OVreturn_word result;
+  UtilNCopyToLower(lower_name, name, sizeof(WordType));
+  if(OVreturn_IS_OK((result = OVLexicon_BorrowFromCString(I->Lex, lower_name)))) {
+    if(OVreturn_IS_OK((result = OVOneToAny_GetKey(I->Key, result.word)))) {
+      return 1;
+    }
+  }
+  return 0;
+}
+
+
+/*========================================================================*/
+static int SelectorIsSelectionDiscrete(PyMOLGlobals * G, int sele, int update_table)
+{
+  CSelector *I = G->Selector;
+  ObjectMolecule **i_obj = I->Obj, *obj;
+  AtomInfoType *ai;
+  int result = false;
+  TableRec *i_table = I->Table, *table_a;
+  ov_size a;
+
+  if(update_table) {
+    SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+  }
+
+  table_a = i_table + cNDummyAtoms;
+  for(a = cNDummyAtoms; a < I->NAtom; a++) {
+    obj = i_obj[table_a->model];
+    ai = obj->AtomInfo + table_a->atom;
+    if(SelectorIsMember(G, ai->selEntry, sele)) {
+      if(obj->DiscreteFlag) {
+        result = true;
+        break;
+      }
+    }
+    table_a++;
+  }
+  return (result);
+}
+
+static sele_array_t SelectorUpdateTableMultiObjectIdxTag(PyMOLGlobals * G,
+                                                 ObjectMolecule ** obj_list,
+                                                 int no_dummies,
+                                                 int **idx_list, int *n_idx_list,
+                                                 int n_obj)
+{
+  int a = 0;
+  int b;
+  int c = 0;
+  int modelCnt;
+  sele_array_t result{};
+  CSelector *I = G->Selector;
+  ObjectMolecule *obj = NULL;
+  int *idx, n_idx;
+
+  PRINTFD(G, FB_Selector)
+    "SelectorUpdateTableMultiObject-Debug: entered ...\n" ENDFD;
+
+  SelectorClean(G);
+
+  I->SeleBaseOffsetsValid = true;       /* all states -> all atoms -> offsets valid */
+  I->NCSet = 0;
+  if(no_dummies) {
+    modelCnt = 0;
+    c = 0;
+  } else {
+    modelCnt = cNDummyModels;
+    c = cNDummyAtoms;
+  }
+  for(b = 0; b < n_obj; b++) {
+    obj = obj_list[b];
+    c += obj->NAtom;
+    if(I->NCSet < obj->NCSet)
+      I->NCSet = obj->NCSet;
+    modelCnt++;
+  }
+  sele_array_calloc(result, c);
+  I->Table = pymol::calloc<TableRec>(c);
+  ErrChkPtr(G, I->Table);
+  I->Obj = pymol::calloc<ObjectMolecule *>(modelCnt);
+  ErrChkPtr(G, I->Obj);
+  if(no_dummies) {
+    modelCnt = 0;
+    c = 0;
+  } else {
+    c = cNDummyAtoms;
+    modelCnt = cNDummyModels;
+  }
+  for(b = 0; b < n_obj; b++) {
+    obj = obj_list[b];
+    idx = idx_list[b];
+    n_idx = n_idx_list[b];
+
+    I->Obj[modelCnt] = obj;
+    obj->SeleBase = c;
+    for(a = 0; a < obj->NAtom; a++) {
+      I->Table[c].model = modelCnt;
+      I->Table[c].atom = a;
+      c++;
+    }
+    if(idx && n_idx) {
+      if(n_idx > 0) {
+        for(a = 0; a < n_idx; a++) {
+          int at = idx[2 * a];  /* index first */
+          int pri = idx[2 * a + 1];     /* then priority */
+          if((at >= 0) && (at < obj->NAtom)) {
+            result[obj->SeleBase + at] = pri;
+          }
+        }
+      }
+    }
+    modelCnt++;
+    I->NModel = modelCnt;
+  }
+  I->NAtom = c;
+  I->Flag1 = pymol::malloc<int>(c);
+  ErrChkPtr(G, I->Flag1);
+  I->Flag2 = pymol::malloc<int>(c);
+  ErrChkPtr(G, I->Flag2);
+  I->Vertex = pymol::malloc<float>(c * 3);
+  ErrChkPtr(G, I->Vertex);
+
+  PRINTFD(G, FB_Selector)
+    "SelectorUpdateTableMultiObject-Debug: leaving...\n" ENDFD;
+
+  return (result);
+}
+
+static int IntInOrder(int *list, int a, int b)
+{
+  return (list[a] <= list[b]);
+}
+
+static int SelectorAddName(PyMOLGlobals * G, int index)
+{
+  CSelector *I = G->Selector;
+  int ok = false;
+  OVreturn_word result;
+  OVstatus status;
+  if(OVreturn_IS_OK((result = OVLexicon_GetFromCString(I->Lex, I->Name[index])))) {
+    if(OVreturn_IS_OK((status = OVOneToOne_Set(I->NameOffset, result.word, index)))) {
+      ok = true;
+    }
+  }
+  return ok;
+}
+
+static int SelectorDelName(PyMOLGlobals * G, int index)
+{
+  CSelector *I = G->Selector;
+  int ok = false;
+  OVreturn_word result;
+  if(OVreturn_IS_OK((result = OVLexicon_BorrowFromCString(I->Lex, I->Name[index])))) {
+    if(OVreturn_IS_OK(OVLexicon_DecRef(I->Lex, result.word)) &&
+       OVreturn_IS_OK(OVOneToOne_DelForward(I->NameOffset, result.word))) {
+      ok = true;
+    }
+  }
+  return ok;
+}
+
+int SelectorClassifyAtoms(PyMOLGlobals * G, int sele, int preserve,
+                          ObjectMolecule * only_object)
+{
+  CSelector *I = G->Selector;
+  ObjectMolecule *obj, *last_obj = NULL, *obj0, *obj1 = NULL;
+  int a, aa, at, a0, a1;
+  AtomInfoType *ai, *last_ai = NULL, *ai0, *ai1;
+  unsigned int mask;
+  int n_dummies = 0;
+
+  int auto_show_classified = SettingGetGlobal_i(G, cSetting_auto_show_classified);
+  int auto_show_mask = (auto_show_classified != 2) ? 0 : cRepBitmask;
+
+  int visRep_organic = cRepCylBit | cRepNonbondedSphereBit;
+  int visRep_inorganic = cRepSphereBit;
+  int visRep_polymer = cRepCartoonBit;
+
+  // detect large systems
+  if (auto_show_classified == -1 &&
+      only_object &&
+      only_object->NAtom * (only_object->DiscreteFlag ?
+        1 : only_object->NCSet) > 5e5) {
+    auto_show_classified = 3;
+  }
+
+  if (auto_show_classified == 3) {
+    visRep_organic = visRep_inorganic = cRepLineBit | cRepNonbondedBit;
+    visRep_polymer = cRepRibbonBit;
+  }
+
+  if(only_object) {
+    SelectorUpdateTableSingleObject(G, only_object, cSelectorUpdateTableAllStates,
+                                    true, NULL, 0, false);
+    n_dummies = 0;
+  } else {
+    SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+    n_dummies = cNDummyAtoms;
+  }
+  a = 0;
+  while(a < I->NAtom) {
+    obj = I->Obj[I->Table[a].model];
+    at = I->Table[a].atom;
+    ai = obj->AtomInfo + at;
+
+    if(SelectorIsMember(G, ai->selEntry, sele) &&
+       ((!AtomInfoSameResidueP(G, ai, last_ai)))) {
+
+      AtomInfoType *guide_atom = NULL;
+
+      /* delimit residue */
+
+      a0 = a - 1;
+      while(a0 >= n_dummies) {
+        obj0 = I->Obj[I->Table[a0].model];
+        if(obj0 != obj)
+          break;
+        ai0 = obj0->AtomInfo + I->Table[a0].atom;
+        if(!AtomInfoSameResidue(G, ai0, ai))
+          break;
+        a0--;
+      }
+
+      a1 = a + 1;
+      while(a1 < I->NAtom) {
+        obj1 = I->Obj[I->Table[a1].model];
+        if(obj1 != obj)
+          break;
+        ai1 = obj1->AtomInfo + I->Table[a1].atom;
+        if(!AtomInfoSameResidue(G, ai1, ai))
+          break;
+        a1++;
+      }
+
+      a0++;
+      a1--;
+
+      mask = 0;
+      if(!ai->hetatm && AtomInfoKnownProteinResName(LexStr(G, ai->resn)))
+        mask = cAtomFlag_polymer | cAtomFlag_protein;
+      else if(!ai->hetatm && AtomInfoKnownNucleicResName(LexStr(G, ai->resn)))
+        mask = cAtomFlag_polymer | cAtomFlag_nucleic;
+      else if(AtomInfoKnownWaterResName(G, LexStr(G, ai->resn)))
+        mask = cAtomFlag_solvent;
+      else {
+
+        /* does this residue have a canonical atoms? */
+
+        int found_ca = false;
+        int found_n = false;
+        int found_c = false;
+        int found_o = false;
+        int found_oh2 = false;
+        int found_carbon = false;
+        int found_cn_bond = false;
+        int found_nc_bond = false;
+        int found_o3_bond = false;
+        int found_o3star = false;
+        int found_c3star = false;
+        int found_c4star = false;
+        int found_c5star = false;
+        int found_o5star = false;
+        int found_p_bond = false;
+        if(obj != last_obj) {
+          ObjectMoleculeUpdateNeighbors(obj);
+          last_obj = obj;
+        }
+
+        ai0 = obj->AtomInfo + I->Table[a0].atom;
+        for(aa = a0; aa <= a1; aa++) {
+          if(ai0->protons == cAN_C) {
+            const char *name = LexStr(G, ai0->name);
+            found_carbon = true;
+            switch (name[0]) {
+            case 'C':
+              switch (name[1]) {
+              case 0:
+                found_c = true;
+                found_cn_bond =
+                  ObjectMoleculeIsAtomBondedToName(obj, I->Table[aa].atom, "N", 0);
+                break;
+              case 'A':
+                switch (name[2]) {
+                case 0:
+                  found_ca = true;
+                  guide_atom = ai0;
+                  break;
+                }
+              case '3':
+                switch (name[2]) {
+                case '*':
+                case '\'':
+                  guide_atom = ai0;
+                  found_c3star = true;
+                  break;
+                }
+                break;
+              case '4':
+                switch (name[2]) {
+                case '*':
+                case '\'':
+                  found_c4star = true;
+                  break;
+                }
+                break;
+              case '5':
+                switch (name[2]) {
+                case '*':
+                case '\'':
+                  found_c5star = true;
+                  break;
+                }
+                break;
+              }
+            }
+          } else if(ai0->protons == cAN_N) {
+            const char *name = LexStr(G, ai0->name);
+            switch (name[0]) {
+            case 'N':
+              switch (name[1]) {
+              case 0:
+                found_n = true;
+                found_nc_bond =
+                  ObjectMoleculeIsAtomBondedToName(obj, I->Table[aa].atom, "C", 0);
+                break;
+              }
+            }
+          } else if(ai0->protons == cAN_O) {
+            const char *name = LexStr(G, ai0->name);
+            switch (name[0]) {
+            case 'O':
+              switch (name[1]) {
+              case 0:
+                found_o = true;
+                break;
+              case 'H':
+                switch (name[2]) {
+                case '2':
+                  found_oh2 = true;
+                  break;
+                }
+              case '3':
+                switch (name[2]) {
+                case '*':
+                case '\'':
+                  found_o3star = true;
+                  found_o3_bond =
+                    ObjectMoleculeIsAtomBondedToName(obj, I->Table[aa].atom, "P", 0);
+                  break;
+                }
+                break;
+              case '5':
+                switch (name[2]) {
+                case '*':
+                case '\'':
+                  found_o5star = true;
+                  break;
+                }
+                break;
+              }
+            }
+          } else if(ai0->protons == cAN_P) {
+
+            const char *name = LexStr(G, ai0->name);
+            switch (name[0]) {
+            case 'P':
+              switch (name[1]) {
+              case 0:
+                found_p_bond =
+                  (ObjectMoleculeIsAtomBondedToName(obj, I->Table[aa].atom, "O3*", 0)
+                   || ObjectMoleculeIsAtomBondedToName(obj, I->Table[aa].atom, "O3'", 0));
+                break;
+              }
+            }
+          }
+          ai0++;
+        }
+
+        if(found_ca && found_n && found_c && found_o && (found_cn_bond || found_nc_bond)) {
+          mask = cAtomFlag_polymer | cAtomFlag_protein;
+        } else if (found_o3star && found_c3star && found_c4star && found_c5star
+               && found_o5star && (found_o3_bond || found_p_bond)) {
+          mask = cAtomFlag_polymer | cAtomFlag_nucleic;
+        } else if(found_carbon)
+          mask = cAtomFlag_organic;
+        else if((found_o || found_oh2) && (a1 == a0))
+          mask = cAtomFlag_solvent;
+        else
+          mask = cAtomFlag_inorganic;
+      }
+
+      /* mark which atoms we can write to */
+
+      ai0 = obj->AtomInfo + I->Table[a0].atom;
+      if(preserve) {
+        printf("NOT IMPLEMENTED\n");
+      } else {
+        auto visRep_polymer_obj = visRep_polymer;
+        if (obj->NAtom < 50) {
+          // prevent single residue objects from disappearing
+          visRep_polymer_obj |= visRep_organic;
+        }
+
+        for(aa = a0; aa <= a1; aa++) {
+          if(SelectorIsMember(G, ai0->selEntry, sele))
+          {
+            // apply styles if atom was unclassified
+            if (auto_show_classified && !(ai0->flags & cAtomFlag_class)) {
+              if (mask & cAtomFlag_organic) {
+                ai0->visRep = (ai0->visRep & auto_show_mask) | visRep_organic;
+              } else if (mask & cAtomFlag_inorganic) {
+                ai0->visRep = (ai0->visRep & auto_show_mask) | visRep_inorganic;
+              } else if (mask & cAtomFlag_polymer) {
+                ai0->visRep = (ai0->visRep & auto_show_mask) | visRep_polymer_obj;
+              }
+            }
+            ai0->flags = (ai0->flags & cAtomFlag_class_mask) | mask;
+          }
+          ai0++;
+        }
+      }
+
+      if((mask & cAtomFlag_polymer)) {
+        ai0 = obj->AtomInfo + I->Table[a0].atom;
+        for(aa = a0; !guide_atom && aa <= a1; aa++) {
+          if(ai0->protons == cAN_C) {
+            const char *name = LexStr(G, ai0->name);
+            switch (name[0]) {
+            case 'C':
+              switch (name[1]) {
+              case 'A':
+                switch (name[2]) {
+                case 0:
+                  guide_atom = ai0;
+                  break;
+                }
+                break;
+              case '4':
+                switch (name[2]) {      /* use C4* as guide atom for nucleic acids */
+                case '*':
+                case '\'':
+                  guide_atom = ai0;
+                  break;
+                }
+                break;
+              }
+            }
+          }
+          ai0++;
+        }
+      }
+
+      if(guide_atom)
+        guide_atom->flags |= cAtomFlag_guide;
+
+      if(a1 > (a + 1))
+        a = a1;
+    }
+    a++;
+  }
+  return true;
+}
+
+static void SelectionInfoInit(SelectionInfoRec * rec)
+{
+  rec->justOneObjectFlag = false;
+  rec->justOneAtomFlag = false;
+}
+
+void SelectorComputeFragPos(PyMOLGlobals * G, ObjectMolecule * obj, int state, int n_frag,
+                            char *prefix, float **vla)
+{
+  CSelector *I = G->Selector;
+  WordType name;
+  int *sele;
+  int *cnt;
+  SelectorUpdateTableSingleObject(G, obj, cSelectorUpdateTableAllStates, true, NULL, 0,
+                                  false);
+  sele = pymol::malloc<int>(n_frag);
+  cnt = pymol::calloc<int>(n_frag);
+  VLACheck(*vla, float, n_frag * 3 + 2);
+  {
+    int a;
+    for(a = 0; a < n_frag; a++) {
+      sprintf(name, "%s%d", prefix, a + 1);
+      sele[a] = SelectorIndexByName(G, name);
+      zero3f((*vla) + 3 * a);
+    }
+  }
+  {
+    int at, a, ati;
+    AtomInfoType *ai;
+    float v[3], *vp;
+    int vert_flag;
+    for(at = 0; at < I->NAtom; at++) {
+
+      ati = I->Table[at].atom;
+      ai = obj->AtomInfo + ati;
+
+      vert_flag = false;
+      for(a = 0; a < n_frag; a++) {
+        if(SelectorIsMember(G, ai->selEntry, sele[a])) {
+          if(!vert_flag) {
+            vert_flag = ObjectMoleculeGetAtomVertex(obj, state, ati, v);
+          }
+          if(vert_flag) {
+            vp = (*vla) + 3 * a;
+            add3f(v, vp, vp);
+            cnt[a]++;
+          }
+        }
+      }
+    }
+  }
+
+  {
+    int a;
+    float div, *vp;
+    for(a = 0; a < n_frag; a++) {
+      if(cnt[a]) {
+        vp = (*vla) + 3 * a;
+        div = 1.0F / cnt[a];
+        scale3f(vp, div, vp);
+      }
+    }
+  }
+
+  FreeP(sele);
+  FreeP(cnt);
+}
+
+MapType *SelectorGetSpacialMapFromSeleCoord(PyMOLGlobals * G, int sele, int state,
+                                            float cutoff, float **coord_vla)
+{
+  //  register CSelector *I = G->Selector;
+
+  int *index_vla = NULL;
+  float *coord = NULL;
+  int n, nc = 0;
+  MapType *result = NULL;
+  if(sele < 0)
+    return NULL;
+  else {
+    CSelector *I = NULL;
+    SelectorInitImpl(G, &I, 0);
+    SelectorUpdateTableImpl(G, I, state, -1);
+    index_vla = SelectorGetIndexVLAImpl(G, I, sele);
+
+    if(index_vla) {
+      n = VLAGetSize(index_vla);
+      if(n)
+        coord = VLAlloc(float, n * 3);
+      if(coord) {
+        int i, a;
+        int st, sta;
+        ObjectMolecule *obj;
+        CoordSet *cs;
+        int at;
+        int idx;
+        float *src, *dst;
+        for(i = 0; i < n; i++) {
+          a = index_vla[i];
+
+          obj = I->Obj[I->Table[a].model];
+          at = +I->Table[a].atom;
+          for(st = 0; st < I->NCSet; st++) {
+
+            if((state < 0) || (st == state)) {
+
+              sta = st;
+              if(sta < obj->NCSet)
+                cs = obj->CSet[sta];
+              else
+                cs = NULL;
+              if(cs) {
+                idx = cs->atmToIdx(at);
+              } else {
+                idx = -1;
+              }
+              if(idx >= 0) {
+                VLACheck(coord, float, nc * 3 + 2);
+                src = cs->Coord + 3 * idx;
+                dst = coord + 3 * nc;
+                *(dst++) = *(src++);
+                *(dst++) = *(src++);
+                *(dst++) = *(src++);
+                nc++;
+              }
+            }
+          }
+        }
+        if(nc) {
+          result = MapNew(G, cutoff, coord, nc, NULL);
+        }
+      }
+    }
+    SelectorFreeImpl(G, I, 0);
+  }
+  VLAFreeP(index_vla);
+  if(coord)
+    VLASize(coord, float, nc * 3);
+  *(coord_vla) = coord;
+  return (result);
+}
+
+static ov_diff SelectGetNameOffset(PyMOLGlobals * G, const char *name, ov_size minMatch,
+                                   int ignCase)
+{
+
+  CSelector *I = G->Selector;
+  int result = -1;
+  while(name[0] == '?')
+    name++;
+  {                             /* first try for perfect match using the dictionary */
+    OVreturn_word res;
+    if(OVreturn_IS_OK((res = OVLexicon_BorrowFromCString(I->Lex, name)))) {
+      if(OVreturn_IS_OK((res = OVOneToOne_GetForward(I->NameOffset, res.word)))) {
+        result = res.word;
+      }
+    }
+  }
+  if(result < 0) {              /* not found, so try partial/ignored-case match */
+
+    int offset, wm, best_match, best_offset;
+    SelectorWordType *I_Name = I->Name;
+    offset = 0;
+    best_offset = -1;
+    best_match = -1;
+
+    while(I_Name[offset][0]) {
+      wm = WordMatch(G, name, I_Name[offset], ignCase);
+      if(wm < 0) {              /* exact match is always good */
+        best_offset = offset;
+        best_match = wm;
+        break;
+      }
+      if(wm > 0) {
+        if(best_match < wm) {
+          best_match = wm;
+          best_offset = offset;
+        } else if(best_match == wm) {   /* uh oh -- ambiguous match */
+          best_offset = -1;
+        }
+      }
+      offset++;
+    }
+    if((best_match < 0) || (best_match > (ov_diff) minMatch))
+      result = best_offset;
+  }
+  return (result);
+}
+
+void SelectorSelectByID(PyMOLGlobals * G, const char *name, ObjectMolecule * obj, int *id,
+                        int n_id)
+{
+  CSelector *I = G->Selector;
+  int min_id, max_id, range, *lookup = NULL;
+  int *atom = NULL;
+  /* this routine only works if IDs cover a reasonable range --
+     should rewrite using a hash table */
+
+  SelectorUpdateTableSingleObject(G, obj, cSelectorUpdateTableAllStates, true, NULL, 0,
+                                  false);
+  atom = pymol::calloc<int>(I->NAtom);
+  if(I->NAtom) {
+
+    /* determine range */
+
+    {
+      int a, cur_id;
+      cur_id = obj->AtomInfo[0].id;
+      min_id = cur_id;
+      max_id = cur_id;
+      for(a = 1; a < obj->NAtom; a++) {
+        cur_id = obj->AtomInfo[a].id;
+        if(min_id > cur_id)
+          min_id = cur_id;
+        if(max_id < cur_id)
+          max_id = cur_id;
+      }
+    }
+
+    /* create cross-reference table */
+
+    {
+      int a, offset;
+
+      range = max_id - min_id + 1;
+      lookup = pymol::calloc<int>(range);
+      for(a = 0; a < obj->NAtom; a++) {
+        offset = obj->AtomInfo[a].id - min_id;
+        if(lookup[offset])
+          lookup[offset] = -1;
+        else {
+          lookup[offset] = a + 1;
+        }
+      }
+    }
+
+    /* iterate through IDs and mark */
+
+    {
+      int i, a, offset, lkup;
+
+      for(i = 0; i < n_id; i++) {
+        offset = id[i] - min_id;
+        if((offset >= 0) && (offset < range)) {
+          lkup = lookup[offset];
+          if(lkup > 0) {
+            atom[lkup - 1] = true;
+          } else if(lkup < 0) {
+            for(a = 0; a < obj->NAtom; a++) {
+              if(obj->AtomInfo[a].id == id[i])
+                atom[a] = true;
+            }
+          }
+        }
+      }
+    }
+  }
+
+  SelectorEmbedSelection(G, atom, name, NULL, true, -1);
+  FreeP(atom);
+  FreeP(lookup);
+  SelectorClean(G);
+}
+
+void SelectorDefragment(PyMOLGlobals * G)
+{
+  CSelector *I = G->Selector;
+  /* restore new member ordering so that CPU can continue to get good cache hit */
+
+  int n_free = 0;
+  int m;
+  int *list, *l;
+  int a;
+  m = I->FreeMember;
+  while(m) {
+    n_free++;
+    m = I->Member[m].next;
+  }
+  if(n_free) {
+    list = pymol::malloc<int>(n_free);
+    l = list;
+    m = I->FreeMember;
+    while(m) {
+      *(l++) = m;
+      m = I->Member[m].next;
+    }
+    UtilSortInPlace(G, list, n_free, sizeof(int), (UtilOrderFn *) IntInOrder);
+    while(n_free > 5000) {      /* compact inactive members when possible */
+      if(list[n_free - 1] == I->NMember) {
+        I->NMember--;
+        n_free--;
+      } else
+        break;
+    }
+    for(a = 0; a < (n_free - 1); a++) {
+      I->Member[list[a]].next = list[a + 1];
+    }
+    I->Member[list[n_free - 1]].next = 0;
+    I->FreeMember = list[0];
+    FreeP(list);
+  }
+}
+
+typedef struct {
+  int color;
+  int sele;
+} ColorectionRec;
+
+static void SelectorDeleteSeleAtOffset(PyMOLGlobals * G, int n)
+{
+  CSelector *I = G->Selector;
+  int id;
+  id = I->Info[n].ID;
+  SelectorDelName(G, n);
+  SelectorPurgeMembers(G, id);
+
+  I->NActive--;
+  {
+    OVreturn_word result;
+    /* repoint the name index at the relocated entry */
+    if(OVreturn_IS_OK(result = OVOneToOne_GetReverse(I->NameOffset, I->NActive))) {
+      OVOneToOne_DelForward(I->NameOffset, result.word);
+      OVOneToOne_Set(I->NameOffset, result.word, n);
+    }
+    if (I->Name[n]!=I->Name[I->NActive])
+      strcpy(I->Name[n], I->Name[I->NActive]);
+    I->Info[n] = I->Info[I->NActive];
+    I->Name[I->NActive][0] = 0;
+  }
+}
+
+char *SelectorGetNameFromIndex(PyMOLGlobals * G, int index)
+{
+  CSelector *I = G->Selector;
+  int a;
+  for(a = 1; a < I->NActive; a++) {
+    if(I->Info[a].ID == index) {
+      return I->Name[a];
+    }
+  }
+  return NULL;
+}
+
+#ifndef _PYMOL_NOPY
+static void SelectorDeleteIndex(PyMOLGlobals * G, int index)
+{
+  CSelector *I = G->Selector;
+  int n = 0;
+  int a;
+  for(a = 1; a < I->NActive; a++) {
+    if(I->Info[a].ID == index) {
+      n = a;
+      break;
+    }
+  }
+  if(n)
+    SelectorDeleteSeleAtOffset(G, n);
+}
+#endif
+
+#define cSSMaxHBond 6
+
+#define cSSHelix3HBond          0x0001
+#define cSSHelix4HBond          0x0002
+#define cSSHelix5HBond          0x0004
+#define cSSGotPhiPsi            0x0008
+#define cSSPhiPsiHelix          0x0010
+#define cSSPhiPsiNotHelix       0x0020
+#define cSSPhiPsiStrand         0x0040
+#define cSSPhiPsiNotStrand      0x0080
+#define cSSAntiStrandSingleHB   0x0100
+#define cSSAntiStrandDoubleHB   0x0200
+#define cSSAntiStrandBuldgeHB   0x0400
+#define cSSAntiStrandSkip       0x0800
+#define cSSParaStrandSingleHB   0x1000
+#define cSSParaStrandDoubleHB   0x2000
+#define cSSParaStrandSkip       0x4000
+
+#define cSSBreakSize 5
+
+typedef struct {
+  int real;
+  int ca, n, c, o;              /* indices in selection-table space */
+  float phi, psi;
+  char ss, ss_save;
+  int flags;
+  int n_acc, n_don;
+  int acc[cSSMaxHBond];         /* interactions where this residue is an acceptor */
+  int don[cSSMaxHBond];         /* interactions where this residue is a donor */
+  ObjectMolecule *obj;
+  int preserve;
+  int present;
+} SSResi;
+
+int SelectorAssignSS(PyMOLGlobals * G, int target, int present,
+                     int state_value, int preserve, ObjectMolecule * single_object,
+                     int quiet)
+{
+
+  /* PyMOL's secondary structure assignment algorithm: 
+
+     General principal -- if it looks like a duck, then it's a duck:
+
+     I. Helices
+     - must have reasonably helical geometry within the helical span
+     - near-ideal geometry guarantees helix assignment
+     - a continuous ladder stre i+3, i+4, or i+5 hydrogen bonding
+     with permissible geometry can reinforce marginal cases
+     - a minimum helix is three residues with i+3 H-bond
+
+     II. Sheets
+     - Hydrogen bonding ladders are the primary guide
+     - Out-of-the envelope 
+     - 1-residue gaps in sheets are filled unless there
+     is a turn.
+   */
+
+  CSelector *I = G->Selector;
+  SSResi *res;
+  int n_res = 0;
+  int state_start, state_stop, state;
+  int consensus = true;
+  int first_last_only = false;
+  int first_pass = true;
+
+  if(!single_object) {
+    if(state_value < 0) {
+      switch (state_value) {
+      case -2:                 /* api: state=-1: current global state */
+      case -3:                 /* api: state=-2: effective object states TO DO! */
+        SelectorUpdateTable(G, state_value, -1);
+        break;
+      default:
+        SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+        break;
+      }
+    } else {
+      SelectorUpdateTable(G, state_value, -1);
+    }
+  } else {
+    SelectorUpdateTableSingleObject(G, single_object, state_value, false, NULL, 0, 0);
+  }
+
+  res = VLACalloc(SSResi, 1000);
+
+  if(state_value < 0) {
+    if(state_value == -4)
+      consensus = false;
+    if(state_value == -5)
+      first_last_only = true;
+    state_start = 0;
+    state_stop = SelectorGetSeleNCSet(G, target);
+
+    if (state_value == -2) {
+      /* api: state=-1: current global state */
+      StateIterator iter(G, NULL, state_value, state_stop);
+      if (iter.next()) {
+        state_start = iter.state;
+        state_stop = iter.state + 1;
+      }
+    }
+  } else {
+    state_start = state_value;
+    state_stop = state_value + 1;
+  }
+  for(state = state_start; state < state_stop; state++) {
+    int a;
+    ObjectMolecule *obj;
+    int aa, a0, a1, at, idx;
+    AtomInfoType *ai, *ai0, *ai1;
+    CoordSet *cs;
+    ObjectMolecule *last_obj = NULL;
+    /* first, we need to count the number of residues under consideration */
+
+    if(first_pass) {
+      for(a = cNDummyAtoms; a < I->NAtom; a++) {
+
+        obj = I->Obj[I->Table[a].model];
+        at = +I->Table[a].atom;
+        ai = obj->AtomInfo + at;
+
+        /* see if CA coordinates exist... */
+
+        if(SelectorIsMember(G, ai->selEntry, present)) {
+
+          if((ai->protons == cAN_C) && (WordMatchExact(G, G->lex_const.CA, ai->name, true))) {
+
+            if(last_obj != obj) {
+              ObjectMoleculeUpdateNeighbors(obj);
+              ObjectMoleculeVerifyChemistry(obj, state_value);
+              last_obj = obj;
+            }
+            /* delimit residue */
+
+            a0 = a - 1;
+            while(a0 >= cNDummyAtoms) {
+              ai0 = I->Obj[I->Table[a0].model]->AtomInfo + I->Table[a0].atom;
+              if(!AtomInfoSameResidue(G, ai0, ai))
+                break;
+              a0--;
+            }
+
+            a1 = a + 1;
+            while(a1 < I->NAtom) {
+              ai1 = I->Obj[I->Table[a1].model]->AtomInfo + I->Table[a1].atom;
+              if(!AtomInfoSameResidue(G, ai1, ai))
+                break;
+              a1++;
+            }
+
+            {
+              int found_N = 0;
+              int found_O = 0;
+              int found_C = 0;
+
+              /* locate key atoms */
+
+              for(aa = a0 + 1; aa < a1; aa++) {
+                ai = I->Obj[I->Table[aa].model]->AtomInfo + I->Table[aa].atom;
+                if((ai->protons == cAN_C) && (WordMatchExact(G, G->lex_const.C, ai->name, true))) {
+                  found_C = aa;
+                }
+                if((ai->protons == cAN_N) && (WordMatchExact(G, G->lex_const.N, ai->name, true))) {
+                  found_N = aa;
+                }
+                if((ai->protons == cAN_O) && (WordMatchExact(G, G->lex_const.O, ai->name, true))) {
+                  found_O = aa;
+                }
+              }
+
+              if((found_C) && (found_N) && (found_O)) {
+
+                VLACheck(res, SSResi, n_res);
+                res[n_res].n = found_N;
+                res[n_res].o = found_O;
+                res[n_res].c = found_C;
+                res[n_res].ca = a;
+                res[n_res].obj = I->Obj[I->Table[a].model];
+                res[n_res].real = true;
+
+                n_res++;
+
+              } else {
+                if(!quiet) {
+                  PRINTFB(G, FB_Selector, FB_Warnings)
+                    " AssignSS-Warning: Ignoring incomplete residue /%s/%s/%s/%d%c ...\n",
+                    obj->Name, LexStr(G, ai->segi), LexStr(G, ai->chain), ai->resv, ai->getInscode(true) ENDFB(G);
+                }
+              }
+            }
+          }
+        }
+      }                         /* count pass */
+
+      if(preserve) {            /* if we're in preserve mode, then mark which objects don't get changed */
+        int a, b;
+        char ss;
+        ObjectMolecule *p_obj = NULL;
+        SSResi *r, *r2;
+        for(a = 0; a < n_res; a++) {
+          r = res + a;
+          if(r->real) {
+            if(p_obj != r->obj) {
+              ss = r->obj->AtomInfo[I->Table[r->ca].atom].ssType[0];
+              if((ss == 'S') || (ss == 'H') || (ss == 's') || (ss == 'h')) {
+                p_obj = r->obj;
+
+                b = a;
+                while(b >= 0) {
+                  r2 = res + b;
+                  if(p_obj == r2->obj)
+                    r2->preserve = true;
+                  b--;
+                }
+                b = a + 1;
+                while(b < n_res) {
+                  r2 = res + b;
+                  if(p_obj == r2->obj)
+                    r2->preserve = true;
+                  b++;
+                }
+              }
+            }
+          }
+        }
+      }
+      /*  printf("n_res %d\n",n_res); */
+
+      /* now, let's repack res. into discrete chunks so that we can do easy gap & ladder analysis */
+
+      {
+        SSResi *res2;
+        int a;
+        int n_res2 = 0;
+        int add_break;
+        int at_ca0, at_ca1;
+
+        res2 = VLACalloc(SSResi, n_res * 2);
+
+        for(a = 0; a < n_res; a++) {
+          add_break = false;
+
+          if(!a) {
+            add_break = true;
+          } else if(res[a].obj != res[a - 1].obj) {
+            add_break = true;
+          } else if(res[a].obj) {
+            at_ca0 = I->Table[res[a].ca].atom;
+            at_ca1 = I->Table[res[a - 1].ca].atom;
+            if(!ObjectMoleculeCheckBondSep(res[a].obj, at_ca0, at_ca1, 3)) {    /* CA->N->C->CA = 3 bonds */
+              add_break = true;
+            }
+          }
+
+          if(add_break) {
+            n_res2 += cSSBreakSize;
+          }
+
+          VLACheck(res2, SSResi, n_res2);
+          res2[n_res2] = res[a];
+          n_res2++;
+        }
+
+        n_res2 += cSSBreakSize;
+        VLACheck(res2, SSResi, n_res2);
+
+        VLAFreeP(res);
+        res = res2;
+        n_res = n_res2;
+      }
+      first_pass = false;
+    }
+
+    /* okay, the rest of this loop runs for each coordinate set */
+
+    {
+      int b;
+      for(a = 0; a < n_res; a++) {
+        res[a].present = res[a].real;
+
+        if(res[a].present) {
+          obj = res[a].obj;
+          if(state < obj->NCSet)
+            cs = obj->CSet[state];
+          else
+            cs = NULL;
+          for(b = 0; b < 4; b++) {
+            if(cs) {
+              switch (b) {
+              case 0:
+                at = I->Table[res[a].n].atom;
+                break;
+              case 1:
+                at = I->Table[res[a].o].atom;
+                break;
+              case 2:
+                at = I->Table[res[a].c].atom;
+                break;
+              default:
+              case 3:
+                at = I->Table[res[a].ca].atom;
+                break;
+              }
+              idx = cs->atmToIdx(at);
+            } else
+              idx = -1;
+            if(idx < 0) {
+              res[a].present = false;
+            }
+          }
+        }
+      }
+    }
+
+    /* next, we need to record hydrogen bonding relationships */
+
+    {
+
+      MapType *map;
+      float *v0, *v1;
+      int n1;
+      int i, h, k, l;
+      int at;
+
+      int a, aa;
+      int a0, a1;               /* SS res space */
+      int as0, as1;             /* selection space */
+      int at0, at1;             /* object-atom space */
+      int exclude;
+
+      ObjectMolecule *obj0, *obj1;
+
+      CoordSet *cs;
+      float cutoff;
+      HBondCriteria hbcRec, *hbc;
+      int *zero = NULL, *scratch = NULL;
+
+      {
+        int max_n_atom = I->NAtom;
+        ObjectMolecule *lastObj = NULL;
+        for(a = cNDummyAtoms; a < I->NAtom; a++) {
+          ObjectMolecule *obj = I->Obj[I->Table[a].model];
+          if(obj != lastObj) {
+            if(max_n_atom < obj->NAtom)
+              max_n_atom = obj->NAtom;
+            lastObj = obj;
+          }
+        }
+        zero = pymol::calloc<int>(max_n_atom);
+        scratch = pymol::malloc<int>(max_n_atom);
+      }
+
+      for(a = 0; a < n_res; a++) {
+        res[a].n_acc = 0;
+        res[a].n_don = 0;
+      }
+      hbc = &hbcRec;
+      ObjectMoleculeInitHBondCriteria(G, hbc);
+
+      /* use parameters which reflect the spirit of Kabsch and Sander
+         ( i.e. long hydrogen-bonds/polar electrostatic interactions ) */
+
+      hbc->maxAngle = 63.0F;
+      hbc->maxDistAtMaxAngle = 3.2F;
+      hbc->maxDistAtZero = 4.0F;
+      hbc->power_a = 1.6F;
+      hbc->power_b = 5.0F;
+      hbc->cone_dangle = 0.0F;  /* 180 deg. */
+      if(hbc->maxDistAtMaxAngle != 0.0F) {
+        hbc->factor_a = 0.5F / (float) pow(hbc->maxAngle, hbc->power_a);
+        hbc->factor_b = 0.5F / (float) pow(hbc->maxAngle, hbc->power_b);
+      }
+
+      cutoff = hbc->maxDistAtMaxAngle;
+      if(cutoff < hbc->maxDistAtZero) {
+        cutoff = hbc->maxDistAtZero;
+      }
+
+      n1 = 0;
+
+      for(aa = 0; aa < I->NAtom; aa++) {        /* first, clear flags */
+        I->Flag1[aa] = false;
+        I->Flag2[aa] = false;
+      }
+
+      for(a = 0; a < n_res; a++) {
+        if(res[a].present) {
+          obj0 = res[a].obj;
+
+          if(obj0) {
+            /* map will contain the h-bond backbone nitrogens */
+
+            aa = res[a].n;
+            at = I->Table[aa].atom;
+            I->Flag2[aa] = a;   /* so we can find the atom again... */
+
+            if(state < obj0->NCSet)
+              cs = obj0->CSet[state];
+            else
+              cs = NULL;
+            if(cs) {
+              if(CoordSetGetAtomVertex(cs, at,
+                    I->Vertex + 3 * aa /* record coordinate */)) {
+                I->Flag1[aa] = true;
+                n1++;
+              }
+            }
+
+            /* also copy O coordinates for usage below */
+
+            aa = res[a].o;
+            at = I->Table[aa].atom;
+
+            if(state < obj0->NCSet)
+              cs = obj0->CSet[state];
+            else
+              cs = NULL;
+            if(cs) {
+              CoordSetGetAtomVertex(cs, at,
+                  I->Vertex + 3 * aa /* record coordinate */);
+            }
+          }
+        }
+      }
+
+      if(n1) {
+        short too_many_atoms = false;
+        map = MapNewFlagged(G, -cutoff, I->Vertex, I->NAtom, NULL, I->Flag1);
+        if(map) {
+          MapSetupExpress(map);
+
+          for(a0 = 0; a0 < n_res; a0++) {
+
+            if(res[a0].obj) {
+
+              /* now iterate through carbonyls */
+              obj0 = res[a0].obj;
+              as0 = res[a0].o;
+              at0 = I->Table[as0].atom;
+
+              v0 = I->Vertex + 3 * as0;
+              if(MapExclLocus(map, v0, &h, &k, &l)) {
+                i = *(MapEStart(map, h, k, l));
+                if(i) {
+                  int nat = 0;
+                  as1 = map->EList[i++];
+                  while(as1 >= 0) {
+                    v1 = I->Vertex + 3 * as1;
+
+                    if(within3f(v0, v1, cutoff)) {
+
+                      obj1 = I->Obj[I->Table[as1].model];
+                      at1 = I->Table[as1].atom;
+
+                      if(obj0 == obj1) {        /* don't count hbonds between adjacent residues */
+                        exclude = SelectorCheckNeighbors(G, 5, obj0, at0, at1,
+                                                         zero, scratch);
+                      } else {
+                        exclude = false;
+                      }
+
+                      /*                      if(!exclude) {
+                         printf("at1 %s %s vs at0 %s %s\n",
+                         obj1->AtomInfo[at1].resi,
+                         obj1->AtomInfo[at1].name,
+                         obj0->AtomInfo[at0].resi,
+                         obj0->AtomInfo[at0].name
+                         );
+                         }
+                       */
+                      if((!exclude) && ObjectMoleculeGetCheckHBond(NULL, NULL, obj1,    /* donor first */
+                                                                   at1, state, obj0,    /* then acceptor */
+                                                                   at0, state, hbc)) {
+
+                        /*                        printf(" found hbond between acceptor resi %s and donor resi %s\n",
+                           res[a0].obj->AtomInfo[at0].resi,
+                           res[I->Flag2[as1]].obj->AtomInfo[I->Table[as1].atom].resi); */
+
+                        a1 = I->Flag2[as1];     /* index in SS n_res space */
+
+                        /* store acceptor link */
+
+                        n1 = res[a0].n_acc;
+                        if(n1 < (cSSMaxHBond - 1)) {
+                          res[a0].acc[n1] = a1;
+                          res[a0].n_acc = n1 + 1;
+                        }
+
+                        /* store donor link */
+
+                        n1 = res[a1].n_don;
+                        if(n1 < (cSSMaxHBond - 1)) {
+                          res[a1].don[n1] = a0;
+                          res[a1].n_don = n1 + 1;
+                        }
+                      }
+                    }
+                    as1 = map->EList[i++];
+		    nat++;
+                  }
+                  if (nat > 1000){ // if map returns more than 1000 atoms within 4, should be a dss error
+                    too_many_atoms = true;
+                    break;
+                  }
+                }
+              }
+            }
+          }
+        }
+        MapFree(map);
+	if (too_many_atoms){
+	  PRINTFB(G, FB_Selector, FB_Errors)
+	    " %s: ERROR: Unreasonable number of neighbors for dss, cannot assign secondary structure.\n", __func__ ENDFB(G);
+	}
+      }
+      FreeP(zero);
+      FreeP(scratch);
+    }
+
+    {                           /* compute phi, psi's */
+
+      SSResi *r;
+      int a;
+
+      float helix_psi_delta, helix_phi_delta;
+      float strand_psi_delta, strand_phi_delta;
+
+      float helix_psi_target = SettingGet_f(G, NULL, NULL, cSetting_ss_helix_psi_target);
+      float helix_psi_include =
+        SettingGet_f(G, NULL, NULL, cSetting_ss_helix_psi_include);
+      float helix_psi_exclude =
+        SettingGet_f(G, NULL, NULL, cSetting_ss_helix_psi_exclude);
+
+      float helix_phi_target = SettingGet_f(G, NULL, NULL, cSetting_ss_helix_phi_target);
+      float helix_phi_include =
+        SettingGet_f(G, NULL, NULL, cSetting_ss_helix_phi_include);
+      float helix_phi_exclude =
+        SettingGet_f(G, NULL, NULL, cSetting_ss_helix_phi_exclude);
+
+      float strand_psi_target =
+        SettingGet_f(G, NULL, NULL, cSetting_ss_strand_psi_target);
+      float strand_psi_include =
+        SettingGet_f(G, NULL, NULL, cSetting_ss_strand_psi_include);
+      float strand_psi_exclude =
+        SettingGet_f(G, NULL, NULL, cSetting_ss_strand_psi_exclude);
+
+      float strand_phi_target =
+        SettingGet_f(G, NULL, NULL, cSetting_ss_strand_phi_target);
+      float strand_phi_include =
+        SettingGet_f(G, NULL, NULL, cSetting_ss_strand_phi_include);
+      float strand_phi_exclude =
+        SettingGet_f(G, NULL, NULL, cSetting_ss_strand_phi_exclude);
+
+      for(a = 0; a < n_res; a++) {
+        r = res + a;
+        if(r->real && ((r - 1)->real)) {
+          r->flags = 0;
+
+          if(ObjectMoleculeGetPhiPsi
+             (r->obj, I->Table[r->ca].atom, &r->phi, &r->psi, state)) {
+            r->flags |= cSSGotPhiPsi;
+
+            helix_psi_delta = (float) fabs(r->psi - helix_psi_target);
+            strand_psi_delta = (float) fabs(r->psi - strand_psi_target);
+            helix_phi_delta = (float) fabs(r->phi - helix_phi_target);
+            strand_phi_delta = (float) fabs(r->phi - strand_phi_target);
+
+            if(helix_psi_delta > 180.0F)
+              helix_psi_delta = 360.0F - helix_psi_delta;
+            if(strand_psi_delta > 180.0F)
+              strand_psi_delta = 360.0F - strand_psi_delta;
+            if(helix_phi_delta > 180.0F)
+              helix_phi_delta = 360.0F - helix_phi_delta;
+            if(strand_phi_delta > 180.0F)
+              strand_phi_delta = 360.0F - strand_phi_delta;
+
+            /* printf("helix %d strand %d\n",helix_delta,strand_delta); */
+
+            if((helix_psi_delta > helix_psi_exclude) ||
+               (helix_phi_delta > helix_phi_exclude)) {
+              r->flags |= cSSPhiPsiNotHelix;
+            } else if((helix_psi_delta < helix_psi_include) &&
+                      (helix_phi_delta < helix_phi_include)) {
+              r->flags |= cSSPhiPsiHelix;
+            }
+
+            if((strand_psi_delta > strand_psi_exclude) ||
+               (strand_phi_delta > strand_phi_exclude)) {
+              r->flags |= cSSPhiPsiNotStrand;
+            } else if((strand_psi_delta < strand_psi_include) &&
+                      (strand_phi_delta < strand_phi_include)) {
+              r->flags |= cSSPhiPsiStrand;
+            }
+          }
+        }
+      }
+    }
+
+    /* by default, tentatively assign everything as loop */
+
+    {
+      int a;
+      for(a = cSSBreakSize; a < (n_res - cSSBreakSize); a++) {
+        if(res[a].present)
+          res[a].ss = 'L';
+      }
+    }
+
+    {
+      SSResi *r, *r2;
+      int a, b, c;
+
+      for(a = cSSBreakSize; a < (n_res - cSSBreakSize); a++) {
+        r = res + a;
+        if(r->real) {
+
+          /* look for tell-tale i+3,4,5 hydrogen bonds for helix  */
+
+          /* is residue an acceptor for i+3,4,5 residue? */
+          for(b = 0; b < r->n_acc; b++) {
+            r->flags |=
+              ((r->acc[b] == (a + 3)) ? cSSHelix3HBond : 0) |
+              ((r->acc[b] == (a + 4)) ? cSSHelix4HBond : 0) |
+              ((r->acc[b] == (a + 5)) ? cSSHelix5HBond : 0);
+
+          }
+
+          /* is residue a donor for i-3,4,5 residue */
+          for(b = 0; b < r->n_don; b++) {
+            r->flags |=
+              ((r->don[b] == (a - 3)) ? cSSHelix3HBond : 0) |
+              ((r->don[b] == (a - 4)) ? cSSHelix4HBond : 0) |
+              ((r->don[b] == (a - 5)) ? cSSHelix5HBond : 0);
+
+          }
+
+          /*        if(r->flags & (cSSHelix3HBond | cSSHelix4HBond | cSSHelix5HBond)) {
+             printf("HelixHB %s \n",
+             r->obj->AtomInfo[I->Table[r->ca].atom].resi);
+             }
+           */
+
+          /* look for double h-bonded antiparallel beta sheet pairs:
+           * 
+           *  \ /\ /
+           *   N  C
+           *   #  O
+           *   O  #
+           *   C  N
+           *  / \/ \
+           *
+           */
+
+          for(b = 0; b < r->n_acc; b++) {       /* iterate through acceptors */
+            r2 = (res + r->acc[b]);
+            if(r2->real) {
+              for(c = 0; c < r2->n_acc; c++) {
+                if(r2->acc[c] == a) {   /* found a pair */
+                  r->flags |= cSSAntiStrandDoubleHB;
+                  r2->flags |= cSSAntiStrandDoubleHB;
+
+                  /*                printf("anti double %s to %s\n",
+                     r->obj->AtomInfo[I->Table[r->ca].atom].resi,
+                     r2->obj->AtomInfo[I->Table[r2->ca].atom].resi); */
+
+                }
+              }
+            }
+          }
+
+          /* look for antiparallel beta buldges
+           * 
+           *     CCNC
+           *  \ / O  \ /
+           *   N      C
+           *   #      O
+           *    O    #
+           *     C  N
+           *    / \/ \
+           *
+           */
+
+          for(b = 0; b < r->n_acc; b++) {       /* iterate through acceptors */
+            r2 = (res + r->acc[b]) + 1; /* go forward 1 */
+            if(r2->real) {
+              for(c = 0; c < r2->n_acc; c++) {
+                if(r2->acc[c] == a) {   /* found a buldge */
+                  r->flags |= cSSAntiStrandDoubleHB;
+                  r2->flags |= cSSAntiStrandBuldgeHB;
+                  (r2 - 1)->flags |= cSSAntiStrandBuldgeHB;
+
+                  /*                printf("anti BULDGE %s to %s %s\n",
+                     r->obj->AtomInfo[I->Table[r->ca].atom].resi,
+                     r2->obj->AtomInfo[I->Table[r2->ca].atom].resi,
+                     r2->obj->AtomInfo[I->Table[(r2-1)->ca].atom].resi); */
+
+                }
+              }
+            }
+          }
+
+          /* look for antiparallel beta sheet ladders (single or double)
+           *
+           *        O
+           *     N  C
+           *  \ / \/ \ /
+           *   C      N
+           *   O      #
+           *   #      O
+           *   N      C
+           *  / \ /\ / \
+           *     C  N
+           *     O
+           */
+
+          if((r + 1)->real && (r + 2)->real) {
+
+            for(b = 0; b < r->n_acc; b++) {     /* iterate through acceptors */
+              r2 = (res + r->acc[b]) - 2;       /* go back 2 */
+              if(r2->real) {
+
+                for(c = 0; c < r2->n_acc; c++) {
+
+                  if(r2->acc[c] == a + 2) {     /* found a ladder */
+
+                    (r)->flags |= cSSAntiStrandSingleHB;
+                    (r + 1)->flags |= cSSAntiStrandSkip;
+                    (r + 2)->flags |= cSSAntiStrandSingleHB;
+
+                    (r2)->flags |= cSSAntiStrandSingleHB;
+                    (r2 + 1)->flags |= cSSAntiStrandSkip;
+                    (r2 + 2)->flags |= cSSAntiStrandSingleHB;
+
+                    /*                  printf("anti ladder %s %s to %s %s\n",
+                       r->obj->AtomInfo[I->Table[r->ca].atom].resi,
+                       r->obj->AtomInfo[I->Table[(r+2)->ca].atom].resi,
+                       r2->obj->AtomInfo[I->Table[r2->ca].atom].resi,
+                       r2->obj->AtomInfo[I->Table[(r2+2)->ca].atom].resi); */
+                  }
+                }
+              }
+            }
+          }
+
+          /* look for parallel beta sheet ladders 
+           *
+
+           *    \ /\ /
+           *     C  N
+           *    O    #
+           *   #      O
+           *   N      C
+           *  / \ /\ / \
+           *     C  N
+           *     O
+           */
+
+          if((r + 1)->real && (r + 2)->real) {
+
+            for(b = 0; b < r->n_acc; b++) {     /* iterate through acceptors */
+              r2 = (res + r->acc[b]);
+              if(r2->real) {
+
+                for(c = 0; c < r2->n_acc; c++) {
+
+                  if(r2->acc[c] == a + 2) {     /* found a ladder */
+
+                    (r)->flags |= cSSParaStrandSingleHB;
+                    (r + 1)->flags |= cSSParaStrandSkip;
+                    (r + 2)->flags |= cSSParaStrandSingleHB;
+
+                    (r2)->flags |= cSSParaStrandDoubleHB;
+
+                    /*                                    printf("parallel ladder %s %s to %s \n",
+                       r->obj->AtomInfo[I->Table[r->ca].atom].resi,
+                       r->obj->AtomInfo[I->Table[(r+2)->ca].atom].resi,
+                       r2->obj->AtomInfo[I->Table[r2->ca].atom].resi); */
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+
+    {
+      int a;
+      SSResi *r;
+      /* convert flags to assignments */
+
+      /* HELICES FIRST */
+
+      for(a = cSSBreakSize; a < (n_res - cSSBreakSize); a++) {
+        r = res + a;
+
+        if(r->real) {
+          /* clean internal helical residues are easy to find using H-bonds */
+
+          if(((r - 1)->flags & (cSSHelix3HBond | cSSHelix4HBond | cSSHelix5HBond)) &&
+             ((r)->flags & (cSSHelix3HBond | cSSHelix4HBond | cSSHelix5HBond)) &&
+             ((r + 1)->flags & (cSSHelix3HBond | cSSHelix4HBond | cSSHelix5HBond))) {
+            if(!(r->flags & (cSSPhiPsiNotHelix))) {
+              r->ss = 'H';
+            }
+          }
+
+          /*
+             if(((r-1)->flags & (cSSHelix3HBond )) &&
+             ((r  )->flags & (cSSHelix3HBond )) &&
+             ((r+1)->flags & (cSSHelix3HBond ))) {
+             if(!(r->flags & (cSSPhiPsiNotHelix))) {
+             r->ss = 'H';
+             }
+             }
+
+             if(((r-1)->flags & (cSSHelix4HBond)) &&
+             ((r  )->flags & (cSSHelix4HBond)) &&
+             ((r+1)->flags & (cSSHelix4HBond))) {
+             if(!(r->flags & (cSSPhiPsiNotHelix))) {
+             r->ss = 'H';
+             }
+             }
+
+             if(((r-1)->flags & (cSSHelix5HBond)) &&
+             ((r  )->flags & (cSSHelix5HBond)) &&
+             ((r+1)->flags & (cSSHelix5HBond))) {
+             if(!(r->flags & (cSSPhiPsiNotHelix))) {
+             r->ss = 'H';
+             }
+             }
+           */
+
+        }
+      }
+
+      for(a = cSSBreakSize; a < (n_res - cSSBreakSize); a++) {
+        r = res + a;
+
+        if(r->real) {
+
+          /* occasionally they'll be one whacked out residue missing h-bonds... 
+             in an otherwise good segment */
+
+          if(((r - 2)->flags & (cSSHelix3HBond | cSSHelix4HBond | cSSHelix5HBond)) &&
+             ((r - 1)->flags & (cSSHelix3HBond | cSSHelix4HBond | cSSHelix5HBond)) &&
+             ((r - 1)->flags & (cSSPhiPsiHelix)) &&
+             ((r)->flags & (cSSPhiPsiHelix)) &&
+             ((r + 1)->flags & (cSSHelix3HBond | cSSHelix4HBond | cSSHelix5HBond)) &&
+             ((r + 1)->flags & (cSSPhiPsiHelix)) &&
+             ((r + 2)->flags & (cSSHelix3HBond | cSSHelix4HBond | cSSHelix5HBond))
+            ) {
+            r->ss = 'h';
+          }
+        }
+      }
+
+      for(a = cSSBreakSize; a < (n_res - cSSBreakSize); a++) {
+        r = res + a;
+        if(r->real) {
+          if(r->ss == 'h') {
+            r->flags |= (cSSHelix3HBond | cSSHelix4HBond | cSSHelix5HBond);
+            r->ss = 'H';
+          }
+        }
+      }
+
+      for(a = cSSBreakSize; a < (n_res - cSSBreakSize); a++) {
+        r = res + a;
+
+        if(r->real) {
+
+          /* deciding where the helix ends is trickier -- here we use helix geometry */
+
+          if(((r)->flags & (cSSHelix3HBond | cSSHelix4HBond | cSSHelix5HBond)) &&
+             ((r)->flags & (cSSPhiPsiHelix)) &&
+             ((r + 1)->flags & (cSSHelix3HBond | cSSHelix4HBond | cSSHelix5HBond)) &&
+             ((r + 1)->flags & (cSSPhiPsiHelix)) &&
+             ((r + 2)->flags & (cSSHelix3HBond | cSSHelix4HBond | cSSHelix5HBond)) &&
+             ((r + 2)->flags & (cSSPhiPsiHelix)) && ((r + 1)->ss == 'H')
+            ) {
+            r->ss = 'H';
+          }
+
+          if(((r)->flags & (cSSHelix3HBond | cSSHelix4HBond | cSSHelix5HBond)) &&
+             ((r)->flags & (cSSPhiPsiHelix)) &&
+             ((r - 1)->flags & (cSSHelix3HBond | cSSHelix4HBond | cSSHelix5HBond)) &&
+             ((r - 1)->flags & (cSSPhiPsiHelix)) &&
+             ((r - 2)->flags & (cSSHelix3HBond | cSSHelix4HBond | cSSHelix5HBond)) &&
+             ((r - 2)->flags & (cSSPhiPsiHelix)) && ((r - 1)->ss == 'H')
+            ) {
+            r->ss = 'H';
+          }
+
+        }
+      }
+
+      /* THEN SHEETS/STRANDS */
+
+      for(a = cSSBreakSize; a < (n_res - cSSBreakSize); a++) {
+        r = res + a;
+        if(r->real) {
+
+          /* Antiparallel Sheets */
+
+          if(((r)->flags & (cSSAntiStrandDoubleHB)) &&
+             (!((r->flags & (cSSPhiPsiNotStrand))))) {
+            (r)->ss = 'S';
+          }
+
+          if(((r)->flags & (cSSAntiStrandBuldgeHB)) &&  /* no strand geometry filtering for buldges.. */
+             ((r + 1)->flags & (cSSAntiStrandBuldgeHB))) {
+            (r)->ss = 'S';
+            (r + 1)->ss = 'S';
+          }
+
+          if(((r - 1)->flags & (cSSAntiStrandDoubleHB)) &&
+             ((r)->flags & (cSSAntiStrandSkip)) &&
+             (!(((r)->flags & (cSSPhiPsiNotStrand)))) &&
+             ((r + 1)->flags & (cSSAntiStrandSingleHB | cSSAntiStrandDoubleHB))) {
+
+            (r)->ss = 'S';
+          }
+
+          if(((r - 1)->flags & (cSSAntiStrandSingleHB | cSSAntiStrandDoubleHB)) &&
+             ((r)->flags & (cSSAntiStrandSkip)) &&
+             (!(((r)->flags & (cSSPhiPsiNotStrand)))) &&
+             ((r + 1)->flags & (cSSAntiStrandDoubleHB))) {
+            (r)->ss = 'S';
+          }
+
+          /* include open "ladders" if PHIPSI geometry supports assignment */
+
+          if(((r - 1)->flags & (cSSAntiStrandSingleHB | cSSAntiStrandDoubleHB)) &&
+             ((r - 1)->flags & (cSSPhiPsiStrand)) &&
+             (!(((r - 1)->flags & (cSSPhiPsiNotStrand)))) &&
+             ((r)->flags & (cSSPhiPsiStrand)) &&
+             (!(((r - 1)->flags & (cSSPhiPsiNotStrand)))) &&
+             ((r + 1)->flags & (cSSAntiStrandSingleHB | cSSAntiStrandDoubleHB)) &&
+             ((r + 1)->flags & (cSSPhiPsiStrand))) {
+
+            (r - 1)->ss = 'S';
+            (r)->ss = 'S';
+            (r + 1)->ss = 'S';
+          }
+
+          /* Parallel Sheets */
+
+          if(((r)->flags & (cSSParaStrandDoubleHB)) &&
+             (!(((r)->flags & (cSSPhiPsiNotStrand))))) {
+            (r)->ss = 'S';
+          }
+
+          if(((r - 1)->flags & (cSSParaStrandDoubleHB)) &&
+             ((r)->flags & (cSSParaStrandSkip)) &&
+             (!(((r)->flags & (cSSPhiPsiNotStrand)))) &&
+             ((r + 1)->flags & (cSSParaStrandSingleHB | cSSParaStrandDoubleHB))) {
+
+            (r)->ss = 'S';
+          }
+
+          if(((r - 1)->flags & (cSSParaStrandSingleHB | cSSParaStrandDoubleHB)) &&
+             ((r)->flags & (cSSParaStrandSkip)) &&
+             (!(((r)->flags & (cSSPhiPsiNotStrand)))) &&
+             ((r + 1)->flags & (cSSParaStrandDoubleHB))) {
+            (r)->ss = 'S';
+          }
+
+          /* include open "ladders" if PHIPSI geometry supports assignment */
+
+          if(((r - 1)->flags & (cSSParaStrandSingleHB | cSSParaStrandDoubleHB)) &&
+             ((r - 1)->flags & (cSSPhiPsiStrand)) &&
+             ((r)->flags & (cSSParaStrandSkip)) &&
+             ((r)->flags & (cSSPhiPsiStrand)) &&
+             ((r + 1)->flags & (cSSParaStrandSingleHB | cSSParaStrandDoubleHB)) &&
+             ((r + 1)->flags & (cSSPhiPsiStrand))) {
+
+            (r - 1)->ss = 'S';
+            (r)->ss = 'S';
+            (r + 1)->ss = 'S';
+
+          }
+        }
+      }
+    }
+
+    {
+      int a, b;
+      SSResi *r, *r2;
+      int repeat = true;
+      int found;
+
+      while(repeat) {
+        repeat = false;
+
+        for(a = cSSBreakSize; a < (n_res - cSSBreakSize); a++) {
+          r = res + a;
+          if(r->real) {
+
+            /* make sure we don't have any 2-residue segments */
+
+            if((r->ss == 'S') && ((r + 1)->ss == 'S') &&
+               (((r - 1)->ss != 'S') && ((r + 2)->ss != 'S'))) {
+              r->ss = 'L';
+              (r + 1)->ss = 'L';
+              repeat = true;
+            }
+            if((r->ss == 'H') && ((r + 1)->ss == 'H') &&
+               (((r - 1)->ss != 'H') && ((r + 2)->ss != 'H'))) {
+              r->ss = 'L';
+              (r + 1)->ss = 'L';
+              repeat = true;
+            }
+
+            /* make sure we don't have any 1-residue segments */
+
+            if((r->ss == 'S') && (((r - 1)->ss != 'S') && ((r + 1)->ss != 'S'))) {
+              r->ss = 'L';
+              repeat = true;
+            }
+            if((r->ss == 'H') && (((r - 1)->ss != 'H') && ((r + 1)->ss != 'H'))) {
+              r->ss = 'L';
+              repeat = true;
+            }
+
+            /* double-check to make sure every terminal strand residue 
+               that should have a partner has one */
+
+            if((r->ss == 'S') && (((r - 1)->ss != 'S') || ((r + 1)->ss != 'S'))) {
+
+              found = false;
+
+              for(b = 0; b < r->n_acc; b++) {
+                r2 = res + r->acc[b];
+                if(r2->ss == r->ss) {
+                  found = true;
+                  break;
+                }
+              }
+
+              if(!found) {
+                for(b = 0; b < r->n_don; b++) {
+                  r2 = res + r->don[b];
+                  if(r2->ss == r->ss) {
+                    found = true;
+                    break;
+                  }
+                }
+              }
+
+              if(!found) {     
+                /* allow these strand "skip" residues to persist if a neighbor has hydrogen bonds */
+                if(r->flags & (cSSAntiStrandSkip | cSSParaStrandSkip)) {
+
+                  if((r + 1)->ss == r->ss)
+                    for(b = 0; b < (r + 1)->n_acc; b++) {
+                      r2 = res + (r + 1)->acc[b];
+                      if(r2->ss == r->ss) {
+                        found = true;
+                        break;
+                      }
+                    }
+
+                  if(!found) {
+                    if((r - 1)->ss == r->ss) {
+                      for(b = 0; b < (r - 1)->n_don; b++) {
+                        r2 = res + (r - 1)->don[b];
+                        if(r2->ss == r->ss) {
+                          found = true;
+                          break;
+                        }
+                      }
+                    }
+                  }
+                }
+              }
+
+              if(!found) {
+                r->ss = 'L';
+                repeat = true;
+              }
+            }
+          }
+        }
+      }
+    }
+
+    {
+      int a;
+      for(a = 0; a < n_res; a++) {      /* now apply consensus or union behavior, if appropriate */
+        if(res[a].present) {
+          if(res[a].ss_save) {
+            if(res[a].ss != res[a].ss_save) {
+              if(consensus) {
+                res[a].ss = res[a].ss_save = 'L';
+              } else if(res[a].ss == 'L')
+                res[a].ss = res[a].ss_save;
+            }
+          }
+          res[a].ss_save = res[a].ss;
+        }
+      }
+    }
+
+    {
+      int a, aa;
+      ObjectMolecule *obj = NULL, *last_obj = NULL;
+      AtomInfoType *ai;
+      int changed_flag = false;
+
+      for(a = 0; a < n_res; a++) {
+        if(res[a].present && (!res[a].preserve)) {
+
+          aa = res[a].ca;
+          obj = I->Obj[I->Table[aa].model];
+
+          if(obj != last_obj) {
+            if(changed_flag && last_obj) {
+              ObjectMoleculeInvalidate(last_obj, cRepCartoon, cRepInvRep, -1);
+              SceneChanged(G);
+              changed_flag = false;
+            }
+            last_obj = obj;
+          }
+          ai = obj->AtomInfo + I->Table[aa].atom;
+
+          if(SelectorIsMember(G, ai->selEntry, target)) {
+            ai->ssType[0] = res[a].ss;
+            ai->cartoon = 0;    /* switch back to auto */
+            ai->ssType[1] = 0;
+            changed_flag = true;
+          }
+        }
+      }
+
+      if(changed_flag && last_obj) {
+        ObjectMoleculeInvalidate(last_obj, cRepCartoon, cRepInvRep, -1);
+        SceneChanged(G);
+        changed_flag = false;
+      }
+    }
+    if(first_last_only && (state == state_start))
+      state = state_stop - 2;
+  }
+
+  VLAFreeP(res);
+  return 1;
+}
+
+PyObject *SelectorColorectionGet(PyMOLGlobals * G, const char *prefix)
+{
+#ifdef _PYMOL_NOPY
+  return NULL;
+#else
+  CSelector *I = G->Selector;
+  PyObject *result = NULL;
+  int n_used = 0;
+  ColorectionRec *used = NULL, tmp;
+  ov_size a, b, n;
+  int sele;
+  int found;
+  int m;
+  int color;
+  AtomInfoType *ai;
+  used = VLAlloc(ColorectionRec, 1000);
+
+  SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+  for(a = cNDummyAtoms; a < I->NAtom; a++) {
+    ai = I->Obj[I->Table[a].model]->AtomInfo + I->Table[a].atom;
+    color = ai->color;
+    found = false;
+    for(b = 0; b < n_used; b++) {
+      if(used[b].color == color) {
+        tmp = used[0];          /* optimize to minimize N^2 effects */
+        used[0] = used[b];
+        used[b] = tmp;
+        found = true;
+        break;
+      }
+    }
+    if(!found) {
+      VLACheck(used, ColorectionRec, n_used);
+      used[n_used] = used[0];
+      used[0].color = color;
+      n_used++;
+    }
+  }
+  for(a = 0; a < n_used; a++) {
+    /* create selections */
+
+    n = I->NActive;
+    VLACheck(I->Name, SelectorWordType, n + 1);
+    VLACheck(I->Info, SelectionInfoRec, n + 1);
+    sele = I->NSelection++;
+    used[a].sele = sele;
+    sprintf(I->Name[n], cColorectionFormat, prefix, used[a].color);
+    I->Name[n + 1][0] = 0;
+    SelectorAddName(G, n);
+    SelectionInfoInit(I->Info + n);
+    I->Info[n].ID = sele;
+    I->NActive++;
+  }
+
+  for(a = cNDummyAtoms; a < I->NAtom; a++) {
+    ai = I->Obj[I->Table[a].model]->AtomInfo + I->Table[a].atom;
+    color = ai->color;
+    for(b = 0; b < n_used; b++) {
+      if(used[b].color == color) {
+        tmp = used[0];          /* optimize to minimize N^2 effects */
+        used[0] = used[b];
+        used[b] = tmp;
+
+        /* add selection onto atom */
+        if(I->FreeMember > 0) {
+          m = I->FreeMember;
+          I->FreeMember = I->Member[m].next;
+        } else {
+          I->NMember++;
+          m = I->NMember;
+          VLACheck(I->Member, MemberType, m);
+        }
+        I->Member[m].selection = used[0].sele;
+        I->Member[m].tag = 1;
+        I->Member[m].next = ai->selEntry;
+        ai->selEntry = m;
+        break;
+      }
+    }
+  }
+
+  VLASize(used, ColorectionRec, n_used * 2);
+  result = PConvIntVLAToPyList((int *) used);
+  VLAFreeP(used);
+  return (result);
+#endif
+}
+
+int SelectorColorectionApply(PyMOLGlobals * G, PyObject * list, const char *prefix)
+{
+#ifdef _PYMOL_NOPY
+  return 0;
+#else
+
+  CSelector *I = G->Selector;
+  int ok = true;
+  ColorectionRec *used = NULL;
+  ov_size n_used = 0;
+  int a, b;
+  AtomInfoType *ai;
+  ObjectMolecule *obj, *last = NULL;
+  SelectorWordType name;
+
+  if(ok)
+    ok = (list != NULL);
+  if(ok)
+    ok = PyList_Check(list);
+  if(ok)
+    n_used = PyList_Size(list) / 2;
+  if(ok)
+    ok = ((used = VLAlloc(ColorectionRec, n_used)) != NULL);
+  if(ok)
+    ok = PConvPyListToIntArrayInPlace(list, (int *) used, n_used * 2);
+  if(ok) {
+
+    SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+
+    for(b = 0; b < n_used; b++) {       /* update selection indices */
+      sprintf(name, cColorectionFormat, prefix, used[b].color);
+      used[b].sele = SelectorIndexByName(G, name);
+    }
+
+    for(a = cNDummyAtoms; a < I->NAtom; a++) {
+      obj = I->Obj[I->Table[a].model];
+      ai = obj->AtomInfo + I->Table[a].atom;
+
+      for(b = 0; b < n_used; b++) {
+        if(SelectorIsMember(G, ai->selEntry, used[b].sele)) {
+          ai->color = used[b].color;
+          if(obj != last) {
+            ObjectMoleculeInvalidate(obj, cRepAll, cRepInvColor, -1);
+            last = obj;
+          }
+          break;
+        }
+      }
+    }
+  }
+  VLAFreeP(used);
+  return (ok);
+#endif
+}
+
+int SelectorColorectionSetName(PyMOLGlobals * G, PyObject * list, const char *prefix,
+                               char *new_prefix)
+{
+#ifdef _PYMOL_NOPY
+  return 0;
+#else
+
+  int ok = true;
+  ColorectionRec *used = NULL;
+  ov_size n_used = 0;
+  ov_size b;
+  SelectorWordType name;
+  SelectorWordType new_name;
+
+  if(ok)
+    ok = (list != NULL);
+  if(ok)
+    ok = PyList_Check(list);
+  if(ok)
+    n_used = PyList_Size(list) / 2;
+  if(ok)
+    ok = ((used = VLAlloc(ColorectionRec, n_used)) != NULL);
+  if(ok)
+    ok = PConvPyListToIntArrayInPlace(list, (int *) used, n_used * 2);
+  if(ok) {
+    for(b = 0; b < n_used; b++) {       /* update selection indices */
+      sprintf(name, cColorectionFormat, prefix, used[b].color);
+      sprintf(new_name, cColorectionFormat, new_prefix, used[b].color);
+      SelectorSetName(G, new_name, name);
+    }
+  }
+  VLAFreeP(used);
+  return (ok);
+#endif
+
+}
+
+int SelectorColorectionFree(PyMOLGlobals * G, PyObject * list, const char *prefix)
+{
+#ifdef _PYMOL_NOPY
+  return 0;
+#else
+
+  int ok = true;
+  ColorectionRec *used = NULL;
+  ov_size n_used = 0;
+  ov_size b;
+  SelectorWordType name;
+
+  if(ok)
+    ok = (list != NULL);
+  if(ok)
+    ok = PyList_Check(list);
+  if(ok)
+    n_used = PyList_Size(list) / 2;
+  if(ok)
+    ok = ((used = VLAlloc(ColorectionRec, n_used)) != NULL);
+  if(ok)
+    ok = PConvPyListToIntArrayInPlace(list, (int *) used, n_used * 2);
+  if(ok) {
+
+    for(b = 0; b < n_used; b++) {       /* update selection indices */
+      sprintf(name, cColorectionFormat, prefix, used[b].color);
+      used[b].sele = SelectorIndexByName(G, name);
+    }
+
+    for(b = 0; b < n_used; b++) {
+      SelectorDeleteIndex(G, used[b].sele);
+    }
+  }
+  VLAFreeP(used);
+  return (ok);
+#endif
+
+}
+
+PyObject *SelectorSecretsAsPyList(PyMOLGlobals * G)
+{
+  CSelector *I = G->Selector;
+  int n_secret;
+  int a;
+  PyObject *result, *list;
+
+  n_secret = 0;
+  for(a = 0; a < I->NActive; a++) {
+    if((I->Name[a][0] == '_') && (I->Name[a][1] == '!'))
+      n_secret++;
+  }
+  result = PyList_New(n_secret);
+  n_secret = 0;
+  SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+  for(a = 0; a < I->NActive; a++) {
+    if((I->Name[a][0] == '_') && (I->Name[a][1] == '!')) {
+      list = PyList_New(2);
+      PyList_SetItem(list, 0, PyString_FromString(I->Name[a]));
+      PyList_SetItem(list, 1, SelectorAsPyList(G, I->Info[a].ID));
+      PyList_SetItem(result, n_secret, list);
+      n_secret++;
+    }
+  }
+  return (result);
+}
+
+int SelectorSecretsFromPyList(PyMOLGlobals * G, PyObject * list)
+{
+  int ok = true;
+  ov_size n_secret = 0;
+  ov_size a;
+  PyObject *entry = NULL;
+  SelectorWordType name;
+  ov_size ll = 0;
+  if(ok)
+    ok = (list != NULL);
+  if(ok)
+    ok = PyList_Check(list);
+  if(ok)
+    n_secret = PyList_Size(list);
+  if(ok) {
+    for(a = 0; a < n_secret; a++) {
+      if(ok)
+        entry = PyList_GetItem(list, a);
+      if(ok)
+        ok = (entry != NULL);
+      if(ok)
+        ok = PyList_Check(entry);
+      if(ok)
+        ll = PyList_Size(entry);
+      if(ok & (ll > 1)) {
+        if(ok)
+          ok = PConvPyStrToStr(PyList_GetItem(entry, 0), name, sizeof(SelectorWordType));
+        if(ok)
+          ok = SelectorFromPyList(G, name, PyList_GetItem(entry, 1));
+      }
+      if(!ok)
+        break;
+    }
+  }
+  return (ok);
+}
+
+typedef struct {
+  int atom;
+  int tag;
+} SelAtomTag;
+
+PyObject *SelectorAsPyList(PyMOLGlobals * G, int sele1)
+{                               /* assumes SelectorUpdateTable has been called */
+  CSelector *I = G->Selector;
+  int a, b;
+  int at;
+  int s;
+  SelAtomTag **vla_list = NULL;
+  int n_obj = 0;
+  int n_idx = 0;
+  int cur = -1;
+  ObjectMolecule **obj_list = NULL;
+  ObjectMolecule *obj, *cur_obj = NULL;
+  PyObject *result = NULL;
+  PyObject *obj_pyobj;
+  PyObject *idx_pyobj;
+  PyObject *tag_pyobj;
+
+  vla_list = VLACalloc(SelAtomTag *, 10);
+  obj_list = VLAlloc(ObjectMolecule *, 10);
+
+  n_idx = 0;
+  for(a = cNDummyAtoms; a < I->NAtom; a++) {
+    int tag;
+    at = I->Table[a].atom;
+    obj = I->Obj[I->Table[a].model];
+    s = obj->AtomInfo[at].selEntry;
+    if((tag = SelectorIsMember(G, s, sele1))) {
+      if(cur_obj != obj) {
+        if(n_idx) {
+          VLASize(vla_list[cur], SelAtomTag, n_idx);
+        }
+        cur++;
+        VLACheck(vla_list, SelAtomTag *, n_obj);
+        vla_list[cur] = VLAlloc(SelAtomTag, 1000);
+        VLACheck(obj_list, ObjectMolecule *, n_obj);
+        obj_list[cur] = obj;
+        cur_obj = obj;
+        n_obj++;
+        n_idx = 0;
+      }
+      VLACheck(vla_list[cur], SelAtomTag, n_idx);
+      vla_list[cur][n_idx].atom = at;
+      vla_list[cur][n_idx].tag = tag;
+      n_idx++;
+    }
+  }
+  if(cur_obj) {
+    if(n_idx) {
+      VLASize(vla_list[cur], SelAtomTag, n_idx);
+    }
+  }
+  if(n_obj) {
+    result = PyList_New(n_obj);
+    for(a = 0; a < n_obj; a++) {
+      obj_pyobj = PyList_New(3);
+      n_idx = VLAGetSize(vla_list[a]);
+      idx_pyobj = PyList_New(n_idx);
+      tag_pyobj = PyList_New(n_idx);
+      for(b = 0; b < n_idx; b++) {
+        PyList_SetItem(idx_pyobj, b, PyInt_FromLong(vla_list[a][b].atom));
+        PyList_SetItem(tag_pyobj, b, PyInt_FromLong(vla_list[a][b].tag));
+      }
+      VLAFreeP(vla_list[a]);
+      PyList_SetItem(obj_pyobj, 0, PyString_FromString(obj_list[a]->Name));
+      PyList_SetItem(obj_pyobj, 1, idx_pyobj);
+      PyList_SetItem(obj_pyobj, 2, tag_pyobj);
+      PyList_SetItem(result, a, obj_pyobj);
+    }
+  } else {
+    result = PyList_New(0);
+  }
+  VLAFreeP(vla_list);
+  VLAFreeP(obj_list);
+  return (result);
+}
+
+int SelectorFromPyList(PyMOLGlobals * G, const char *name, PyObject * list)
+{
+  int ok = true;
+  CSelector *I = G->Selector;
+  ov_size a, b;
+  ov_diff n;
+  int m, sele;
+  ov_size ll;
+  PyObject *obj_list = NULL;
+  PyObject *idx_list = NULL, *tag_list;
+  ov_size n_obj = 0, n_idx = 0;
+  int idx, tag;
+  const char *oname;
+  ObjectMolecule *obj;
+  int singleAtomFlag = true;
+  int singleObjectFlag = true;
+  ObjectMolecule *singleObject = NULL;
+  int singleAtom = -1;
+
+  AtomInfoType *ai;
+  if(ok)
+    ok = PyList_Check(list);
+  if(ok)
+    n_obj = PyList_Size(list);
+
+  /* get rid of existing selection */
+  SelectorDelete(G, name);
+
+  n = I->NActive;
+  VLACheck(I->Name, SelectorWordType, n + 1);
+  VLACheck(I->Info, SelectionInfoRec, n + 1);
+  strcpy(I->Name[n], name);
+  I->Name[n + 1][0] = 0;
+  SelectorAddName(G, n);
+  sele = I->NSelection++;
+  SelectionInfoInit(I->Info + n);
+  I->Info[n].ID = sele;
+  I->NActive++;
+  if(ok) {
+    for(a = 0; a < n_obj; a++) {
+      ll = 0;
+      if(ok)
+        obj_list = PyList_GetItem(list, a);
+      if(ok)
+        ok = PyList_Check(obj_list);
+      if(ok)
+        ll = PyList_Size(obj_list);
+      if(ok)
+        ok = PConvPyStrToStrPtr(PyList_GetItem(obj_list, 0), &oname);
+      obj = NULL;
+      if(ok)
+        obj = ExecutiveFindObjectMoleculeByName(G, oname);
+      if(ok && obj) {
+        if(ok)
+          idx_list = PyList_GetItem(obj_list, 1);
+        if(ll > 2)
+          tag_list = PyList_GetItem(obj_list, 2);
+        else
+          tag_list = NULL;
+        if(ok)
+          ok = PyList_Check(idx_list);
+        if(ok)
+          n_idx = PyList_Size(idx_list);
+        for(b = 0; b < n_idx; b++) {
+          if(ok)
+            ok = PConvPyIntToInt(PyList_GetItem(idx_list, b), &idx);
+          if(tag_list)
+            PConvPyIntToInt(PyList_GetItem(tag_list, b), &tag);
+          else
+            tag = 1;
+          if(ok && (idx < obj->NAtom)) {
+            ai = obj->AtomInfo + idx;
+            if(I->FreeMember > 0) {
+              m = I->FreeMember;
+              I->FreeMember = I->Member[m].next;
+            } else {
+              I->NMember++;
+              m = I->NMember;
+              VLACheck(I->Member, MemberType, m);
+            }
+            I->Member[m].selection = sele;
+            I->Member[m].tag = tag;
+            I->Member[m].next = ai->selEntry;
+            ai->selEntry = m;
+
+            /* take note of selections which are one atom/one object */
+            if(singleObjectFlag) {
+              if(singleObject) {
+                if(obj != singleObject) {
+                  singleObjectFlag = false;
+                }
+              } else {
+                singleObject = obj;
+              }
+            }
+
+            if(singleAtomFlag) {
+              if(singleAtom >= 0) {
+                if(idx != singleAtom) {
+                  singleAtomFlag = false;
+                }
+              } else {
+                singleAtom = idx;
+              }
+            }
+          }
+        }
+      }
+    }
+    {                           /* make note of single atom/object selections */
+      SelectionInfoRec *info = I->Info + (I->NActive - 1);
+      if(singleObjectFlag && singleObject) {
+        info->justOneObjectFlag = true;
+        info->theOneObject = singleObject;
+        if(singleAtomFlag && (singleAtom >= 0)) {
+          info->justOneAtomFlag = true;
+          info->theOneAtom = singleAtom;
+        }
+      }
+    }
+  }
+  return (ok);
+}
+
+int SelectorVdwFit(PyMOLGlobals * G, int sele1, int state1, int sele2, int state2,
+                   float buffer, int quiet)
+{
+  int ok = true;
+  CSelector *I = G->Selector;
+  int *vla = NULL;
+  int c;
+  float sumVDW = 0.0, dist;
+  int a1, a2;
+  AtomInfoType *ai1, *ai2;
+  int at1, at2;
+  CoordSet *cs1, *cs2;
+  ObjectMolecule *obj1, *obj2;
+  int idx1, idx2;
+  float *adj = NULL;
+  int a;
+
+  if(state1 < 0)
+    state1 = 0;
+  if(state2 < 0)
+    state2 = 0;
+
+  if(state1 != state2) {
+    SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+  } else {
+    SelectorUpdateTable(G, state1, -1);
+  }
+
+  c =
+    SelectorGetInterstateVLA(G, sele1, state1, sele2, state2, 2 * MAX_VDW + buffer, &vla);
+  if(c) {
+    adj = pymol::calloc<float>(2 * c);
+    for(a = 0; a < c; a++) {
+      a1 = vla[a * 2];
+      a2 = vla[a * 2 + 1];
+
+      at1 = I->Table[a1].atom;
+      at2 = I->Table[a2].atom;
+
+      obj1 = I->Obj[I->Table[a1].model];
+      obj2 = I->Obj[I->Table[a2].model];
+
+      if((state1 < obj1->NCSet) && (state2 < obj2->NCSet)) {
+        cs1 = obj1->CSet[state1];
+        cs2 = obj2->CSet[state2];
+        if(cs1 && cs2) {        /* should always be true */
+
+          ai1 = obj1->AtomInfo + at1;
+          ai2 = obj2->AtomInfo + at2;
+
+          idx1 = cs1->AtmToIdx[at1];    /* these are also pre-validated */
+          idx2 = cs2->AtmToIdx[at2];
+
+          sumVDW = ai1->vdw + ai2->vdw;
+          dist = (float) diff3f(cs1->Coord + 3 * idx1, cs2->Coord + 3 * idx2);
+
+          if(dist < (sumVDW + buffer)) {
+            float shift = (dist - (sumVDW + buffer)) / 2.0F;
+            adj[2 * a] = ai1->vdw + shift;
+            adj[2 * a + 1] = ai2->vdw + shift;
+          } else {
+            adj[2 * a] = ai1->vdw;
+            adj[2 * a + 1] = ai2->vdw;
+          }
+
+        }
+      }
+    }
+
+    for(a = 0; a < c; a++) {
+      a1 = vla[a * 2];
+      a2 = vla[a * 2 + 1];
+
+      at1 = I->Table[a1].atom;
+      at2 = I->Table[a2].atom;
+
+      obj1 = I->Obj[I->Table[a1].model];
+      obj2 = I->Obj[I->Table[a2].model];
+
+      if((state1 < obj1->NCSet) && (state2 < obj2->NCSet)) {
+        cs1 = obj1->CSet[state1];
+        cs2 = obj2->CSet[state2];
+        if(cs1 && cs2) {        /* should always be true */
+
+          ai1 = obj1->AtomInfo + at1;
+          ai2 = obj2->AtomInfo + at2;
+
+          if(adj[2 * a] < ai1->vdw) {
+            ai1->vdw = adj[2 * a];
+          }
+
+          if(adj[2 * a + 1] < ai2->vdw) {
+            ai2->vdw = adj[2 * a + 1];
+          }
+
+        }
+      }
+    }
+  }
+
+  VLAFreeP(vla);
+  FreeP(adj);
+  return ok;
+}
+
+
+/*========================================================================*/
+
+int SelectorGetPairIndices(PyMOLGlobals * G, int sele1, int state1, int sele2, int state2,
+                           int mode, float cutoff, float h_angle,
+                           int **indexVLA, ObjectMolecule *** objVLA)
+{
+  CSelector *I = G->Selector;
+  int *vla = NULL;
+  int c;
+  float dist;
+  int a1, a2;
+  int at1, at2;
+  CoordSet *cs1, *cs2;
+  ObjectMolecule *obj1, *obj2;
+  int idx1, idx2;
+  int a;
+  int dist_cnt = 0;
+  float dir[3];
+  float v1[3], v2[3];
+  int flag;
+  float angle_cutoff = 0.0;
+
+  if(mode == 1) {
+    angle_cutoff = (float) cos(PI * h_angle / 180.0);
+  }
+
+  if(state1 < 0)
+    state1 = 0;
+  if(state2 < 0)
+    state2 = 0;
+
+  if(state1 != state2) {
+    SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+  } else {
+    SelectorUpdateTable(G, state1, -1);
+  }
+  if(cutoff < 0)
+    cutoff = 1000.0;
+  c = SelectorGetInterstateVLA(G, sele1, state1, sele2, state2, cutoff, &vla);
+  (*indexVLA) = VLAlloc(int, 1000);
+  (*objVLA) = VLAlloc(ObjectMolecule *, 1000);
+
+  for(a = 0; a < c; a++) {
+    a1 = vla[a * 2];
+    a2 = vla[a * 2 + 1];
+
+    if(a1 != a2) {
+      at1 = I->Table[a1].atom;
+      at2 = I->Table[a2].atom;
+
+      obj1 = I->Obj[I->Table[a1].model];
+      obj2 = I->Obj[I->Table[a2].model];
+
+      if(state1 < obj1->NCSet && state2 < obj2->NCSet) {
+        cs1 = obj1->CSet[state1];
+        cs2 = obj2->CSet[state2];
+        if(cs1 && cs2) {
+          idx1 = cs1->atmToIdx(at1);
+          idx2 = cs2->atmToIdx(at2);
+
+          if((idx1 >= 0) && (idx2 >= 0)) {
+            subtract3f(cs1->Coord + 3 * idx1, cs2->Coord + 3 * idx2, dir);
+            dist = (float) length3f(dir);
+            if(dist > R_SMALL4) {
+              float dist_1 = 1.0F / dist;
+              scale3f(dir, dist_1, dir);
+            }
+            if(dist < cutoff) {
+              if(mode == 1) {   /* coarse hydrogen bonding assessment */
+                flag = false;
+                if(ObjectMoleculeGetAvgHBondVector(obj1, at1, state1, v1, NULL) > 0.3)
+                  if(dot_product3f(v1, dir) < -angle_cutoff)
+                    flag = true;
+                if(ObjectMoleculeGetAvgHBondVector(obj2, at2, state2, v2, NULL) > 0.3)
+                  if(dot_product3f(v2, dir) > angle_cutoff)
+                    flag = true;
+              } else
+                flag = true;
+
+              if(flag) {
+                VLACheck((*objVLA), ObjectMolecule *, dist_cnt + 1);
+                VLACheck((*indexVLA), int, dist_cnt + 1);
+                (*objVLA)[dist_cnt] = obj1;
+                (*indexVLA)[dist_cnt] = at1;
+                dist_cnt++;
+                (*objVLA)[dist_cnt] = obj2;
+                (*indexVLA)[dist_cnt] = at2;
+                dist_cnt++;
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+
+  VLASize((*objVLA), ObjectMolecule *, dist_cnt);
+  VLASize((*indexVLA), int, dist_cnt);
+  VLAFreeP(vla);
+  dist_cnt = dist_cnt / 2;
+  return (dist_cnt);
+}
+
+
+/*========================================================================*/
+int SelectorCreateAlignments(PyMOLGlobals * G,
+                             int *pair, int sele1, int *vla1, int sele2,
+                             int *vla2, const char *name1, const char *name2,
+                             int identical, int atomic_input)
+{
+  CSelector *I = G->Selector;
+  int *flag1 = NULL, *flag2 = NULL;
+  int *p;
+  int i, np;
+  int cnt;
+  int mod1, mod2;               /* model indexes */
+  int at1, at2, at1a, at2a;     /* atoms indexes */
+  int vi1, vi2;                 /* vla indexes */
+  int index1, index2;           /* indices in the selection array */
+  AtomInfoType *ai1, *ai2, *ai1a, *ai2a;        /* atom information pointers */
+  ObjectMolecule *obj1, *obj2;
+  int cmp;
+  PRINTFD(G, FB_Selector)
+    " %s-DEBUG: entry.\n", __func__ ENDFD cnt = 0;
+  /* number of pairs of atoms */
+  np = VLAGetSize(pair) / 2;
+  if(np) {
+
+    SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);  /* unnecessary? */
+    /* flags initialized to false */
+    flag1 = pymol::calloc<int>(I->NAtom);
+    flag2 = pymol::calloc<int>(I->NAtom);
+
+    /* we need to create two selection arrays: for the matched 
+     * atoms in the original selections */
+    p = pair;
+    for(i = 0; i < np; i++) {   /* iterate through all pairs of matched residues */
+      vi1 = *(p++);
+      vi2 = *(p++);
+
+      /* find positions in the selection arrays */
+      /* SelectorGetResidueVLA returns a VLA with 3 entries per atom, index0=model,
+       * index1=atom#, hence: *3, and *3+1 */
+      mod1 = vla1[vi1 * 3];
+      at1 = vla1[vi1 * 3 + 1];
+
+      mod2 = vla2[vi2 * 3];
+      at2 = vla2[vi2 * 3 + 1];
+
+      PRINTFD(G, FB_Selector)
+        " S.C.A.-DEBUG: mod1 %d at1 %d mod2 %d at2 %d\n", mod1, at1, mod2, at2
+        ENDFD obj1 = I->Obj[mod1];
+      obj2 = I->Obj[mod2];
+
+      ai1 = obj1->AtomInfo + at1;
+      ai2 = obj2->AtomInfo + at2;
+      at1a = at1;
+      at2a = at2;
+      ai1a = ai1;
+      ai2a = ai2;
+
+      if(atomic_input) {
+        index1 = SelectorGetObjAtmOffset(I, obj1, at1a);
+        index2 = SelectorGetObjAtmOffset(I, obj2, at2a);
+        flag1[index1] = true;
+        flag2[index2] = true;
+        cnt++;
+      } else {
+
+        /* search back to first atom in residue */
+        while(at1a > 0 && AtomInfoSameResidue(G, ai1a, ai1a - 1)) { ai1a--; at1a--; }
+        while(at2a > 0 && AtomInfoSameResidue(G, ai2a, ai2a - 1)) { ai2a--; at2a--; }
+
+        while(1) {              /* match up all matching atom names in each residue */
+          cmp = AtomInfoNameOrder(G, ai1a, ai2a);
+          if(cmp == 0) {        /* atoms match */
+            index1 = SelectorGetObjAtmOffset(I, obj1, at1a);
+            index2 = SelectorGetObjAtmOffset(I, obj2, at2a);
+
+            PRINTFD(G, FB_Selector)
+              " S.C.A.-DEBUG: compare %s %s %d\n", LexStr(G, ai1a->name), LexStr(G, ai2a->name), cmp
+              ENDFD PRINTFD(G, FB_Selector)
+              " S.C.A.-DEBUG: entry %d %d\n",
+              ai1a->selEntry, ai2a->selEntry ENDFD if((index1 >= 0) && (index2 >= 0)) {
+              if(SelectorIsMember(G, ai1a->selEntry, sele1) &&
+                 SelectorIsMember(G, ai2a->selEntry, sele2)) {
+                if((!identical) || (ai1a->resn == ai2a->resn)) {
+                  flag1[index1] = true;
+                  flag2[index2] = true;
+                  cnt++;
+                }
+              }
+            }
+            at1a++;
+            at2a++;
+          } else if(cmp < 0) {  /* 1 is before 2 */
+            at1a++;
+          } else if(cmp > 0) {  /* 1 is after 2 */
+            at2a++;
+          }
+          if(at1a >= obj1->NAtom)
+            break;
+          if(at2a >= obj2->NAtom)
+            break;
+          ai1a = obj1->AtomInfo + at1a;
+          ai2a = obj2->AtomInfo + at2a;
+          /* make sure we're still in the same residue */
+          if(!AtomInfoSameResidue(G, ai1a, ai1))
+            break;
+          if(!AtomInfoSameResidue(G, ai2a, ai2))
+            break;
+        }
+      }
+    }
+    if(cnt) {
+      SelectorEmbedSelection(G, flag1, name1, NULL, false, -1);
+      SelectorEmbedSelection(G, flag2, name2, NULL, false, -1);
+    }
+    FreeP(flag1);
+    FreeP(flag2);
+  }
+  PRINTFD(G, FB_Selector)
+    " %s-DEBUG: exit, cnt = %d.\n", __func__, cnt ENDFD return cnt;
+}
+
+
+/*========================================================================*/
+int SelectorCountStates(PyMOLGlobals * G, int sele)
+{
+  CSelector *I = G->Selector;
+  int a;
+  int result = 0;
+  int n_frame;
+  int at1;
+  ObjectMolecule *last = NULL;
+  ObjectMolecule *obj;
+  SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+  if(I->NAtom) {
+    for(a = cNDummyAtoms; a < I->NAtom; a++) {
+      obj = I->Obj[I->Table[a].model];
+      if(obj != last) {
+        at1 = I->Table[a].atom;
+        if(SelectorIsMember(G, obj->AtomInfo[at1].selEntry, sele)) {
+          if(obj->fGetNFrame) {
+            n_frame = obj->fGetNFrame((CObject *) obj);
+            if(result < n_frame)
+              result = n_frame;
+          }
+          last = obj;
+        }
+      }
+    }
+  }
+  return (result);
+}
+
+
+/*========================================================================*/
+int SelectorCheckIntersection(PyMOLGlobals * G, int sele1, int sele2)
+{
+  CSelector *I = G->Selector;
+  int a;
+  int at1;
+  ObjectMolecule *obj;
+
+  SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+  if(I->NAtom) {
+    for(a = cNDummyAtoms; a < I->NAtom; a++) {
+      obj = I->Obj[I->Table[a].model];
+      at1 = I->Table[a].atom;
+      if(SelectorIsMember(G, obj->AtomInfo[at1].selEntry, sele1) &&
+         SelectorIsMember(G, obj->AtomInfo[at1].selEntry, sele2))
+        return 1;
+    }
+  }
+  return 0;
+}
+
+
+/*========================================================================*/
+int SelectorCountAtoms(PyMOLGlobals * G, int sele, int state)
+{
+  CSelector *I = G->Selector;
+  int a;
+  int result = 0;
+  int at1;
+  ObjectMolecule *obj;
+
+  SelectorUpdateTable(G, state, -1);
+  if(I->NAtom) {
+    for(a = cNDummyAtoms; a < I->NAtom; a++) {
+      obj = I->Obj[I->Table[a].model];
+      at1 = I->Table[a].atom;
+      if(SelectorIsMember(G, obj->AtomInfo[at1].selEntry, sele)) {
+        result++;
+      }
+    }
+  }
+  return (result);
+}
+
+/*========================================================================*/
+void SelectorSetDeleteFlagOnSelectionInObject(PyMOLGlobals * G, int sele, ObjectMolecule *obj, signed char val){
+  CSelector *I = G->Selector;
+  int a,nflags = 0;
+  int at1;
+  ObjectMolecule *obj0;
+
+  SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+  if(I->NAtom) {
+    for(a = cNDummyAtoms; a < I->NAtom; a++) {
+      obj0 = I->Obj[I->Table[a].model];
+      if (obj==obj0){
+	at1 = I->Table[a].atom;
+	if(SelectorIsMember(G, obj->AtomInfo[at1].selEntry, sele)) {
+	  obj->AtomInfo[at1].deleteFlag = val;
+	  nflags++;
+	}
+      }
+    }
+  }
+}
+
+/*========================================================================*/
+int *SelectorGetResidueVLA(PyMOLGlobals * G, int sele, int ca_only,
+                           ObjectMolecule * exclude)
+{
+  /* returns a VLA containing atom indices followed by residue integers
+     (residue names packed as characters into integers)
+     The indices are the first and last residue in the selection...
+   */
+  CSelector *I = G->Selector;
+  int *result = NULL, *r;
+  AtomInfoType *ai1 = NULL, *ai2;
+
+  /* update the selector's table */
+  SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+
+  /* make room for model#, at#, rcode, per atom */
+  result = VLAlloc(int, I->NAtom * 3);
+
+  r = result;
+  PRINTFD(G, FB_Selector)
+    " %s-DEBUG: entry, sele = %d\n", __func__, sele ENDFD;
+
+  for(SeleAtomIterator iter(G, sele); iter.next();) {
+    if(iter.obj == exclude)
+      continue;
+
+    ai2 = iter.getAtomInfo();
+
+    if(ca_only) {
+      if(!(ai2->flags & cAtomFlag_guide))
+        continue;
+    } else if(ai1 && AtomInfoSameResidue(G, ai1, ai2)) {
+      continue;
+    }
+
+    *(r++) = I->Table[iter.a].model;
+    *(r++) = I->Table[iter.a].atom;
+
+    const char * resn = LexStr(G, ai2->resn);
+    *(r)    = (resn[0] << (8 * 2));
+    if (resn[0] && resn[1]) {
+      *(r) |= (resn[1] << (8 * 1));
+      *(r) |= (resn[2] << (8 * 0));
+    }
+    r++;
+
+    ai1 = ai2;
+  }
+  if(result) {
+    VLASize(result, int, (ov_size) (r - result));
+  }
+  PRINTFD(G, FB_Selector)
+    " %s-DEBUG: exit, result = %p, size = %d\n", __func__,
+    (void *) result, (unsigned int) VLAGetSize(result)
+    ENDFD;
+
+  return (result);
+}
+
+
+/*========================================================================*/
+/* bad to make this non-static? */
+/* static int *SelectorGetIndexVLA(PyMOLGlobals * G, int sele) */
+static int *SelectorGetIndexVLA(PyMOLGlobals * G, int sele)
+{
+  return (SelectorGetIndexVLAImpl(G, G->Selector, sele));
+}
+static int *SelectorGetIndexVLAImpl(PyMOLGlobals * G, CSelector *I, int sele)
+{                               /* assumes updated tables */
+  int a, c = 0;
+  int *result = NULL;
+  ObjectMolecule *obj;
+  int at1;
+
+  result = VLAlloc(int, (I->NAtom / 10) + 1);
+  for(a = cNDummyAtoms; a < I->NAtom; a++) {
+    obj = I->Obj[I->Table[a].model];
+    at1 = I->Table[a].atom;
+    if(SelectorIsMember(G, obj->AtomInfo[at1].selEntry, sele)) {
+      VLACheck(result, int, c);
+      result[c++] = a;
+    }
+  }
+  VLASize(result, int, c);
+  return (result);
+}
+
+
+/*========================================================================*/
+void SelectorUpdateObjectSele(PyMOLGlobals * G, ObjectMolecule * obj)
+{
+  if(obj->Name[0]) {
+    SelectorDelete(G, obj->Name);
+    SelectorCreate(G, obj->Name, NULL, obj, true, NULL);    
+    /* create a selection with same name */
+    if(SettingGetGlobal_b(G, cSetting_auto_classify_atoms))
+    {
+      SelectorClassifyAtoms(G, 0, false, obj);
+
+      // for file formats other than PDB
+      if (obj->need_hetatm_classification) {
+        for (auto ai = obj->AtomInfo.data(), ai_end = ai + obj->NAtom;
+            ai != ai_end; ++ai) {
+          if (!(ai->flags & cAtomFlag_polymer)) {
+            ai->hetatm = true;
+            ai->flags |= cAtomFlag_ignore;
+          }
+        }
+        obj->need_hetatm_classification = false;
+      }
+    }
+  }
+}
+
+
+/*========================================================================*/
+void SelectorLogSele(PyMOLGlobals * G, const char *name)
+{
+  CSelector *I = G->Selector;
+  int a;
+  OrthoLineType line, buf1;
+  int cnt = -1;
+  int first = 1;
+  int append = 0;
+  ObjectMolecule *obj;
+  int at1;
+  int sele;
+  int logging;
+  int robust;
+  logging = SettingGetGlobal_i(G, cSetting_logging);
+  robust = SettingGetGlobal_b(G, cSetting_robust_logs);
+  if(logging) {
+    sele = SelectorIndexByName(G, name);
+    if(sele >= 0) {
+      SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+      for(a = cNDummyAtoms; a < I->NAtom; a++) {
+        obj = I->Obj[I->Table[a].model];
+        at1 = I->Table[a].atom;
+        if(SelectorIsMember(G, obj->AtomInfo[at1].selEntry, sele)) {
+          if(cnt < 0) {
+            if(first) {
+              switch (logging) {
+              case cPLog_pml:
+                sprintf(line, "_ cmd.select(\"%s\",\"(", name);
+                break;
+              case cPLog_pym:
+                sprintf(line, "cmd.select(\"%s\",\"(", name);
+                break;
+              }
+              append = 0;
+              cnt = 0;
+              first = 0;
+            } else {
+              switch (logging) {
+              case cPLog_pml:
+                sprintf(line, "_ cmd.select(\"%s\",\"(%s", name, name);
+                break;
+              case cPLog_pym:
+                sprintf(line, "cmd.select(\"%s\",\"(%s", name, name);
+                break;
+              }
+              append = 1;
+              cnt = 0;
+            }
+          }
+          if(append)
+            strcat(line, "|");
+          if(robust)
+            ObjectMoleculeGetAtomSeleFast(obj, at1, buf1);
+          else
+            sprintf(buf1, "%s`%d", obj->Name, at1 + 1);
+          strcat(line, buf1);
+          append = 1;
+          cnt++;
+          if(strlen(line) > (sizeof(OrthoLineType) / 2)) {
+            strcat(line, ")\")\n");
+            PLog(G, line, cPLog_no_flush);
+            cnt = -1;
+          }
+        }
+      }
+      if(cnt > 0) {
+        strcat(line, ")\")\n");
+        PLog(G, line, cPLog_no_flush);
+        PLogFlush(G);
+      }
+    }
+  }
+}
+
+
+/*========================================================================*/
+/*
+ * This is the most heavily called routine in interactive PyMOL
+ *
+ * s:    AtomInfoType.selEntry
+ * sele: selection index or 0 for "all"
+ */
+int SelectorIsMember(PyMOLGlobals * G, int s, int sele)
+{
+  if(sele > 1) {
+    const MemberType *mem, *member = G->Selector->Member;
+    for(; s; s = mem->next) {
+      mem = member + s;
+      if(mem->selection == sele)
+        return mem->tag;
+    }
+  } else if(!sele)
+    return true;                /* "all" is selection number 0, unordered */
+  return false;
+}
+
+
+/*========================================================================*/
+int SelectorMoveMember(PyMOLGlobals * G, int s, int sele_old, int sele_new)
+{
+  CSelector *I = G->Selector;
+  int result = false;
+  while(s) {
+    if(I->Member[s].selection == sele_old) {
+      I->Member[s].selection = sele_new;
+      result = true;
+    }
+    s = I->Member[s].next;
+  }
+  return result;
+}
+
+
+/*========================================================================*/
+static int SelectorIndexByID(PyMOLGlobals * G, int id)
+{
+  CSelector *I = G->Selector;
+  int i = 0;
+  int result = -1;
+  SelectionInfoRec *info = I->Info;
+  while(i < I->NActive) {
+    if((info++)->ID == id) {
+      result = i;
+      break;
+    }
+    i++;
+  }
+  return result;
+}
+
+
+/*========================================================================*/
+ObjectMolecule *SelectorGetFastSingleObjectMolecule(PyMOLGlobals * G, int sele)
+{
+  CSelector *I = G->Selector;
+  ObjectMolecule *result = NULL;
+  SelectionInfoRec *info;
+  int sele_idx = SelectorIndexByID(G, sele);
+  if((sele_idx >= 0) && (sele_idx < I->NActive)) {
+    info = I->Info + sele_idx;
+    if(info->justOneObjectFlag) {
+      if(ExecutiveValidateObjectPtr(G, (CObject *) info->theOneObject, cObjectMolecule))
+        result = info->theOneObject;
+    } else {
+      result = SelectorGetSingleObjectMolecule(G, sele);        /* fallback onto slow approach */
+    }
+  }
+  return (result);
+}
+
+
+/*========================================================================*/
+ObjectMolecule *SelectorGetFastSingleAtomObjectIndex(PyMOLGlobals * G, int sele,
+                                                     int *index)
+{
+  CSelector *I = G->Selector;
+  ObjectMolecule *result = NULL;
+  SelectionInfoRec *info;
+  int got_it = false;
+  int sele_idx = SelectorIndexByID(G, sele);
+
+  if((sele_idx >= 0) && (sele_idx < I->NActive)) {
+    info = I->Info + sele_idx;
+    if(info->justOneObjectFlag && info->justOneAtomFlag) {
+      ObjectMolecule *obj = info->theOneObject;
+      int at = info->theOneAtom;
+      if(ExecutiveValidateObjectPtr(G, (CObject *) obj, cObjectMolecule)) {
+        if((at < obj->NAtom) && SelectorIsMember(G, obj->AtomInfo[at].selEntry, sele)) {
+          result = obj;
+          *index = at;
+          got_it = true;
+        }
+      }
+    }
+    if(!got_it) {               /* fallback onto slow approach */
+      if(!SelectorGetSingleAtomObjectIndex(G, sele, &result, index))
+        result = NULL;
+    }
+  }
+  return (result);
+}
+
+
+/*========================================================================
+ * SelectorGetSingleObjectMolecule -- get a ptr to the molecule indiecated
+ *    by the selection parameter
+ * PARAMS
+ *   (int) selection #
+ * RETURNS
+ *   (ptr) pts to the ObjectMolecule or NULL if not found
+ */
+ObjectMolecule *SelectorGetSingleObjectMolecule(PyMOLGlobals * G, int sele)
+{
+  /* slow way */
+
+  int a;
+  ObjectMolecule *result = NULL;
+  ObjectMolecule *obj;
+  CSelector *I = G->Selector;
+  int at1;
+  SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+
+  for(a = 0; a < I->NAtom; a++) {
+    obj = I->Obj[I->Table[a].model];
+    at1 = I->Table[a].atom;
+    if(SelectorIsMember(G, obj->AtomInfo[at1].selEntry, sele)) {
+      if(result) {
+        if(result != obj) {
+          result = NULL;
+          break;
+        }
+      } else {
+        result = obj;
+      }
+    }
+  }
+  return (result);
+}
+
+
+/*========================================================================*/
+ObjectMolecule *SelectorGetFirstObjectMolecule(PyMOLGlobals * G, int sele)
+{
+  /* slow way */
+
+  int a;
+  ObjectMolecule *result = NULL;
+  ObjectMolecule *obj;
+  CSelector *I = G->Selector;
+  int at1;
+  SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+
+  for(a = 0; a < I->NAtom; a++) {
+    obj = I->Obj[I->Table[a].model];
+    at1 = I->Table[a].atom;
+    if(SelectorIsMember(G, obj->AtomInfo[at1].selEntry, sele)) {
+      result = obj;
+      break;
+    }
+  }
+  return (result);
+}
+
+
+/*========================================================================*/
+ObjectMolecule **SelectorGetObjectMoleculeVLA(PyMOLGlobals * G, int sele)
+{
+  int a;
+  ObjectMolecule *last = NULL;
+  ObjectMolecule *obj, **result = NULL;
+  CSelector *I = G->Selector;
+  int at1;
+  int n = 0;
+  SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+
+  result = VLAlloc(ObjectMolecule *, 10);
+  for(a = cNDummyAtoms; a < I->NAtom; a++) {
+    obj = I->Obj[I->Table[a].model];
+    at1 = I->Table[a].atom;
+    if(SelectorIsMember(G, obj->AtomInfo[at1].selEntry, sele)) {
+      if(obj != last) {
+        VLACheck(result, ObjectMolecule *, n);
+        result[n] = obj;
+        last = obj;
+        n++;
+      }
+    }
+  }
+  VLASize(result, ObjectMolecule *, n);
+  return (result);
+}
+
+
+/*========================================================================*/
+int SelectorGetSingleAtomObjectIndex(PyMOLGlobals * G, int sele, ObjectMolecule ** in_obj,
+                                     int *index)
+{
+  /* slow way */
+
+  int found_it = false;
+  int a;
+  void *iterator = NULL;
+  ObjectMolecule *obj = NULL;
+
+  while(ExecutiveIterateObjectMolecule(G, &obj, &iterator)) {
+    int n_atom = obj->NAtom;
+    AtomInfoType *ai = obj->AtomInfo;
+    for(a = 0; a < n_atom; a++) {
+      int s = (ai++)->selEntry;
+      if(SelectorIsMember(G, s, sele)) {
+        if(found_it) {
+          return false;         /* ADD'L EXIT POINT */
+        } else {
+          found_it = true;
+          (*in_obj) = obj;
+          (*index) = a;
+        }
+      }
+    }
+  }
+  return (found_it);
+}
+
+
+/*========================================================================*/
+int SelectorGetSingleAtomVertex(PyMOLGlobals * G, int sele, int state, float *v)
+{
+  ObjectMolecule *obj = NULL;
+  int index = 0;
+  int found_it = false;
+  if(SelectorGetSingleAtomObjectIndex(G, sele, &obj, &index))
+    found_it = ObjectMoleculeGetAtomTxfVertex(obj, state, index, v);
+  return (found_it);
+}
+
+
+/*========================================================================*/
+void SelectorDeletePrefixSet(PyMOLGlobals * G, const char *pref)
+{
+  ov_diff a;
+  CSelector *I = G->Selector;
+  SelectorWordType name_copy;
+  int ignore_case = SettingGetGlobal_b(G, cSetting_ignore_case);
+
+  while(1) {
+    a = SelectGetNameOffset(G, pref, strlen(pref), ignore_case);
+    if(a > 0) {
+      strcpy(name_copy, I->Name[a]);
+      ExecutiveDelete(G, name_copy);    /* import to use a copy, otherwise 
+                                         * you'll delete all objects  */
+    } else
+      break;
+  }
+}
+
+
+/*========================================================================*/
+#define MAX_DEPTH 1000
+
+static int SelectorCheckNeighbors(PyMOLGlobals * G, int maxDist, ObjectMolecule * obj,
+                                  int at1, int at2, int *zero, int *scratch)
+{
+  int s;
+  int a, a1;
+  int stkDepth = 0;
+  int si = 0;
+  int stk[MAX_DEPTH];
+  int dist = 0;
+
+  zero[at1] = dist;
+  scratch[si++] = at1;
+  stk[stkDepth] = at1;
+  stkDepth++;
+
+  while(stkDepth) {             /* this will explore a tree */
+    stkDepth--;
+    a = stk[stkDepth];
+    dist = zero[a] + 1;
+
+    s = obj->Neighbor[a];       /* add neighbors onto the stack */
+    s++;                        /* skip count */
+    while(1) {
+      a1 = obj->Neighbor[s];
+      if(a1 == at2) {
+        while(si--) {
+          zero[scratch[si]] = 0;
+        }
+        /* EXIT POINT 1 */
+        return 1;
+      }
+      if(a1 >= 0) {
+        if((!zero[a1]) && (stkDepth < MAX_DEPTH) && (dist < maxDist)) {
+          zero[a1] = dist;
+          scratch[si++] = a1;
+          stk[stkDepth] = a1;
+          stkDepth++;
+        }
+      } else
+        break;
+      s += 2;
+    }
+  }
+  while(si--) {
+    zero[scratch[si]] = 0;
+  }
+  /* EXIT POINT 2 */
+  return 0;
+}
+
+
+/*========================================================================*/
+static
+int SelectorWalkTree(PyMOLGlobals * G, int *atom, int *comp, int *toDo, int **stk,
+                     int stkDepth, ObjectMolecule * obj,
+                     int sele1, int sele2, int sele3, int sele4)
+{
+  int s;
+  int c = 0;
+  int a, a1;
+  int seleFlag;
+  AtomInfoType *ai;
+
+  while(stkDepth) {             /* this will explore a tree, stopping at protected atoms */
+    stkDepth--;
+    a = (*stk)[stkDepth];
+    toDo[a] = 0;
+    seleFlag = false;
+    ai = obj->AtomInfo + a;
+    s = ai->selEntry;
+    seleFlag = SelectorIsMember(G, s, sele1);
+    if(!seleFlag)
+      seleFlag = SelectorIsMember(G, s, sele2);
+    if(!seleFlag)
+      seleFlag = SelectorIsMember(G, s, sele3);
+    if(!seleFlag)
+      seleFlag = SelectorIsMember(G, s, sele4);
+    if(!seleFlag) {
+      if(!(ai->protekted == 1)) {       /* if not explicitly protected... */
+        atom[a] = 1;            /* mark this atom into the selection */
+        comp[a] = 1;
+      }
+      s = obj->Neighbor[a];     /* add neighbors onto the stack */
+      s++;                      /* skip count */
+      while(1) {
+        a1 = obj->Neighbor[s];
+        if(a1 >= 0) {
+          if(toDo[a1]) {
+            VLACheck((*stk), int, stkDepth);
+            (*stk)[stkDepth] = a1;
+            stkDepth++;
+          }
+        } else
+          break;
+        s += 2;
+      }
+      c++;
+    }
+  }
+  return (c);
+}
+
+
+/*========================================================================*/
+static int SelectorWalkTreeDepth(PyMOLGlobals * G, int *atom, int *comp, int *toDo,
+                                 int **stk, int stkDepth, ObjectMolecule * obj, int sele1,
+                                 int sele2, int sele3, int sele4, int **extraStk,
+                                 WalkDepthRec * wd)
+{
+  int s;
+  int c = 0;
+  int a, a1;
+  int seleFlag;
+  int depth;
+  AtomInfoType *ai;
+
+  wd->depth1 = -1;
+  wd->depth2 = -1;
+  wd->depth3 = -1;
+  wd->depth4 = -1;
+  VLACheck(*extraStk, int, stkDepth);
+  UtilZeroMem(*extraStk, sizeof(int) * stkDepth);
+
+  while(stkDepth) {             /* this will explore a tree, stopping at protected atoms */
+    stkDepth--;
+    a = (*stk)[stkDepth];
+    depth = ((*extraStk)[stkDepth] + 1);
+    seleFlag = false;
+    ai = obj->AtomInfo + a;
+    s = ai->selEntry;
+
+    /* record how many cycles it take to reach each & any picked atoms */
+
+    seleFlag = false;
+    if(SelectorIsMember(G, s, sele1)) {
+      if(((wd->depth1 < 0) || (wd->depth1 > depth))) {
+        wd->depth1 = depth;
+      }
+      seleFlag = true;
+    }
+    if(SelectorIsMember(G, s, sele2)) {
+      if(((wd->depth2 < 0) || (wd->depth2 > depth))) {
+        wd->depth2 = depth;
+      }
+      seleFlag = true;
+    }
+    if(SelectorIsMember(G, s, sele3)) {
+      if(((wd->depth3 < 0) || (wd->depth3 > depth))) {
+        wd->depth3 = depth;
+      }
+      seleFlag = true;
+    }
+    if(SelectorIsMember(G, s, sele4)) {
+      if(((wd->depth4 < 0) || (wd->depth4 > depth))) {
+        wd->depth4 = depth;
+      }
+      seleFlag = true;
+    }
+
+    if(!seleFlag) {
+      toDo[a] = 0;
+      if(!(ai->protekted == 1)) {       /* if not explicitly protected... */
+        atom[a] = 1;            /* mark this atom into the selection */
+        comp[a] = 1;
+      }
+      s = obj->Neighbor[a];     /* add neighbors onto the stack */
+      s++;                      /* skip count */
+      while(1) {
+        a1 = obj->Neighbor[s];
+        if(a1 >= 0) {
+          if(toDo[a1]) {
+            VLACheck((*stk), int, stkDepth);
+            (*stk)[stkDepth] = a1;
+            VLACheck((*extraStk), int, stkDepth);
+            (*extraStk)[stkDepth] = depth;
+            stkDepth++;
+          }
+        } else
+          break;
+        s += 2;
+      }
+      c++;
+    }
+  }
+  return (c);
+}
+
+
+/*========================================================================*/
+
+int SelectorIsAtomBondedToSele(PyMOLGlobals * G, ObjectMolecule * obj, int sele1atom,
+                               int sele2)
+{
+  int a0, a2, s, ss;
+  int bonded = false;
+  ObjectMoleculeUpdateNeighbors(obj);
+
+  a0 = ObjectMoleculeGetAtomIndex(obj, sele1atom);
+
+  if(a0 >= 0) {
+    s = obj->Neighbor[a0];
+    s++;                        /* skip count */
+    while(1) {
+      a2 = obj->Neighbor[s];
+      if(a2 < 0)
+        break;
+      ss = obj->AtomInfo[a2].selEntry;
+      if(SelectorIsMember(G, ss, sele2)) {
+        bonded = true;
+        break;
+      }
+      s += 2;
+    }
+  }
+  return bonded;
+}
+
+static void update_min_walk_depth(WalkDepthRec * minWD,
+                                  int frag, WalkDepthRec * wd,
+                                  int sele1, int sele2, int sele3, int sele4)
+{
+  /* first, does this fragment even qualify ? */
+  int qualifies = true;
+  int cnt = 0;
+  wd->sum = 0;
+  if(sele1 >= 0) {
+    if(wd->depth1 < 0) {
+      qualifies = false;
+    } else {
+      wd->sum += wd->depth1;
+      cnt++;
+    }
+  }
+  if(sele2 >= 0) {
+    if(wd->depth2 < 0) {
+      qualifies = false;
+    } else {
+      wd->sum += wd->depth2;
+      cnt++;
+    }
+  }
+  if(sele3 >= 0) {
+    if(wd->depth3 < 0) {
+      qualifies = false;
+    } else {
+      wd->sum += wd->depth3;
+      cnt++;
+    }
+  }
+  if(sele4 >= 0) {
+    if(wd->depth4 < 0) {
+      qualifies = false;
+    } else {
+      wd->sum += wd->depth4;
+      cnt++;
+    }
+  }
+  if(qualifies && (cnt > 1)) {
+
+    /* is it better than the current min? */
+
+    if((!minWD->frag) || (wd->sum < minWD->sum)) {
+      (*minWD) = (*wd);
+      minWD->frag = frag;
+    }
+  }
+}
+
+
+/*========================================================================*/
+int SelectorSubdivide(PyMOLGlobals * G, const char *pref, int sele1, int sele2,
+                      int sele3, int sele4, const char *fragPref, const char *compName, int *bondMode)
+{
+  CSelector *I = G->Selector;
+  int a0 = 0, a1 = 0, a2;
+  int *atom = NULL;
+  int *toDo = NULL;
+  int *comp = NULL;
+  int *pkset = NULL;
+  int set_cnt = 0;
+  int nFrag = 0;
+  int *stk = NULL;
+  int stkDepth;
+  int c, s;
+  int cycFlag = false;
+  SelectorWordType name, link_sele = "";
+  ObjectMolecule *obj1 = NULL, *obj2 = NULL, *obj3 = NULL, *obj4 = NULL;
+  int index1 = 0, index2 = 0, index3 = 0, index4 = 0;
+
+  /* this is seriously getting out of hand -- need to switch over to arrays soon */
+
+  int *atom1_base = NULL, *atom2_base = NULL, *atom3_base = NULL, *atom4_base = NULL;
+  int *toDo1_base = NULL, *toDo2_base = NULL, *toDo3_base = NULL, *toDo4_base = NULL;
+  int *comp1_base = NULL, *comp2_base = NULL, *comp3_base = NULL, *comp4_base = NULL;
+  int *pkset1_base = NULL, *pkset2_base = NULL, *pkset3_base = NULL, *pkset4_base = NULL;
+
+  PRINTFD(G, FB_Selector)
+    " SelectorSubdivideObject: entered...\n" ENDFD;
+  SelectorDeletePrefixSet(G, pref);
+  SelectorDeletePrefixSet(G, fragPref);
+  ExecutiveDelete(G, cEditorLink);
+  ExecutiveDelete(G, cEditorSet);
+  /* delete any existing matches */
+
+  obj1 = SelectorGetFastSingleAtomObjectIndex(G, sele1, &index1);
+  obj2 = SelectorGetFastSingleAtomObjectIndex(G, sele2, &index2);
+  obj3 = SelectorGetFastSingleAtomObjectIndex(G, sele3, &index3);
+  obj4 = SelectorGetFastSingleAtomObjectIndex(G, sele4, &index4);
+
+  if(obj1 || obj2 || obj3 || obj4) {
+
+    if(obj1)
+      ObjectMoleculeUpdateNeighbors(obj1);
+    if(obj2)
+      ObjectMoleculeUpdateNeighbors(obj2);
+    if(obj3)
+      ObjectMoleculeUpdateNeighbors(obj3);
+    if(obj4)
+      ObjectMoleculeUpdateNeighbors(obj4);
+
+    SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+
+    comp = pymol::calloc<int>(I->NAtom);
+    atom = pymol::malloc<int>(I->NAtom);
+    toDo = pymol::malloc<int>(I->NAtom);
+    pkset = pymol::calloc<int>(I->NAtom);
+
+    /* NOTE: SeleBase only safe with cSelectorUpdateTableAllStates!  */
+
+    if(obj1) {
+      atom1_base = atom + obj1->SeleBase;
+      toDo1_base = toDo + obj1->SeleBase;
+      comp1_base = comp + obj1->SeleBase;
+      pkset1_base = pkset + obj1->SeleBase;
+    }
+
+    if(obj2) {
+      atom2_base = atom + obj2->SeleBase;
+      toDo2_base = toDo + obj2->SeleBase;
+      comp2_base = comp + obj2->SeleBase;
+      pkset2_base = pkset + obj2->SeleBase;
+    }
+
+    if(obj3) {
+      atom3_base = atom + obj3->SeleBase;
+      toDo3_base = toDo + obj3->SeleBase;
+      comp3_base = comp + obj3->SeleBase;
+      pkset3_base = pkset + obj3->SeleBase;
+    }
+
+    if(obj4) {
+      atom4_base = atom + obj4->SeleBase;
+      toDo4_base = toDo + obj4->SeleBase;
+      comp4_base = comp + obj4->SeleBase;
+      pkset4_base = pkset + obj4->SeleBase;
+    }
+
+    stk = VLAlloc(int, 100);
+
+    {
+      int a;
+      int *p1;
+      p1 = toDo;
+      for(a = 0; a < I->NAtom; a++)
+        *(p1++) = true;
+    }
+
+    if(*bondMode) {
+      /* verify bond mode, or clear the flag */
+
+      *bondMode = false;
+
+      if((sele1 >= 0) && (sele2 >= 0) && (sele3 < 0) && (sele4 < 0) && (obj1 == obj2)) {
+        /* two selections only, in same object... */
+
+        a0 = index1;
+        a1 = index2;
+
+        if((a0 >= 0) && (a1 >= 0)) {
+          s = obj1->Neighbor[a0];       /* add neighbors onto the stack */
+          s++;                  /* skip count */
+          while(1) {
+            a2 = obj1->Neighbor[s];
+            if(a2 < 0)
+              break;
+            if(a2 == a1) {
+              *bondMode = true;
+              break;
+            }
+            s += 2;
+          }
+        }
+      }
+    }
+
+    /* ===== BOND MODE ===== (sele0 and sele1 only) */
+
+    if(*bondMode) {
+      if(obj1 == obj2) {        /* just to be safe */
+
+        pkset1_base[a0] = 1;
+        pkset1_base[a1] = 1;
+        SelectorEmbedSelection(G, pkset, cEditorBond, NULL, false, -1);
+
+        a0 = index1;
+        if(a0 >= 0) {
+          stkDepth = 0;
+          s = obj1->Neighbor[a0];       /* add neighbors onto the stack */
+          s++;                  /* skip count */
+          while(1) {
+            a1 = obj1->Neighbor[s];
+            if(a1 >= 0) {
+              if(toDo1_base[a1]) {
+                VLACheck(stk, int, stkDepth);
+                stk[stkDepth] = a1;
+                stkDepth++;
+              }
+            } else
+              break;
+            s += 2;
+          }
+          UtilZeroMem(atom, sizeof(int) * I->NAtom);
+          atom1_base[a0] = 1;   /* create selection for this atom alone as fragment base atom */
+          comp1_base[a0] = 1;
+          sprintf(name, "%s%1d", fragPref, nFrag + 1);
+          SelectorEmbedSelection(G, atom, name, NULL, false, -1);
+          c =
+            SelectorWalkTree(G, atom1_base, comp1_base, toDo1_base, &stk, stkDepth, obj1,
+                             sele1, sele2, -1, -1) + 1;
+          sprintf(name, "%s%1d", pref, nFrag + 1);
+
+          /* check for cyclic situation */
+          cycFlag = false;
+          a2 = index2;
+          if(a2 >= 0) {
+            stkDepth = 0;
+            s = obj1->Neighbor[a2];     /* add neighbors onto the stack */
+            s++;                /* skip count */
+            while(1) {
+              a1 = obj1->Neighbor[s];
+              if(a1 < 0)
+                break;
+              if((a1 >= 0) && (a1 != a0)) {
+                if(!toDo1_base[a1]) {
+                  cycFlag = true;       /* we have a cycle... */
+                  break;
+                }
+              }
+              s += 2;
+            }
+          }
+          if(cycFlag) {         /* cyclic situation is a bit complex... */
+
+            a0 = index2;
+            if(a0 >= 0) {
+              stkDepth = 0;
+              s = obj1->Neighbor[a0];   /* add neighbors onto the stack */
+              s++;              /* skip count */
+              while(1) {
+                a1 = obj1->Neighbor[s];
+                if(a1 >= 0) {
+                  if(toDo1_base[a1]) {
+                    VLACheck(stk, int, stkDepth);
+                    stk[stkDepth] = a1;
+                    stkDepth++;
+                  }
+                } else
+                  break;
+                s += 2;
+              }
+              atom1_base[a0] = 1;
+              comp1_base[a0] = 1;
+              c =
+                SelectorWalkTree(G, atom1_base, comp1_base, toDo1_base, &stk, stkDepth,
+                                 obj1, sele1, sele2, -1, -1) + 1;
+            }
+          }
+          SelectorEmbedSelection(G, atom, name, NULL, false, -1);
+          nFrag++;
+        }
+
+        if(!cycFlag) {
+          a0 = index2;
+          if(a0 >= 0) {
+            stkDepth = 0;
+            s = obj1->Neighbor[a0];     /* add neighbors onto the stack */
+            s++;                /* skip count */
+            while(1) {
+              a1 = obj1->Neighbor[s];
+              if(a1 >= 0) {
+                if(toDo1_base[a1]) {
+                  VLACheck(stk, int, stkDepth);
+                  stk[stkDepth] = a1;
+                  stkDepth++;
+                }
+              } else
+                break;
+              s += 2;
+            }
+
+            UtilZeroMem(atom, sizeof(int) * I->NAtom);
+            atom1_base[a0] = 1; /* create selection for this atom alone as fragment base atom */
+            comp1_base[a0] = 1;
+            sprintf(name, "%s%1d", fragPref, nFrag + 1);
+            SelectorEmbedSelection(G, atom, name, NULL, false, -1);
+            c =
+              SelectorWalkTree(G, atom1_base, comp1_base, toDo1_base, &stk, stkDepth,
+                               obj1, sele1, sele2, -1, -1) + 1;
+            sprintf(name, "%s%1d", pref, nFrag + 1);
+            SelectorEmbedSelection(G, atom, name, NULL, false, -1);
+            nFrag++;
+          }
+        }
+      }
+    } else {
+      /* ===== WALK MODE ===== (any combination of sele0, sele1, sele2, sele3 */
+
+      int *extraStk = VLAlloc(int, 50);
+      WalkDepthRec curWalk, minWalk;
+      minWalk.sum = 0;
+      minWalk.frag = 0;
+
+      if(obj1) {
+        a0 = index1;
+        if(a0 >= 0) {
+          pkset1_base[a0] = 1;
+          set_cnt++;
+          comp1_base[a0] = 1;
+          stkDepth = 0;
+          s = obj1->Neighbor[a0];       /* add neighbors onto the stack */
+          s++;                  /* skip count */
+          while(1) {
+            a1 = obj1->Neighbor[s];
+            if(a1 < 0)
+              break;
+            if(toDo1_base[a1]) {
+              stkDepth = 1;
+              stk[0] = a1;
+              UtilZeroMem(atom, sizeof(int) * I->NAtom);
+              atom1_base[a1] = 1;       /* create selection for this atom alone as fragment base atom */
+              comp1_base[a1] = 1;
+              sprintf(name, "%s%1d", fragPref, nFrag + 1);
+              SelectorEmbedSelection(G, atom, name, NULL, false, -1);
+              atom1_base[a1] = 0;
+              c = SelectorWalkTreeDepth(G, atom1_base, comp1_base, toDo1_base, &stk,
+                                        stkDepth, obj1, sele1, sele2, sele3, sele4,
+                                        &extraStk, &curWalk);
+              if(c) {
+                nFrag++;
+                sprintf(name, "%s%1d", pref, nFrag);
+                SelectorEmbedSelection(G, atom, name, NULL, false, -1);
+                update_min_walk_depth(&minWalk,
+                                      nFrag, &curWalk, sele1, sele2, sele3, sele4);
+              }
+            }
+            s += 2;
+          }
+        }
+      }
+
+      if(obj2) {
+        a0 = index2;
+        if(a0 >= 0) {
+          pkset2_base[a0] = 1;
+          set_cnt++;
+          comp2_base[a0] = 1;
+          stkDepth = 0;
+          s = obj2->Neighbor[a0];       /* add neighbors onto the stack */
+          s++;                  /* skip count */
+          while(1) {
+            a1 = obj2->Neighbor[s];
+            if(a1 < 0)
+              break;
+            if(toDo2_base[a1]) {
+              stkDepth = 1;
+              stk[0] = a1;
+              UtilZeroMem(atom, sizeof(int) * I->NAtom);
+              atom2_base[a1] = 1;       /* create selection for this atom alone as fragment base atom */
+              comp2_base[a1] = 1;
+              sprintf(name, "%s%1d", fragPref, nFrag + 1);
+              SelectorEmbedSelection(G, atom, name, NULL, false, -1);
+              atom2_base[a1] = 0;
+              c = SelectorWalkTreeDepth(G, atom2_base, comp2_base, toDo2_base, &stk,
+                                        stkDepth, obj2, sele1, sele2, sele3, sele4,
+                                        &extraStk, &curWalk);
+              if(c) {
+                nFrag++;
+                sprintf(name, "%s%1d", pref, nFrag);
+                SelectorEmbedSelection(G, atom, name, NULL, false, -1);
+                update_min_walk_depth(&minWalk,
+                                      nFrag, &curWalk, sele1, sele2, sele3, sele4);
+              }
+            }
+            s += 2;
+          }
+        }
+      }
+
+      if(obj3) {
+        a0 = index3;
+        if(a0 >= 0) {
+          pkset3_base[a0] = 1;
+          set_cnt++;
+          comp3_base[a0] = 1;
+          stkDepth = 0;
+          s = obj3->Neighbor[a0];       /* add neighbors onto the stack */
+          s++;                  /* skip count */
+          while(1) {
+            a1 = obj3->Neighbor[s];
+            if(a1 < 0)
+              break;
+            if(toDo3_base[a1]) {
+              stkDepth = 1;
+              stk[0] = a1;
+              UtilZeroMem(atom, sizeof(int) * I->NAtom);
+              atom3_base[a1] = 1;       /* create selection for this atom alone as fragment base atom */
+              comp3_base[a1] = 1;
+              sprintf(name, "%s%1d", fragPref, nFrag + 1);
+              SelectorEmbedSelection(G, atom, name, NULL, false, -1);
+              atom3_base[a1] = 0;
+              c = SelectorWalkTreeDepth(G, atom3_base, comp3_base, toDo3_base, &stk,
+                                        stkDepth, obj3, sele1, sele2, sele3, sele4,
+                                        &extraStk, &curWalk);
+              if(c) {
+                nFrag++;
+                sprintf(name, "%s%1d", pref, nFrag);
+                SelectorEmbedSelection(G, atom, name, NULL, false, -1);
+                update_min_walk_depth(&minWalk,
+                                      nFrag, &curWalk, sele1, sele2, sele3, sele4);
+
+              }
+            }
+            s += 2;
+          }
+        }
+      }
+
+      if(obj4) {
+        a0 = index4;
+        if(a0 >= 0) {
+          pkset4_base[a0] = 1;
+          set_cnt++;
+          comp4_base[a0] = 1;
+          stkDepth = 0;
+          s = obj4->Neighbor[a0];       /* add neighbors onto the stack */
+          s++;                  /* skip count */
+          while(1) {
+            a1 = obj4->Neighbor[s];
+            if(a1 < 0)
+              break;
+            if(toDo4_base[a1]) {
+              stkDepth = 1;
+              stk[0] = a1;
+              UtilZeroMem(atom, sizeof(int) * I->NAtom);
+              atom4_base[a1] = 1;       /* create selection for this atom alone as fragment base atom */
+              comp4_base[a1] = 1;
+              sprintf(name, "%s%1d", fragPref, nFrag + 1);
+              SelectorEmbedSelection(G, atom, name, NULL, false, -1);
+              atom4_base[a1] = 0;
+              c = SelectorWalkTreeDepth(G, atom4_base, comp4_base, toDo4_base, &stk,
+                                        stkDepth, obj4, sele1, sele2, sele3, sele4,
+                                        &extraStk, &curWalk);
+              if(c) {
+                nFrag++;
+                sprintf(name, "%s%1d", pref, nFrag);
+                SelectorEmbedSelection(G, atom, name, NULL, false, -1);
+                update_min_walk_depth(&minWalk,
+                                      nFrag, &curWalk, sele1, sele2, sele3, sele4);
+              }
+            }
+            s += 2;
+          }
+        }
+      }
+
+      if(minWalk.frag) {        /* create the linking selection if one exists */
+        sprintf(link_sele, "%s%d|?pk1|?pk2|?pk3|?pk4", pref, minWalk.frag);
+      }
+      VLAFreeP(extraStk);
+    }
+
+    if(set_cnt > 1) {
+      SelectorEmbedSelection(G, pkset, cEditorSet, NULL, false, -1);
+    }
+
+    if(nFrag) {
+      SelectorEmbedSelection(G, comp, compName, NULL, false, -1);
+    }
+
+    if(link_sele[0])
+      SelectorCreate(G, cEditorLink, link_sele, NULL, true, NULL);
+
+    FreeP(toDo);
+    FreeP(atom);
+    FreeP(comp);
+    FreeP(pkset);
+    VLAFreeP(stk);
+    SelectorClean(G);
+  }
+  PRINTFD(G, FB_Selector)
+    " SelectorSubdivideObject: leaving...nFrag %d\n", nFrag ENDFD;
+
+  return (nFrag);
+}
+
+
+/*========================================================================*/
+int SelectorGetSeleNCSet(PyMOLGlobals * G, int sele)
+{
+  CSelector *I = G->Selector;
+
+  int a, s, at = 0;
+  ObjectMolecule *obj, *last_obj = NULL;
+  int result = 0;
+
+  if((obj = SelectorGetFastSingleAtomObjectIndex(G, sele, &at))) {
+    int a = obj->NCSet;
+    CoordSet *cs;
+    int idx;
+
+    while(a--) {
+      cs = obj->CSet[a];
+      idx = cs->atmToIdx(at);
+      if(idx >= 0) {
+        result = a + 1;
+        break;
+      }
+    }
+  } else {
+    for(a = cNDummyAtoms; a < I->NAtom; a++) {
+      obj = I->Obj[I->Table[a].model];
+      if(obj != last_obj) {
+        at = I->Table[a].atom;
+        s = obj->AtomInfo[at].selEntry;
+        if(SelectorIsMember(G, s, sele)) {
+          if(result < obj->NCSet) {
+            result = obj->NCSet;
+            last_obj = obj;
+          }
+        }
+      }
+    }
+  }
+  return (result);
+}
+
+
+/*========================================================================*/
+static int SelectorGetArrayNCSet(
+    PyMOLGlobals* G, const sele_array_t& uptr, int no_dummies)
+{
+  const int* array = uptr.get();
+  CSelector *I = G->Selector;
+  int a;
+  ObjectMolecule *obj;
+  int result = 0;
+  int start = 0;
+  if(no_dummies)
+    start = cNDummyAtoms;
+  for(a = start; a < I->NAtom; a++) {
+    if(*(array++)) {
+      if(a >= cNDummyAtoms) {
+        obj = I->Obj[I->Table[a].model];
+        if(result < obj->NCSet)
+          result = obj->NCSet;
+      } else {
+        if(result < 1)
+          result = 1;           /* selected dummy has at least one CSet */
+      }
+
+    }
+  }
+  return (result);
+}
+
+
+/*========================================================================*/
+float SelectorSumVDWOverlap(PyMOLGlobals * G, int sele1, int state1, int sele2,
+                            int state2, float adjust)
+{
+  CSelector *I = G->Selector;
+  int *vla = NULL;
+  int c;
+  float result = 0.0;
+  float sumVDW = 0.0, dist;
+  int a1, a2;
+  AtomInfoType *ai1, *ai2;
+  int at1, at2;
+  CoordSet *cs1, *cs2;
+  ObjectMolecule *obj1, *obj2;
+  int idx1, idx2;
+  int a;
+
+  if(state1 < 0)
+    state1 = 0;
+  if(state2 < 0)
+    state2 = 0;
+
+  if(state1 != state2) {
+    SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+  } else {
+    SelectorUpdateTable(G, state1, -1);
+  }
+
+  c =
+    SelectorGetInterstateVLA(G, sele1, state1, sele2, state2, 2 * MAX_VDW + adjust, &vla);
+  for(a = 0; a < c; a++) {
+    a1 = vla[a * 2];
+    a2 = vla[a * 2 + 1];
+
+    at1 = I->Table[a1].atom;
+    at2 = I->Table[a2].atom;
+
+    obj1 = I->Obj[I->Table[a1].model];
+    obj2 = I->Obj[I->Table[a2].model];
+
+    if((state1 < obj1->NCSet) && (state2 < obj2->NCSet)) {
+      cs1 = obj1->CSet[state1];
+      cs2 = obj2->CSet[state2];
+      if(cs1 && cs2) {          /* should always be true */
+
+        ai1 = obj1->AtomInfo + at1;
+        ai2 = obj2->AtomInfo + at2;
+
+        idx1 = cs1->AtmToIdx[at1];      /* these are also pre-validated */
+        idx2 = cs2->AtmToIdx[at2];
+
+        sumVDW = ai1->vdw + ai2->vdw + adjust;
+        dist = (float) diff3f(cs1->Coord + 3 * idx1, cs2->Coord + 3 * idx2);
+
+        if(dist < sumVDW) {
+          result += ((sumVDW - dist) / 2.0F);
+        }
+      }
+    }
+  }
+  VLAFreeP(vla);
+  return (result);
+}
+
+
+/*========================================================================*/
+static int SelectorGetInterstateVLA(PyMOLGlobals * G,
+                                    int sele1, int state1,
+                                    int sele2, int state2, float cutoff, int **vla)
+{                               /* Assumes valid tables */
+  CSelector *I = G->Selector;
+  MapType *map;
+  float *v2;
+  int n1, n2;
+  int c, i, j, h, k, l;
+  int at;
+  int a, s, idx;
+  ObjectMolecule *obj;
+  CoordSet *cs;
+
+  if(!(*vla))
+    (*vla) = VLAlloc(int, 1000);
+
+  c = 0;
+  n1 = 0;
+
+  for(a = 0; a < I->NAtom; a++) {
+    /* foreach atom, grab its atom ID, object ID, selection ID,
+     * and current state's coordinate set */
+    I->Flag1[a] = false;
+    at = I->Table[a].atom;
+    obj = I->Obj[I->Table[a].model];
+    s = obj->AtomInfo[at].selEntry;
+    if(SelectorIsMember(G, s, sele1)) {
+      if(state1 < obj->NCSet)
+        cs = obj->CSet[state1];
+      else
+        cs = NULL;
+      if(cs) {
+        if(CoordSetGetAtomVertex(cs, at, I->Vertex + 3 * a)) {
+          I->Flag1[a] = true;
+          n1++;
+        }
+      }
+    }
+  }
+  /* now create and apply voxel map */
+  c = 0;
+  if(n1) {
+    n2 = 0;
+    map = MapNewFlagged(G, -cutoff, I->Vertex, I->NAtom, NULL, I->Flag1);
+    if(map) {
+      MapSetupExpress(map);
+      for(a = cNDummyAtoms; a < I->NAtom; a++) {
+        at = I->Table[a].atom;
+        obj = I->Obj[I->Table[a].model];
+        s = obj->AtomInfo[at].selEntry;
+        if(SelectorIsMember(G, s, sele2)) {
+          if(state2 < obj->NCSet)
+            cs = obj->CSet[state2];
+          else
+            cs = NULL;
+          if(cs) {
+            idx = cs->atmToIdx(at);
+            if(idx >= 0) {
+              v2 = cs->Coord + (3 * idx);
+              if(MapExclLocus(map, v2, &h, &k, &l)) {
+                i = *(MapEStart(map, h, k, l));
+                if(i) {
+                  j = map->EList[i++];
+                  while(j >= 0) {
+                    if(within3f(I->Vertex + 3 * j, v2, cutoff)) {
+                      VLACheck((*vla), int, c * 2 + 1);
+                      *((*vla) + c * 2) = j;
+                      *((*vla) + c * 2 + 1) = a;
+                      c++;
+                    }
+                    j = map->EList[i++];
+                  }
+                }
+              }
+              n2++;
+            }
+          }
+        }
+      }
+      MapFree(map);
+    }
+  }
+  return (c);
+}
+
+
+/*========================================================================*/
+int SelectorMapMaskVDW(PyMOLGlobals * G, int sele1, ObjectMapState * oMap, float buffer,
+                       int state)
+{
+  CSelector *I = G->Selector;
+  MapType *map;
+  float *v2;
+  int n1;
+  int a, b, c, i, j, h, k, l;
+  int at;
+  int s;
+  AtomInfoType *ai;
+  ObjectMolecule *obj;
+  CoordSet *cs;
+  int state1, state2;
+  int once_flag;
+
+  c = 0;
+  n1 = 0;
+  SelectorUpdateTable(G, state, -1);
+
+  for(a = 0; a < I->NAtom; a++) {
+    I->Flag1[a] = false;
+    at = I->Table[a].atom;
+    obj = I->Obj[I->Table[a].model];
+    s = obj->AtomInfo[at].selEntry;
+    if(SelectorIsMember(G, s, sele1)) {
+      once_flag = true;
+      for(state2 = 0; state2 < obj->NCSet; state2++) {
+        if(state < 0)
+          once_flag = false;
+        if(!once_flag)
+          state1 = state2;
+        else
+          state1 = state;
+        if(state1 < obj->NCSet)
+          cs = obj->CSet[state1];
+        else
+          cs = NULL;
+        if(cs) {
+          if(CoordSetGetAtomVertex(cs, at, I->Vertex + 3 * a)) {
+            I->Flag1[a] = true;
+            n1++;
+          }
+        }
+        if(once_flag)
+          break;
+      }
+    }
+  }
+  /* now create and apply voxel map */
+  c = 0;
+  if(n1) {
+    map = MapNewFlagged(G, -(buffer + MAX_VDW), I->Vertex, I->NAtom, NULL, I->Flag1);
+    if(map) {
+      MapSetupExpress(map);
+
+      for(a = oMap->Min[0]; a <= oMap->Max[0]; a++) {
+        for(b = oMap->Min[1]; b <= oMap->Max[1]; b++) {
+          for(c = oMap->Min[2]; c <= oMap->Max[2]; c++) {
+            F3(oMap->Field->data, a, b, c) = 0.0;
+
+            v2 = F4Ptr(oMap->Field->points, a, b, c, 0);
+
+            if(MapExclLocus(map, v2, &h, &k, &l)) {
+              i = *(MapEStart(map, h, k, l));
+              if(i) {
+                j = map->EList[i++];
+                while(j >= 0) {
+                  ai = I->Obj[I->Table[j].model]->AtomInfo + I->Table[j].atom;
+                  if(within3f(I->Vertex + 3 * j, v2, ai->vdw + buffer)) {
+                    F3(oMap->Field->data, a, b, c) = 1.0;
+                  }
+                  j = map->EList[i++];
+                }
+              }
+            }
+          }
+        }
+      }
+      oMap->Active = true;
+      MapFree(map);
+    }
+  }
+  return (c);
+}
+
+static double max2d(double a, double b)
+{
+  if(a > b)
+    return a;
+  else
+    return b;
+}
+
+static double max6d(double a, double b, double c, double d, double e, double f)
+{
+
+  if(d > a)
+    a = d;
+  if(e > b)
+    b = e;
+  if(f > c)
+    c = f;
+  if(b > a)
+    a = b;
+  if(c > a)
+    a = c;
+  return (a);
+}
+
+#define D_SMALL10 1e-10
+
+typedef double AtomSF[11];
+
+
+/*========================================================================*/
+int SelectorMapGaussian(PyMOLGlobals * G, int sele1, ObjectMapState * oMap,
+                        float buffer, int state, int normalize, int use_max, int quiet,
+                        float resolution)
+{
+  CSelector *I = G->Selector;
+  MapType *map;
+  float *v2;
+  int n1, n2;
+  int a, b, c, i, j, h, k, l;
+  int at;
+  int s, idx;
+  AtomInfoType *ai;
+  ObjectMolecule *obj;
+  CoordSet *cs;
+  int state1, state2;
+  float *point = NULL, *fp;
+  int *sfidx = NULL, *ip;
+  float *b_factor = NULL, *bf, bfact;
+  float *occup = NULL, *oc;
+  int prot;
+  int once_flag;
+  float d, e_val;
+  double sum, sumsq;
+  float mean, stdev;
+  double sf[256][11], *sfp;
+  AtomSF *atom_sf = NULL;
+  double b_adjust = (double) SettingGetGlobal_f(G, cSetting_gaussian_b_adjust);
+  double elim = 7.0;
+  double rcut2;
+  float rcut;
+  float max_rcut = 0.0F;
+  float b_floor = SettingGetGlobal_f(G, cSetting_gaussian_b_floor);
+  float blur_factor = 1.0F;
+
+  {
+    if(resolution < R_SMALL4)
+      resolution = SettingGetGlobal_f(G, cSetting_gaussian_resolution);
+    if(resolution < 1.0 ) 
+      resolution = 1.0F;
+    blur_factor = 2.0F / resolution;    
+    /* a gaussian_resolution of 2.0 is considered perfect ? Hmm...where is this from??? */
+
+  }
+
+  if(b_adjust > 500.0)
+    b_adjust = 500.0;           /* constrain to be somewhat reasonable */
+
+  for(a = 0; a < 256; a++) {
+    sf[a][0] = -1.0;
+  }
+
+  sf[cAN_H][0] = 0.493002;
+  sf[cAN_H][1] = 10.510900;
+  sf[cAN_H][2] = 0.322912;
+  sf[cAN_H][3] = 26.125700;
+  sf[cAN_H][4] = 0.140191;
+  sf[cAN_H][5] = 3.142360;
+  sf[cAN_H][6] = 0.040810;
+  sf[cAN_H][7] = 57.799698;
+  sf[cAN_H][8] = 0.003038;
+  sf[cAN_H][9] = 0.0;
+
+  /* LP currently using scattering factors of carbon 
+     (Roche Pocket viewer relies upon this behavior) */
+
+  sf[cAN_LP][0] = 2.310000;
+  sf[cAN_LP][1] = 20.843899;
+  sf[cAN_LP][2] = 1.020000;
+  sf[cAN_LP][3] = 10.207500;
+  sf[cAN_LP][4] = 1.588600;
+  sf[cAN_LP][5] = 0.568700;
+  sf[cAN_LP][6] = 0.865000;
+  sf[cAN_LP][7] = 51.651199;
+  sf[cAN_LP][8] = 0.215600;
+  sf[cAN_LP][9] = 0.0;
+
+  sf[cAN_C][0] = 2.310000;
+  sf[cAN_C][1] = 20.843899;
+  sf[cAN_C][2] = 1.020000;
+  sf[cAN_C][3] = 10.207500;
+  sf[cAN_C][4] = 1.588600;
+  sf[cAN_C][5] = 0.568700;
+  sf[cAN_C][6] = 0.865000;
+  sf[cAN_C][7] = 51.651199;
+  sf[cAN_C][8] = 0.215600;
+  sf[cAN_C][9] = 0.0;
+
+  sf[cAN_O][0] = 3.048500;
+  sf[cAN_O][1] = 13.277100;
+  sf[cAN_O][2] = 2.286800;
+  sf[cAN_O][3] = 5.701100;
+  sf[cAN_O][4] = 1.546300;
+  sf[cAN_O][5] = 0.323900;
+  sf[cAN_O][6] = 0.867000;
+  sf[cAN_O][7] = 32.908897;
+  sf[cAN_O][8] = 0.250800;
+  sf[cAN_O][9] = 0.0;
+
+  sf[cAN_N][0] = 12.212600;
+  sf[cAN_N][1] = 0.005700;
+  sf[cAN_N][2] = 3.132200;
+  sf[cAN_N][3] = 9.893300;
+  sf[cAN_N][4] = 2.012500;
+  sf[cAN_N][5] = 28.997499;
+  sf[cAN_N][6] = 1.166300;
+  sf[cAN_N][7] = 0.582600;
+  sf[cAN_N][8] = -11.528999;
+  sf[cAN_N][9] = 0.0;
+
+  sf[cAN_S][0] = 6.905300;
+  sf[cAN_S][1] = 1.467900;
+  sf[cAN_S][2] = 5.203400;
+  sf[cAN_S][3] = 22.215099;
+  sf[cAN_S][4] = 1.437900;
+  sf[cAN_S][5] = 0.253600;
+  sf[cAN_S][6] = 1.586300;
+  sf[cAN_S][7] = 56.172001;
+  sf[cAN_S][8] = 0.866900;
+  sf[cAN_S][9] = 0.0;
+
+  sf[cAN_Cl][0] = 11.460400;
+  sf[cAN_Cl][1] = 0.010400;
+  sf[cAN_Cl][2] = 7.196400;
+  sf[cAN_Cl][3] = 1.166200;
+  sf[cAN_Cl][4] = 6.255600;
+  sf[cAN_Cl][5] = 18.519400;
+  sf[cAN_Cl][6] = 1.645500;
+  sf[cAN_Cl][7] = 47.778400;
+  sf[cAN_Cl][8] = 0.866900;
+  sf[cAN_Cl][9] = 0.0;
+
+  sf[cAN_Br][0] = 17.178900;
+  sf[cAN_Br][1] = 2.172300;
+  sf[cAN_Br][2] = 5.235800;
+  sf[cAN_Br][3] = 16.579599;
+  sf[cAN_Br][4] = 5.637700;
+  sf[cAN_Br][5] = 0.260900;
+  sf[cAN_Br][6] = 3.985100;
+  sf[cAN_Br][7] = 41.432800;
+  sf[cAN_Br][8] = 2.955700;
+  sf[cAN_Br][9] = 0.0;
+
+  sf[cAN_I][0] = 20.147200;
+  sf[cAN_I][1] = 4.347000;
+  sf[cAN_I][2] = 18.994900;
+  sf[cAN_I][3] = 0.381400;
+  sf[cAN_I][4] = 7.513800;
+  sf[cAN_I][5] = 27.765999;
+  sf[cAN_I][6] = 2.273500;
+  sf[cAN_I][7] = 66.877602;
+  sf[cAN_I][8] = 4.071200;
+  sf[cAN_I][9] = 0.0;
+
+  sf[cAN_F][0] = 3.539200;
+  sf[cAN_F][1] = 10.282499;
+  sf[cAN_F][2] = 2.641200;
+  sf[cAN_F][3] = 4.294400;
+  sf[cAN_F][4] = 1.517000;
+  sf[cAN_F][5] = 0.261500;
+  sf[cAN_F][6] = 1.024300;
+  sf[cAN_F][7] = 26.147600;
+  sf[cAN_F][8] = 0.277600;
+  sf[cAN_F][9] = 0.0;
+
+  sf[cAN_K][0] = 8.218599;
+  sf[cAN_K][1] = 12.794900;
+  sf[cAN_K][2] = 7.439800;
+  sf[cAN_K][3] = 0.774800;
+  sf[cAN_K][4] = 1.051900;
+  sf[cAN_K][5] = 213.186996;
+  sf[cAN_K][6] = 0.865900;
+  sf[cAN_K][7] = 41.684097;
+  sf[cAN_K][8] = 1.422800;
+  sf[cAN_K][9] = 0.0;
+
+  sf[cAN_Mg][0] = 5.420400;
+  sf[cAN_Mg][1] = 2.827500;
+  sf[cAN_Mg][2] = 2.173500;
+  sf[cAN_Mg][3] = 79.261101;
+  sf[cAN_Mg][4] = 1.226900;
+  sf[cAN_Mg][5] = 0.380800;
+  sf[cAN_Mg][6] = 2.307300;
+  sf[cAN_Mg][7] = 7.193700;
+  sf[cAN_Mg][8] = 0.858400;
+  sf[cAN_Mg][9] = 0.0;
+
+  sf[cAN_Na][0] = 4.762600;
+  sf[cAN_Na][1] = 3.285000;
+  sf[cAN_Na][2] = 3.173600;
+  sf[cAN_Na][3] = 8.842199;
+  sf[cAN_Na][4] = 1.267400;
+  sf[cAN_Na][5] = 0.313600;
+  sf[cAN_Na][6] = 1.112800;
+  sf[cAN_Na][7] = 129.423996;
+  sf[cAN_Na][8] = 0.676000;
+  sf[cAN_Na][9] = 0.0;
+
+  sf[cAN_P][0] = 6.434500;
+  sf[cAN_P][1] = 1.906700;
+  sf[cAN_P][2] = 4.179100;
+  sf[cAN_P][3] = 27.157000;
+  sf[cAN_P][4] = 1.780000;
+  sf[cAN_P][5] = 0.526000;
+  sf[cAN_P][6] = 1.490800;
+  sf[cAN_P][7] = 68.164497;
+  sf[cAN_P][8] = 1.114900;
+  sf[cAN_P][9] = 0.0;
+
+  sf[cAN_Zn][0] = 14.074300;
+  sf[cAN_Zn][1] = 3.265500;
+  sf[cAN_Zn][2] = 7.031800;
+  sf[cAN_Zn][3] = 0.233300;
+  sf[cAN_Zn][4] = 5.162500;
+  sf[cAN_Zn][5] = 10.316299;
+  sf[cAN_Zn][6] = 2.410000;
+  sf[cAN_Zn][7] = 58.709702;
+  sf[cAN_Zn][8] = 1.304100;
+  sf[cAN_Zn][9] = 0.0;
+
+  sf[cAN_Ca][0] = 8.626600;
+  sf[cAN_Ca][1] = 10.442100;
+  sf[cAN_Ca][2] = 7.387300;
+  sf[cAN_Ca][3] = 0.659900;
+  sf[cAN_Ca][4] = 1.589900;
+  sf[cAN_Ca][5] = 85.748398;
+  sf[cAN_Ca][6] = 1.021100;
+  sf[cAN_Ca][7] = 178.436996;
+  sf[cAN_Ca][8] = 1.375100;
+  sf[cAN_Ca][9] = 0.0;
+
+  sf[cAN_Cu][0] = 13.337999;
+  sf[cAN_Cu][1] = 3.582800;
+  sf[cAN_Cu][2] = 7.167600;
+  sf[cAN_Cu][3] = 0.247000;
+  sf[cAN_Cu][4] = 5.615800;
+  sf[cAN_Cu][5] = 11.396600;
+  sf[cAN_Cu][6] = 1.673500;
+  sf[cAN_Cu][7] = 64.812599;
+  sf[cAN_Cu][8] = 1.191000;
+  sf[cAN_Cu][9] = 0.0;
+
+  sf[cAN_Fe][0] = 11.769500;
+  sf[cAN_Fe][1] = 4.761100;
+  sf[cAN_Fe][2] = 7.357300;
+  sf[cAN_Fe][3] = 0.307200;
+  sf[cAN_Fe][4] = 3.522200;
+  sf[cAN_Fe][5] = 15.353500;
+  sf[cAN_Fe][6] = 2.304500;
+  sf[cAN_Fe][7] = 76.880501;
+  sf[cAN_Fe][8] = 1.036900;
+  sf[cAN_Fe][9] = 0.0;
+
+  sf[cAN_Se][0] = 17.000599;
+  sf[cAN_Se][1] = 2.409800;
+  sf[cAN_Se][2] = 5.819600;
+  sf[cAN_Se][3] = 0.272600;
+  sf[cAN_Se][4] = 3.973100;
+  sf[cAN_Se][5] = 15.237200;
+  sf[cAN_Se][6] = 4.354300;
+  sf[cAN_Se][7] = 43.816299;
+  sf[cAN_Se][8] = 2.840900;
+  sf[cAN_Se][9] = 0.0;
+
+  buffer += MAX_VDW;
+  c = 0;
+  n1 = 0;
+  if(state >= cSelectorUpdateTableEffectiveStates) {
+    SelectorUpdateTable(G, state, -1);
+  } else {
+    SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+  }
+  for(a = 0; a < I->NAtom; a++) {
+    at = I->Table[a].atom;
+    obj = I->Obj[I->Table[a].model];
+    s = obj->AtomInfo[at].selEntry;
+    if(SelectorIsMember(G, s, sele1)) {
+      once_flag = true;
+      for(state1 = 0; state1 < obj->NCSet; state1++) {
+        if(state < 0)
+          once_flag = false;
+        if(!once_flag)
+          state2 = state1;
+        else
+          state2 = state;
+        if(state2 < obj->NCSet)
+          cs = obj->CSet[state2];
+        else
+          cs = NULL;
+        if(cs) {
+          idx = cs->atmToIdx(at);
+          if(idx >= 0) {
+            n1++;
+          }
+        }
+        if(once_flag)
+          break;
+      }
+    }
+  }
+  point = pymol::malloc<float>(3 * n1);
+  sfidx = pymol::malloc<int>(n1);
+  b_factor = pymol::malloc<float>(n1);
+  occup = pymol::malloc<float>(n1);
+  atom_sf = pymol::malloc<AtomSF>(n1);
+
+  if(!quiet) {
+    PRINTFB(G, FB_ObjectMap, FB_Details)
+      " ObjectMap: Computing Gaussian map for %d atom positions.\n", n1 ENDFB(G);
+  }
+
+  n1 = 0;
+  fp = point;
+  ip = sfidx;
+  bf = b_factor;
+  oc = occup;
+  for(a = 0; a < I->NAtom; a++) {
+    at = I->Table[a].atom;
+    obj = I->Obj[I->Table[a].model];
+    ai = obj->AtomInfo + at;
+    s = ai->selEntry;
+    if(SelectorIsMember(G, s, sele1)) {
+      once_flag = true;
+      for(state1 = 0; state1 < obj->NCSet; state1++) {
+        if(state < 0)
+          once_flag = false;
+        if(!once_flag)
+          state2 = state1;
+        else
+          state2 = state;
+        if(state2 < obj->NCSet)
+          cs = obj->CSet[state2];
+        else
+          cs = NULL;
+        if(cs) {
+          if(CoordSetGetAtomVertex(cs, at, fp)) {
+            prot = ai->protons;
+            if(sf[prot][0] == -1.0F)
+              prot = cAN_C;
+            bfact = ai->b + (float) b_adjust;
+            if(bfact < b_floor)
+              bfact = b_floor;
+            if((bfact > R_SMALL4) && (ai->q > R_SMALL4)) {
+              fp += 3;
+              *(ip++) = prot;
+              *(bf++) = bfact;
+              *(oc++) = ai->q;
+              n1++;
+            }
+          }
+        }
+        if(once_flag)
+          break;
+      }
+    }
+  }
+
+  for(a = 0; a < n1; a++) {
+    double *src_sf;
+
+    src_sf = &sf[sfidx[a]][0];
+    bfact = b_factor[a];
+
+    for(b = 0; b < 10; b += 2) {
+      double sfa, sfb;
+      sfa = src_sf[b];
+      sfb = src_sf[b + 1];
+
+      atom_sf[a][b] = occup[a] * sfa * pow(sqrt1d(4 * PI / (sfb + bfact)), 3.0);
+      atom_sf[a][b + 1] = 4 * PI * PI / (sfb + bfact);
+
+    }
+
+    rcut2 = max6d(0.0,
+                  (elim + log(max2d(fabs(atom_sf[a][0]), D_SMALL10))) / atom_sf[a][1],
+                  (elim + log(max2d(fabs(atom_sf[a][2]), D_SMALL10))) / atom_sf[a][3],
+                  (elim + log(max2d(fabs(atom_sf[a][4]), D_SMALL10))) / atom_sf[a][5],
+                  (elim + log(max2d(fabs(atom_sf[a][6]), D_SMALL10))) / atom_sf[a][7],
+                  (elim + log(max2d(fabs(atom_sf[a][8]), D_SMALL10))) / atom_sf[a][9]);
+    rcut = ((float) sqrt1d(rcut2)) / blur_factor;
+    atom_sf[a][10] = rcut;
+    if(max_rcut < rcut)
+      max_rcut = rcut;
+  }
+
+  /* now create and apply voxel map */
+  c = 0;
+  if(n1) {
+    n2 = 0;
+    map = MapNew(G, -max_rcut, point, n1, NULL);
+    if(map) {
+      MapSetupExpress(map);
+      sum = 0.0;
+      sumsq = 0.0;
+      for(a = oMap->Min[0]; a <= oMap->Max[0]; a++) {
+        OrthoBusyFast(G, a - oMap->Min[0], oMap->Max[0] - oMap->Min[0] + 1);
+        for(b = oMap->Min[1]; b <= oMap->Max[1]; b++) {
+          for(c = oMap->Min[2]; c <= oMap->Max[2]; c++) {
+            e_val = 0.0;
+            v2 = F4Ptr(oMap->Field->points, a, b, c, 0);
+            if(MapExclLocus(map, v2, &h, &k, &l)) {
+              i = *(MapEStart(map, h, k, l));
+              if(i) {
+                j = map->EList[i++];
+                if(use_max) {
+                  float e_partial;
+                  while(j >= 0) {
+                    d = (float) diff3f(point + 3 * j, v2) * blur_factor;        
+                    /* scale up width */
+                    sfp = atom_sf[j];
+                    if(d < sfp[10]) {
+                      d = d * d;
+                      if(d < R_SMALL8)
+                        d = R_SMALL8;
+                      e_partial = (float) ((sfp[0] * exp(-sfp[1] * d))
+                                           + (sfp[2] * exp(-sfp[3] * d))
+                                           + (sfp[4] * exp(-sfp[5] * d))
+                                           + (sfp[6] * exp(-sfp[7] * d))
+                                           + (sfp[8] * exp(-sfp[9] * d))) * blur_factor;       
+                      /* scale down intensity */
+                      if(e_partial > e_val)
+                        e_val = e_partial;
+                    }
+                    j = map->EList[i++];
+                  }
+                } else {
+                  while(j >= 0) {
+                    d = (float) diff3f(point + 3 * j, v2) * blur_factor;       
+                    /* scale up width */
+                    sfp = atom_sf[j];
+                    if(d < sfp[10]) {
+                      d = d * d;
+                      if(d < R_SMALL8)
+                        d = R_SMALL8;
+                      e_val += (float) ((sfp[0] * exp(-sfp[1] * d))
+                                        + (sfp[2] * exp(-sfp[3] * d))
+                                        + (sfp[4] * exp(-sfp[5] * d))
+                                        + (sfp[6] * exp(-sfp[7] * d))
+                                        + (sfp[8] * exp(-sfp[9] * d))) * blur_factor;  
+                      /* scale down intensity */
+                    }
+                    j = map->EList[i++];
+                  }
+                }
+              }
+            }
+            F3(oMap->Field->data, a, b, c) = e_val;
+            sum += e_val;
+            sumsq += (e_val * e_val);
+            n2++;
+          }
+        }
+      }
+      mean = (float) (sum / n2);
+      stdev = (float) sqrt1d((sumsq - (sum * sum / n2)) / (n2 - 1));
+      if(normalize) {
+
+        if(!quiet) {
+          PRINTFB(G, FB_ObjectMap, FB_Details)
+            " ObjectMap: Normalizing: mean = %8.6f & stdev = %8.6f.\n", mean, stdev
+            ENDFB(G);
+        }
+
+        if(stdev < R_SMALL8)
+          stdev = R_SMALL8;
+
+        for(a = oMap->Min[0]; a <= oMap->Max[0]; a++) {
+          for(b = oMap->Min[1]; b <= oMap->Max[1]; b++) {
+            for(c = oMap->Min[2]; c <= oMap->Max[2]; c++) {
+              fp = F3Ptr(oMap->Field->data, a, b, c);
+
+              *fp = (*fp - mean) / stdev;
+            }
+          }
+        }
+      } else {
+        if(!quiet) {
+          PRINTFB(G, FB_ObjectMap, FB_Details)
+            " ObjectMap: Not normalizing: mean = %8.6f and stdev = %8.6f.\n",
+            mean, stdev ENDFB(G);
+        }
+      }
+      oMap->Active = true;
+      MapFree(map);
+    }
+  }
+  FreeP(point);
+  FreeP(sfidx);
+  FreeP(atom_sf);
+  FreeP(b_factor);
+  FreeP(occup);
+  return (c);
+}
+
+
+/*========================================================================*/
+int SelectorMapCoulomb(PyMOLGlobals * G, int sele1, ObjectMapState * oMap,
+                       float cutoff, int state, int neutral, int shift, float shift_power)
+{
+  CSelector *I = G->Selector;
+  MapType *map;
+  float *v2;
+  int a, b, c, j, i;
+  int h, k, l;
+  int at;
+  int s, idx;
+  AtomInfoType *ai;
+  ObjectMolecule *obj;
+  CoordSet *cs;
+  int state1, state2;
+  int once_flag;
+  int n_at = 0;
+  double tot_charge = 0.0;
+  float *point = NULL;
+  float *charge = NULL;
+  int n_point = 0;
+  int n_occur;
+  float *v0, *v1;
+  float c_factor = 1.0F;
+  float cutoff_to_power = 1.0F;
+  const float _1 = 1.0F;
+
+  if(shift)
+    cutoff_to_power = (float) pow(cutoff, shift_power);
+
+  c_factor = SettingGetGlobal_f(G, cSetting_coulomb_units_factor) /
+             SettingGetGlobal_f(G, cSetting_coulomb_dielectric);
+
+  c = 0;
+  SelectorUpdateTable(G, state, -1);
+
+  point = VLAlloc(float, I->NAtom * 3);
+  charge = VLAlloc(float, I->NAtom);
+
+  /* first count # of times each atom appears */
+
+  for(a = cNDummyAtoms; a < I->NAtom; a++) {
+    at = I->Table[a].atom;
+    obj = I->Obj[I->Table[a].model];
+    s = obj->AtomInfo[at].selEntry;
+    ai = obj->AtomInfo + at;
+    if(SelectorIsMember(G, s, sele1)) {
+      n_occur = 0;
+      /* count */
+      once_flag = true;
+      for(state2 = 0; state2 < obj->NCSet; state2++) {
+        if(state < 0)
+          once_flag = false;
+        if(!once_flag)
+          state1 = state2;
+        else
+          state1 = state;
+        if(state1 < obj->NCSet)
+          cs = obj->CSet[state1];
+        else
+          cs = NULL;
+        if(cs) {
+          idx = cs->atmToIdx(at);
+          if(idx >= 0) {
+            n_occur++;
+            n_at++;
+          }
+        }
+        if(once_flag)
+          break;
+      }
+      /* copy */
+      if(n_occur) {
+        once_flag = true;
+        for(state2 = 0; state2 < obj->NCSet; state2++) {
+          if(state < 0)
+            once_flag = false;
+          if(!once_flag)
+            state1 = state2;
+          else
+            state1 = state;
+          if(state1 < obj->NCSet)
+            cs = obj->CSet[state1];
+          else
+            cs = NULL;
+          if(cs) {
+            idx = cs->atmToIdx(at);
+            if(idx >= 0) {
+              VLACheck(point, float, 3 * n_point + 2);
+              VLACheck(charge, float, n_point);
+              v0 = cs->Coord + (3 * idx);
+              v1 = point + 3 * n_point;
+              copy3f(v0, v1);
+              charge[n_point] = ai->partialCharge * ai->q / n_occur;
+
+              tot_charge += charge[n_point];
+              n_point++;
+            }
+          }
+          if(once_flag)
+            break;
+        }
+      }
+    }
+  }
+
+  PRINTFB(G, FB_Selector, FB_Details)
+    " %s: Total charge is %0.3f for %d points (%d atoms).\n", __func__, tot_charge,
+    n_point, n_at ENDFB(G);
+
+  if(neutral && (fabs(tot_charge) > R_SMALL4)) {
+    float adjust;
+
+    adjust = (float) (-tot_charge / n_point);
+
+    for(a = 0; a < n_point; a++) {
+      charge[a] += adjust;
+    }
+
+    PRINTFB(G, FB_Selector, FB_Details)
+      " %s: Setting net charge to zero...\n", __func__ ENDFB(G);
+
+  }
+
+  for(a = 0; a < n_point; a++) {        /* premultiply c_factor by charges */
+    charge[a] *= c_factor;
+  }
+
+  /* now create and apply voxel map */
+  c = 0;
+  if(n_point) {
+    int *min = oMap->Min;
+    int *max = oMap->Max;
+    CField *data = oMap->Field->data;
+    CField *points = oMap->Field->points;
+    float dist;
+
+    if(cutoff > 0.0F) {         /* we are using a cutoff */
+      if(shift) {
+        PRINTFB(G, FB_Selector, FB_Details)
+          " %s: Evaluating local Coulomb potential for grid (shift=%0.2f)...\n", __func__,
+          cutoff ENDFB(G);
+      } else {
+        PRINTFB(G, FB_Selector, FB_Details)
+          " %s: Evaluating Coulomb potential for grid (cutoff=%0.2f)...\n", __func__,
+          cutoff ENDFB(G);
+      }
+
+      map = MapNew(G, -(cutoff), point, n_point, NULL);
+      if(map) {
+        int *elist;
+        float dx, dy, dz;
+        float cut = cutoff;
+        float cut2 = cutoff * cutoff;
+
+        MapSetupExpress(map);
+        elist = map->EList;
+        for(a = min[0]; a <= max[0]; a++) {
+          OrthoBusyFast(G, a - min[0], max[0] - min[0] + 1);
+          for(b = min[1]; b <= max[1]; b++) {
+            for(c = min[2]; c <= max[2]; c++) {
+              F3(data, a, b, c) = 0.0F;
+              v2 = F4Ptr(points, a, b, c, 0);
+
+              if(MapExclLocus(map, v2, &h, &k, &l)) {
+                i = *(MapEStart(map, h, k, l));
+                if(i) {
+                  j = elist[i++];
+                  while(j >= 0) {
+                    v1 = point + 3 * j;
+                    while(1) {
+
+                      dx = v1[0] - v2[0];
+                      dy = v1[1] - v2[1];
+                      dx = (float) fabs(dx);
+                      dy = (float) fabs(dy);
+                      if(dx > cut)
+                        break;
+                      dz = v1[2] - v2[2];
+                      dx = dx * dx;
+                      if(dy > cut)
+                        break;
+                      dz = (float) fabs(dz);
+                      dy = dy * dy;
+                      if(dz > cut)
+                        break;
+                      dx = dx + dy;
+                      dz = dz * dz;
+                      if(dx > cut2)
+                        break;
+                      dy = dx + dz;
+                      if(dy > cut2)
+                        break;
+                      dist = (float) sqrt1f(dy);
+
+                      if(dist > R_SMALL4) {
+                        if(shift) {
+                          if(dist < cutoff) {
+                            F3(data, a, b, c) += (charge[j] / dist) *
+                              (_1 - (float) pow(dist, shift_power) / cutoff_to_power);
+                          }
+                        } else {
+                          F3(data, a, b, c) += charge[j] / dist;
+                        }
+                      }
+
+                      break;
+                    }
+                    j = map->EList[i++];
+                  }
+                }
+              }
+            }
+          }
+        }
+        MapFree(map);
+      }
+    } else {
+      float *v1;
+      PRINTFB(G, FB_Selector, FB_Details)
+        " %s: Evaluating Coulomb potential for grid (no cutoff)...\n", __func__
+        ENDFB(G);
+
+      for(a = min[0]; a <= max[0]; a++) {
+        OrthoBusyFast(G, a - min[0], max[0] - min[0] + 1);
+        for(b = min[1]; b <= max[1]; b++) {
+          for(c = min[2]; c <= max[2]; c++) {
+            F3(data, a, b, c) = 0.0F;
+            v1 = point;
+            v2 = F4Ptr(points, a, b, c, 0);
+            for(j = 0; j < n_point; j++) {
+              dist = (float) diff3f(v1, v2);
+              v1 += 3;
+              if(dist > R_SMALL4) {
+                F3(data, a, b, c) += charge[j] / dist;
+              }
+            }
+          }
+        }
+      }
+    }
+    oMap->Active = true;
+  }
+  VLAFreeP(point);
+  VLAFreeP(charge);
+  return (1);
+}
+
+
+/*========================================================================*/
+int SelectorAssignAtomTypes(PyMOLGlobals * G, int sele, int state, int quiet, int format)
+{
+#ifndef NO_MMLIBS
+  CSelector *I = G->Selector;
+  int ok = true;
+
+  SelectorUpdateTable(G, state, -1);
+
+  if(ok) {
+    ObjectMolecule *prevobj = NULL;
+    int a;
+    for(a = cNDummyAtoms; a < I->NAtom; a++) {
+      int at = I->Table[a].atom;
+      ObjectMolecule *obj = I->Obj[I->Table[a].model];
+      int s = obj->AtomInfo[at].selEntry;
+      I->Table[a].index = 0;
+      if(SelectorIsMember(G, s, sele)) {
+	ObjectMoleculeInvalidateAtomType(obj, state);
+      }
+    }
+    for(a = cNDummyAtoms; a < I->NAtom; a++) {
+      int at = I->Table[a].atom;
+      ObjectMolecule *obj = I->Obj[I->Table[a].model];
+      int s = obj->AtomInfo[at].selEntry;
+      I->Table[a].index = 0;
+      if(obj != prevobj && SelectorIsMember(G, s, sele)) {
+	ObjectMoleculeUpdateAtomTypeInfoForState(G, obj, state, 1, format);
+          prevobj = obj;
+      }
+    }
+  }
+  return 1;
+#else
+  if (format != 1) {
+    PRINTFB(G, FB_Selector, FB_Errors)
+      " Error: assign_atom_types only supports format='mol2'\n" ENDFB(G);
+    return 0;
+  }
+
+  SelectorUpdateTable(G, state, -1);
+
+  ObjectMolecule *obj = NULL;
+
+  for (SeleAtomIterator iter(G, sele); iter.next();) {
+    if (obj != iter.obj) {
+      obj = iter.obj;
+      ObjectMoleculeVerifyChemistry(obj, state);
+    }
+
+    LexAssign(G, iter.getAtomInfo()->textType,
+        getMOL2Type(obj, iter.getAtm()));
+  }
+  return 1;
+#endif
+}
+
+/*========================================================================*/
+/*
+ * Get selection coordinates as Nx3 numpy array. Equivalent to
+ *
+ * PyMOL> coords = []
+ * PyMOL> cmd.iterate_state(state, sele, 'coords.append([x,y,z])')
+ * PyMOL> coords = numpy.array(coords)
+ */
+PyObject *SelectorGetCoordsAsNumPy(PyMOLGlobals * G, int sele, int state)
+{
+#ifndef _PYMOL_NUMPY
+  printf("No numpy support\n");
+  return NULL;
+#else
+
+  double matrix[16];
+  double *matrix_ptr = NULL;
+  float *v_ptr, v_tmp[3], *dataptr;
+  int i, nAtom = 0;
+  int typenum = -1;
+  const int base_size = sizeof(float);
+  SeleCoordIterator iter(G, sele, state);
+  CoordSet *mat_cs = NULL;
+  PyObject *result = NULL;
+  npy_intp dims[2] = {0, 3};
+
+  for(iter.reset(); iter.next();)
+    nAtom++;
+
+  if(!nAtom)
+    return NULL;
+
+  dims[0] = nAtom;
+
+  import_array1(NULL);
+
+  switch(base_size) {
+    case 4: typenum = NPY_FLOAT32; break;
+    case 8: typenum = NPY_FLOAT64; break;
+  }
+
+  if(typenum == -1) {
+    printf("error: no typenum for float size %d\n", base_size);
+    return NULL;
+  }
+
+  result = PyArray_SimpleNew(2, dims, typenum);
+  dataptr = (float*) PyArray_DATA((PyArrayObject *)result);
+
+  for(i = 0, iter.reset(); iter.next(); i++) {
+    v_ptr = iter.getCoord();
+
+    if(mat_cs != iter.cs) {
+      /* compute the effective matrix for output coordinates */
+      matrix_ptr = ObjectGetTotalMatrix(iter.obj, state, false, matrix) ? matrix : NULL;
+      mat_cs = iter.cs;
+    }
+
+    if(matrix_ptr) {
+      transform44d3f(matrix_ptr, v_ptr, v_tmp);
+      v_ptr = v_tmp;
+    }
+
+    copy3f(v_ptr, dataptr + i * 3);
+  }
+
+  return result;
+#endif
+}
+
+/*========================================================================*/
+/*
+ * Load coordinates from a Nx3 sequence into the given selection.
+ * Most efficiant with numpy arrays. Equivalent to
+ *
+ * PyMOL> coords = iter(coords)
+ * PyMOL> cmd.alter_state(state, sele, '(x,y,z) = coords.next()')
+ */
+int SelectorLoadCoords(PyMOLGlobals * G, PyObject * coords, int sele, int state)
+{
+#ifdef _PYMOL_NOPY
+  return false;
+#else
+
+  double matrix[16];
+  double *matrix_ptr = NULL;
+  float v_xyz[3];
+  int a, b, nAtom = 0, itemsize;
+  SeleCoordIterator iter(G, sele, state);
+  CoordSet *mat_cs = NULL;
+  PyObject *v, *w;
+  bool is_np_array = false;
+  void * ptr;
+
+  if(!PySequence_Check(coords)) {
+    ErrMessage(G, "LoadCoords", "passed argument is not a sequence");
+    ok_raise(1);
+  }
+
+  // atom count in selection
+  while(iter.next())
+    nAtom++;
+
+  // sequence length must match atom count
+  if(nAtom != PySequence_Size(coords)) {
+    ErrMessage(G, "LoadCoords", "atom count mismatch");
+    return false;
+  }
+
+  // detect numpy arrays, allows faster data access (see below)
+#ifdef _PYMOL_NUMPY
+  import_array1(false);
+
+  if(PyArray_Check(coords)) {
+    if(PyArray_NDIM((PyArrayObject *)coords) != 2 ||
+        PyArray_DIM((PyArrayObject *)coords, 1) != 3) {
+      ErrMessage(G, "LoadCoords", "numpy array shape mismatch");
+      return false;
+    }
+    itemsize = PyArray_ITEMSIZE((PyArrayObject *)coords);
+    switch(itemsize) {
+      case sizeof(double):
+      case sizeof(float):
+        is_np_array = true;
+        break;
+      default:
+        PRINTFB(G, FB_Selector, FB_Warnings)
+          " LoadCoords-Warning: numpy array with unsupported dtype\n" ENDFB(G);
+    }
+  }
+#endif
+
+  for(a = 0, iter.reset(); iter.next(); a++) {
+    // get xyz from python
+    if (is_np_array) {
+      // fast implementation for numpy arrays only
+#ifdef _PYMOL_NUMPY
+      for(b = 0; b < 3; b++) {
+        ptr = PyArray_GETPTR2((PyArrayObject *)coords, a, b);
+
+        switch(itemsize) {
+          case sizeof(double):
+            v_xyz[b] = (float) *((double*)ptr);
+            break;
+          default:
+            v_xyz[b] = *((float*)ptr);
+        }
+      }
+#endif
+    } else {
+      // general implementation for any 2d sequence
+      v = PySequence_ITEM(coords, a);
+
+      // get xyz from python sequence item
+      for(b = 0; b < 3; b++) {
+        if(!(w = PySequence_GetItem(v, b)))
+          break;
+
+        v_xyz[b] = (float) PyFloat_AsDouble(w);
+        Py_DECREF(w);
+      }
+
+      Py_DECREF(v);
+    }
+
+    ok_assert(2, !PyErr_Occurred());
+
+    // coord set specific stuff
+    if(mat_cs != iter.cs) {
+      // update matrix
+      matrix_ptr = ObjectGetTotalMatrix(iter.obj, state, false, matrix) ? matrix : NULL;
+      mat_cs = iter.cs;
+
+      // invalidate reps
+      iter.cs->invalidateRep(cRepAll, cRepInvRep);
+    }
+
+    // handle matrix
+    if(matrix_ptr) {
+      inverse_transform44d3f(matrix_ptr, v_xyz, v_xyz);
+    }
+
+    // copy coordinates
+    copy3f(v_xyz, iter.getCoord());
+  }
+
+  return true;
+
+  // error handling
+ok_except2:
+  PyErr_Print();
+ok_except1:
+  ErrMessage(G, "LoadCoords", "failed");
+  return false;
+#endif
+}
+
+/*========================================================================*/
+void SelectorUpdateCmd(PyMOLGlobals * G, int sele0, int sele1, int sta0, int sta1,
+                       int matchmaker, int quiet)
+{
+  CSelector *I = G->Selector;
+  int a, b;
+  int at0 = 0, at1;
+  int *vla0 = NULL;
+  int *vla1 = NULL;
+  int c0 = 0, c1 = 0;
+  int i0 = 0, i1;
+  ObjectMolecule *obj0 = NULL, *obj1;
+  CoordSet *cs0;
+  const CoordSet *cs1;
+  int matched_flag;
+  int b_start;
+  int ccc = 0;
+
+  bool ignore_case = SettingGetGlobal_b(G, cSetting_ignore_case);
+  bool ignore_case_chain = SettingGetGlobal_b(G, cSetting_ignore_case_chain);
+
+  PRINTFD(G, FB_Selector)
+    " %s-Debug: entered sta0 %d sta1 %d", __func__, sta0, sta1 ENDFD;
+
+  // either both or none must be "all states"
+  if (sta0 != sta1) {
+    if (sta0 == cSelectorUpdateTableAllStates) {
+      sta0 = sta1;
+    } else if (sta1 == cSelectorUpdateTableAllStates) {
+      sta1 = sta0;
+    }
+  }
+
+  if((sta0 < 0) || (sta1 < 0) || (sta0 != sta1)) {
+    SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+  } else {
+    SelectorUpdateTable(G, sta0, -1);
+  }
+
+  vla0 = SelectorGetIndexVLA(G, sele0);
+  vla1 = SelectorGetIndexVLA(G, sele1);
+
+  if (vla0 && vla1) {
+    c0 = VLAGetSize(vla0);
+    c1 = VLAGetSize(vla1);
+  }
+
+  if (c0 < 1 || c1 < 1)
+    ErrMessage(G, "Update", "no coordinates updated.");
+  else {
+
+    b = 0;
+    for(a = 0; a < c1; a++) {   /* iterate over source atoms */
+      /* NOTE, this algorithm is N^2 and slow in the worst case...
+         however the best case (N) is quite common, especially when merging 
+         files written out of PyMOL */
+
+      i1 = vla1[a];
+      at1 = I->Table[i1].atom;
+      obj1 = I->Obj[I->Table[i1].model];
+      matched_flag = false;
+
+      switch (matchmaker) {
+      case 0:                 
+        /* simply assume that atoms are stored in PyMOL in the identical order, one for one */
+        if(b < c0) {
+          i0 = vla0[b];
+          at0 = I->Table[i0].atom;
+          obj0 = I->Obj[I->Table[i0].model];
+          b++;
+          matched_flag = true;
+        }
+        break;
+      case 1:                  
+        /* match each pair based on atom info */
+        b_start = b;
+        matched_flag = false;
+        while(1) {
+          i0 = vla0[b];
+          at0 = I->Table[i0].atom;
+          obj0 = I->Obj[I->Table[i0].model];
+          if(obj0 != obj1) {
+            if(AtomInfoMatch(G, obj1->AtomInfo + at1, obj0->AtomInfo + at0, ignore_case, ignore_case_chain)) {
+              matched_flag = true;
+              break;
+            }
+          } else if(at0 == at1) {
+            matched_flag = true;
+            break;
+          }
+          b++;
+          if(b >= c0)
+            b = 0;
+          if(b == b_start)
+            break;
+        }
+        break;
+      case 2:                  /* match based on ID */
+        {
+          int target = obj1->AtomInfo[at1].id;
+          b_start = b;
+          matched_flag = false;
+          while(1) {
+            i0 = vla0[b];
+            at0 = I->Table[i0].atom;
+            obj0 = I->Obj[I->Table[i0].model];
+            if(obj0 != obj1) {
+              if(obj0->AtomInfo[at0].id == target) {
+                matched_flag = true;
+                break;
+              }
+            } else if(at0 == at1) {
+              matched_flag = true;
+              break;
+            }
+            b++;
+            if(b >= c0)
+              b = 0;
+            if(b == b_start)
+              break;
+          }
+        }
+        break;
+      case 3:                  /* match based on rank */
+        {
+          int target = obj1->AtomInfo[at1].rank;
+          b_start = b;
+          matched_flag = false;
+          while(1) {
+            i0 = vla0[b];
+            at0 = I->Table[i0].atom;
+            obj0 = I->Obj[I->Table[i0].model];
+            if(obj0 != obj1) {
+              if(obj0->AtomInfo[at0].rank == target) {
+                matched_flag = true;
+                break;
+              }
+            } else if(at0 == at1) {
+              matched_flag = true;
+            }
+            b++;
+            if(b >= c0)
+              b = 0;
+            if(b == b_start)
+              break;
+          }
+        }
+        break;
+      case 4:                  /* match based on index */
+        {
+          b_start = b;
+          matched_flag = false;
+          while(1) {
+            i0 = vla0[b];
+            at0 = I->Table[i0].atom;
+            obj0 = I->Obj[I->Table[i0].model];
+            if(obj0 != obj1) {
+              if(at0 == at1) {
+                matched_flag = true;
+                break;
+              }
+            } else if(at0 == at1) {
+              matched_flag = true;
+              break;
+            }
+            b++;
+            if(b >= c0)
+              b = 0;
+            if(b == b_start)
+              break;
+          }
+        }
+        break;
+      }
+
+      if(matched_flag) {        /* atom matched, so copy coordinates */
+        ccc++;
+
+        StateIterator iter0(G, obj0->Setting, sta0, obj0->NCSet);
+        StateIterator iter1(G, obj1->Setting, sta1, obj1->NCSet);
+
+        while (iter0.next() && iter1.next()) {
+          cs0 = obj0->CSet[iter0.state];
+          cs1 = obj1->CSet[iter1.state];
+          if (cs1 && cs0) {
+            int idx0 = cs0->atmToIdx(at0);
+            int idx1 = cs1->atmToIdx(at1);
+            if (idx0 >= 0 && idx1 >= 0) {
+              copy3f(cs1->coordPtr(idx1), cs0->coordPtr(idx0));
+            }
+          }
+        }
+      }
+    }
+    obj0 = NULL;
+
+    {
+      ObjectMolecule **objs = SelectorGetObjectMoleculeVLA(G, sele0);
+      int sz = VLAGetSize(objs);
+      for(b = 0; b < sz; b++) {
+	ObjectMoleculeInvalidate(objs[b], cRepAll, cRepInvCoord, -1);
+      }
+      VLAFree(objs);
+    }
+    SceneChanged(G);
+    if(!quiet) {
+      PRINTFB(G, FB_Selector, FB_Actions)
+        " Update: coordinates updated for %d atoms.\n", ccc ENDFB(G);
+
+    }
+  }
+  VLAFreeP(vla0);
+  VLAFreeP(vla1);
+}
+
+
+/*========================================================================*/
+
+int SelectorCreateObjectMolecule(PyMOLGlobals * G, int sele, const char *name,
+                                 int target, int source, int discrete,
+                                 int zoom, int quiet, int singletons, int copy_properties)
+{
+  CSelector *I = G->Selector;
+  int ok = true;
+  int a, b, a2, b1, b2, c, d, s, at;
+  BondType *ii1, *bond = NULL;
+  int nBond = 0;
+  int nCSet, nAtom, ts;
+  int isNew;
+  CoordSet *cs = NULL;
+  CoordSet *cs1, *cs2;
+  ObjectMolecule *obj;
+  CObject *ob;
+  ObjectMolecule *targ = NULL;
+  ObjectMolecule *info_src = NULL;
+  int static_singletons = SettingGetGlobal_b(G, cSetting_static_singletons);
+
+  if(singletons < 0)
+    singletons = static_singletons;
+
+  ob = ExecutiveFindObjectByName(G, name);
+  if(ob)
+    if(ob->type == cObjectMolecule)
+      targ = (ObjectMolecule *) ob;
+
+  c = 0;
+    SelectorUpdateTable(G, source, -1);
+
+  if(!targ) {
+    isNew = true;
+    if(discrete < 0)
+      discrete = SelectorIsSelectionDiscrete(G, sele, false);
+    targ = ObjectMoleculeNew(G, discrete);
+    targ->Bond = VLACalloc(BondType, 1);
+    {
+      /* copy object color of previous object (if any) */
+      ObjectMolecule *singleObj = NULL;
+      for(a = cNDummyAtoms; a < I->NAtom; a++) {
+        at = I->Table[a].atom;
+        I->Table[a].index = -1;
+        obj = I->Obj[I->Table[a].model];
+        s = obj->AtomInfo[at].selEntry;
+        if(SelectorIsMember(G, s, sele)) {
+          if(!singleObj)
+            singleObj = obj;
+          else if(singleObj && (obj != singleObj)) {
+            singleObj = NULL;
+            break;
+          }
+        }
+      }
+      if(singleObj)
+        targ->Color = singleObj->Color;
+      /* should also consider copying lots of other stuff from the source object ... */
+    }
+  } else {
+    isNew = false;
+  }
+
+  for(a = cNDummyAtoms; a < I->NAtom; a++) {
+    at = I->Table[a].atom;
+    I->Table[a].index = -1;
+    obj = I->Obj[I->Table[a].model];
+    s = obj->AtomInfo[at].selEntry;
+    if(SelectorIsMember(G, s, sele)) {
+      I->Table[a].index = c;    /* Mark records as to which atom they'll be */
+      c++;
+      if(!info_src)
+        info_src = obj;
+    }
+  }
+  if(isNew && info_src) {       /* copy symmetry information, etc. */
+    targ->Symmetry = SymmetryCopy(info_src->Symmetry);
+  }
+  nAtom = c;
+
+  nBond = 0;
+  bond = VLACalloc(BondType, nAtom * 4);
+  for(a = cNDummyModels; a < I->NModel; a++) {  /* find bonds wholly contained in the selection */
+    obj = I->Obj[a];
+    ii1 = obj->Bond;
+    for(b = 0; b < obj->NBond; b++) {
+      b1 = SelectorGetObjAtmOffset(I, obj, ii1->index[0]);
+      b2 = SelectorGetObjAtmOffset(I, obj, ii1->index[1]);
+      if((b1 >= 0) && (b2 >= 0)) {
+        if((I->Table[b1].index >= 0) && (I->Table[b2].index >= 0)) {
+          VLACheck(bond, BondType, nBond);
+          {
+            BondType *dst_bond = bond + nBond;
+            AtomInfoBondCopy(G, ii1, dst_bond);
+            dst_bond->index[0] = I->Table[b1].index;    /* store what will be the new index */
+            dst_bond->index[1] = I->Table[b2].index;
+            /*            printf("Selector-DEBUG %d %d\n",dst_bond->index[0],dst_bond->index[1]); */
+            nBond++;
+          }
+        }
+      }
+      ii1++;
+    }
+  }
+
+  pymol::vla<AtomInfoType> atInfo(nAtom);
+  /* copy the atom info records and create new zero-based IDs */
+  c = 0;
+  {
+    for(a = cNDummyAtoms; a < I->NAtom; a++) {
+      if(I->Table[a].index >= 0) {
+        obj = I->Obj[I->Table[a].model];
+        at = I->Table[a].atom;
+        VLACheck(atInfo, AtomInfoType, c);
+        AtomInfoCopy(G, obj->AtomInfo + at, atInfo + c);
+        c++;
+      }
+    }
+  }
+
+  cs = CoordSetNew(G);          /* set up a dummy coordinate set for the merge xref */
+  cs->NIndex = nAtom;
+  cs->enumIndices();
+  cs->TmpBond = bond;           /* load up the bonds */
+  cs->NTmpBond = nBond;
+  bond = NULL;
+
+  /*  printf("Selector-DEBUG nAtom %d\n",nAtom); */
+  ObjectMoleculeMerge(targ, std::move(atInfo), cs, false, cAIC_AllMask, true);     /* will free atInfo */
+  /* cs->IdxToAtm will now have the reverse mapping from the new subset
+     to the new merged molecule */
+
+  ObjectMoleculeExtendIndices(targ, -1);
+  ObjectMoleculeUpdateIDNumbers(targ);
+  ObjectMoleculeUpdateNonbonded(targ);
+
+  if(!isNew) {                  /* recreate selection table */
+
+      SelectorUpdateTable(G, source, -1);
+
+  }
+
+  /* get maximum state index for the selection...note that
+     we'll be creating states from 1 up to the maximum required to
+     capture atoms in the selection 
+   */
+
+  nCSet = 0;
+
+  {
+    c = 0;
+    for(a = cNDummyAtoms; a < I->NAtom; a++) {
+      at = I->Table[a].atom;
+      I->Table[a].index = -1;
+      obj = I->Obj[I->Table[a].model];
+      s = obj->AtomInfo[at].selEntry;
+      if(SelectorIsMember(G, s, sele)) {
+        I->Table[a].index = c;  /* Mark records  */
+        if(nCSet < obj->NCSet)
+          nCSet = obj->NCSet;
+        c++;
+      }
+    }
+  }
+
+  if(c != nAtom)
+    ErrFatal(G, "SelectorCreate", "inconsistent selection.");
+  /* cs->IdxToAtm now has the relevant indexes for the coordinate transfer */
+
+  for(StateIterator iter(G, NULL, source, nCSet); iter.next();) {
+    d = iter.state;
+    {
+      cs2 = CoordSetNew(G);
+      c = 0;
+      cs2->Coord = VLAlloc(float, 3 * nAtom);
+      cs2->AtmToIdx = VLACalloc(int, targ->NAtom + 1);
+      for(a = 0; a < targ->NAtom; a++)
+        cs2->AtmToIdx[a] = -1;
+      cs2->NAtIndex = targ->NAtom;
+      cs2->IdxToAtm = VLACalloc(int, nAtom);
+      for(a = cNDummyAtoms; a < I->NAtom; a++)  /* any selected atoms in this state? */
+        if(I->Table[a].index >= 0) {
+          at = I->Table[a].atom;
+          obj = I->Obj[I->Table[a].model];
+          cs1 = NULL;
+          if(d < obj->NCSet) {
+            cs1 = obj->CSet[d];
+          } else if(singletons && (obj->NCSet == 1)) {
+            cs1 = obj->CSet[0];
+          }
+          if(cs1) {
+            if((!cs2->Name[0]) && (cs1->Name[0]))       /* copy the molecule name (if any) */
+              strcpy(cs2->Name, cs1->Name);
+
+            if(CoordSetGetAtomVertex(cs1, at, cs2->Coord + c * 3)) {
+              a2 = cs->IdxToAtm[I->Table[a].index];     /* actual merged atom index */
+              cs2->IdxToAtm[c] = a2;
+              cs2->AtmToIdx[a2] = c;
+              c++;
+            }
+          }
+        }
+      VLASize(cs2->IdxToAtm, int, c);
+      VLASize(cs2->Coord, float, c * 3);
+      cs2->NIndex = c;
+      if(target >= 0) {
+        if(source == -1)
+          ts = target + d;
+        else
+          ts = target;
+      } else {
+        ts = d;
+      }
+      VLACheck(targ->CSet, CoordSet *, ts);
+      if(targ->NCSet <= ts)
+        targ->NCSet = ts + 1;
+      if(targ->CSet[ts])
+        targ->CSet[ts]->fFree();
+      targ->CSet[ts] = cs2;
+      cs2->Obj = targ;
+    }
+  }
+  VLAFreeP(bond);               /* null-safe */
+  if(cs)
+    cs->fFree();
+  if(targ->DiscreteFlag) {      /* if the new object is discrete, then eliminate the AtmToIdx array */
+    for(d = 0; d < targ->NCSet; d++) {
+      cs = targ->CSet[d];
+      if(cs) {
+        if(cs->AtmToIdx) {
+          for(a = 0; a < cs->NIndex; a++) {
+            b = cs->IdxToAtm[a];
+            targ->DiscreteAtmToIdx[b] = a;
+            targ->DiscreteCSet[b] = cs;
+          }
+          VLAFree(cs->AtmToIdx);
+          cs->AtmToIdx = NULL;
+        }
+      }
+    }
+  }
+  SceneCountFrames(G);
+  if(!quiet) {
+    PRINTFB(G, FB_Selector, FB_Details)
+      " Selector: found %d atoms.\n", nAtom ENDFB(G);
+  }
+  if (ok)
+    ok &= ObjectMoleculeSort(targ);
+  if(isNew) {
+    ObjectSetName((CObject *) targ, name);
+    ExecutiveManageObject(G, (CObject *) targ, zoom, quiet);
+  } else {
+    ExecutiveUpdateObjectSelection(G, (CObject *) targ);
+  }
+  SceneChanged(G);
+  return ok;
+}
+
+
+/*========================================================================*/
+int SelectorSetName(PyMOLGlobals * G, const char *new_name, const char *old_name)
+{
+  CSelector *I = G->Selector;
+  ov_diff i;
+  int ignore_case = SettingGetGlobal_b(G, cSetting_ignore_case);
+
+  i = SelectGetNameOffset(G, old_name, 1, ignore_case);
+  if(i >= 0) {
+    SelectorDelName(G, i);
+    UtilNCopy(I->Name[i], new_name, WordLength);
+    SelectorAddName(G, i);
+    return true;
+  } else {
+    return false;
+  }
+}
+
+
+/*========================================================================
+ * SelectorIndexByName -- fetch the global selector's ID for sname
+ * PARAMS
+ *  (string) sname, object name
+ * RETURNS
+ *   (int) index #, or -1 if not found
+ */
+int SelectorIndexByName(PyMOLGlobals * G, const char *sname, int ignore_case)
+{
+  CSelector *I = G->Selector;
+  ov_diff i = -1;
+
+  if(sname) {
+    if (ignore_case < 0)
+      ignore_case = SettingGetGlobal_b(G, cSetting_ignore_case);
+
+    while((sname[0] == '%') || (sname[0] == '?'))
+      sname++;
+    i = SelectGetNameOffset(G, sname, 1, ignore_case);
+
+    if((i >= 0) && (sname[0] != '_')) {  /* don't do checking on internal selections */
+      const char *best;
+      best = ExecutiveFindBestNameMatch(G, sname);      /* suppress spurious matches
+                                                           of selections with non-selections */
+      if((best != sname) && (strcmp(best, I->Name[i])))
+        i = -1;
+    }
+    if(i >= 0)
+      i = I->Info[i].ID;
+  }
+  return (i);
+}
+
+
+/*========================================================================*/
+static void SelectorPurgeMembers(PyMOLGlobals * G, int sele)
+{
+  CSelector *I = G->Selector;
+  void *iterator = NULL;
+  ObjectMolecule *obj = NULL;
+  short changed = 0;
+
+  if(I->Member) {
+    MemberType *I_Member = I->Member;
+    int I_FreeMember = I->FreeMember;
+
+    while(ExecutiveIterateObjectMolecule(G, &obj, &iterator)) {
+      if(obj->type == cObjectMolecule) {
+        AtomInfoType *ai = obj->AtomInfo;
+        int a, n_atom = obj->NAtom;
+        for(a = 0; a < n_atom; a++) {
+          int s = (ai++)->selEntry;
+          int l = -1;
+          while(s) {
+            MemberType *i_member_s = I_Member + s;
+            int nxt = i_member_s->next;
+            if(i_member_s->selection == sele) {
+              if(l > 0)
+                I_Member[l].next = i_member_s->next;
+              else
+                ai[-1].selEntry = i_member_s->next;
+	      changed = 1;
+              i_member_s->next = I_FreeMember;
+              I_FreeMember = s;
+            }
+            l = s;
+            s = nxt;
+          }
+        }
+      }
+    }
+    I->FreeMember = I_FreeMember;
+  }
+  if (changed){
+    // not sure if this is needed since its in SelectorClean()
+    ExecutiveInvalidateSelectionIndicatorsCGO(G);
+  }
+}
+
+
+/*========================================================================*/
+int SelectorPurgeObjectMembers(PyMOLGlobals * G, ObjectMolecule * obj)
+{
+  int a = 0;
+  int s = 0;
+  int nxt;
+  short changed = 0;
+
+  CSelector *I = G->Selector;
+  if(I->Member) {
+    for(a = 0; a < obj->NAtom; a++) {
+      s = obj->AtomInfo[a].selEntry;
+      while(s) {
+        nxt = I->Member[s].next;
+        I->Member[s].next = I->FreeMember;
+        I->FreeMember = s;
+        s = nxt;
+      }
+      obj->AtomInfo[a].selEntry = 0;
+      changed = 1;
+    }
+  }
+  if (changed){
+    // not sure if this is needed since its in SelectorClean()
+    ExecutiveInvalidateSelectionIndicatorsCGO(G);
+  }
+
+  return 1;
+}
+
+
+/*========================================================================*/
+void SelectorDelete(PyMOLGlobals * G, const char *sele)
+
+
+/* should (only) be called by Executive or by Selector, unless the
+
+   named selection has never been registered with the executive 
+
+   (i.e., temporary on-the-fly selection) */
+{
+  ov_diff n;
+  n = SelectGetNameOffset(G, sele, 999, SettingGetGlobal_b(G, cSetting_ignore_case));   /* already exist? */
+  if(n >= 0) {                  /* get rid of existing selection -- but never selection 0 (all) */
+    SelectorDeleteSeleAtOffset(G, n);
+  }
+}
+
+
+/*========================================================================*/
+void SelectorGetUniqueTmpName(PyMOLGlobals * G, char *name_buffer)
+{
+  CSelector *I = G->Selector;
+  sprintf(name_buffer, "%s%d", cSelectorTmpPrefix, I->TmpCounter++);
+}
+
+/*========================================================================*/
+/*
+ * If `input` is already a name of an object or a valid position keyword
+ * (center, origin, all, ...), then simply copy it to `store`. Otherwise
+ * process the selection expression and create a temporary named selection.
+ *
+ * Unlike `SelectorGetTmp`, this will accept names of maps, groups, etc.
+ */
+int SelectorGetTmp2(PyMOLGlobals * G, const char *input, char *store, bool quiet)
+{
+  int count = 0;
+  /* ASSUMES that store is at least as big as an OrthoLineType */
+  CSelector *I = G->Selector;
+  PRINTFD(G, FB_Selector)
+    " %s-Debug: entered with \"%s\".\n", __func__, input ENDFD;
+
+  store[0] = 0;
+
+  /* skip trivial cases */
+
+  if(input[0] && !((input[0] == '\'') && (input[1] == '\'') && (!input[2]))) {
+
+    /* OKAY, this routine is in flux.  Eventually this routine will...
+
+       (1) fully parse the input recognizing selection keywords, nested
+       parens, quotes, escaped strings, etc.
+
+       (2) replace selection blocks with temporary selection names
+
+       (3) return a space-separated list of names for processing
+
+       However, right now, this routine simply handles two cases.
+
+       A. where the input is a selection, in which case store is set to a
+       temporary selection name
+
+       B. where the input is simply a list of space-separated name patterns,
+       in which case store is simply passed along as a copy of the input
+
+     */
+
+    // make selection if "input" doesn't fit into "store"
+    int is_selection = strlen(input) >= OrthoLineLength;
+
+    const char *p = input;
+    OrthoLineType word;
+    OVreturn_word result;
+
+    if (!is_selection) while(*p) {
+      /* copy first word/token of p into "word", remainder of string in p */
+      p = ParseWord(word, p, sizeof(OrthoLineType));
+      /* see a paren? then this must be a selection */
+
+      if(word[0] == '(') {
+        is_selection = true;
+        break;
+      }
+
+      if(strchr(word, '/')) {
+        is_selection = true;
+        break;
+      }
+
+      /* encounterd a selection keyword? then this must be a selection */
+
+      if(OVreturn_IS_OK((result = OVLexicon_BorrowFromCString(I->Lex, word)))) {
+        if(OVreturn_IS_OK((result = OVOneToAny_GetKey(I->Key, result.word)))) {
+          if((result.word != SELE_ALLz) &&
+             (result.word != SELE_ORIz) && (result.word != SELE_CENz)) {
+            is_selection = true;
+            break;
+          }
+        }
+      }
+
+      if(!ExecutiveValidName(G, word)) {        /* don't recognize the name? */
+        if(!ExecutiveValidNamePattern(G, word)) {       /* don't recognize this as a pattern? */
+          is_selection = true;  /* must be a selection */
+          break;
+        }
+      }
+    }
+    if(is_selection) {          /* incur the computational expense of 
+                                   parsing the input as an atom selection */
+      WordType name;
+      sprintf(name, "%s%d", cSelectorTmpPrefix, I->TmpCounter++);
+      count = SelectorCreate(G, name, input, NULL, quiet, NULL);
+      if(count >= 0) {
+        strcpy(store, name);
+      } else {
+        store[0] = 0;
+      }
+    } else {                    /* otherwise, just parse the input as a space-separated list of names */
+      /* not a selection */
+      strcpy(store, input);
+    }
+  }
+  PRINTFD(G, FB_Selector)
+    " %s-Debug: leaving with \"%s\".\n", __func__, store ENDFD;
+  return count;
+
+}
+
+/*========================================================================*/
+/*
+ * Like SelectorGetTmp2, but doesn't accept names from any non-molecular
+ * entities like groups or map objects (those will be processed as selection
+ * expressions).
+ */
+int SelectorGetTmp(PyMOLGlobals * G, const char *input, char *store, bool quiet)
+{
+  int count = 0;
+  CSelector *I = G->Selector;
+
+  store[0] = 0;
+
+  // trivial (but valid) case: empty selection string
+  ok_assert(1, input[0]);
+
+  // if object molecule or named selection, then don't create a temp selection
+  if (ExecutiveIsMoleculeOrSelection(G, input)
+      && strncmp(input, cSelectorTmpPrefix, cSelectorTmpPrefixLen) != 0) {
+    strcpy(store, input);
+    return 0;
+  }
+
+  // evaluate expression and create a temp selection
+  sprintf(store, "%s%d", cSelectorTmpPrefix, I->TmpCounter++);
+  count = SelectorCreate(G, store, input, NULL, quiet, NULL);
+  if(count < 0)
+    store[0] = 0;
+
+ok_except1:
+  return count;
+}
+
+int SelectorCheckTmp(PyMOLGlobals * G, const char *name)
+{
+  if(WordMatch(G, cSelectorTmpPattern, name, false) + 1 ==
+     - cSelectorTmpPrefixLen)
+    return true;
+  else
+    return false;
+}
+
+
+/*========================================================================*/
+void SelectorFreeTmp(PyMOLGlobals * G, const char *name)
+{                               /* remove temporary selections */
+  if(name && name[0]) {
+    if(strncmp(name, cSelectorTmpPrefix, cSelectorTmpPrefixLen) == 0) {
+      ExecutiveDelete(G, name);
+    }
+  }
+}
+
+
+/*========================================================================*/
+static int SelectorEmbedSelection(PyMOLGlobals * G, const int *atom, const char *name,
+                                  ObjectMolecule * obj, int no_dummies, int exec_managed)
+{
+  /* either atom or obj should be NULL, not both and not neither */
+
+  CSelector *I = G->Selector;
+  int tag;
+  int newFlag = true;
+  int n, a, m, sele;
+  int c = 0;
+  int start = 0;
+  int singleAtomFlag = true;
+  int singleObjectFlag = true;
+  ObjectMolecule *singleObject = NULL, *selObj;
+  int singleAtom = -1;
+  int index;
+  AtomInfoType *ai;
+
+  if(exec_managed < 0) {
+    if(atom)                    /* automatic behavior: manage selections defined via atom masks */
+      exec_managed = true;
+    else
+      exec_managed = false;
+  }
+
+  n = SelectGetNameOffset(G, name, 999, SettingGetGlobal_b(G, cSetting_ignore_case));   /* already exist? */
+  if(n == 0)                    /* don't allow redefinition of "all" */
+    return 0;
+  if(n > 0) {                   /* get rid of existing selection */
+    SelectorDeleteSeleAtOffset(G, n);
+    newFlag = false;
+  }
+
+  /*  printf("I->NMember %d I->FreeMember %d\n",I->NMember,I->FreeMember); */
+
+  n = I->NActive;
+  /* make sure there's enough space for n+1 SelectorWordTypes
+   * and SelectorInfoRecs in the Selector */
+  VLACheck(I->Name, SelectorWordType, n + 1);
+  VLACheck(I->Info, SelectionInfoRec, n + 1);
+  /* copy the name and null terminate it */
+  strcpy(I->Name[n], name);
+  I->Name[n + 1][0] = 0;
+  /* This name is in Name, so now set it in the OVLexicon hash */
+  SelectorAddName(G, n);
+  sele = I->NSelection++;
+  SelectionInfoInit(I->Info + n);
+  I->Info[n].ID = sele;
+  I->NActive++;
+
+  if(no_dummies) {
+    start = 0;
+  } else {
+    start = cNDummyAtoms;
+  }
+  for(a = start; a < I->NAtom; a++) {
+    tag = false;
+    /* set tag based on passed in atom list or on global atom table */
+    if(atom) {
+      if(atom[a])
+        tag = atom[a];
+    } else {
+      if(I->Obj[I->Table[a].model] == obj)
+        tag = 1;
+    }
+    if(tag) {
+      /* if this this atom is tagged, grab its object
+       * index, and info record */
+      selObj = I->Obj[I->Table[a].model];
+      index = I->Table[a].atom;
+      ai = selObj->AtomInfo + index;
+
+      /* update whether or not this is a selection w/only one object */
+      if(singleObjectFlag) {
+        if(singleObject) {
+          if(selObj != singleObject) {
+            singleObjectFlag = false;
+          }
+        } else {
+          singleObject = selObj;
+        }
+      }
+      /* update whether or not this is a selection w/only one atom */
+      if(singleAtomFlag) {
+        if(singleAtom >= 0) {
+          if(index != singleAtom) {
+            singleAtomFlag = false;
+          }
+        } else {
+          singleAtom = index;
+        }
+      }
+
+      /* store this is the Selectors->Member table, so make sure there's room */
+      c++;
+      if(I->FreeMember > 0) {
+        m = I->FreeMember;
+        I->FreeMember = I->Member[m].next;
+      } else {
+        I->NMember++;
+        m = I->NMember;
+        VLACheck(I->Member, MemberType, m);
+      }
+      I->Member[m].selection = sele;
+      I->Member[m].tag = tag;
+      /* at runtime, selections can now have transient ordering --
+         but these are not yet persistent through session saves & restores */
+      I->Member[m].next = ai->selEntry;
+      ai->selEntry = m;
+    }
+  }
+
+  /* after scanning, update whether or not we touched multiple objects/atoms */
+  if(c) {                       
+    SelectionInfoRec *info = I->Info + (I->NActive - 1);
+    if(singleObjectFlag) {
+      info->justOneObjectFlag = true;
+      info->theOneObject = singleObject;
+      if(singleAtomFlag) {
+        info->justOneAtomFlag = true;
+        info->theOneAtom = singleAtom;
+      }
+    }
+  }
+
+  if(exec_managed) {
+    if(newFlag)
+      ExecutiveManageSelection(G, name);
+  }
+  PRINTFD(G, FB_Selector)
+    " Selector: Embedded %s, %d atoms.\n", name, c ENDFD;
+  return (c);
+}
+
+
+/*========================================================================*/
+static sele_array_t SelectorApplyMultipick(PyMOLGlobals * G, Multipick * mp)
+{
+  CSelector *I = G->Selector;
+  sele_array_t result;
+  int n;
+  Picking *p;
+  ObjectMolecule *obj;
+  SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+  sele_array_calloc(result, I->NAtom);
+  n = mp->picked[0].src.index;
+  p = mp->picked + 1;
+  while(n--) {                  /* what if this object isn't a molecule object?? */
+    obj = (ObjectMolecule *) p->context.object;
+    /* NOTE: SeleBase only safe with cSelectorUpdateTableAllStates!  */
+    result[obj->SeleBase + p->src.index] = true;
+    p++;
+  }
+  return (result);
+}
+
+
+/*========================================================================*/
+static sele_array_t SelectorSelectFromTagDict(PyMOLGlobals * G, OVOneToAny * id2tag)
+{
+  CSelector *I = G->Selector;
+  sele_array_t result{};
+  int a;
+  AtomInfoType *ai;
+  OVreturn_word ret;
+
+  SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);    /* for now, update the entire table */
+  {
+    TableRec *i_table = I->Table, *table_a;
+    ObjectMolecule **i_obj = I->Obj;
+
+    sele_array_calloc(result, I->NAtom);
+    if(result) {
+      table_a = i_table + cNDummyAtoms;
+      for(a = cNDummyAtoms; a < I->NAtom; a++) {
+        ai = i_obj[table_a->model]->AtomInfo + table_a->atom;
+        if(ai->unique_id) {
+          if(!OVreturn_IS_ERROR(ret = OVOneToAny_GetKey(id2tag, ai->unique_id)))
+            result[a] = ret.word;
+        }
+        table_a++;
+      }
+    }
+  }
+  return (result);
+}
+
+
+/*========================================================================*/
+
+static int _SelectorCreate(PyMOLGlobals * G, const char *sname, const char *sele,
+                           ObjectMolecule ** obj, int quiet, Multipick * mp,
+                           CSeqRow * rowVLA, int nRow, int **obj_idx, int *n_idx,
+                           int n_obj, OVOneToAny * id2tag, int executive_manage,
+                           int state, int domain)
+{
+  sele_array_t atom{};
+  OrthoLineType name;
+  int ok = true;
+  int c = 0;
+  int ignore_case = SettingGetGlobal_b(G, cSetting_ignore_case);
+  ObjectMolecule *embed_obj = NULL;
+
+  PRINTFD(G, FB_Selector)
+    "SelectorCreate-Debug: entered...\n" ENDFD;
+
+  /* copy sname into name and check if it's a keyword; abort on 
+   * the selection name == keyword: eg. "select all, none" */
+  if(sname[0] == '%')
+    strcpy(name, &sname[1]);
+  else
+    strcpy(name, sname);
+  if(WordMatchExact(G, cKeywordAll, name, ignore_case)) {
+    name[0] = 0;                /* force error */
+  }
+  UtilCleanStr(name);
+  /* name was invalid, output error msg to user */
+  if(!name[0]) {
+      PRINTFB(G, FB_Selector, FB_Errors)
+	"Selector-Error: Invalid selection name \"%s\".\n", sname ENDFB(G);
+  }
+  if(ok) {
+    if(sele) {
+      atom = SelectorSelect(G, sele, state, domain, quiet);
+      if(!atom)
+        ok = false;
+    } else if(id2tag) {
+      atom = SelectorSelectFromTagDict(G, id2tag);
+    } else if(obj && obj[0]) {  /* optimized full-object selection */
+      if(n_obj <= 0) {
+        embed_obj = *obj;
+        if(obj_idx && n_idx) {
+          atom =
+            SelectorUpdateTableSingleObject(G, embed_obj, cSelectorUpdateTableAllStates,
+                                            false, *obj_idx, *n_idx, (n_obj == 0));
+        } else {
+          atom =
+            SelectorUpdateTableSingleObject(G, embed_obj, cSelectorUpdateTableAllStates,
+                                            false, NULL, 0, (n_obj == 0));
+        }
+      } else {
+        atom = SelectorUpdateTableMultiObjectIdxTag(G, obj, false, obj_idx, n_idx, n_obj);
+      }
+    } else if(mp) {
+      atom = SelectorApplyMultipick(G, mp);
+#if 0
+    } else if(rowVLA) {
+      atom = SelectorApplySeqRowVLA(G, rowVLA, nRow);
+#endif
+    } else
+      ok = false;
+  }
+  if(ok)
+    c = SelectorEmbedSelection(G, atom.get(), name, embed_obj, false, executive_manage);
+  atom.reset();
+  SelectorClean(G);
+  /* ignore reporting on quiet */
+  if(!quiet) {
+    /* ignore reporting on internal/private names */
+    if(name[0] != '_') {
+      if(ok) {
+        PRINTFB(G, FB_Selector, FB_Actions)
+          " Selector: selection \"%s\" defined with %d atoms.\n", name, c ENDFB(G);
+      }
+    }
+  }
+  if(ok) {
+    PRINTFD(G, FB_Selector)
+      " %s: \"%s\" created with %d atoms.\n", __func__, name, c ENDFD;
+  } else {
+    PRINTFD(G, FB_Selector)
+      " %s: \"%s\" not created due to error\n", __func__, name ENDFD;
+  }
+  if(!ok)
+    c = -1;
+  return (c);
+}
+
+int SelectorCreateFromTagDict(PyMOLGlobals * G, const char *sname, OVOneToAny * id2tag,
+                              int exec_managed)
+{
+  return _SelectorCreate(G, sname, NULL, NULL, true, NULL, NULL, 0, NULL, NULL, 0, id2tag,
+                         exec_managed, -1, -1);
+}
+
+int SelectorCreateEmpty(PyMOLGlobals * G, const char *name, int exec_managed)
+{
+  return _SelectorCreate(G, name, "none", NULL, 1, NULL, NULL, 0, NULL, 0, 0, NULL,
+                         exec_managed, -1, -1);
+}
+
+int SelectorCreateSimple(PyMOLGlobals * G, const char *name, const char *sele)
+{
+  return _SelectorCreate(G, name, sele, NULL, 1, NULL, NULL, 0, NULL, 0, 0, NULL, -1, -1,
+                         -1);
+}
+
+int SelectorCreateFromObjectIndices(PyMOLGlobals * G, const char *sname, ObjectMolecule * obj,
+                                    int *idx, int n_idx)
+{
+  return _SelectorCreate(G, sname, NULL, &obj, true, NULL, NULL, 0, &idx, &n_idx, -1, NULL, -1, -1, -1); 
+  /* n_obj = -1 disables numbered tags */
+}
+
+int SelectorCreateOrderedFromObjectIndices(PyMOLGlobals * G, const char *sname,
+                                           ObjectMolecule * obj, int *idx, int n_idx)
+{
+  return _SelectorCreate(G, sname, NULL, &obj, true, NULL, NULL, 0, &idx, &n_idx, 0, NULL, -1, -1, -1);
+  /* assigned numbered tags */
+}
+
+int SelectorCreateOrderedFromMultiObjectIdxTag(PyMOLGlobals * G, const char *sname,
+                                               ObjectMolecule ** obj,
+                                               int **idx_tag, int *n_idx, int n_obj)
+{
+  return _SelectorCreate(G, sname, NULL, obj, true, NULL, NULL, 0, idx_tag, n_idx, n_obj,
+                         NULL, -1, -1, -1);
+}
+
+int SelectorCreate(PyMOLGlobals * G, const char *sname, const char *sele, ObjectMolecule * obj,
+                   int quiet, Multipick * mp)
+{
+  return _SelectorCreate(G, sname, sele, &obj, quiet, mp, NULL, 0, NULL, 0, 0, NULL, -1,
+                         -1, -1);
+}
+
+int SelectorCreateWithStateDomain(PyMOLGlobals * G, const char *sname, const char *sele,
+                                  ObjectMolecule * obj, int quiet, Multipick * mp,
+                                  int state, const char *domain)
+{
+  int domain_sele = -1;
+  ObjectNameType valid_name;
+
+  UtilNCopy(valid_name, sname, sizeof(valid_name));
+  if(SettingGetGlobal_b(G, cSetting_validate_object_names)) {
+    ObjectMakeValidName(G, valid_name);
+    sname = valid_name;
+  }
+
+  if(domain && domain[0]) {
+    if(!WordMatchExact(G, cKeywordAll, domain, true)) { /* allow domain=all */
+      domain_sele = SelectorIndexByName(G, domain);
+      if(domain_sele < 0) {
+
+        PRINTFB(G, FB_Selector, FB_Errors)
+          "Selector-Error: Invalid domain selection name \"%s\".\n", domain ENDFB(G);
+        return -1;
+      }
+    }
+  }
+  return _SelectorCreate(G, sname, sele, &obj, quiet, mp, NULL, 0, NULL, 0, 0, NULL, -1,
+                         state, domain_sele);
+}
+
+
+/*========================================================================*/
+static void SelectorClean(PyMOLGlobals * G)
+{
+  SelectorCleanImpl(G, G->Selector);
+}
+
+static void SelectorCleanImpl(PyMOLGlobals * G, CSelector *I)
+{
+  FreeP(I->Table);
+  I->Table = NULL;
+  FreeP(I->Obj);
+  I->Obj = NULL;
+  FreeP(I->Vertex);
+  I->Vertex = NULL;
+  FreeP(I->Flag1);
+  I->Flag1 = NULL;
+  FreeP(I->Flag2);
+  I->Flag2 = NULL;
+  I->NAtom = 0;
+  ExecutiveInvalidateSelectionIndicatorsCGO(G);
+}
+
+
+/*========================================================================*/
+static sele_array_t SelectorUpdateTableSingleObject(PyMOLGlobals * G, ObjectMolecule * obj,
+                                            int req_state,
+                                            int no_dummies, int *idx,
+                                            int n_idx, int numbered_tags)
+{
+  int a = 0;
+  int c = 0;
+  int modelCnt;
+  sele_array_t result{};
+  int tag = true;
+  int state = req_state;
+  CSelector *I = G->Selector;
+
+  PRINTFD(G, FB_Selector)
+    "SelectorUpdateTableSingleObject-Debug: entered for %s...\n", obj->Name ENDFD;
+
+  SelectorClean(G);
+
+  switch (req_state) {
+  case cSelectorUpdateTableAllStates:
+    state = req_state;
+    break;
+  case cSelectorUpdateTableEffectiveStates:
+    state = ObjectGetCurrentState(obj, true);
+    break;
+  case cSelectorUpdateTableCurrentState:
+    state = SceneGetState(G);
+    break;
+  default:
+    if(req_state < 0)
+      state = cSelectorUpdateTableAllStates;    /* fail safe */
+    break;
+  }
+
+  switch (req_state) {
+  case cSelectorUpdateTableAllStates:
+    I->SeleBaseOffsetsValid = true;     /* all states -> all atoms -> offsets valid */
+    break;
+  default:
+    I->SeleBaseOffsetsValid = false;    /* not including all atoms, so atom-based offsets are invalid */
+    break;
+  }
+
+  I->NCSet = 0;
+  if(no_dummies) {
+    modelCnt = 0;
+    c = 0;
+  } else {
+    modelCnt = cNDummyModels;
+    c = cNDummyAtoms;
+  }
+  c += obj->NAtom;
+  if(I->NCSet < obj->NCSet)
+    I->NCSet = obj->NCSet;
+  modelCnt++;
+  I->Table = pymol::calloc<TableRec>(c);
+  ErrChkPtr(G, I->Table);
+  I->Obj = pymol::calloc<ObjectMolecule *>(modelCnt);
+  ErrChkPtr(G, I->Obj);
+  if(no_dummies) {
+    modelCnt = 0;
+    c = 0;
+  } else {
+    c = cNDummyAtoms;
+    modelCnt = cNDummyModels;
+  }
+  I->Obj[modelCnt] = obj;
+
+  obj->SeleBase = c;
+
+  if(state < 0) {
+    for(a = 0; a < obj->NAtom; a++) {
+      I->Table[c].model = modelCnt;
+      I->Table[c].atom = a;
+      c++;
+    }
+  } else if(state < obj->NCSet) {
+    TableRec *rec = I->Table + c;
+    CoordSet *cs = obj->CSet[state];
+    if(cs) {
+      for(a = 0; a < obj->NAtom; a++) {
+        int ix;
+        ix = cs->atmToIdx(a);
+        if(ix >= 0) {
+          rec->model = modelCnt;
+          rec->atom = a;
+          rec++;
+        }
+      }
+    }
+    c = rec - I->Table;
+  }
+
+  if(idx && n_idx) {
+    sele_array_calloc(result, c);
+    if(n_idx > 0) {
+      for(a = 0; a < n_idx; a++) {
+        int at = idx[a];
+        if(numbered_tags)
+          tag = a + SELECTOR_BASE_TAG;
+        if((at >= 0) && (at < obj->NAtom)) {
+          /* create an ordered selection based on the input order of the object indices */
+          result[obj->SeleBase + at] = tag;
+        }
+      }
+    } else {                    /* -1 terminated list */
+      int *at_idx = idx;
+      int at;
+      a = SELECTOR_BASE_TAG + 1;
+      while((at = *(at_idx++)) >= 0) {
+        if(numbered_tags) {
+          tag = a++;
+        }
+        if((at >= 0) && (at < obj->NAtom)) {
+          /* create an ordered selection based on the input order of the object indices */
+          result[obj->SeleBase + at] = tag;
+        }
+      }
+    }
+  }
+  modelCnt++;
+  I->NModel = modelCnt;
+  I->NAtom = c;
+  I->Flag1 = pymol::malloc<int>(c);
+  ErrChkPtr(G, I->Flag1);
+  I->Flag2 = pymol::malloc<int>(c);
+  ErrChkPtr(G, I->Flag2);
+  I->Vertex = pymol::malloc<float>(c * 3);
+  ErrChkPtr(G, I->Vertex);
+
+  PRINTFD(G, FB_Selector)
+    "SelectorUpdateTableSingleObject-Debug: leaving...\n" ENDFD;
+
+  return (result);
+}
+
+
+/*========================================================================*/
+int SelectorUpdateTable(PyMOLGlobals * G, int req_state, int domain)
+{
+  return (SelectorUpdateTableImpl(G, G->Selector, req_state, domain));
+}
+
+int SelectorUpdateTableImpl(PyMOLGlobals * G, CSelector *I, int req_state, int domain)
+{
+  int a = 0;
+  ov_size c = 0;
+  int modelCnt;
+  int state = req_state;
+  void *iterator = NULL;
+  ObjectMolecule *obj = NULL;
+
+  /* Origin and Center are dummy objects */
+  if(!I->Origin)
+    I->Origin = ObjectMoleculeDummyNew(G, cObjectMoleculeDummyOrigin);
+
+  if(!I->Center)
+    I->Center = ObjectMoleculeDummyNew(G, cObjectMoleculeDummyCenter);
+
+  SelectorClean(G);
+  I->NCSet = 0;
+
+  /* take a summary of PyMOL's current state; foreach molecular object
+   * sum up the number of atoms, count how many models, states, etc... */
+  modelCnt = cNDummyModels;
+  c = cNDummyAtoms;
+  while(ExecutiveIterateObjectMolecule(G, &obj, &iterator)) {
+    c += obj->NAtom;
+    if(I->NCSet < obj->NCSet)
+      I->NCSet = obj->NCSet;
+    modelCnt++;
+  }
+  /* allocate space for each atom, in the record table */
+  I->Table = pymol::calloc<TableRec>(c);
+  ErrChkPtr(G, I->Table);
+  I->Obj = pymol::calloc<ObjectMolecule *>(modelCnt);
+  ErrChkPtr(G, I->Obj);
+
+  switch (req_state) {
+  case cSelectorUpdateTableAllStates:
+    I->SeleBaseOffsetsValid = true;     /* all states -> all atoms -> offsets valid */
+    break;
+  default:
+    I->SeleBaseOffsetsValid = false;    /* not including all atoms, so atom-based offsets are invalid */
+    break;
+  }
+
+  c = 0;
+  modelCnt = 0;
+
+  /* update the origin and center dummies */
+  obj = I->Origin;
+  if(obj) {
+    I->Obj[modelCnt] = I->Origin;
+    obj->SeleBase = c;          /* make note of where this object starts */
+    for(a = 0; a < obj->NAtom; a++) {
+      I->Table[c].model = modelCnt;
+      I->Table[c].atom = a;
+      c++;
+    }
+    modelCnt++;
+  }
+
+  obj = I->Center;
+  if(obj) {
+    I->Obj[modelCnt] = I->Center;
+    obj->SeleBase = c;          /* make note of where this object starts */
+    for(a = 0; a < obj->NAtom; a++) {
+      I->Table[c].model = modelCnt;
+      I->Table[c].atom = a;
+      c++;
+    }
+    modelCnt++;
+  }
+
+  if(req_state < cSelectorUpdateTableAllStates) {
+    state = SceneGetState(G);   /* just in case... */
+  }
+
+  while(ExecutiveIterateObjectMolecule(G, &obj, &iterator)) {
+    int skip_flag = false;
+    if(req_state < 0) {
+      switch (req_state) {
+      case cSelectorUpdateTableAllStates:
+        state = -1;             /* all states */
+        /* proceed... */
+        break;
+      case cSelectorUpdateTableCurrentState:
+        state = SettingGetGlobal_i(G, cSetting_state) - 1;
+        break;
+      case cSelectorUpdateTableEffectiveStates:
+        state = ObjectGetCurrentState(obj, true);
+        break;
+      default:                 /* unknown input -- fail safe (all states) */
+        state = -1;
+        break;
+      }
+    } else {
+      if(state >= obj->NCSet)
+        skip_flag = true;
+      else if(!obj->CSet[state])
+        skip_flag = true;
+    }
+
+    if(!skip_flag) {
+      /* fill in the table */
+      I->Obj[modelCnt] = obj;
+      {
+        int n_atom = obj->NAtom;
+        TableRec *rec = I->Table + c;
+        TableRec *start_rec = rec;
+        if(state < 0) {         /* all states */
+          if(domain < 0) {      /* domain=all */
+            for(a = 0; a < n_atom; a++) {
+              rec->model = modelCnt;
+              rec->atom = a;
+              rec++;
+            }
+          } else {
+            AtomInfoType *ai = obj->AtomInfo;
+            int included_one = false;
+            int excluded_one = false;
+            for(a = 0; a < n_atom; a++) {
+              if(SelectorIsMember(G, ai->selEntry, domain)) {
+                rec->model = modelCnt;
+                rec->atom = a;
+                rec++;
+                included_one = true;
+              } else {
+                excluded_one = true;
+              }
+              ai++;
+            }
+            if(included_one && excluded_one)
+              I->SeleBaseOffsetsValid = false;  /* partial objects in domain, so
+                                                   base offsets are invalid */
+          }
+        } else {                /* specific states */
+          CoordSet *cs;
+          int idx;
+          if(domain < 0) {
+            for(a = 0; a < n_atom; a++) {
+              /* does coordinate exist for this atom in the requested state? */
+              if(state < obj->NCSet)
+                cs = obj->CSet[state];
+              else
+                cs = NULL;
+              if(cs) {
+                idx = cs->atmToIdx(a);
+                if(idx >= 0) {
+                  rec->model = modelCnt;
+                  rec->atom = a;
+                  rec++;
+                }
+              }
+            }
+          } else {
+            AtomInfoType *ai = obj->AtomInfo;
+            for(a = 0; a < n_atom; a++) {
+              /* does coordinate exist for this atom in the requested state? */
+              if(state < obj->NCSet)
+                cs = obj->CSet[state];
+              else
+                cs = NULL;
+              if(cs) {
+                idx = cs->atmToIdx(a);
+                if(idx >= 0) {
+                  if(SelectorIsMember(G, ai->selEntry, domain)) {
+                    rec->model = modelCnt;
+                    rec->atom = a;
+                    rec++;
+                  }
+                }
+              }
+              ai++;
+            }
+          }
+        }
+        if(rec != start_rec) {  /* skip excluded models */
+          modelCnt++;
+          obj->SeleBase = c;    /* make note of where this object starts */
+          c += (rec - start_rec);
+        } else {
+          obj->SeleBase = 0;
+        }
+      }
+    }
+  }
+  I->NModel = modelCnt;
+  I->NAtom = c;
+  I->Flag1 = pymol::malloc<int>(c);
+  ErrChkPtr(G, I->Flag1);
+  I->Flag2 = pymol::malloc<int>(c);
+  ErrChkPtr(G, I->Flag2);
+  I->Vertex = pymol::malloc<float>(c * 3);
+  ErrChkPtr(G, I->Vertex);
+  /* printf("selector update table state=%d, natom=%d\n",req_state,c); */
+  return (true);
+}
+
+
+/*========================================================================*/
+static sele_array_t SelectorSelect(PyMOLGlobals * G, const char *sele, int state, int domain, int quiet)
+{
+  PRINTFD(G, FB_Selector)
+    "SelectorSelect-DEBUG: sele = \"%s\"\n", sele ENDFD;
+  SelectorUpdateTable(G, state, domain);
+  auto parsed = SelectorParse(G, sele);
+  if (!parsed.empty()) {
+    return SelectorEvaluate(G, parsed, state, quiet);
+  }
+  return {};
+}
+
+
+/*========================================================================*/
+static int SelectorModulate1(PyMOLGlobals * G, EvalElem * base, int state)
+{
+  CSelector *I = G->Selector;
+  int a, d, e;
+  int c = 0;
+  float dist;
+  int nbond;
+  float *v2;
+  CoordSet *cs;
+  int ok = true;
+  int nCSet;
+  MapType *map;
+  int i, j, h, k, l;
+  int n1, at, idx;
+  ObjectMolecule *obj;
+
+  if(state < 0) {
+    switch (state) {
+    case -2:
+    case -3:
+      state = SceneGetState(G);
+      break;
+    }
+  }
+
+  base[1].sele = std::move(base[0].sele);  /* base1 has the mask */
+  base->sele_calloc(I->NAtom);
+  base->sele_check_ok(ok);
+  if (!ok)
+    return false;
+  switch (base[1].code) {
+  case SELE_ARD_:
+  case SELE_EXP_:
+    if(!sscanf(base[2].text(), "%f", &dist))
+      ok = ErrMessage(G, "Selector", "Invalid distance.");
+    if(ok) {
+      for(d = 0; d < I->NCSet; d++) {
+        if((state < 0) || (d == state)) {
+          n1 = 0;
+          for(a = 0; a < I->NAtom; a++) {
+            I->Flag1[a] = false;
+            at = I->Table[a].atom;
+            obj = I->Obj[I->Table[a].model];
+            if(d < obj->NCSet)
+              cs = obj->CSet[d];
+            else
+              cs = NULL;
+            if(cs) {
+              if(CoordSetGetAtomVertex(cs, at, I->Vertex + 3 * a)) {
+                I->Flag1[a] = true;
+                n1++;
+              }
+            }
+          }
+          if(n1) {
+            map = MapNewFlagged(G, -dist, I->Vertex, I->NAtom, NULL, I->Flag1);
+            if(map) {
+              ok &= MapSetupExpress(map);
+              nCSet = SelectorGetArrayNCSet(G, base[1].sele, false);
+              for(e = 0; ok && e < nCSet; e++) {
+                if((state < 0) || (e == state)) {
+                  for(a = 0; ok && a < I->NAtom; a++) {
+                    if(base[1].sele[a]) {
+                      at = I->Table[a].atom;
+                      obj = I->Obj[I->Table[a].model];
+                      if(e < obj->NCSet)
+                        cs = obj->CSet[e];
+                      else
+                        cs = NULL;
+                      if(cs) {
+                        idx = cs->atmToIdx(at);
+                        if(idx >= 0) {
+                          v2 = cs->Coord + (3 * idx);
+                          MapLocus(map, v2, &h, &k, &l);
+                          i = *(MapEStart(map, h, k, l));
+                          if(i) {
+                            j = map->EList[i++];
+                            while(j >= 0) {
+                              if((!base[0].sele[j]) && ((base[1].code == SELE_EXP_)
+                                                        || (!base[1].sele[j]))) {   
+                                /*exclude current selection */
+                                if(within3f(I->Vertex + 3 * j, v2, dist))
+                                  base[0].sele[j] = true;
+                              }
+                              j = map->EList[i++];
+                            }
+                          }
+                        }
+                      }
+                    }
+                  }
+                }
+              }
+              MapFree(map);
+            }
+          }
+        }
+      }
+    }
+    break;
+
+  case SELE_EXT_:
+    if(sscanf(base[2].text(), "%d", &nbond) != 1)
+      ok = ErrMessage(G, "Selector", "Invalid bond count.");
+    if(ok) {
+      ObjectMolecule *lastObj = NULL;
+      int a, n, a0, a1, a2;
+      std::copy_n(base[1].sele_data(), I->NAtom, base[0].sele_data());
+      while((nbond--) > 0) {
+        std::swap(base[1].sele, base[0].sele);
+        for(a = cNDummyAtoms; a < I->NAtom; a++) {
+          if(base[1].sele[a]) {
+            if(I->Obj[I->Table[a].model] != lastObj) {
+              lastObj = I->Obj[I->Table[a].model];
+              ObjectMoleculeUpdateNeighbors(lastObj);
+            }
+            a0 = I->Table[a].atom;
+            n = lastObj->Neighbor[a0];
+            n++;
+            while(1) {
+              a1 = lastObj->Neighbor[n];
+              if(a1 < 0)
+                break;
+              if((a2 = SelectorGetObjAtmOffset(I, lastObj, a1)) >= 0) {
+                base[0].sele[a2] = 1;
+                n += 2;
+              }
+            }
+          }
+        }
+      }
+      base[1].sele_free();
+    }
+    break;
+
+  case SELE_GAP_:
+    if(!sscanf(base[2].text(), "%f", &dist))
+      ok = ErrMessage(G, "Selector", "Invalid distance.");
+    if(ok) {
+      for(a = 0; a < I->NAtom; a++) {
+        obj = I->Obj[I->Table[a].model];
+        at = I->Table[a].atom;
+        I->Table[a].f1 = obj->AtomInfo[at].vdw;
+        base[0].sele[a] = true; /* start selected, subtract off */
+        c = I->NAtom;
+      }
+      for(d = 0; d < I->NCSet; d++) {
+        if((state < 0) || (d == state)) {
+          n1 = 0;
+          for(a = 0; a < I->NAtom; a++) {
+            obj = I->Obj[I->Table[a].model];
+            I->Flag1[a] = false;
+            at = I->Table[a].atom;
+            if(d < obj->NCSet)
+              cs = obj->CSet[d];
+            else
+              cs = NULL;
+            if(cs) {
+              if(CoordSetGetAtomVertex(cs, at, I->Vertex + 3 * a)) {
+                I->Flag1[a] = true;
+                n1++;
+              }
+            }
+          }
+          if(n1) {
+            map =
+              MapNewFlagged(G, -(dist + 2 * MAX_VDW), I->Vertex, I->NAtom, NULL,
+                            I->Flag1);
+            if(map) {
+
+              ok &= MapSetupExpress(map);
+              nCSet = SelectorGetArrayNCSet(G, base[1].sele, false);
+              for(e = 0; ok && e < nCSet; e++) {
+                if((state < 0) || (e == state)) {
+                  for(a = 0; a < I->NAtom; a++) {
+                    if(base[1].sele[a]) {
+                      at = I->Table[a].atom;
+                      obj = I->Obj[I->Table[a].model];
+                      if(e < obj->NCSet)
+                        cs = obj->CSet[e];
+                      else
+                        cs = NULL;
+                      if(cs) {
+                        idx = cs->atmToIdx(at);
+
+                        if(idx >= 0) {
+                          v2 = cs->Coord + (3 * idx);
+                          MapLocus(map, v2, &h, &k, &l);
+                          i = *(MapEStart(map, h, k, l));
+                          if(i) {
+                            j = map->EList[i++];
+                            while(j >= 0) {
+                              if((base[0].sele[j]) && (!base[1].sele[j])) {     /*exclude current selection */
+                                if(within3f(I->Vertex + 3 * j, v2, dist +       /* eliminate atoms w/o gap */
+                                            I->Table[a].f1 + I->Table[j].f1)) {
+                                  base[0].sele[j] = false;
+                                  c--;
+                                }
+                              } else if(base[1].sele[j]) {
+                                base[0].sele[j] = false;
+                                c--;
+                              }
+                              j = map->EList[i++];
+                            }
+                          }
+                        }
+                      }
+                    }
+                  }
+                }
+              }
+              MapFree(map);
+            }
+          }
+        }
+      }
+    }
+    break;
+  }
+  base[1].sele_free();
+  if(Feedback(G, FB_Selector, FB_Debugging)) {
+    c = 0;
+    for(a = cNDummyAtoms; a < I->NAtom; a++)
+      if(base[0].sele[a])
+        c++;
+    fprintf(stderr, "SelectorModulate0: %d atoms selected.\n", c);
+  }
+  return (ok);
+
+}
+
+
+/*========================================================================*/
+static int SelectorSelect0(PyMOLGlobals * G, EvalElem * passed_base)
+{
+  CSelector *I = G->Selector;
+  TableRec *i_table = I->Table;
+  ObjectMolecule **i_obj = I->Obj;
+  int a, b, flag;
+  EvalElem *base = passed_base;
+  int c = 0;
+  int state;
+  ObjectMolecule *obj, *cur_obj = NULL;
+  CoordSet *cs;
+
+  base->type = STYP_LIST;
+  base->sele_calloc(I->NAtom);
+  base->sele_err_chk_ptr(G);
+
+  switch (base->code) {
+  case SELE_HBAs:
+  case SELE_HBDs:
+  case SELE_DONz:
+  case SELE_ACCz:
+
+    {
+      /* first, verify chemistry for all atoms... */
+      ObjectMolecule *lastObj = NULL, *obj;
+      for(a = cNDummyAtoms; a < I->NAtom; a++) {
+        obj = i_obj[i_table[a].model];
+        if(obj != lastObj) {
+          ObjectMoleculeUpdateNeighbors(obj);
+          ObjectMoleculeVerifyChemistry(obj, -1);
+          lastObj = obj;
+        }
+      }
+    }
+    switch (base->code) {
+    case SELE_HBAs:
+    case SELE_ACCz:
+      for(a = cNDummyAtoms; a < I->NAtom; a++)
+        base[0].sele[a] = i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].hb_acceptor;
+      break;
+    case SELE_HBDs:
+    case SELE_DONz:
+      for(a = cNDummyAtoms; a < I->NAtom; a++)
+        base[0].sele[a] = i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].hb_donor;
+      break;
+
+    }
+    break;
+  case SELE_NONz:
+    for(a = cNDummyAtoms; a < I->NAtom; a++)
+      base[0].sele[a] = false;
+    break;
+  case SELE_BNDz:
+    for(a = cNDummyAtoms; a < I->NAtom; a++)
+      base[0].sele[a] = i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].bonded;
+    break;
+  case SELE_HETz:
+    for(a = cNDummyAtoms; a < I->NAtom; a++)
+      base[0].sele[a] = i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].hetatm;
+    break;
+  case SELE_HYDz:
+    for(a = cNDummyAtoms; a < I->NAtom; a++)
+      base[0].sele[a] = i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].isHydrogen();
+    break;
+  case SELE_METz:
+    for(a = cNDummyAtoms; a < I->NAtom; a++) {
+      base[0].sele[a] = i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].isMetal();
+    }
+    break;
+  case SELE_BB_z:
+  case SELE_SC_z:
+    {
+      AtomInfoType *ai;
+      flag = (base->code == SELE_BB_z);
+      for(a = cNDummyAtoms; a < I->NAtom; a++) {
+        ai = i_obj[i_table[a].model]->AtomInfo + i_table[a].atom;
+        if(!(ai->flags & cAtomFlag_polymer)) {
+          base[0].sele[a] = 0;
+          continue;
+        }
+        base[0].sele[a] = !flag;
+        for(b = 0; backbone_names[b][0]; b++) {
+          if(!(strcmp(LexStr(G, ai->name), backbone_names[b]))) {
+            base[0].sele[a] = flag;
+            break;
+          }
+        }
+      }
+    }
+    break;
+  case SELE_FXDz:
+    for(a = cNDummyAtoms; a < I->NAtom; a++)
+      base[0].sele[a] =
+        i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].flags & cAtomFlag_fix;
+    break;
+  case SELE_RSTz:
+    for(a = cNDummyAtoms; a < I->NAtom; a++)
+      base[0].sele[a] =
+        i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].flags & cAtomFlag_restrain;
+    break;
+  case SELE_POLz:
+    for(a = cNDummyAtoms; a < I->NAtom; a++)
+      base[0].sele[a] =
+        i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].flags & cAtomFlag_polymer;
+    break;
+  case SELE_PROz:
+    for(a = cNDummyAtoms; a < I->NAtom; a++)
+      base[0].sele[a] =
+        i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].flags & cAtomFlag_protein;
+    break;
+  case SELE_NUCz:
+    for(a = cNDummyAtoms; a < I->NAtom; a++)
+      base[0].sele[a] =
+        i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].flags & cAtomFlag_nucleic;
+    break;
+  case SELE_SOLz:
+    for(a = cNDummyAtoms; a < I->NAtom; a++)
+      base[0].sele[a] =
+        i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].flags & cAtomFlag_solvent;
+    break;
+  case SELE_PTDz:
+    for(a = cNDummyAtoms; a < I->NAtom; a++)
+      base[0].sele[a] = i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].protekted;
+    break;
+  case SELE_MSKz:
+    for(a = cNDummyAtoms; a < I->NAtom; a++)
+      base[0].sele[a] = i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].masked;
+    break;
+  case SELE_ORGz:
+    for(a = cNDummyAtoms; a < I->NAtom; a++)
+      base[0].sele[a] =
+        i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].flags & cAtomFlag_organic;
+    break;
+  case SELE_INOz:
+    for(a = cNDummyAtoms; a < I->NAtom; a++)
+      base[0].sele[a] =
+        i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].flags & cAtomFlag_inorganic;
+    break;
+  case SELE_GIDz:
+    for(a = cNDummyAtoms; a < I->NAtom; a++)
+      base[0].sele[a] =
+        i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].flags & cAtomFlag_guide;
+    break;
+
+  case SELE_PREz:
+    flag = false;
+    cs = NULL;
+    for(a = cNDummyAtoms; a < I->NAtom; a++) {
+      base[0].sele[a] = false;
+      obj = i_obj[i_table[a].model];
+      if(obj != cur_obj) {      /* different object */
+        state = obj->getState();
+        if(state >= obj->NCSet)
+          flag = false;
+        else if(state < 0)
+          flag = false;
+        else if(!obj->CSet[state])
+          flag = false;
+        else {
+          cs = obj->CSet[state];
+          flag = true;          /* valid state */
+        }
+        cur_obj = obj;
+      }
+      if(flag && cs) {
+        if(cs->atmToIdx(i_table[a].atom) >= 0) {
+          base[0].sele[a] = true;
+          c++;
+        }
+      }
+    }
+    break;
+  case SELE_ALLz:
+    for(a = cNDummyAtoms; a < I->NAtom; a++) {
+      base[0].sele[a] = true;
+      c++;
+    }
+    break;
+  case SELE_ORIz:
+    for(a = 0; a < I->NAtom; a++) {
+      base[0].sele[a] = false;
+      c++;
+    }
+    if(I->Origin)
+      ObjectMoleculeDummyUpdate(I->Origin, cObjectMoleculeDummyOrigin);
+    base[0].sele[cDummyOrigin] = true;
+    break;
+  case SELE_CENz:
+    for(a = 0; a < I->NAtom; a++) {
+      base[0].sele[a] = false;
+      c++;
+    }
+    if(I->Center)
+      ObjectMoleculeDummyUpdate(I->Center, cObjectMoleculeDummyCenter);
+    base[0].sele[cDummyCenter] = true;
+    break;
+  case SELE_VISz:
+    {
+      ObjectMolecule *last_obj = NULL;
+      AtomInfoType *ai;
+      for(a = cNDummyAtoms; a < I->NAtom; a++) {
+        flag = false;
+        obj = i_obj[i_table[a].model];
+        if(obj->Enabled) {
+          ai = obj->AtomInfo + i_table[a].atom;
+
+          if(last_obj != obj) {
+            ObjectMoleculeUpdateNeighbors(obj);
+            ObjectMoleculeVerifyChemistry(obj, -1);
+            last_obj = obj;
+          }
+
+          flag = ai->isVisible();
+        }
+        base[0].sele[a] = flag;
+        if(flag)
+          c++;
+      }
+    }
+    break;
+  case SELE_ENAz:
+    for(a = cNDummyAtoms; a < I->NAtom; a++) {
+      flag = (i_obj[i_table[a].model]->Enabled);
+      base[0].sele[a] = flag;
+      if(flag)
+        c++;
+    }
+    break;
+  }
+  PRINTFD(G, FB_Selector)
+    " %s: %d atoms selected.\n", __func__, c ENDFD;
+
+  return (1);
+}
+
+
+/*========================================================================*/
+static int SelectorSelect1(PyMOLGlobals * G, EvalElem * base, int quiet)
+{
+  CSelector *I = G->Selector;
+  CWordMatcher *matcher = NULL;
+  int a, b, c = 0, hit_flag;
+  ObjectMolecule **i_obj = I->Obj, *obj, *last_obj;
+  TableRec *i_table = I->Table, *table_a;
+  int ignore_case = SettingGetGlobal_b(G, cSetting_ignore_case);
+  int ignore_case_chain = SettingGetGlobal_b(G, cSetting_ignore_case_chain);
+  int I_NAtom = I->NAtom;
+  int *base_0_sele_a;
+
+  int model, sele, s, col_idx;
+  int flag;
+  int ok = true;
+  int index, state;
+  int rep_mask;
+  const char *wildcard = SettingGetGlobal_s(G, cSetting_wildcard);
+
+  ObjectMolecule *cur_obj = NULL;
+  CoordSet *cs = NULL;
+
+  base->type = STYP_LIST;
+  base->sele_calloc(I_NAtom);    /* starting with zeros */
+  base->sele_err_chk_ptr(G);
+  switch (base->code) {
+  case SELE_PEPs:
+    if(base[1].text()[0]) {
+      AtomInfoType *last_ai0 = NULL, *ai0;
+      for(a = cNDummyAtoms; a < I_NAtom; a++) {
+        ai0 = i_obj[i_table[a].model]->AtomInfo + i_table[a].atom;
+        if(!AtomInfoSameResidueP(G, ai0, last_ai0)) {   /* new starting residue */
+          int match_found = false;
+          const char *ch = base[1].text();      /* sequence argument */
+          AtomInfoType *ai1, *last_ai1 = NULL;
+          for(b = a; b < I_NAtom; b++) {
+            ai1 = i_obj[i_table[b].model]->AtomInfo + i_table[b].atom;
+            if(!AtomInfoSameResidueP(G, ai1, last_ai1)) {
+              if(*ch != '-') {  /* if not skipping this residue */
+                if(!((*ch == '+') || (SeekerGetAbbr(G, LexStr(G, ai1->resn), 'O', 0) == *ch))) {   /* if a mismatch */
+                  break;
+                }
+              }
+              ch++;
+              if(!*ch) {        /* end of sequence pattern */
+                match_found = true;
+                break;
+              }
+              last_ai1 = ai1;
+            }
+          }
+          if(match_found) {
+            const char *ch = base[1].text();    /* sequence argument */
+            AtomInfoType *ai1, *last_ai1 = NULL, *ai2;
+            for(b = a; b < I_NAtom; b++) {
+              ai1 = i_obj[i_table[b].model]->AtomInfo + i_table[b].atom;
+              if(!AtomInfoSameResidueP(G, ai1, last_ai1)) {
+                if(*ch != '-') {        /* if not skipping this residue */
+                  if((*ch == '+') || (SeekerGetAbbr(G, LexStr(G, ai1->resn), 'O', 0) == *ch)) {    /* if matched */
+                    int d;
+                    for(d = b; d < I_NAtom; d++) {
+                      ai2 = i_obj[i_table[d].model]->AtomInfo + i_table[d].atom;        /* complete residue */
+                      if(AtomInfoSameResidue(G, ai1, ai2)) {
+                        c++;
+                        base[0].sele[d] = true;
+                      }
+                    }
+                  }
+                }
+                ch++;
+                if(!*ch) {      /* end of sequence pattern */
+                  break;
+                }
+                last_ai1 = ai1;
+              }
+            }
+          }
+        }
+      }
+    }
+    break;
+  case SELE_IDXs:
+    {
+      CWordMatchOptions options;
+
+      WordMatchOptionsConfigInteger(&options);
+
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
+        table_a = i_table + cNDummyAtoms;
+        base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+        for(a = cNDummyAtoms; a < I_NAtom; a++) {
+          if((*base_0_sele_a = WordMatcherMatchInteger(matcher, table_a->atom + 1)))
+            c++;
+          table_a++;
+          base_0_sele_a++;
+        }
+        WordMatcherFree(matcher);
+      }
+
+    }
+    break;
+  case SELE_ID_s:
+    {
+      CWordMatchOptions options;
+
+      WordMatchOptionsConfigInteger(&options);
+
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
+        table_a = i_table + cNDummyAtoms;
+        base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+        for(a = cNDummyAtoms; a < I_NAtom; a++) {
+          if((*base_0_sele_a =
+              WordMatcherMatchInteger(matcher,
+                                      i_obj[table_a->model]->AtomInfo[table_a->atom].id)))
+            c++;
+          table_a++;
+          base_0_sele_a++;
+        }
+        WordMatcherFree(matcher);
+      }
+    }
+    break;
+  case SELE_RNKs:
+    {
+      CWordMatchOptions options;
+
+      WordMatchOptionsConfigInteger(&options);
+
+      table_a = i_table + cNDummyAtoms;
+      base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
+        table_a = i_table + cNDummyAtoms;
+        base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+        for(a = cNDummyAtoms; a < I_NAtom; a++) {
+          if((*base_0_sele_a =
+              WordMatcherMatchInteger(matcher,
+                                      i_obj[table_a->model]->AtomInfo[table_a->atom].
+                                      rank)))
+            c++;
+          table_a++;
+          base_0_sele_a++;
+        }
+        WordMatcherFree(matcher);
+      }
+    }
+    break;
+  case SELE_NAMs:
+    {
+      CWordMatchOptions options;
+      const char *atom_name_wildcard = SettingGetGlobal_s(G, cSetting_atom_name_wildcard);
+
+      if(!atom_name_wildcard[0])
+        atom_name_wildcard = wildcard;
+
+      WordMatchOptionsConfigAlphaList(&options, atom_name_wildcard[0], ignore_case);
+
+      matcher = WordMatcherNew(G, base[1].text(), &options, false);
+
+      table_a = i_table + cNDummyAtoms;
+      base_0_sele_a = &base[0].sele[cNDummyAtoms];
+      last_obj = NULL;
+      for(a = cNDummyAtoms; a < I_NAtom; a++) {
+        obj = i_obj[table_a->model];
+        if(obj != last_obj) {
+
+          /* allow objects to have their own atom_name_wildcards...this is a tricky workaround
+             for handling nucleic acid structures that use "*" in atom names */
+
+          const char *atom_name_wildcard =
+            SettingGet_s(G, obj->Setting, NULL, cSetting_atom_name_wildcard);
+
+          if(!atom_name_wildcard[0])
+            atom_name_wildcard = wildcard;
+
+          if(options.wildcard != atom_name_wildcard[0]) {
+            options.wildcard = atom_name_wildcard[0];
+            if(matcher)
+              WordMatcherFree(matcher);
+            matcher = WordMatcherNew(G, base[1].text(), &options, false);
+            if(!matcher)
+              WordPrimeCommaMatch(G, &base[1].m_text[0] /* replace '+' with ',' */);
+          }
+          last_obj = obj;
+        }
+
+        const char * name = LexStr(G, obj->AtomInfo[table_a->atom].name);
+        if(matcher)
+          hit_flag =
+            WordMatcherMatchAlpha(matcher,
+                                  name);
+        else
+          hit_flag = (WordMatchCommaExact(G, base[1].text(),
+                                          name,
+                                          ignore_case) < 0);
+
+        if((*base_0_sele_a = hit_flag))
+          c++;
+        table_a++;
+        base_0_sele_a++;
+      }
+      if(matcher)
+        WordMatcherFree(matcher);
+    }
+    break;
+  case SELE_TTYs:
+    {
+      CWordMatchOptions options;
+
+      WordMatchOptionsConfigAlphaList(&options, wildcard[0], ignore_case);
+
+      table_a = i_table + cNDummyAtoms;
+      base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
+	AtomInfoType * ai;
+        table_a = i_table + cNDummyAtoms;
+        base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+#ifndef NO_MMLIBS
+#endif
+        for(a = cNDummyAtoms; a < I_NAtom; a++) {
+          ai = i_obj[table_a->model]->AtomInfo + table_a->atom;
+#ifndef NO_MMLIBS
+#endif
+          if((*base_0_sele_a = WordMatcherMatchAlpha(matcher, LexStr(G, ai->textType))))
+	    c++;
+          table_a++;
+          base_0_sele_a++;
+        }
+        WordMatcherFree(matcher);
+      }
+    }
+    break;
+  case SELE_ELEs:
+    {
+      CWordMatchOptions options;
+
+      WordMatchOptionsConfigAlphaList(&options, wildcard[0], ignore_case);
+
+      table_a = i_table + cNDummyAtoms;
+      base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
+        table_a = i_table + cNDummyAtoms;
+        base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+        for(a = cNDummyAtoms; a < I_NAtom; a++) {
+          if((*base_0_sele_a =
+              WordMatcherMatchAlpha(matcher,
+                                    i_obj[table_a->model]->AtomInfo[table_a->atom].elem)))
+            c++;
+          table_a++;
+          base_0_sele_a++;
+        }
+        WordMatcherFree(matcher);
+      }
+    }
+    break;
+  case SELE_STRO:
+    {
+      CWordMatchOptions options;
+      WordMatchOptionsConfigAlphaList(&options, wildcard[0], ignore_case);
+
+      table_a = i_table + cNDummyAtoms;
+      base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
+        table_a = i_table + cNDummyAtoms;
+        base_0_sele_a = &base[0].sele[cNDummyAtoms];
+#ifndef NO_MMLIBS
+#endif
+        for(a = cNDummyAtoms; a < I_NAtom; a++) {
+#ifndef NO_MMLIBS
+#endif
+          const char * mmstereotype =
+            AtomInfoGetStereoAsStr(i_obj[table_a->model]->AtomInfo + table_a->atom);
+          if((*base_0_sele_a =
+              WordMatcherMatchAlpha(matcher,mmstereotype)))
+            c++;
+          table_a++;
+          base_0_sele_a++;
+        }
+        WordMatcherFree(matcher);
+      }
+    }
+    break;
+  case SELE_REPs:
+    rep_mask = 0;
+    WordPrimeCommaMatch(G, &base[1].m_text[0] /* replace '+' with ',' */);
+    for(a = 0; rep_names[a].word[0]; a++) {
+      if(WordMatchComma(G, base[1].text(), rep_names[a].word, ignore_case) < 0)
+        rep_mask |= rep_names[a].value;
+    }
+    for(SelectorAtomIterator iter(I); iter.next();) {
+      if(iter.getAtomInfo()->visRep & rep_mask) {
+        base[0].sele[iter.a] = true;
+        c++;
+      } else {
+        base[0].sele[iter.a] = false;
+      }
+    }
+    break;
+  case SELE_COLs:
+    col_idx = ColorGetIndex(G, base[1].text());
+    for(a = cNDummyAtoms; a < I_NAtom; a++) {
+      base[0].sele[a] = false;
+      if(i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].color == col_idx) {
+        base[0].sele[a] = true;
+        c++;
+      }
+    }
+    break;
+  case SELE_CCLs:
+  case SELE_RCLs:
+    // setting index
+    index = (base->code == SELE_CCLs) ? cSetting_cartoon_color : cSetting_ribbon_color;
+    col_idx = ColorGetIndex(G, base[1].text());
+    for(a = cNDummyAtoms; a < I_NAtom; a++) {
+      base[0].sele[a] = false;
+      {
+        AtomInfoType *ai = i_obj[i_table[a].model]->AtomInfo + i_table[a].atom;
+        int value;
+        if (AtomSettingGetIfDefined(G, ai, index, &value)) {
+            if(value == col_idx) {
+              base[0].sele[a] = true;
+              c++;
+            }
+        }
+      }
+    }
+    break;
+  case SELE_CHNs:
+  case SELE_SEGs:
+  case SELE_CUST:
+  case SELE_LABs:
+    {
+      CWordMatchOptions options;
+
+      WordMatchOptionsConfigAlphaList(&options, wildcard[0], ignore_case_chain);
+
+      table_a = i_table + cNDummyAtoms;
+      base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+      int offset = 0;
+      switch (base->code) {
+        case SELE_CHNs:
+          offset = offsetof(AtomInfoType, chain);
+          break;
+        case SELE_SEGs:
+          offset = offsetof(AtomInfoType, segi);
+          break;
+        case SELE_CUST:
+          offset = offsetof(AtomInfoType, custom);
+          break;
+        case SELE_LABs:
+          offset = offsetof(AtomInfoType, label);
+          break;
+        default:
+          printf("coding error: missing case\n");
+      }
+
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
+        table_a = i_table + cNDummyAtoms;
+        base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+        for(a = cNDummyAtoms; a < I_NAtom; a++) {
+          if((*base_0_sele_a =
+              WordMatcherMatchAlpha(matcher, LexStr(G,
+                  *reinterpret_cast<lexidx_t*>
+                  (((char*)(i_obj[table_a->model]->AtomInfo + table_a->atom)) + offset)
+                  ))))
+            c++;
+          table_a++;
+          base_0_sele_a++;
+        }
+        WordMatcherFree(matcher);
+      }
+    }
+    break;
+  case SELE_SSTs:
+    {
+      CWordMatchOptions options;
+
+      WordMatchOptionsConfigAlphaList(&options, wildcard[0], ignore_case);
+
+      table_a = i_table + cNDummyAtoms;
+      base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
+        table_a = i_table + cNDummyAtoms;
+        base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+        for(a = cNDummyAtoms; a < I_NAtom; a++) {
+          if((*base_0_sele_a =
+              WordMatcherMatchAlpha(matcher,
+                                    i_obj[table_a->model]->AtomInfo[table_a->atom].
+                                    ssType)))
+            c++;
+          table_a++;
+          base_0_sele_a++;
+        }
+        WordMatcherFree(matcher);
+      }
+    }
+    break;
+  case SELE_STAs:
+    sscanf(base[1].text(), "%d", &state);
+    state = state - 1;
+    obj = NULL;
+
+    {
+      auto state_arg = state;
+      for(a = cNDummyAtoms; a < I_NAtom; a++) {
+        base[0].sele[a] = false;
+        obj = i_obj[i_table[a].model];
+        if(obj != cur_obj) {    /* different object */
+          if (state_arg == cSelectorUpdateTableCurrentState)
+            state = obj->getState();
+          if(state >= obj->NCSet)
+            flag = false;
+          else if(state < 0)
+            flag = false;
+          else if(!obj->CSet[state])
+            flag = false;
+          else {
+            cs = obj->CSet[state];
+            flag = true;        /* valid state */
+          }
+          cur_obj = obj;
+        }
+        if(flag && cs) {
+          if(cs->atmToIdx(i_table[a].atom) >= 0) {
+            base[0].sele[a] = true;
+            c++;
+          }
+        }
+      }
+    }
+    break;
+  case SELE_ALTs:
+    {
+      CWordMatchOptions options;
+
+      WordMatchOptionsConfigAlphaList(&options, wildcard[0], ignore_case);
+
+      table_a = i_table + cNDummyAtoms;
+      base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
+        table_a = i_table + cNDummyAtoms;
+        base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+        for(a = cNDummyAtoms; a < I_NAtom; a++) {
+          if((*base_0_sele_a =
+              WordMatcherMatchAlpha(matcher,
+                                    i_obj[table_a->model]->AtomInfo[table_a->atom].alt)))
+            c++;
+          table_a++;
+          base_0_sele_a++;
+        }
+        WordMatcherFree(matcher);
+      }
+    }
+    break;
+  case SELE_FLGs:
+    sscanf(base[1].text(), "%d", &flag);
+    flag = (1 << flag);
+    for(a = cNDummyAtoms; a < I_NAtom; a++) {
+      if(i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].flags & flag) {
+        base[0].sele[a] = true;
+        c++;
+      } else
+        base[0].sele[a] = false;
+    }
+    break;
+  case SELE_NTYs:
+    {
+      CWordMatchOptions options;
+
+      WordMatchOptionsConfigInteger(&options);
+
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
+        table_a = i_table + cNDummyAtoms;
+        base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+        for(a = cNDummyAtoms; a < I_NAtom; a++) {
+          if((*base_0_sele_a =
+              WordMatcherMatchInteger(matcher,
+                                      i_obj[table_a->model]->AtomInfo[table_a->atom].
+                                      customType)))
+            c++;
+          table_a++;
+          base_0_sele_a++;
+        }
+        WordMatcherFree(matcher);
+      }
+    }
+    break;
+  case SELE_RSIs:
+    {
+      CWordMatchOptions options;
+      AtomInfoType *ai;
+
+      WordMatchOptionsConfigMixed(&options, wildcard[0], ignore_case);
+
+      table_a = i_table + cNDummyAtoms;
+      base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
+        table_a = i_table + cNDummyAtoms;
+        base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+        for(a = cNDummyAtoms; a < I_NAtom; a++) {
+          ai = i_obj[table_a->model]->AtomInfo + table_a->atom;
+          char resi[8];
+          AtomResiFromResv(resi, sizeof(resi), ai);
+          if((*base_0_sele_a = WordMatcherMatchMixed(matcher, resi, ai->resv)))
+            c++;
+          table_a++;
+          base_0_sele_a++;
+        }
+        WordMatcherFree(matcher);
+      }
+    }
+    break;
+  case SELE_RSNs:
+    {
+      CWordMatchOptions options;
+
+      WordMatchOptionsConfigAlphaList(&options, wildcard[0], ignore_case);
+
+      table_a = i_table + cNDummyAtoms;
+      base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
+        table_a = i_table + cNDummyAtoms;
+        base_0_sele_a = &base[0].sele[cNDummyAtoms];
+
+        for(a = cNDummyAtoms; a < I_NAtom; a++) {
+          auto& resn = i_obj[table_a->model]->AtomInfo[table_a->atom].resn;
+          if((*base_0_sele_a =
+              WordMatcherMatchAlpha(matcher, LexStr(G, resn))))
+            c++;
+          table_a++;
+          base_0_sele_a++;
+        }
+        WordMatcherFree(matcher);
+      }
+    }
+    break;
+  case SELE_SELs:
+    {
+      const char *word = base[1].text();
+      WordType activeselename = "";
+      int enabled_only = false;
+      CWordMatchOptions options;
+
+      if(word[0] == '?') {
+        word++;
+        if(word[0] == '?') {
+          enabled_only = true;
+          word++;
+        }
+      }
+      WordMatchOptionsConfigAlpha(&options, wildcard[0], ignore_case);
+
+      if((matcher = WordMatcherNew(G, word, &options, false))) {
+
+        SelectorWordType *list = I->Name;
+        int idx = 0;
+
+        for(a = 0; a < I_NAtom; a++)    /* zero out first before iterating through selections */
+          base[0].sele[a] = false;
+
+        while(list[idx][0]) {
+          if(WordMatcherMatchAlpha(matcher, list[idx])) {
+            if((idx >= 0) &&
+               ((!enabled_only) ||
+                ExecutiveGetActiveSeleName(G, list[idx], false, false))) {
+              MemberType *I_Member = I->Member;
+              sele = I->Info[idx].ID;
+              for(a = cNDummyAtoms; a < I_NAtom; a++) {
+                s = i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].selEntry;
+                while(s) {
+                  if(I_Member[s].selection == sele) {
+                    if(!base[0].sele[a]) {
+                      base[0].sele[a] = I_Member[s].tag;
+                      c++;
+                    }
+                  }
+                  s = I_Member[s].next;
+                }
+              }
+            }
+          }
+          idx++;
+        }
+        WordMatcherFree(matcher);
+
+        /* must also allow for group name pattern matches */
+
+        {
+          int group_list_id;
+          if((group_list_id = ExecutiveGetExpandedGroupListFromPattern(G, word))) {
+            int last_was_member = false;
+            last_obj = NULL;
+            for(a = cNDummyAtoms; a < I_NAtom; a++) {
+              if(last_obj != i_obj[i_table[a].model]) {
+                last_obj = i_obj[i_table[a].model];
+                last_was_member = ExecutiveCheckGroupMembership(G,
+                                                                group_list_id,
+                                                                (CObject *) last_obj);
+              }
+              if(last_was_member && !base[0].sele[a]) {
+                base[0].sele[a] = true;
+                c++;
+              }
+            }
+          }
+          ExecutiveFreeGroupList(G, group_list_id);
+        }
+
+      } else if((!enabled_only) || ExecutiveGetActiveSeleName(G, activeselename, false, false)) {
+        if (activeselename[0]) {
+          // TODO not sure if this is intentional. If the active selection is
+          // "foo", then the expression "??bar" will evaluate to "foo". I assume
+          // the intention was to evaluate to the empty selection if "bar" is
+          // not active, and to "bar" in case it's active.
+          // Used with cmd.select(..., merge=2)
+          base[1].m_text = activeselename;
+          word = base[1].text();
+        }
+        sele = SelectGetNameOffset(G, word, 1, ignore_case);
+        if(sele >= 0) {
+          MemberType *I_Member = I->Member;
+          sele = I->Info[sele].ID;
+          for(a = cNDummyAtoms; a < I_NAtom; a++) {
+            base[0].sele[a] = false;
+            s = i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].selEntry;
+            while(s) {
+              if(I_Member[s].selection == sele) {
+                base[0].sele[a] = I_Member[s].tag;
+                c++;
+              }
+              s = I_Member[s].next;
+            }
+          }
+        } else {
+          int group_list_id;
+          if((group_list_id = ExecutiveGetExpandedGroupList(G, word))) {
+            int last_was_member = false;
+            last_obj = NULL;
+            for(a = 0; a < I_NAtom; a++)        /* zero out first before iterating through selections */
+              base[0].sele[a] = false;
+            for(a = cNDummyAtoms; a < I_NAtom; a++) {
+              if(last_obj != i_obj[i_table[a].model]) {
+                last_obj = i_obj[i_table[a].model];
+                last_was_member = ExecutiveCheckGroupMembership(G,
+                                                                group_list_id,
+                                                                (CObject *) last_obj);
+              }
+              if((base[0].sele[a] = last_was_member))
+                c++;
+            }
+            ExecutiveFreeGroupList(G, group_list_id);
+          } else if(base[1].m_text[0] == '?') {   /* undefined ?sele allowed */
+            for(a = cNDummyAtoms; a < I_NAtom; a++)
+              base[0].sele[a] = false;
+          } else {
+	      PRINTFB(G, FB_Selector, FB_Errors)
+		"Selector-Error: Invalid selection name \"%s\".\n", word ENDFB(G);
+            ok = false;
+          }
+        }
+      }
+    }
+    break;
+  case SELE_MODs:
+
+    /* need to change this to handle wildcarded model names */
+
+    /* first, trim off and record the atom index if one exists */
+
+    index = -1;
+    auto pos = base[1].m_text.find('`');
+    if (pos != std::string::npos) {
+      const char* np = base[1].text() + pos;
+      if(sscanf(np + 1, "%d", &index) != 1)
+        index = -1;
+      else
+        index--;
+      base[1].m_text.resize(pos);
+    }
+    model = 0;
+
+    {
+      CWordMatchOptions options;
+      WordMatchOptionsConfigAlpha(&options, wildcard[0], ignore_case);
+
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, false))) {
+
+        int obj_matches = false;
+
+        for(a = 0; a < I_NAtom; a++)    /* zero out first before iterating through selections */
+          base[0].sele[a] = false;
+
+        table_a = i_table + cNDummyAtoms;
+        base_0_sele_a = &base[0].sele[cNDummyAtoms];
+        last_obj = NULL;
+        for(a = cNDummyAtoms; a < I_NAtom; a++) {
+          obj = i_obj[table_a->model];
+          if(obj != last_obj) {
+
+            obj_matches = WordMatcherMatchAlpha(matcher, i_obj[table_a->model]->Name);
+            last_obj = obj;
+          }
+          if(obj_matches) {
+            if((index < 0) || (table_a->atom == index)) {
+              *base_0_sele_a = true;
+              c++;
+            }
+          }
+          table_a++;
+          base_0_sele_a++;
+        }
+        WordMatcherFree(matcher);
+      } else {
+
+        obj = (ObjectMolecule *) ExecutiveFindObjectByName(G, base[1].text());
+        if(obj) {
+          for(a = cNDummyModels; a < I->NModel; a++)
+            if(i_obj[a] == obj) {
+              model = a + 1;
+              break;
+            }
+        }
+        if(!model)
+          if(sscanf(base[1].text(), "%i", &model) == 1) {
+            if(model <= 0)
+              model = 0;
+            else if(model > I->NModel)
+              model = 0;
+            else if(!i_obj[model])
+              model = 0;
+          }
+        if(model) {
+          model--;
+          if(index >= 0) {
+            for(a = cNDummyAtoms; a < I_NAtom; a++) {
+              if(i_table[a].model == model)
+                if(i_table[a].atom == index) {
+                  base[0].sele[a] = true;
+                  c++;
+                } else {
+                  base[0].sele[a] = false;
+              } else
+                base[0].sele[a] = false;
+            }
+          } else {
+            for(a = cNDummyAtoms; a < I_NAtom; a++) {
+              if(i_table[a].model == model) {
+                base[0].sele[a] = true;
+                c++;
+              } else
+                base[0].sele[a] = false;
+            }
+          }
+        } else {
+          PRINTFB(G, FB_Selector, FB_Errors)
+            " Selector-Error: invalid model \"%s\".\n", base[1].text() ENDFB(G);
+          ok = false;
+        }
+      }
+    }
+    break;
+  }
+  PRINTFD(G, FB_Selector)
+    " %s:  %d atoms selected.\n", __func__, c ENDFD;
+  return (ok);
+}
+
+
+/*========================================================================*/
+static int SelectorSelect2(PyMOLGlobals * G, EvalElem * base, int state)
+{
+  int a;
+  int c = 0;
+  int ok = true;
+  int oper;
+  float comp1;
+  int exact;
+  int ignore_case = SettingGetGlobal_b(G, cSetting_ignore_case);
+
+  AtomInfoType *at1;
+  CSelector *I = G->Selector;
+  base->type = STYP_LIST;
+  base->sele_calloc(I->NAtom);
+  base->sele_err_chk_ptr(G);
+  switch (base->code) {
+  case SELE_XVLx:
+  case SELE_YVLx:
+  case SELE_ZVLx:
+    oper = WordKey(G, AtOper, base[1].text(), 4, ignore_case, &exact);
+    switch (oper) {
+    case SCMP_GTHN:
+    case SCMP_LTHN:
+    case SCMP_EQAL:
+      if(sscanf(base[2].text(), "%f", &comp1) != 1)
+        ok = ErrMessage(G, "Selector", "Invalid Number");
+      break;
+    default:
+      ok = ErrMessage(G, "Selector", "Invalid Operator.");
+      break;
+    }
+    if(ok) {
+      ObjectMolecule *obj;
+      CoordSet *cs;
+      int at, idx, s, s0 = 0, sN = I->NCSet;
+
+      if(state != -1) {
+        s0 = (state < -1) ? SceneGetState(G) : state;
+        sN = s0 + 1;
+      }
+
+      for(a = cNDummyAtoms; a < I->NAtom; a++)
+        base[0].sele[a] = false;
+
+      for(s = s0; s < sN; s++) {
+        for(a = cNDummyAtoms; a < I->NAtom; a++) {
+          if(base[0].sele[a])
+            continue;
+
+          obj = I->Obj[I->Table[a].model];
+          if(s >= obj->NCSet)
+            continue;
+
+          at = I->Table[a].atom;
+          cs = obj->CSet[s];
+          idx = cs->atmToIdx(at);
+          if(idx < 0)
+            continue;
+
+          idx *= 3;
+          switch (base->code) {
+          case SELE_ZVLx:
+            idx++;
+          case SELE_YVLx:
+            idx++;
+          }
+
+          base[0].sele[a] = fcmp(cs->Coord[idx], comp1, oper);
+        }
+      }
+    }
+    break;
+  case SELE_PCHx:
+  case SELE_FCHx:
+  case SELE_BVLx:
+  case SELE_QVLx:
+    oper = WordKey(G, AtOper, base[1].text(), 4, ignore_case, &exact);
+    if(!oper)
+      ok = ErrMessage(G, "Selector", "Invalid Operator.");
+    if(ok) {
+      switch (oper) {
+      case SCMP_GTHN:
+      case SCMP_LTHN:
+      case SCMP_EQAL:
+        if(sscanf(base[2].text(), "%f", &comp1) != 1)
+          ok = ErrMessage(G, "Selector", "Invalid Number");
+        break;
+      }
+      if(ok) {
+        switch (oper) {
+        case SCMP_GTHN:
+          switch (base->code) {
+          case SELE_BVLx:
+            for(a = cNDummyAtoms; a < I->NAtom; a++) {
+              at1 = &I->Obj[I->Table[a].model]->AtomInfo[I->Table[a].atom];
+              if(at1->b > comp1) {
+                base[0].sele[a] = true;
+                c++;
+              } else {
+                base[0].sele[a] = false;
+              }
+            }
+            break;
+          case SELE_QVLx:
+            for(a = cNDummyAtoms; a < I->NAtom; a++) {
+              at1 = &I->Obj[I->Table[a].model]->AtomInfo[I->Table[a].atom];
+              if(at1->q > comp1) {
+                base[0].sele[a] = true;
+                c++;
+              } else {
+                base[0].sele[a] = false;
+              }
+            }
+            break;
+          case SELE_PCHx:
+            for(a = cNDummyAtoms; a < I->NAtom; a++) {
+              at1 = &I->Obj[I->Table[a].model]->AtomInfo[I->Table[a].atom];
+              if(at1->partialCharge > comp1) {
+                base[0].sele[a] = true;
+                c++;
+              } else {
+                base[0].sele[a] = false;
+              }
+            }
+            break;
+          case SELE_FCHx:
+            for(a = cNDummyAtoms; a < I->NAtom; a++) {
+              at1 = &I->Obj[I->Table[a].model]->AtomInfo[I->Table[a].atom];
+              if(at1->formalCharge > comp1) {
+                base[0].sele[a] = true;
+                c++;
+              } else {
+                base[0].sele[a] = false;
+              }
+            }
+            break;
+          }
+          break;
+        case SCMP_LTHN:
+          switch (base->code) {
+          case SELE_BVLx:
+            for(a = cNDummyAtoms; a < I->NAtom; a++) {
+              at1 = &I->Obj[I->Table[a].model]->AtomInfo[I->Table[a].atom];
+              if(at1->b < comp1) {
+                base[0].sele[a] = true;
+                c++;
+              } else {
+                base[0].sele[a] = false;
+              }
+            }
+            break;
+          case SELE_QVLx:
+            for(a = cNDummyAtoms; a < I->NAtom; a++) {
+              at1 = &I->Obj[I->Table[a].model]->AtomInfo[I->Table[a].atom];
+              if(at1->q < comp1) {
+                base[0].sele[a] = true;
+                c++;
+              } else {
+                base[0].sele[a] = false;
+              }
+            }
+            break;
+          case SELE_PCHx:
+            for(a = cNDummyAtoms; a < I->NAtom; a++) {
+              at1 = &I->Obj[I->Table[a].model]->AtomInfo[I->Table[a].atom];
+              if(at1->partialCharge < comp1) {
+                base[0].sele[a] = true;
+                c++;
+              } else {
+                base[0].sele[a] = false;
+              }
+            }
+            break;
+          case SELE_FCHx:
+            for(a = cNDummyAtoms; a < I->NAtom; a++) {
+              at1 = &I->Obj[I->Table[a].model]->AtomInfo[I->Table[a].atom];
+              if(at1->formalCharge < comp1) {
+                base[0].sele[a] = true;
+                c++;
+              } else {
+                base[0].sele[a] = false;
+              }
+            }
+            break;
+          }
+          break;
+        case SCMP_EQAL:
+          switch (base->code) {
+          case SELE_BVLx:
+            for(a = cNDummyAtoms; a < I->NAtom; a++) {
+              at1 = &I->Obj[I->Table[a].model]->AtomInfo[I->Table[a].atom];
+              if(fabs(at1->b - comp1) < R_SMALL4) {
+                base[0].sele[a] = true;
+                c++;
+              } else {
+                base[0].sele[a] = false;
+              }
+            }
+            break;
+          case SELE_QVLx:
+            for(a = cNDummyAtoms; a < I->NAtom; a++) {
+              at1 = &I->Obj[I->Table[a].model]->AtomInfo[I->Table[a].atom];
+              if(fabs(at1->q - comp1) < R_SMALL4) {
+                base[0].sele[a] = true;
+                c++;
+              } else {
+                base[0].sele[a] = false;
+              }
+            }
+            break;
+          case SELE_PCHx:
+            for(a = cNDummyAtoms; a < I->NAtom; a++) {
+              at1 = &I->Obj[I->Table[a].model]->AtomInfo[I->Table[a].atom];
+              if(fabs(at1->partialCharge - comp1) < R_SMALL4) {
+                base[0].sele[a] = true;
+                c++;
+              } else {
+                base[0].sele[a] = false;
+              }
+            }
+            break;
+          case SELE_FCHx:
+            for(a = cNDummyAtoms; a < I->NAtom; a++) {
+              at1 = &I->Obj[I->Table[a].model]->AtomInfo[I->Table[a].atom];
+              if(fabs(at1->formalCharge - comp1) < R_SMALL4) {
+                base[0].sele[a] = true;
+                c++;
+              } else {
+                base[0].sele[a] = false;
+              }
+            }
+            break;
+          }
+          break;
+        }
+        break;
+      }
+    }
+  }
+
+  PRINTFD(G, FB_Selector)
+    " %s: %d atoms selected.\n", __func__, c ENDFD;
+  return (ok);
+}
+
+/*========================================================================*/
+static int SelectorSelect3(PyMOLGlobals * G, EvalElem * base, int state)
+{
+  switch (base->code) {
+  case SELE_PROP:
+    ErrMessage(G, "Selector", "properties (p.) not supported in Open-Source PyMOL");
+    return false;
+  }
+  return true;
+ok_except1:
+  return false;
+}
+
+/*========================================================================*/
+
+/*
+ * Ring finder subroutine
+ */
+class SelectorRingFinder {
+  CSelector * I;
+  EvalElem * base;
+  ObjectMolecule * obj;
+  std::vector<int> indices;
+
+  void recursion(int atm, int depth) {
+    int atm_neighbor, offset, j;
+
+    indices[depth] = atm;
+
+    ITERNEIGHBORATOMS(obj->Neighbor, atm, atm_neighbor, j) {
+      // check bond order
+      if (obj->Bond[obj->Neighbor[j + 1]].order < 1)
+        continue;
+
+      // check if closing a ring of size >= 3
+      if (depth > 1 && atm_neighbor == indices[0]) {
+        // found ring, add it to the selection
+        for (int i = 0; i <= depth; ++i)
+          if ((offset = SelectorGetObjAtmOffset(I, obj, indices[i])) >= 0)
+            base->sele[offset] = 1;
+      } else if (depth < indices.size() - 1) {
+        // check for undesired ring with start != 0
+        int i = depth;
+        while ((--i) >= 0)
+          if (atm_neighbor == indices[i])
+            break; // stop recursion
+        if (i == -1) {
+          recursion(atm_neighbor, depth + 1);
+        }
+      }
+    }
+  }
+
+public:
+  SelectorRingFinder(CSelector * I, EvalElem * base, int maxringsize=7) :
+    I(I), base(base), obj(NULL), indices(maxringsize) {}
+
+  /*
+   * Does a depth-first search for all paths of length in range [3, maxringsize],
+   * which lead back to `atm` and don't visit any atom twice.
+   *
+   * Modifies base[0].sele
+   */
+  void apply(ObjectMolecule * obj_, int atm) {
+    if (obj != obj_) {
+      obj = obj_;
+      ObjectMoleculeUpdateNeighbors(obj);
+    }
+
+    recursion(atm, 0);
+  }
+};
+
+/*========================================================================*/
+static int SelectorLogic1(PyMOLGlobals * G, EvalElem * inp_base, int state)
+{
+  /* some cases in this function still need to be optimized
+     for performance (see BYR1 for example) */
+
+  CSelector *I = G->Selector;
+  int a, b, tag;
+  int c = 0;
+  int flag;
+  EvalElem *base = inp_base;
+  AtomInfoType *at1, *at2;
+  TableRec *i_table = I->Table, *table_a;
+  ObjectMolecule **i_obj = I->Obj;
+  int n_atom = I->NAtom;
+  int ignore_case = SettingGetGlobal_b(G, cSetting_ignore_case);
+  int n;
+  int a0, a1, a2;
+  ObjectMolecule *lastObj = NULL;
+
+  base[0].sele = std::move(base[1].sele);
+  base[0].type = STYP_LIST;
+  switch (base->code) {
+  case SELE_NOT1:
+    {
+      int *base_0_sele_a;
+
+      base_0_sele_a = base[0].sele_data();
+      for(a = 0; a < n_atom; a++) {
+        if((*base_0_sele_a = !*base_0_sele_a))
+          c++;
+        base_0_sele_a++;
+      }
+    }
+    break;
+  case SELE_RING:
+    {
+      std::vector<bool> selemask(base[0].sele_data(), base[0].sele_data() + n_atom);
+      SelectorRingFinder ringfinder(I, base);
+
+      std::fill_n(base[0].sele_data(), n_atom, 0);
+
+      for (SelectorAtomIterator iter(I); iter.next();) {
+        if (selemask[iter.a])
+          ringfinder.apply(iter.obj, iter.getAtm());
+      }
+    }
+    break;
+  case SELE_NGH1:
+    base[1].sele = std::move(base[0].sele);
+    base[0].sele_calloc(n_atom);
+
+    table_a = i_table + cNDummyAtoms;
+    for(a = cNDummyAtoms; a < n_atom; a++) {
+      if((tag = base[1].sele[a])) {
+        if(i_obj[table_a->model] != lastObj) {
+          lastObj = i_obj[table_a->model];
+          ObjectMoleculeUpdateNeighbors(lastObj);
+        }
+        a0 = table_a->atom;
+        n = lastObj->Neighbor[a0];
+        n++;
+        while(1) {
+          a1 = lastObj->Neighbor[n];
+          if(a1 < 0)
+            break;
+          if((a2 = SelectorGetObjAtmOffset(I, lastObj, a1)) >= 0) {
+            if(!base[1].sele[a2])
+              base[0].sele[a2] = tag;
+          }
+          n += 2;
+        }
+      }
+      table_a++;
+    }
+    base[1].sele_free();
+    break;
+  case SELE_BON1:
+    base[1].sele = std::move(base[0].sele);
+    base[0].sele_calloc(n_atom);
+    table_a = i_table + cNDummyAtoms;
+    for(a = cNDummyAtoms; a < n_atom; a++) {
+      if((tag = base[1].sele[a])) {
+        if(i_obj[table_a->model] != lastObj) {
+          lastObj = i_obj[table_a->model];
+          ObjectMoleculeUpdateNeighbors(lastObj);
+        }
+        a0 = table_a->atom;
+        n = lastObj->Neighbor[a0];
+        n++;
+        while(1) {
+          a1 = lastObj->Neighbor[n];
+          if(a1 < 0)
+            break;
+          if((a2 = SelectorGetObjAtmOffset(I, lastObj, a1)) >= 0) {
+            if(!base[0].sele[a2])
+              base[0].sele[a2] = 1;
+            n += 2;
+          }
+        }
+      }
+      table_a++;
+    }
+    base[1].sele_free();
+    break;
+  case SELE_BYO1:
+    base[1].sele = std::move(base[0].sele);
+    base[0].sele_calloc(n_atom);
+    for(a = cNDummyAtoms; a < n_atom; a++) {
+      if(base[1].sele[a]) {
+        if(i_obj[i_table[a].model] != lastObj) {
+          lastObj = i_obj[i_table[a].model];
+          b = a;
+          while(b >= 0) {
+            if(i_obj[i_table[b].model] != lastObj)
+              break;
+            base[0].sele[b] = 1;
+            b--;
+          }
+          b = a + 1;
+          while(b < n_atom) {
+            if(i_obj[i_table[b].model] != lastObj)
+              break;
+            base[0].sele[b] = 1;
+            b++;
+          }
+        }
+      }
+    }
+    base[1].sele_free();
+    break;
+  case SELE_BYR1:              /* ASSUMES atoms are sorted & grouped by residue */
+  case SELE_CAS1:
+    {
+      int *base_0_sele = base[0].sele_data();
+      int break_atom = -1;
+      int last_tag = 0;
+      table_a = i_table + cNDummyAtoms;
+      for(a = cNDummyAtoms; a < n_atom; a++) {
+        if((tag = base_0_sele[a]) && ((a >= break_atom) || (base_0_sele[a] != last_tag))) {
+          at1 = &i_obj[table_a->model]->AtomInfo[table_a->atom];
+          b = a - 1;
+          while(b >= 0) {
+            if(!base_0_sele[b]) {
+              flag = false;
+              if(table_a->model == i_table[b].model) {
+                at2 = &i_obj[i_table[b].model]->AtomInfo[i_table[b].atom];
+                if(AtomInfoSameResidue(G, at1, at2)) {
+                            base_0_sele[b] = tag;
+                            c++;
+                            flag = 1;
+                          }
+              }
+              if(!flag) {
+                break;
+              }
+            }
+            b--;
+          }
+          b = a + 1;
+          while(b < n_atom) {
+            if(!base_0_sele[b]) {
+              flag = false;
+              if(table_a->model == i_table[b].model) {
+                at2 = &i_obj[i_table[b].model]->AtomInfo[i_table[b].atom];
+                if(AtomInfoSameResidue(G, at1, at2)) {
+                            base_0_sele[b] = tag;
+                            c++;
+                            flag = 1;
+                          }
+              }
+              if(!flag) {
+                break_atom = b - 1;
+                last_tag = tag;
+                break;
+              }
+            }
+            b++;
+          }
+        }
+        table_a++;
+      }
+      if(base->code == SELE_CAS1) {
+        c = 0;
+        table_a = i_table + cNDummyAtoms;
+        for(a = cNDummyAtoms; a < n_atom; a++) {
+          if(base_0_sele[a]) {
+            base_0_sele[a] = false;
+
+            if(i_obj[table_a->model]->AtomInfo[table_a->atom].protons == cAN_C)
+              if(WordMatchExact(G, G->lex_const.CA,
+                                     i_obj[table_a->model]->AtomInfo[table_a->atom].name,
+                                     ignore_case)) {
+                base_0_sele[a] = true;
+                c++;
+              }
+          }
+          table_a++;
+        }
+      }
+    }
+    break;
+  case SELE_BYC1:              /* ASSUMES atoms are sorted & grouped by chain */
+    {
+      int *base_0_sele = base[0].sele_data();
+      int break_atom_high = -1;
+      int break_atom_low = 0;
+      int last_tag = 0;
+      table_a = i_table + cNDummyAtoms;
+      for(a = cNDummyAtoms; a < n_atom; a++) {
+        if((tag = base_0_sele[a])
+           && ((a >= break_atom_high) || (base_0_sele[a] != last_tag))) {
+          if(tag != last_tag)
+            break_atom_low = 0;
+          at1 = &i_obj[table_a->model]->AtomInfo[table_a->atom];
+          b = a - 1;
+          while(b >= break_atom_low) {
+            if(!base_0_sele[b]) {
+              flag = false;
+              if(table_a->model == i_table[b].model) {
+                at2 = &i_obj[i_table[b].model]->AtomInfo[i_table[b].atom];
+                if(at1->chain == at2->chain)
+                  if(at1->segi == at2->segi) {
+                    base_0_sele[b] = tag;
+                    c++;
+                    flag = 1;
+                  }
+              }
+              if(!flag) {
+                break_atom_low = b + 1;
+                break;
+              }
+            }
+            b--;
+          }
+          if(b < 0)
+            break_atom_low = 0;
+          b = a + 1;
+          while(b < n_atom) {
+            if(!base_0_sele[b]) {
+              flag = false;
+              if(table_a->model == i_table[b].model) {
+                at2 = &i_obj[i_table[b].model]->AtomInfo[i_table[b].atom];
+                if(at1->chain == at2->chain)
+                  if(at1->segi == at2->segi) {
+                    base_0_sele[b] = tag;
+                    c++;
+                    flag = 1;
+                  }
+              }
+              if(!flag) {
+                break_atom_high = b - 1;
+                last_tag = tag;
+                break;
+              }
+            }
+            b++;
+          }
+        }
+        table_a++;
+      }
+    }
+    break;
+  case SELE_BYS1:              /* ASSUMES atoms are sorted & grouped by segi */
+    {
+      int *base_0_sele = base[0].sele_data();
+      int break_atom_high = -1;
+      int break_atom_low = 0;
+      int last_tag = 0;
+      table_a = i_table + cNDummyAtoms;
+      for(a = cNDummyAtoms; a < n_atom; a++) {
+        if((tag = base_0_sele[a])
+           && ((a >= break_atom_high) || (base_0_sele[a] != last_tag))) {
+          if(tag != last_tag)
+            break_atom_low = 0;
+          at1 = &i_obj[table_a->model]->AtomInfo[table_a->atom];
+          b = a - 1;
+          while(b >= break_atom_low) {
+            if(!base_0_sele[b]) {
+              flag = false;
+              if(table_a->model == i_table[b].model) {
+                at2 = &i_obj[i_table[b].model]->AtomInfo[i_table[b].atom];
+                if(at1->segi == at2->segi) {
+                  base_0_sele[b] = tag;
+                  c++;
+                  flag = 1;
+                }
+              }
+              if(!flag) {
+                break_atom_low = b + 1;
+                break;
+              }
+            }
+            b--;
+          }
+          b = a + 1;
+          while(b < n_atom) {
+            if(!base_0_sele[b]) {
+              flag = false;
+              if(table_a->model == i_table[b].model) {
+                at2 = &i_obj[i_table[b].model]->AtomInfo[i_table[b].atom];
+                if(at1->segi == at2->segi) {
+                  base_0_sele[b] = tag;
+                  c++;
+                  flag = 1;
+                }
+              }
+              if(!flag) {
+                break_atom_high = b - 1;
+                last_tag = tag;
+                break;
+              }
+            }
+            b++;
+          }
+        }
+        table_a++;
+      }
+    }
+    break;
+  case SELE_BYF1:              /* first, identify all atom by fragment selection */
+    {
+      /* NOTE: this algorithm looks incompatible with selection
+         tags...need to do some more thinking & work... */
+
+      int n_frag = EditorGetNFrag(G);
+
+      base[1].sele = std::move(base[0].sele);
+      base[0].sele_calloc(n_atom);
+
+      if(n_frag) {
+        int a, f, at, s;
+        int *fsele;
+        WordType name;
+        ObjectMolecule *obj;
+
+        fsele = pymol::malloc<int>(n_frag + 1);
+
+        for(f = 0; f < n_frag; f++) {
+          sprintf(name, "%s%1d", cEditorFragPref, f + 1);
+          fsele[f] = SelectorIndexByName(G, name);
+        }
+
+        /* mark atoms by fragment */
+        for(a = 0; a < n_atom; a++) {
+          at = i_table[a].atom;
+          obj = i_obj[i_table[a].model];
+          s = obj->AtomInfo[at].selEntry;
+          for(f = 0; f < n_frag; f++) {
+            if(SelectorIsMember(G, s, fsele[f])) {
+              base[0].sele[a] = f + 1;
+            }
+          }
+        }
+
+        /* mark fragments we keep */
+        for(f = 0; f <= n_frag; f++) {
+          fsele[f] = 0;
+        }
+        for(a = 0; a < n_atom; a++) {
+          int f = base[0].sele[a];
+          if(base[1].sele[a] && f)
+            fsele[f] = 1;
+        }
+
+        /* now set flags */
+        for(a = 0; a < n_atom; a++) {
+          c += (base[0].sele[a] = fsele[base[0].sele[a]]);
+        }
+
+        FreeP(fsele);
+      }
+      base[1].sele_free();
+    }
+    break;
+  case SELE_BYM1:
+    {
+      int s;
+      int c = 0;
+      int a, at, a1, aa;
+      ObjectMolecule *obj, *lastObj = NULL;
+      int *stk;
+      int stkDepth = 0;
+      base[1].sele = std::move(base[0].sele);
+      base[0].sele_calloc(n_atom);
+
+      stk = VLAlloc(int, 50);
+
+      for(a = 0; a < n_atom; a++) {
+        if((tag = base[1].sele[a]) && (!base[0].sele[a])) {
+          VLACheck(stk, int, stkDepth);
+          stk[stkDepth] = a;
+          stkDepth++;
+
+          obj = i_obj[i_table[a].model];
+          if(obj != lastObj) {
+            lastObj = obj;
+            ObjectMoleculeUpdateNeighbors(obj);
+          }
+
+          while(stkDepth) {     /* this will explore a tree */
+            stkDepth--;
+            a = stk[stkDepth];
+            base[0].sele[a] = tag;
+            c++;
+            at = i_table[a].atom;       /* start walk from this location */
+
+            /* add neighbors onto the stack */
+            ITERNEIGHBORATOMS(obj->Neighbor, at, a1, s) {
+              b = obj->Neighbor[s + 1];
+              if (obj->Bond[b].order > 0) {
+                if((aa = SelectorGetObjAtmOffset(I, obj, a1)) >= 0) {
+                  if(!base[0].sele[aa]) {
+                    VLACheck(stk, int, stkDepth);
+                    stk[stkDepth] = aa; /* add index in selector space */
+                    stkDepth++;
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+      base[1].sele_free();
+      VLAFreeP(stk);
+    }
+    break;
+  case SELE_BYX1:              /* by cell */
+    base[1].sele = std::move(base[0].sele);
+    base[0].sele_calloc(n_atom);
+    {
+      ObjectMolecule *obj;
+      CoordSet *cs;
+      int d, n1, at;
+      for(d = 0; d < I->NCSet; d++) {
+        if((state < 0) || (d == state)) {
+          n1 = 0;
+          for(a = 0; a < I->NAtom; a++) {
+            I->Flag1[a] = false;
+            at = I->Table[a].atom;
+            obj = I->Obj[I->Table[a].model];
+            if(d < obj->NCSet)
+              cs = obj->CSet[d];
+            else
+              cs = NULL;
+            if(cs) {
+              CCrystal *cryst = cs->PeriodicBox;
+              if((!cryst) && (obj->Symmetry))
+                cryst = obj->Symmetry->Crystal;
+              if(cryst) {
+                int idx;
+                idx = cs->atmToIdx(at);
+                if(idx >= 0) {
+                  transform33f3f(cryst->RealToFrac, cs->Coord + (3 * idx),
+                                 I->Vertex + 3 * a);
+                  I->Flag1[a] = true;
+                  n1++;
+                }
+              }
+            }
+          }
+          if(n1) {
+            MapType *map = MapNewFlagged(G, -1.1, I->Vertex, I->NAtom, NULL, I->Flag1);
+            if(map) {
+              int e, nCSet;
+              MapSetupExpress(map);
+              nCSet = SelectorGetArrayNCSet(G, base[1].sele, false);
+              for(e = 0; e < nCSet; e++) {
+                if((state < 0) || (e == state)) {
+                  for(a = 0; a < I->NAtom; a++) {
+                    if(base[1].sele[a]) {
+                      at = I->Table[a].atom;
+                      obj = I->Obj[I->Table[a].model];
+                      if(e < obj->NCSet)
+                        cs = obj->CSet[e];
+                      else
+                        cs = NULL;
+                      if(cs) {
+                        CCrystal *cryst = cs->PeriodicBox;
+                        if((!cryst) && (obj->Symmetry))
+                          cryst = obj->Symmetry->Crystal;
+                        if(cryst) {
+                          int idx;
+                          idx = cs->atmToIdx(at);
+                          if(idx >= 0) {
+                            float probe[3], probe_i[3];
+                            int h, i, j, k, l;
+
+                            transform33f3f(cryst->RealToFrac, cs->Coord + (3 * idx),
+                                           probe);
+                            MapLocus(map, probe, &h, &k, &l);
+                            i = *(MapEStart(map, h, k, l));
+                            if(i) {
+                              j = map->EList[i++];
+
+                              probe_i[0] = (int) floor(probe[0]);
+                              probe_i[1] = (int) floor(probe[1]);
+                              probe_i[2] = (int) floor(probe[2]);
+
+                              while(j >= 0) {
+                                if(!base[0].sele[j]) {
+                                  float *tst = I->Vertex + 3 * j;
+                                  base[0].sele[j] = ((probe_i[0] == (int) floor(tst[0]))
+                                                     && (probe_i[1] ==
+                                                         (int) floor(tst[1]))
+                                                     && (probe_i[2] ==
+                                                         (int) floor(tst[2])));
+                                }
+                                j = map->EList[i++];
+                              }
+                            }
+                          }
+                        }
+                      }
+                    }
+                  }
+                }
+              }
+              MapFree(map);
+            }
+          }
+        }
+      }
+    }
+    base[1].sele_free();
+    break;
+  case SELE_FST1:
+    base[1].sele = std::move(base[0].sele);
+    base[0].sele_calloc(n_atom);
+    for(a = cNDummyAtoms; a < n_atom; a++) {
+      if(base[1].sele[a]) {
+        base[0].sele[a] = base[1].sele[a];      /* preserve tag */
+        break;
+      }
+    }
+    base[1].sele_free();
+    break;
+  case SELE_LST1:
+    {
+      int last = -1;
+      base[1].sele = std::move(base[0].sele);
+      base[0].sele_calloc(n_atom);
+      for(a = cNDummyAtoms; a < n_atom; a++) {
+        if(base[1].sele[a]) {
+          last = a;
+        }
+      }
+      if(last >= 0)
+        base[0].sele[last] = base[1].sele[last];        /* preserve tag */
+    }
+    base[1].sele_free();
+    break;
+  }
+  PRINTFD(G, FB_Selector)
+    " %s: %d atoms selected.\n", __func__, c ENDFD;
+  return (1);
+}
+
+
+/*========================================================================*/
+static int SelectorLogic2(PyMOLGlobals * G, EvalElem * base)
+{
+  CSelector *I = G->Selector;
+  int a, b, tag;
+  int c = 0;
+  int ignore_case = SettingGetGlobal_b(G, cSetting_ignore_case);
+  int ignore_case_chain = SettingGetGlobal_b(G, cSetting_ignore_case_chain);
+  int *base_0_sele_a, *base_2_sele_a;
+  TableRec *i_table = I->Table, *table_a, *table_b;
+  ObjectMolecule **i_obj = I->Obj;
+  int n_atom = I->NAtom;
+
+  AtomInfoType *at1, *at2;
+
+  switch (base[1].code) {
+
+  case SELE_OR_2:
+  case SELE_IOR2:
+    {
+      base_0_sele_a = base[0].sele_data();
+      base_2_sele_a = base[2].sele_data();
+
+      for(a = 0; a < n_atom; a++) {
+        if(((*base_0_sele_a) =
+            (((*base_0_sele_a) >
+              (*base_2_sele_a)) ? (*base_0_sele_a) : (*base_2_sele_a)))) {
+          /* use higher tag */
+          c++;
+        }
+        base_0_sele_a++;
+        base_2_sele_a++;
+      }
+    }
+    break;
+  case SELE_AND2:
+
+    base_0_sele_a = base[0].sele_data();
+    base_2_sele_a = base[2].sele_data();
+
+    for(a = 0; a < n_atom; a++) {
+      if((*base_0_sele_a) && (*base_2_sele_a)) {
+        (*base_0_sele_a) =
+          (((*base_0_sele_a) > (*base_2_sele_a)) ? (*base_0_sele_a) : (*base_2_sele_a));
+        /* use higher tag */
+        c++;
+      } else {
+        (*base_0_sele_a) = 0;
+      }
+      base_0_sele_a++;
+      base_2_sele_a++;
+    }
+    break;
+  case SELE_ANT2:
+    base_0_sele_a = base[0].sele_data();
+    base_2_sele_a = base[2].sele_data();
+
+    for(a = 0; a < n_atom; a++) {
+      if((*base_0_sele_a) && !(*base_2_sele_a)) {
+        c++;
+      } else {
+        (*base_0_sele_a) = 0;
+      }
+      base_0_sele_a++;
+      base_2_sele_a++;
+    }
+    break;
+  case SELE_IN_2:
+    {
+      int *base_2_sele_b;
+      base_0_sele_a = &base[0].sele[cNDummyAtoms];
+      table_a = i_table + cNDummyAtoms;
+      for(a = cNDummyAtoms; a < n_atom; a++) {
+        if((tag = *base_0_sele_a)) {
+          at1 = &i_obj[table_a->model]->AtomInfo[table_a->atom];
+          *base_0_sele_a = 0;
+          table_b = i_table + cNDummyAtoms;
+          base_2_sele_b = &base[2].sele[cNDummyAtoms];
+          for(b = cNDummyAtoms; b < n_atom; b++) {
+            if(*base_2_sele_b) {
+              at2 = &i_obj[table_b->model]->AtomInfo[table_b->atom];
+              if(at1->resv == at2->resv)
+                if(WordMatchExact(G, at1->chain, at2->chain, ignore_case_chain))
+                  if(WordMatchExact(G, at1->name, at2->name, ignore_case))
+                    if(WordMatchExact(G, at1->inscode, at2->inscode, ignore_case))
+                      if(WordMatchExact(G, at1->resn, at2->resn, ignore_case))
+                        if(WordMatchExact(G, at1->segi, at2->segi, ignore_case_chain)) {
+                          *base_0_sele_a = tag;
+                          break;
+                        }
+            }
+            base_2_sele_b++;
+            table_b++;
+          }
+        }
+        if(*(base_0_sele_a++))
+          c++;
+        table_a++;
+      }
+    }
+    break;
+  case SELE_LIK2:
+    {
+      int *base_2_sele_b;
+      base_0_sele_a = &base[0].sele[cNDummyAtoms];
+      table_a = i_table + cNDummyAtoms;
+      for(a = cNDummyAtoms; a < n_atom; a++) {
+        if((tag = *base_0_sele_a)) {
+          at1 = &i_obj[table_a->model]->AtomInfo[table_a->atom];
+          *base_0_sele_a = 0;
+          table_b = i_table + cNDummyAtoms;
+          base_2_sele_b = &base[2].sele[cNDummyAtoms];
+          for(b = cNDummyAtoms; b < n_atom; b++) {
+            if(*base_2_sele_b) {
+              at2 = &i_obj[table_b->model]->AtomInfo[table_b->atom];
+              if(at1->resv == at2->resv)
+                if(WordMatchExact(G, at1->name, at2->name, ignore_case))
+                  if(WordMatchExact(G, at1->inscode, at2->inscode, ignore_case)) {
+                    *base_0_sele_a = tag;
+                    break;
+                  }
+            }
+            base_2_sele_b++;
+            table_b++;
+          }
+        }
+        if(*(base_0_sele_a++))
+          c++;
+        table_a++;
+      }
+    }
+    break;
+  }
+  base[2].sele_free();
+  PRINTFD(G, FB_Selector)
+    " %s: %d atoms selected.\n", __func__, c ENDFD;
+  return (1);
+}
+
+
+/*========================================================================*/
+int SelectorOperator22(PyMOLGlobals * G, EvalElem * base, int state)
+{
+  int c = 0;
+  int a, d, e;
+  CSelector *I = G->Selector;
+  ObjectMolecule *obj;
+
+  float dist;
+  float *v2;
+  CoordSet *cs;
+  int ok = true;
+  int nCSet;
+  MapType *map;
+  int i, j, h, k, l;
+  int n1, at, idx;
+  int code = base[1].code;
+
+  if(state < 0) {
+    switch (state) {
+    case -2:
+    case -3:
+      state = SceneGetState(G);
+      break;
+    }
+  }
+
+  switch (code) {
+  case SELE_WIT_:
+  case SELE_BEY_:
+  case SELE_NTO_:
+    if(!sscanf(base[2].text(), "%f", &dist))
+      ok = ErrMessage(G, "Selector", "Invalid distance.");
+    if(ok) {
+      if(dist < 0.0)
+        dist = 0.0;
+
+      /* copy starting mask */
+      for(a = 0; a < I->NAtom; a++) {
+        I->Flag2[a] = base[0].sele[a];
+        base[0].sele[a] = false;
+      }
+
+      for(d = 0; d < I->NCSet; d++) {
+        if((state < 0) || (d == state)) {
+          n1 = 0;
+          for(a = 0; a < I->NAtom; a++) {
+            I->Flag1[a] = false;
+            at = I->Table[a].atom;
+            obj = I->Obj[I->Table[a].model];
+            if(d < obj->NCSet)
+              cs = obj->CSet[d];
+            else
+              cs = NULL;
+            if(cs) {
+              if(CoordSetGetAtomVertex(cs, at, I->Vertex + 3 * a)) {
+                I->Flag1[a] = true;
+                n1++;
+              }
+            }
+          }
+          if(n1) {
+            map = MapNewFlagged(G, -dist, I->Vertex, I->NAtom, NULL, I->Flag1);
+            if(map) {
+              ok &= MapSetupExpress(map);
+              nCSet = SelectorGetArrayNCSet(G, base[4].sele, false);
+              for(e = 0; ok && e < nCSet; e++) {
+                if((state < 0) || (e == state)) {
+                  for(a = 0; a < I->NAtom; a++) {
+                    if(base[4].sele[a]) {
+                      at = I->Table[a].atom;
+                      obj = I->Obj[I->Table[a].model];
+                      if(e < obj->NCSet)
+                        cs = obj->CSet[e];
+                      else
+                        cs = NULL;
+                      if(cs) {
+                        idx = cs->atmToIdx(at);
+                        if(idx >= 0) {
+                          v2 = cs->Coord + (3 * idx);
+                          MapLocus(map, v2, &h, &k, &l);
+                          i = *(MapEStart(map, h, k, l));
+                          if(i) {
+                            j = map->EList[i++];
+
+                            while(j >= 0) {
+                              if(!base[0].sele[j])
+                                if(I->Flag2[j])
+                                  if(within3f(I->Vertex + 3 * j, v2, dist)) {
+                                    if((code != SELE_NTO_) || (!base[4].sele[j]))
+                                      base[0].sele[j] = true;
+                                  }
+                              j = map->EList[i++];
+                            }
+                          }
+                        }
+                      }
+                    }
+                  }
+                }
+              }
+              MapFree(map);
+            }
+          }
+        }
+      }
+      if(code == SELE_BEY_) {
+        for(a = 0; a < I->NAtom; a++) {
+          if(I->Flag2[a])
+            base[0].sele[a] = !base[0].sele[a];
+        }
+      }
+      for(a = cNDummyAtoms; a < I->NAtom; a++)
+        if(base[0].sele[a])
+          c++;
+    }
+    break;
+  }
+  base[4].sele_free();
+  PRINTFD(G, FB_Selector)
+    " %s: %d atoms selected.\n", __func__, c ENDFD;
+  return (1);
+}
+
+/**
+ * Removes matching quotes from a string, at string start as well as after word
+ * list separators ("+" and ","). Does not consider backslash escaping.
+ *
+ * Examples (not sure if all of these are intentional):
+ * @verbatim
+   "foo bar" -> foo bar
+   'foo bar' -> foo bar
+   "foo"+'bar' -> foo+bar
+   "foo bar\" -> foo bar\       # backslash has no escape function
+   "foo" "bar" -> foo "bar"     # second pair of quotes not after separator
+   foo''+''bar -> foo''+bar     # first pair of quotes not after separator
+   "foo"bar" -> foobar"         # third quote unmatched
+   foo'+'bar -> foo'+'bar       # no matching quotes after separator
+   @endverbatim
+ */
+static void remove_quotes(std::string& str)
+{
+  /* nasty */
+
+  char *st = &str[0];
+  char *p, *q;
+  char *quote_start = NULL;
+  char active_quote = 0;
+  p = st;
+  q = st;
+
+  while(*p) {
+    if(((*p) == 34) || ((*p) == 39)) {
+      if(quote_start && (active_quote == *p)) { /* eliminate quotes... */
+        while(quote_start < (q - 1)) {
+          *(quote_start) = *(quote_start + 1);
+          quote_start++;
+        }
+        q--;
+        quote_start = NULL;
+        p++;
+        continue;
+      } else if(quote_start) {
+      } else {
+        if(p == st) {           /* at start => real quote */
+          quote_start = q;
+          active_quote = *p;
+        } else if((*(p - 1) == '+') || (*(p - 1) == ',')) {     /* after separator => real quote */
+          quote_start = q;
+          active_quote = *p;
+        }
+      }
+    }
+    if (q < p) {
+      *q = *p;
+    }
+    ++q;
+    ++p;
+  }
+  if (q < p) {
+    str.resize(q - st);
+  }
+}
+
+#define STACK_PUSH_VALUE(value) { \
+  depth++; \
+  VecCheck(Stack, depth); \
+  e = Stack.data() + depth; \
+  e->level = (level << 4) + 1; \
+  e->imp_op_level = (imp_op_level << 4) + 1; \
+  imp_op_level = level; \
+  e->type = STYP_VALU; \
+  e->m_text = value; \
+  remove_quotes(e->m_text); \
+}
+
+#define STACK_PUSH_OPERATION(ocode) { \
+  depth++; \
+  VecCheck(Stack, depth); \
+  e = Stack.data() + depth; \
+  e->code = ocode; \
+  e->level = (level << 4) + ((e->code & 0xF0) >> 4); \
+  e->imp_op_level = (imp_op_level << 4) + 1; \
+  imp_op_level = level; \
+  e->type = (e->code & 0xF); \
+}
+
+/*========================================================================*/
+sele_array_t SelectorEvaluate(PyMOLGlobals* G,
+    std::vector<std::string>& word,
+    int state, int quiet)
+{
+  int level = 0, imp_op_level = 0;
+  int depth = 0;
+  int a, b, c = 0;
+  int ok = true;
+  unsigned int code = 0;
+  int valueFlag = 0;            /* are we expecting? */
+  int opFlag, maxLevel;
+  int totDepth = 0;
+  int exact = 0;
+
+  int ignore_case = SettingGetGlobal_b(G, cSetting_ignore_case);
+  /* CFGs can efficiently be parsed by stacks; use a clean stack w/space
+   * for 10 (was: 100) elements */
+  EvalElem *e;
+  auto Stack = std::vector<EvalElem>(10);
+
+  /* converts all keywords into code, adds them into a operation list */
+  while(ok && c < word.size()) {
+    if(word[c][0] == '#') {
+      if((!valueFlag) && (!level)) {
+        word.resize(c);         /* terminate selection if we encounter a comment */
+        break;
+      }
+    }
+    switch (word[c][0]) {
+    case 0:
+      break;
+    case '(':
+      /* increase stack depth on open parens: (selection ((and token) blah)) */
+      if(valueFlag)
+        ok = ErrMessage(G, "Selector", "Misplaced (.");
+      if(ok)
+        level++;
+      break;
+    case ')':
+      /* decrease stack depth */
+      if(valueFlag)
+        ok = ErrMessage(G, "Selector", "Misplaced ).");
+      if(ok) {
+        level--;
+        if(level < 0)
+          ok = ErrMessage(G, "Selector", "Syntax error.");
+        else
+          imp_op_level = level;
+      }
+      if(ok && depth)
+        Stack[depth].level--;
+      break;
+    default:
+      if(valueFlag > 0) {       /* standard operand */
+        STACK_PUSH_VALUE(word[c]);
+        valueFlag--;
+      } else if(valueFlag < 0) {        /* operation parameter i.e. around X<-- */
+        depth++;
+        VecCheck(Stack, depth);
+        e = Stack.data() + depth;
+        e->level = (level << 4) + 1;
+        e->imp_op_level = (imp_op_level << 4) + 1;
+        imp_op_level = level;
+        e->type = STYP_PVAL;
+        e->m_text = word[c];
+        valueFlag++;
+      } else {                  /* possible keyword... */
+        code = WordKey(G, Keyword, word[c].c_str(), 4, ignore_case, &exact);
+        if(!code) {
+          b = word[c].size() - 1;
+          if((b > 2) && (word[c][b] == ';')) {
+            /* kludge to accomodate unnec. ';' usage */
+            word[c].resize(b);
+            code = WordKey(G, Keyword, word[c].c_str(), 4, ignore_case, &exact);
+          } else if(!word[c].compare(0, 2, "p.")) {
+            // kludge to parse p.propertyname without space after p.
+            code = SELE_PROP;
+            exact = 1;
+            word[c].erase(0, 2);
+            c--;
+          }
+        }
+        PRINTFD(G, FB_Selector)
+          " Selector: code %x\n", code ENDFD;
+        if((code > 0) && (!exact))
+          if(SelectorIndexByName(G, word[c].c_str()) >= 0)
+            code = 0;           /* favor selections over partial keyword matches */
+        if(code) {
+          /* this is a known operation */
+          STACK_PUSH_OPERATION(code);
+          switch (e->type) {
+          case STYP_SEL0:
+            valueFlag = 0;
+            break;
+          case STYP_SEL1:
+            valueFlag = 1;
+            break;
+          case STYP_SEL2:
+            valueFlag = 2;
+            break;
+          case STYP_SEL3:
+            valueFlag = 3;
+            break;
+          case STYP_OPR1:
+            valueFlag = 0;
+            break;
+          case STYP_OPR2:
+            valueFlag = 0;
+            break;
+          case STYP_PRP1:
+            valueFlag = -1;
+            break;
+          case STYP_OP22:
+            valueFlag = -2;
+            break;
+          }
+        } else {
+          if((a = std::count(word[c].begin(), word[c].end(),
+                  '/'))) { /* handle slash notation */
+            if(a > 5) {
+              ok = ErrMessage(G, "Selector", "too many slashes in macro");
+              break;
+            }
+
+            // macro codes (some special cases apply! see code below)
+            const int macrocodes[] = {SELE_SELs, SELE_SEGs, SELE_CHNs, SELE_RSNs, SELE_NAMs};
+
+            // two code/value pairs to support resn`resi and name`alt
+            int codes[] = {0, 0, 0}; // null-terminated
+            char * values[2];
+
+            std::string tmpKW = word[c];
+            char* q = &tmpKW[0];
+
+            // if macro starts with "/" then read from left, otherwise
+            // read from right
+            if(*q == '/') {
+              a = 4;
+              q++;
+            }
+
+            // loop over macro elements
+            for(b = 0; q && *q; a--) {
+              values[0] = q;
+
+              // null-terminate current element
+              if((q = strchr(q, '/')))
+                *(q++) = '\0';
+
+              // skip empty elements
+              if(!*values[0])
+                continue;
+
+              codes[0] = macrocodes[4 - a];
+              codes[1] = 0;
+
+              // resn`resi or name`alt
+              if (codes[0] == SELE_RSNs || codes[0] == SELE_NAMs) {
+                char * backtick = strchr(values[0], '`');
+                if (backtick) {
+                  if (codes[0] == SELE_RSNs) {
+                    codes[1] = SELE_RSIs;
+                  } else {
+                    codes[1] = SELE_ALTs;
+                  }
+                  values[1] = backtick + 1;
+                  *backtick = '\0';
+                } else if (codes[0] == SELE_RSNs
+                    && values[0][0] >= '0'
+                    && values[0][0] <= '9') {
+                  // numeric -> resi
+                  codes[0] = SELE_RSIs;
+                }
+              }
+
+              for (int i = 0; codes[i]; ++i) {
+                // skip empty and "*" values
+                if (*values[i] && strcmp(values[i], "*")) {
+                  if(b++)
+                    STACK_PUSH_OPERATION(SELE_AND2);
+
+                  STACK_PUSH_OPERATION(codes[i]);
+                  STACK_PUSH_VALUE(values[i]);
+                }
+              }
+            }
+
+            // all-empty slash macro equals "all"
+            if(!b)
+              STACK_PUSH_OPERATION(SELE_ALLz);
+
+          } else if(word[c].find('`') != std::string::npos) { /* handle <object`index> syntax */
+            STACK_PUSH_OPERATION(SELE_MODs);
+            valueFlag = 1;
+            c--;
+          } else {              /* handle <selection-name> syntax */
+            STACK_PUSH_OPERATION(SELE_SELs);
+            valueFlag = 1;
+            c--;
+          }
+        }
+      }
+      break;
+    }
+    if(ok)
+      c++;                      /* go onto next word */
+  }
+  if(level > 0){
+      ok = ErrMessage(G, "Selector", "Malformed selection.");
+  }
+  if(ok) {                      /* this is the main operation loop */
+    totDepth = depth;
+    opFlag = true;
+    maxLevel = -1;
+    for(a = 1; a <= totDepth; a++) {
+      if(Stack[a].level > maxLevel)
+        maxLevel = Stack[a].level;
+    }
+    level = maxLevel;
+    PRINTFD(G, FB_Selector)
+      " Selector: maxLevel %d %d\n", maxLevel, totDepth ENDFD;
+    if(level >= 0)
+      while(ok) {               /* loop until all ops at all levels have been tried */
+
+        /* order & efficiency of this algorithm could be improved... */
+
+        PRINTFD(G, FB_Selector)
+          " Selector: new cycle...\n" ENDFD;
+        depth = 1;
+        opFlag = true;
+        while(ok && opFlag) {   /* loop through all entries looking for ops at the current level */
+          opFlag = false;
+
+          if(Stack[depth].level >= level) {
+            Stack[depth].level = level; /* trim peaks */
+          }
+          if(ok)
+            if(depth > 0)
+              if((!opFlag) && (Stack[depth].type == STYP_SEL0)) {
+                opFlag = true;
+                ok = SelectorSelect0(G, &Stack[depth]);
+              }
+          if(ok)
+            if(depth > 1)
+              if(Stack[depth - 1].level >= Stack[depth].level) {
+                if(ok && (!opFlag) && (Stack[depth - 1].type == STYP_SEL1)
+                   && (Stack[depth].type == STYP_VALU)) {
+                  /* 1 argument selection operator */
+                  opFlag = true;
+                  ok = SelectorSelect1(G, &Stack[depth - 1], quiet);
+                  for(a = depth + 1; a <= totDepth; a++)
+                    Stack[a - 1] = std::move(Stack[a]);
+                  totDepth--;
+                } else if(ok && (!opFlag) && (Stack[depth - 1].type == STYP_OPR1)
+                          && (Stack[depth].type == STYP_LIST)) {
+                  /* 1 argument logical operator */
+                  opFlag = true;
+                  ok = SelectorLogic1(G, &Stack[depth - 1], state);
+                  for(a = depth + 1; a <= totDepth; a++)
+                    Stack[a - 1] = std::move(Stack[a]);
+                  totDepth--;
+                } else if((Stack[depth - 1].type == STYP_LIST) &&
+                          (Stack[depth].type == STYP_LIST) &&
+                          (!((Stack[depth - 1].level & 0xF) ||
+                             (Stack[depth].level & 0xF)))) {
+                  /* two adjacent lists at zeroth priority level
+                     for the scope (lowest nibble of level is
+                     zero) is an implicit OR action */
+                  VecCheck(Stack, totDepth + 1);
+                  for(a = totDepth; a >= depth; a--)
+                    Stack[a + 1] = std::move(Stack[a]);
+                  totDepth++;
+                  Stack[depth].type = STYP_OPR2;
+                  Stack[depth].code = SELE_IOR2;
+                  Stack[depth].level = Stack[depth].imp_op_level;
+                  Stack[depth].m_text.clear();
+                  if(level < Stack[depth].level)
+                    level = Stack[depth].level;
+                  opFlag = true;
+                }
+              }
+          if(ok)
+            if(depth > 2)
+              if((Stack[depth - 1].level >= Stack[depth].level) &&
+                 (Stack[depth - 1].level >= Stack[depth - 2].level)) {
+
+                if(ok && (!opFlag) && (Stack[depth - 1].type == STYP_OPR2)
+                   && (Stack[depth].type == STYP_LIST)
+                   && (Stack[depth - 2].type == STYP_LIST)) {
+                  /* 2 argument logical operator */
+                  ok = SelectorLogic2(G, &Stack[depth - 2]);
+                  opFlag = true;
+                  for(a = depth + 1; a <= totDepth; a++)
+                    Stack[a - 2] = std::move(Stack[a]);
+                  totDepth -= 2;
+                } else if(ok && (!opFlag) && (Stack[depth - 1].type == STYP_PRP1)
+                          && (Stack[depth].type == STYP_PVAL)
+                          && (Stack[depth - 2].type == STYP_LIST)) {
+                  /* 2 argument logical operator */
+                  ok = SelectorModulate1(G, &Stack[depth - 2], state);
+                  opFlag = true;
+                  for(a = depth + 1; a <= totDepth; a++)
+                    Stack[a - 2] = std::move(Stack[a]);
+                  totDepth -= 2;
+                }
+              }
+          if(ok)
+            if(depth > 2)
+              if((Stack[depth - 2].level >= Stack[depth - 1].level) &&
+                 (Stack[depth - 2].level >= Stack[depth].level)) {
+
+                if(ok && (!opFlag) && (Stack[depth - 2].type == STYP_SEL2)
+                   && (Stack[depth - 1].type == STYP_VALU)
+                   && (Stack[depth].type == STYP_VALU)) {
+                  /* 2 argument value operator */
+                  ok = SelectorSelect2(G, &Stack[depth - 2], state);
+                  opFlag = true;
+                  for(a = depth + 1; a <= totDepth; a++)
+                    Stack[a - 2] = std::move(Stack[a]);
+                  totDepth -= 2;
+                }
+              }
+          if(ok)
+            if(depth > 3)
+              if((Stack[depth - 3].level >= Stack[depth].level) &&
+                 (Stack[depth - 3].level >= Stack[depth - 1].level) &&
+                 (Stack[depth - 3].level >= Stack[depth - 2].level)) {
+
+                if(ok && (!opFlag) && (Stack[depth - 3].type == STYP_SEL3)
+                   && (Stack[depth].type == STYP_VALU)
+                   && (Stack[depth - 1].type == STYP_VALU)
+                   && (Stack[depth - 2].type == STYP_VALU)) {
+                  /* 2 argument logical operator */
+                  ok = SelectorSelect3(G, &Stack[depth-3], state);
+                  opFlag = true;
+                  for(a = depth + 1; a <= totDepth; a++)
+                    Stack[a - 3] = std::move(Stack[a]);
+                  totDepth -= 3;
+                }
+              }
+          if(ok)
+            if(depth > 4)
+              if((Stack[depth - 3].level >= Stack[depth].level) &&
+                 (Stack[depth - 3].level >= Stack[depth - 1].level) &&
+                 (Stack[depth - 3].level >= Stack[depth - 2].level) &&
+                 (Stack[depth - 3].level >= Stack[depth - 4].level)) {
+
+                if(ok && (!opFlag) && (Stack[depth - 3].type == STYP_OP22)
+                   && (Stack[depth - 1].type == STYP_VALU)
+                   && (Stack[depth - 2].type == STYP_VALU)
+                   && (Stack[depth].type == STYP_LIST)
+                   && (Stack[depth - 4].type == STYP_LIST)) {
+
+                  ok = SelectorOperator22(G, &Stack[depth - 4], state);
+                  opFlag = true;
+                  for(a = depth + 1; a <= totDepth; a++)
+                    Stack[a - 4] = std::move(Stack[a]);
+                  totDepth -= 4;
+                }
+
+              }
+          if(opFlag) {
+            depth = 1;          /* start back at the left hand side */
+          } else {
+            depth = depth + 1;
+            opFlag = true;
+            if(depth > totDepth)
+              break;
+          }
+        }
+        if(level)
+          level--;
+        else
+          break;
+      }
+    depth = totDepth;
+  }
+  if(ok) {
+    if(depth != 1) {
+	ok = ErrMessage(G, "Selector", "Malformed selection.");
+    } else if(Stack[depth].type != STYP_LIST)
+	ok = ErrMessage(G, "Selector", "Invalid selection.");
+    else
+      return std::move(Stack[totDepth].sele); /* return the selection list */
+  }
+  if(!ok) {
+    for (a = 0; a <= c && a < word.size(); a++) {
+      const char* space = (a && word[a][0]) ? " " : "";
+      PRINTFB(G, FB_Selector, FB_Errors)
+        "%s%s", space, word[a].c_str() ENDFB(G);
+    }
+    PRINTFB(G, FB_Selector, FB_Errors)
+      "<--\n" ENDFB(G);
+  }
+  return {};
+}
+
+
+/*========================================================================*/
+/**
+ * Break a selection down into tokens and return them in a vector.
+ * E.g. "(name CA+CB)" -> {"(", "name", "CA+CB", ")"}.
+ * @param s selection expression to parse
+ * @return tokens
+ */
+std::vector<std::string> SelectorParse(PyMOLGlobals * G, const char *s)
+{
+  int w_flag = false;
+  int quote_flag = false;
+  char quote_char = '"';
+  const char *p = s;
+  std::string* q = nullptr;
+  std::vector<std::string> r;
+  while(*p) {
+    if(w_flag) {                /* currently in a word, thus q is a valid pointer */
+      if(quote_flag) {
+        if(*p != quote_char) {
+          *q += *p;
+        } else {
+          quote_flag = false;
+          *q += *p;
+        }
+      } else
+        switch (*p) {
+        case ' ':
+          w_flag = false;
+          break;
+        case ';':              /* special word terminator */
+          *q += *p;
+          w_flag = false;
+          break;
+        case '!':              /* single words */
+        case '&':
+        case '|':
+        case '(':
+        case ')':
+        case '>':
+        case '<':
+        case '=':
+        case '%':
+          r.emplace_back(1, *p); /* add new word */
+          q = &r.back();
+          w_flag = false;
+          break;
+        case '"':
+          quote_flag = true;
+          *q += *p;
+          break;
+        default:
+          *q += *p;
+          break;
+        }
+    } else {                    /*outside a word -- q is undefined */
+
+      switch (*p) {
+      case '!':                /* single words */
+      case '&':
+      case '|':
+      case '(':
+      case ')':
+      case '>':
+      case '<':
+      case '=':
+      case '%':
+        r.emplace_back(1, *p); /* add new word */
+        q = &r.back();
+        break;
+      case ' ':
+        break;
+      case '"':
+        quote_flag = true;
+        quote_char = *p;
+        w_flag = true;
+        r.emplace_back(1, *p); /* add new word */
+        q = &r.back();
+        break;
+      default:
+        w_flag = true;
+        r.emplace_back(1, *p); /* add new word */
+        q = &r.back();
+        break;
+      }
+    }
+    p++;
+  }
+
+  if(Feedback(G, FB_Selector, FB_Debugging)) {
+    for (auto& word : r) {
+      fprintf(stderr, "word: %s\n", word.c_str());
+    }
+  }
+  return (r);
+}
+
+
+/*========================================================================*/
+void SelectorFree(PyMOLGlobals * G)
+{
+  SelectorFreeImpl(G, G->Selector, 1);
+}
+
+void SelectorFreeImpl(PyMOLGlobals * G, CSelector *I, short init2)
+{
+  SelectorCleanImpl(G, I);
+  if(I->Origin)
+    if(I->Origin->fFree)
+      I->Origin->fFree((CObject *) I->Origin);
+  if(I->Center)
+    if(I->Center->fFree)
+      I->Center->fFree((CObject *) I->Center);
+  if (init2){
+    VLAFreeP(I->Member);
+    VLAFreeP(I->Name);
+    VLAFreeP(I->Info);
+
+    OVLexicon_DEL_AUTO_NULL(I->Lex);
+    OVOneToAny_DEL_AUTO_NULL(I->Key);
+    OVOneToOne_DEL_AUTO_NULL(I->NameOffset);
+  }
+  FreeP(I);
+}
+
+
+/*========================================================================*/
+
+void SelectorMemoryDump(PyMOLGlobals * G)
+{
+  CSelector *I = G->Selector;
+  printf(" SelectorMemory: NSelection %d\n", I->NSelection);
+  printf(" SelectorMemory: NActive %d\n", I->NActive);
+  printf(" SelectorMemory: TmpCounter %d\n", I->TmpCounter);
+  printf(" SelectorMemory: NMember %d\n", I->NMember);
+}
+
+static void SelectorInit2(PyMOLGlobals * G, CSelector *I)
+{
+  I->NSelection = 0;
+  I->NActive = 0;
+  I->TmpCounter = 0;
+  I->NCSet = 0;
+
+  I->Lex = OVLexicon_New(G->Context->heap);
+  I->Key = OVOneToAny_New(G->Context->heap);
+  I->NameOffset = OVOneToOne_New(G->Context->heap);
+
+  {                             /* create placeholder "all" selection, which is selection 0
+                                   and "none" selection, which is selection 1 */
+    int n;
+
+    n = I->NActive;
+    VLACheck(I->Name, SelectorWordType, n + 1);
+    VLACheck(I->Info, SelectionInfoRec, n + 1);
+    strcpy(I->Name[n], cKeywordAll);    /* "all" selection = 0 */
+    I->Name[n + 1][0] = 0;
+    SelectorAddName(G, n);
+    SelectionInfoInit(I->Info + n);
+    I->Info[n].ID = I->NSelection++;
+    I->NActive++;
+
+    n = I->NActive;
+    VLACheck(I->Name, SelectorWordType, n + 1);
+    VLACheck(I->Info, SelectionInfoRec, n + 1);
+    strcpy(I->Name[n], cKeywordNone);   /* "none" selection = 1 */
+    I->Name[n + 1][0] = 0;
+    SelectorAddName(G, n);
+    SelectionInfoInit(I->Info + n);
+    I->Info[n].ID = I->NSelection++;
+    I->NActive++;
+  }
+
+  if(I->Lex && I->Key) {
+    int a = 0;
+    OVreturn_word result;
+    while(1) {
+      if(!Keyword[a].word[0])
+        break;
+      if(OVreturn_IS_OK((result = OVLexicon_GetFromCString(I->Lex, Keyword[a].word)))) {
+        OVOneToAny_SetKey(I->Key, result.word, Keyword[a].value);
+      }
+      a++;
+    }
+
+  }
+}
+
+void SelectorReinit(PyMOLGlobals * G)
+{
+  CSelector *I = G->Selector;
+  SelectorClean(G);
+
+  OVLexicon_DEL_AUTO_NULL(I->Lex);
+  OVOneToAny_DEL_AUTO_NULL(I->Key);
+  OVOneToOne_DEL_AUTO_NULL(I->NameOffset);
+
+  SelectorInit2(G, I);
+}
+
+
+/*========================================================================*/
+int SelectorInit(PyMOLGlobals * G)
+{
+  return SelectorInitImpl(G, &G->Selector, 1);
+}
+
+int SelectorInitImpl(PyMOLGlobals * G, CSelector **Iarg, short init2){
+  CSelector *I = NULL;
+  ok_assert(1, I = pymol::calloc<CSelector>(1));
+
+    *Iarg = I;
+
+    I->Vertex = NULL;
+    I->Origin = NULL;
+    I->Table = NULL;
+    I->Obj = NULL;
+    I->Flag1 = NULL;
+    I->Flag2 = NULL;
+
+    if (init2){
+      I->Member = (MemberType *) VLAMalloc(100, sizeof(MemberType), 5, true);
+      I->NMember = 0;
+      I->FreeMember = 0;
+      I->Name = VLAlloc(SelectorWordType, 10);
+      I->Info = VLAlloc(SelectionInfoRec, 10);
+      SelectorInit2(G, I);
+    } else {
+      CSelector *GI = G->Selector;
+      I->Member = GI->Member;
+      I->NMember = GI->NMember;
+      I->FreeMember = GI->FreeMember;
+      I->NSelection = GI->NSelection;
+      I->NActive = GI->NActive ;
+      I->TmpCounter = GI->TmpCounter;
+      I->NCSet = GI->NCSet;
+      I->Lex = GI->Lex;
+      I->Key = GI->Key;
+      I->NameOffset = GI->NameOffset;
+      I->Name = GI->Name;
+      I->Info = GI->Info;      
+    }
+    return 1;
+ok_except1:
+ return 0;
+}
+ 
+
+/*========================================================================*/
+
+DistSet *SelectorGetDistSet(PyMOLGlobals * G, DistSet * ds,
+                            int sele1, int state1, int sele2, int state2,
+                            int mode, float cutoff, float *result)
+{
+  CSelector *I = G->Selector;
+  int *vla = NULL;
+  int c;
+  float dist;
+  int a1, a2;
+  AtomInfoType *ai1, *ai2;
+  int at, at1, at2;
+  CoordSet *cs1, *cs2;
+  ObjectMolecule *obj, *obj1, *obj2, *lastObj;
+  int idx1, idx2;
+  int a;
+  int nv = 0;
+  float *vv = NULL, *vv0, *vv1;
+  float dist_sum = 0.0;
+  int dist_cnt = 0;
+  int s;
+  int a_keeper = false;
+  int *zero = NULL, *scratch = NULL;
+  std::vector<bool> coverage;
+  HBondCriteria hbcRec, *hbc;
+  int exclusion = 0;
+  int bonds_only = 0;
+  int from_proton = SettingGetGlobal_b(G, cSetting_h_bond_from_proton);
+  AtomInfoType *h_ai;
+  CMeasureInfo *atom1Info=NULL;
+
+  /* if we're creating hydrogen bonds, then set some distance cutoffs */
+  switch (mode) {
+  case 1:
+    bonds_only = 1;
+    break;
+  case 2:
+    exclusion = SettingGetGlobal_i(G, cSetting_h_bond_exclusion);
+    break;
+  case 3:
+    exclusion = SettingGetGlobal_i(G, cSetting_distance_exclusion);
+    break;
+  }
+
+  hbc = &hbcRec;
+  *result = 0.0;
+  /* if the dist set exists, get info from it, otherwise get a new one */
+  if(!ds) {
+    ds = DistSetNew(G);
+  } else {
+    vv = ds->Coord;  /* vertices */
+    nv = ds->NIndex; /* number of vertices */
+  }
+  /* make sure we have memory to hold the vertex info for this distance set */
+  if(!vv) {
+    vv = VLAlloc(float, 10);
+  }
+
+  /* update states: if the two are the same, update that one state, else update all states */
+  if((state1 < 0) || (state2 < 0) || (state1 != state2)) {
+    SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+  } else {
+    SelectorUpdateTable(G, state1, -1);
+  }
+
+  /* find and prepare (neighbortables) in any participating Molecular objects */
+  if((mode == 1) || (mode == 2) || (mode == 3)) {       /* fill in all the neighbor tables */
+    int max_n_atom = I->NAtom;
+    lastObj = NULL;
+    for(a = cNDummyAtoms; a < I->NAtom; a++) {
+      /* foreach atom in the session, get its identifier and ObjectMolecule to which it belongs */
+      at = I->Table[a].atom;  /* grab the atom ID from the Selectors->Table */
+      obj = I->Obj[I->Table[a].model];		/* -- JV -- quick way to get an object from an atom */
+      s = obj->AtomInfo[at].selEntry;  /* grab the selection entry# from this Atoms Info */
+      if(obj != lastObj) {
+        if(max_n_atom < obj->NAtom)
+          max_n_atom = obj->NAtom;
+	/* if the current atom is in sele1 or sele2 then update it's object's neighbor table */
+        if(SelectorIsMember(G, s, sele1) || SelectorIsMember(G, s, sele2)) {
+          ObjectMoleculeUpdateNeighbors(obj);
+	  /* if hbonds (so, more than just distance) */
+          if(mode == 2)
+            ObjectMoleculeVerifyChemistry(obj, -1);
+          lastObj = obj;
+        }
+      }
+    }
+    /* prepare these for the next round */
+    zero = pymol::calloc<int>(max_n_atom);
+    scratch = pymol::malloc<int>(max_n_atom);
+  }
+
+  /* if we're hydrogen bonding, setup the cutoff */
+  if(mode == 2) {
+    ObjectMoleculeInitHBondCriteria(G, hbc);
+    if(cutoff < 0.0F) {
+      cutoff = hbc->maxDistAtMaxAngle;
+      if(cutoff < hbc->maxDistAtZero) {
+        cutoff = hbc->maxDistAtZero;
+      }
+    }
+  }
+  if(cutoff < 0)
+    cutoff = 1000.0;
+	
+  if (mode == 4) {
+    // centroid distance
+    float centroid1[3], centroid2[3];
+    ObjectMoleculeOpRec op;
+
+    // get centroid 1
+    ObjectMoleculeOpRecInit(&op);
+    op.code = OMOP_CSetSumVertices;
+    op.cs1 = state1;
+    ExecutiveObjMolSeleOp(G, sele1, &op);
+
+    if (op.i1 > 0) {
+      scale3f(op.v1, 1.f / op.i1, centroid1);
+
+      // get centroid 2
+      ObjectMoleculeOpRecInit(&op);
+      op.code = OMOP_CSetSumVertices;
+      op.cs1 = state2;
+      ExecutiveObjMolSeleOp(G, sele2, &op);
+
+      if (op.i1 > 0) {
+        scale3f(op.v1, 1.f / op.i1, centroid2);
+
+        // store positions in measurement object
+        VLACheck(vv, float, (nv * 3) + 6);
+        vv0 = vv + (nv * 3);
+        nv += 2;
+        copy3f(centroid1, vv0);
+        copy3f(centroid2, vv0 + 3);
+
+        // for the return value
+        dist_cnt = 1;
+        dist_sum = diff3f(centroid1, centroid2);
+      }
+    }
+
+    // skip searching for pairwise distances
+    c = 0;
+  } else {
+    /* coverage determines if a given atom appears in sel1 and sel2 */
+    coverage.resize(I->NAtom);
+
+    for (SelectorAtomIterator iter(I); iter.next();) {
+      s = iter.getAtomInfo()->selEntry;
+      if (SelectorIsMember(G, s, sele1) &&
+          SelectorIsMember(G, s, sele2))
+        coverage[iter.a] = true;
+    }
+
+    /* this creates an interleaved list of ints for mapping ids to states within a given neighborhood */
+    c = SelectorGetInterstateVLA(G, sele1, state1, sele2, state2, cutoff, &vla);
+  }
+
+  /* for each state */
+  for(a = 0; a < c; a++) {
+    atom1Info = NULL;
+    /* get the interstate atom identifier for the two atoms to distance */
+    a1 = vla[a * 2];
+    a2 = vla[a * 2 + 1];
+
+    /* check their coverage to avoid duplicates */
+    if(a1 < a2 || (a1 != a2 && !(coverage[a1] && coverage[a2]))
+        || (state1 != state2)) {  /* eliminate reverse duplicates */
+      /* get the object-local atom ID */
+      at1 = I->Table[a1].atom;
+      at2 = I->Table[a2].atom;
+      /* get the object for this global atom ID */
+      obj1 = I->Obj[I->Table[a1].model];
+      obj2 = I->Obj[I->Table[a2].model];
+
+      /* the states are valid for these two atoms */
+      if((state1 < obj1->NCSet) && (state2 < obj2->NCSet)) {
+	/* get the coordinate sets for both atoms */
+        cs1 = obj1->CSet[state1];
+        cs2 = obj2->CSet[state2];
+        if(cs1 && cs2) {
+	  /* for bonding */
+          float *don_vv = NULL;
+          float *acc_vv = NULL;
+
+	  /* grab the appropriate atom information for this object-local atom */
+          ai1 = obj1->AtomInfo + at1;
+          ai2 = obj2->AtomInfo + at2;
+	  
+          idx1 = cs1->atmToIdx(at1);
+          idx2 = cs2->atmToIdx(at2);
+
+          if((idx1 >= 0) && (idx2 >= 0)) {
+	    /* actual distance calculation from ptA to ptB */
+            dist = (float) diff3f(cs1->Coord + 3 * idx1, cs2->Coord + 3 * idx2);
+
+	    /* if we pass the boding cutoff */
+            if(dist < cutoff) {
+              float h_crd[3];
+              h_ai = NULL;
+
+              a_keeper = true;
+              if(exclusion && (obj1 == obj2)) {
+                a_keeper = !SelectorCheckNeighbors(G, exclusion,
+                                                   obj1, at1, at2, zero, scratch);
+              } else if(bonds_only) {
+                a_keeper = SelectorCheckNeighbors(G, 1, obj1, at1, at2, zero, scratch);
+              }
+              if(a_keeper && (mode == 2)) {
+		/* proton comes from ai1 */
+                if(ai1->hb_donor && ai2->hb_acceptor) {
+                  a_keeper = ObjectMoleculeGetCheckHBond(&h_ai, h_crd,
+							 obj1, at1, state1, 
+							 obj2, at2, state2,
+							 hbc);
+                  if(a_keeper) {
+                    if(h_ai && from_proton) {
+                      don_vv = h_crd;
+                      ai1 = h_ai;
+		    }
+                    else {
+                      don_vv = cs1->Coord + 3 * idx1;
+		    }
+                    acc_vv = cs2->Coord + 3 * idx2;
+                  }
+                } else if(ai1->hb_acceptor && ai2->hb_donor) {
+		  /* proton comes from ai2 */
+                  a_keeper = ObjectMoleculeGetCheckHBond(&h_ai, h_crd,
+							 obj2, at2, state2,
+							 obj1, at1, state1, 
+							 hbc);
+
+                  if(a_keeper) {
+                    if(h_ai && from_proton) {
+                      don_vv = h_crd;
+                      ai2 = h_ai;
+		    }
+                    else {
+                      don_vv = cs2->Coord + 3 * idx2;
+		    }
+		    acc_vv = cs1->Coord + 3 * idx1;
+                  }
+                } else {
+                  a_keeper = false;
+                }
+	      }
+              if((sele1 == sele2) && (at1 > at2))
+                a_keeper = false;
+
+              if(a_keeper) {
+
+		/* Insert DistInfo records for updating distances */
+		/* Init/Add the elem to the DistInfo list */
+                atom1Info = pymol::malloc<CMeasureInfo>(1);
+
+                // TH
+                atom1Info->id[0] = AtomInfoCheckUniqueID(G, ai1);
+                atom1Info->id[1] = AtomInfoCheckUniqueID(G, ai2);
+
+		atom1Info->offset = nv;  /* offset into this DSet's Coord */
+		atom1Info->state[0] = state1;  /* state1 of sel1 */
+		atom1Info->state[1] = state2;
+		atom1Info->measureType = cRepDash; /* DISTANCE-dash */
+		ListPrepend(ds->MeasureInfo, atom1Info, next);
+
+		/* we have a distance we want to keep */
+                dist_cnt++;
+                dist_sum += dist;
+		/* see if vv has room at another 6 floats */
+                VLACheck(vv, float, (nv * 3) + 6);
+                vv0 = vv + (nv * 3);
+		
+                if((mode == 2) && (don_vv) && (acc_vv)) {
+                  *(vv0++) = *(don_vv++);
+                  *(vv0++) = *(don_vv++);
+                  *(vv0++) = *(don_vv++);
+                  *(vv0++) = *(acc_vv++);
+                  *(vv0++) = *(acc_vv++);
+                  *(vv0++) = *(acc_vv++);
+                } else {
+                  vv1 = cs1->Coord + 3 * idx1;
+                  *(vv0++) = *(vv1++);
+                  *(vv0++) = *(vv1++);
+                  *(vv0++) = *(vv1++);
+                  vv1 = cs2->Coord + 3 * idx2;
+                  *(vv0++) = *(vv1++);
+                  *(vv0++) = *(vv1++);
+                  *(vv0++) = *(vv1++);
+                }
+
+                nv += 2;
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+  if(dist_cnt)
+    (*result) = dist_sum / dist_cnt;
+  VLAFreeP(vla);
+  FreeP(zero);
+  FreeP(scratch);
+  if(vv)
+    VLASize(vv, float, (nv + 1) * 3);
+  ds->NIndex = nv;
+  ds->Coord = vv;
+  return (ds);
+}
+
+DistSet *SelectorGetAngleSet(PyMOLGlobals * G, DistSet * ds,
+                             int sele1, int state1,
+                             int sele2, int state2,
+                             int sele3, int state3,
+                             int mode, float *angle_sum, int *angle_cnt)
+{
+  CSelector *I = G->Selector;
+  float *vv = NULL;
+  int nv = 0;
+  std::vector<bool> coverage;
+
+  if(!ds) {
+    ds = DistSetNew(G);
+  } else {
+    vv = ds->AngleCoord;
+    nv = ds->NAngleIndex;
+  }
+  if(!vv)
+    vv = VLAlloc(float, 10);
+
+  if((state1 < 0) || (state2 < 0) || (state3 < 0) || (state1 != state2)
+     || (state1 != state3)) {
+    SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+  } else {
+    SelectorUpdateTable(G, state1, -1);
+  }
+
+  /* which atoms are involved? */
+
+  {
+    int a, s, at;
+    ObjectMolecule *obj;
+
+    coverage.resize(I->NAtom);
+    for(a = cNDummyAtoms; a < I->NAtom; a++) {
+      at = I->Table[a].atom;
+      obj = I->Obj[I->Table[a].model];
+      s = obj->AtomInfo[at].selEntry;
+      if (SelectorIsMember(G, s, sele1) &&
+          SelectorIsMember(G, s, sele3))
+        coverage[a] = true;
+    }
+  }
+
+  {                             /* fill in neighbor tables */
+    int a, s, at;
+    ObjectMolecule *obj, *lastObj = NULL;
+    for(a = cNDummyAtoms; a < I->NAtom; a++) {
+      at = I->Table[a].atom;
+      obj = I->Obj[I->Table[a].model];
+      s = obj->AtomInfo[at].selEntry;
+      if(obj != lastObj) {
+        if(SelectorIsMember(G, s, sele1) ||
+           SelectorIsMember(G, s, sele2) || SelectorIsMember(G, s, sele3)) {
+          ObjectMoleculeUpdateNeighbors(obj);
+          lastObj = obj;
+        }
+      }
+    }
+  }
+
+  {
+    int a, s, at;
+    ObjectMolecule *obj;
+    int *list1 = VLAlloc(int, 1000);
+    int *list2 = VLAlloc(int, 1000);
+    int *list3 = VLAlloc(int, 1000);
+    int n1 = 0;
+    int n2 = 0;
+    int n3 = 0;
+    int bonded12, bonded23;
+
+    /* now generate three lists of atoms, one for each selection set */
+
+    if(list1 && list2 && list3) {
+      for(a = cNDummyAtoms; a < I->NAtom; a++) {
+        at = I->Table[a].atom;
+        obj = I->Obj[I->Table[a].model];
+        s = obj->AtomInfo[at].selEntry;
+        if(SelectorIsMember(G, s, sele1)) {
+          VLACheck(list1, int, n1);
+          list1[n1++] = a;
+        }
+        if(SelectorIsMember(G, s, sele2)) {
+          VLACheck(list2, int, n2);
+          list2[n2++] = a;
+        }
+        if(SelectorIsMember(G, s, sele3)) {
+          VLACheck(list3, int, n3);
+          list3[n3++] = a;
+        }
+      }
+
+      /* for each set of 3 atoms in each selection... */
+
+      {
+        int i1, i2, i3;
+        int a1, a2, a3;
+        int at1, at2, at3;
+
+        /*        AtomInfoType *ai1,*ai2,ai3; */
+        CoordSet *cs1, *cs2, *cs3;
+        ObjectMolecule *obj1, *obj2, *obj3;
+
+        int idx1, idx2, idx3;
+        float angle;
+        float d1[3], d2[3];
+        float *v1, *v2, *v3, *vv0;
+
+        CMeasureInfo *atom1Info=NULL;
+
+        for(i1 = 0; i1 < n1; i1++) {
+          a1 = list1[i1];
+          at1 = I->Table[a1].atom;
+          obj1 = I->Obj[I->Table[a1].model];
+
+          if(state1 < obj1->NCSet) {
+            cs1 = obj1->CSet[state1];
+
+            if(cs1) {
+              idx1 = cs1->atmToIdx(at1);
+
+              if(idx1 >= 0) {
+
+                for(i2 = 0; i2 < n2; i2++) {
+                  a2 = list2[i2];
+                  at2 = I->Table[a2].atom;
+                  obj2 = I->Obj[I->Table[a2].model];
+
+                  if(state2 < obj2->NCSet) {
+
+                    cs2 = obj2->CSet[state2];
+
+                    if(cs2) {
+                      idx2 = cs2->atmToIdx(at2);
+
+                      if(idx2 >= 0) {
+			/* neighbor table like BPRec */
+                        bonded12 = ObjectMoleculeAreAtomsBonded2(obj1, at1, obj2, at2);
+
+                        for(i3 = 0; i3 < n3; i3++) {
+			  atom1Info = NULL;
+                          a3 = list3[i3];
+
+                          if( (a1 != a2 || state1 != state2) &&
+                              (a2 != a3 || state2 != state3) &&
+                              (a1 != a3 || state1 != state3)) {
+                            if(!(coverage[a1] && coverage[a3])
+                               || (a1 < a3)
+                               || (state1 != state3)) {  /* eliminate alternate-order duplicates */
+
+                              at3 = I->Table[a3].atom;
+                              obj3 = I->Obj[I->Table[a3].model];
+
+                              if(state3 < obj3->NCSet) {
+
+                                cs3 = obj3->CSet[state3];
+
+                                if(cs3) {
+                                  idx3 = cs3->atmToIdx(at3);
+
+                                  if(idx3 >= 0) {
+
+                                    bonded23 =
+                                      ObjectMoleculeAreAtomsBonded2(obj2, at2, obj3, at3);
+
+                                    if(!mode || ((mode == 1) && (bonded12 && bonded23))) {
+                                      /* store the 3 coordinates */
+
+                                      v1 = cs1->Coord + 3 * idx1;
+                                      v2 = cs2->Coord + 3 * idx2;
+                                      v3 = cs3->Coord + 3 * idx3;
+
+                                      subtract3f(v1, v2, d1);
+                                      subtract3f(v3, v2, d2);
+
+				      /* Insert DistInfo records for updating distances */
+				      /* Init/Add the elem to the DistInfo list */
+				      atom1Info = pymol::malloc<CMeasureInfo>(1);
+
+                                      // TH
+                                      atom1Info->id[0] = AtomInfoCheckUniqueID(G, obj1->AtomInfo + at1);
+                                      atom1Info->id[1] = AtomInfoCheckUniqueID(G, obj2->AtomInfo + at2);
+                                      atom1Info->id[2] = AtomInfoCheckUniqueID(G, obj3->AtomInfo + at3);
+
+				      atom1Info->offset = nv;  /* offset into this DSet's Coord */
+				      atom1Info->state[0] = state1;  /* state1 of sel1 */
+				      atom1Info->state[1] = state2;
+				      atom1Info->state[2] = state3;
+				      atom1Info->measureType = cRepAngle;
+				      ListPrepend(ds->MeasureInfo, atom1Info, next);
+
+                                      angle = get_angle3f(d1, d2);
+
+                                      (*angle_sum) += angle;
+                                      (*angle_cnt)++;
+
+                                      VLACheck(vv, float, (nv * 3) + 14);
+                                      vv0 = vv + (nv * 3);
+                                      *(vv0++) = *(v1++);
+                                      *(vv0++) = *(v1++);
+                                      *(vv0++) = *(v1++);
+                                      *(vv0++) = *(v2++);
+                                      *(vv0++) = *(v2++);
+                                      *(vv0++) = *(v2++);
+                                      *(vv0++) = *(v3++);
+                                      *(vv0++) = *(v3++);
+                                      *(vv0++) = *(v3++);
+                                      *(vv0++) = (float) !bonded12;
+                                      /* show line 1 flag */
+                                      *(vv0++) = (float) !bonded23;
+                                      *(vv0++) = 0.0F;
+                                      *(vv0++) = 0.0F;  /* label x relative to v2 */
+                                      *(vv0++) = 0.0F;  /* label y relative to v2 */
+                                      *(vv0++) = 0.0F;  /* label z relative to v2 */
+                                      nv += 5;
+                                    }
+                                  }
+                                }
+                              }
+                            }
+                          }
+                        }
+                      }
+                    }
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+    VLAFreeP(list1);
+    VLAFreeP(list2);
+    VLAFreeP(list3);
+  }
+
+  if(vv)
+    VLASize(vv, float, (nv + 1) * 3);
+  ds->NAngleIndex = nv;
+  ds->AngleCoord = vv;
+  return (ds);
+}
+
+DistSet *SelectorGetDihedralSet(PyMOLGlobals * G, DistSet * ds,
+                                int sele1, int state1,
+                                int sele2, int state2,
+                                int sele3, int state3,
+                                int sele4, int state4,
+                                int mode, float *angle_sum, int *angle_cnt)
+{
+  CSelector *I = G->Selector;
+  float *vv = NULL;
+  int nv = 0;
+  std::vector<bool> coverage14;
+  std::vector<bool> coverage23;
+  ObjectMolecule *just_one_object = NULL;
+  int just_one_atom[4] = { -1, -1, -1, -1 };
+
+  CMeasureInfo *atom1Info;
+
+  if(!ds) {
+    ds = DistSetNew(G);
+  } else {
+    vv = ds->DihedralCoord;
+    nv = ds->NDihedralIndex;
+  }
+  if(!vv)
+    vv = VLAlloc(float, 10);
+
+  if((state1 < 0) || (state2 < 0) || (state3 < 0) || (state4 < 0) ||
+     (state1 != state2) || (state1 != state3) || (state1 != state4)) {
+    SelectorUpdateTable(G, cSelectorUpdateTableAllStates, -1);
+  } else {
+    SelectorUpdateTable(G, state1, -1);
+  }
+
+  /* which atoms are involved? */
+
+  {
+    int a, s, at;
+    ObjectMolecule *obj;
+
+    coverage14.resize(I->NAtom);
+    coverage23.resize(I->NAtom);
+    for(a = cNDummyAtoms; a < I->NAtom; a++) {
+      bool coverage1 = false;
+      bool coverage2 = false;
+      at = I->Table[a].atom;
+      obj = I->Obj[I->Table[a].model];
+      if(!a)
+        just_one_object = obj;
+      s = obj->AtomInfo[at].selEntry;
+      if(SelectorIsMember(G, s, sele1)) {
+        if(obj != just_one_object)
+          just_one_object = NULL;
+        else if(just_one_atom[0] == -1)
+          just_one_atom[0] = a;
+        else
+          just_one_atom[0] = -2;
+        coverage1 = true;
+      }
+      if(SelectorIsMember(G, s, sele2)) {
+        if(obj != just_one_object)
+          just_one_object = NULL;
+        else if(just_one_atom[1] == -1)
+          just_one_atom[1] = a;
+        else
+          just_one_atom[1] = -2;
+        coverage2 = true;
+      }
+      if(SelectorIsMember(G, s, sele3)) {
+        if(obj != just_one_object)
+          just_one_object = NULL;
+        else if(just_one_atom[2] == -1)
+          just_one_atom[2] = a;
+        else
+          just_one_atom[2] = -2;
+        coverage23[a] = coverage2;
+      }
+      if(SelectorIsMember(G, s, sele4)) {
+        if(obj != just_one_object)
+          just_one_object = NULL;
+        else if(just_one_atom[3] == -1)
+          just_one_atom[3] = a;
+        else
+          just_one_atom[3] = -2;
+        coverage14[a] = coverage1;
+      }
+    }
+  }
+
+  if(just_one_object) {
+    ObjectMoleculeUpdateNeighbors(just_one_object);
+  } else {                      /* fill in neighbor tables */
+    int a, s, at;
+    ObjectMolecule *obj, *lastObj = NULL;
+    for(a = cNDummyAtoms; a < I->NAtom; a++) {
+      at = I->Table[a].atom;
+      obj = I->Obj[I->Table[a].model];
+      s = obj->AtomInfo[at].selEntry;
+      if(obj != lastObj) {
+        if(SelectorIsMember(G, s, sele1) ||
+           SelectorIsMember(G, s, sele2) ||
+           SelectorIsMember(G, s, sele3) || SelectorIsMember(G, s, sele4)
+          ) {
+          ObjectMoleculeUpdateNeighbors(obj);
+          lastObj = obj;
+        }
+      }
+    }
+  }
+
+  {
+    int a, s, at;
+    ObjectMolecule *obj;
+    int *list1 = VLAlloc(int, 1000);
+    int *list2 = VLAlloc(int, 1000);
+    int *list3 = VLAlloc(int, 1000);
+    int *list4 = VLAlloc(int, 1000);
+    int n1 = 0;
+    int n2 = 0;
+    int n3 = 0;
+    int n4 = 0;
+    int bonded12, bonded23, bonded34;
+
+    /* now generate three lists of atoms, one for each selection set */
+
+    if(list1 && list2 && list3 && list4) {
+
+      if(just_one_object && (just_one_atom[0] >= 0) && (just_one_atom[1] >= 0)
+         && (just_one_atom[2] >= 0) && (just_one_atom[3] >= 0)) {
+        /* optimal case */
+
+        list1[0] = just_one_atom[0];
+        list2[0] = just_one_atom[1];
+        list3[0] = just_one_atom[2];
+        list4[0] = just_one_atom[3];
+
+        n1 = n2 = n3 = n4 = 1;
+
+      } else {
+
+        for(a = cNDummyAtoms; a < I->NAtom; a++) {
+          at = I->Table[a].atom;
+          obj = I->Obj[I->Table[a].model];
+          s = obj->AtomInfo[at].selEntry;
+          if(SelectorIsMember(G, s, sele1)) {
+            VLACheck(list1, int, n1);
+            list1[n1++] = a;
+          }
+          if(SelectorIsMember(G, s, sele2)) {
+            VLACheck(list2, int, n2);
+            list2[n2++] = a;
+          }
+          if(SelectorIsMember(G, s, sele3)) {
+            VLACheck(list3, int, n3);
+            list3[n3++] = a;
+          }
+          if(SelectorIsMember(G, s, sele4)) {
+            VLACheck(list4, int, n4);
+            list4[n4++] = a;
+          }
+        }
+      }
+
+      /* for each set of 3 atoms in each selection... */
+
+      {
+        int i1, i2, i3, i4;
+        int a1, a2, a3, a4;
+        int at1, at2, at3, at4;
+
+        /*        AtomInfoType *ai1,*ai2,ai3; */
+        CoordSet *cs1, *cs2, *cs3, *cs4;
+        ObjectMolecule *obj1, *obj2, *obj3, *obj4;
+
+        int idx1, idx2, idx3, idx4;
+        float angle;
+        float *v1, *v2, *v3, *v4, *vv0;
+
+        for(i1 = 0; i1 < n1; i1++) {
+          a1 = list1[i1];
+          at1 = I->Table[a1].atom;
+          obj1 = I->Obj[I->Table[a1].model];
+          if(state1 < obj1->NCSet) {
+            cs1 = obj1->CSet[state1];
+
+            if(cs1) {
+              idx1 = cs1->atmToIdx(at1);
+
+              if(idx1 >= 0) {
+
+                for(i2 = 0; i2 < n2; i2++) {
+                  a2 = list2[i2];
+                  at2 = I->Table[a2].atom;
+                  obj2 = I->Obj[I->Table[a2].model];
+
+                  if(state2 < obj2->NCSet) {
+
+                    cs2 = obj2->CSet[state2];
+
+                    if(cs2) {
+                      idx2 = cs2->atmToIdx(at2);
+
+                      if(idx2 >= 0) {
+
+                        bonded12 = ObjectMoleculeAreAtomsBonded2(obj1, at1, obj2, at2);
+
+                        if(!mode || ((mode == 1) && bonded12))
+                          for(i3 = 0; i3 < n3; i3++) {
+                            a3 = list3[i3];
+                            at3 = I->Table[a3].atom;
+                            obj3 = I->Obj[I->Table[a3].model];
+
+                            if(state3 < obj3->NCSet) {
+
+                              cs3 = obj3->CSet[state3];
+
+                              if(cs3) {
+                                idx3 = cs3->atmToIdx(at3);
+
+                                if(idx3 >= 0) {
+
+                                  bonded23 =
+                                    ObjectMoleculeAreAtomsBonded2(obj2, at2, obj3, at3);
+                                  if(!mode || ((mode == 1) && bonded23))
+                                    for(i4 = 0; i4 < n4; i4++) {
+				      atom1Info = NULL;
+                                      a4 = list4[i4];
+
+                                      if((a1 != a2) && (a1 != a3) && (a1 != a4)
+                                         && (a2 != a3) && (a2 != a4) && (a3 != a4)) {
+                                        if (!(coverage14[a1] &&
+                                              coverage14[a4] &&
+                                              coverage23[a2] &&
+                                              coverage23[a3])
+                                           || (a1 < a4)) {
+                                          /* eliminate alternate-order duplicates */
+
+                                          at4 = I->Table[a4].atom;
+                                          obj4 = I->Obj[I->Table[a4].model];
+
+                                          if(state4 < obj4->NCSet) {
+
+                                            cs4 = obj4->CSet[state4];
+
+                                            if(cs4) {
+                                              idx4 = cs3->atmToIdx(at4);
+
+                                              if(idx4 >= 0) {
+
+                                                bonded34 =
+                                                  ObjectMoleculeAreAtomsBonded2(obj3, at3,
+                                                                                obj4,
+                                                                                at4);
+
+                                                if(!mode || ((mode == 1) && bonded34)) {
+                                                  /* store the 3 coordinates */
+
+                                                  v1 = cs1->Coord + 3 * idx1;
+                                                  v2 = cs2->Coord + 3 * idx2;
+                                                  v3 = cs3->Coord + 3 * idx3;
+                                                  v4 = cs4->Coord + 3 * idx4;
+
+						  /* Insert DistInfo records for updating distances */
+						  /* Init/Add the elem to the DistInfo list */
+						  atom1Info = pymol::malloc<CMeasureInfo >(1);
+
+                                                  // TH
+                                                  atom1Info->id[0] = AtomInfoCheckUniqueID(G, obj1->AtomInfo + at1);
+                                                  atom1Info->id[1] = AtomInfoCheckUniqueID(G, obj2->AtomInfo + at2);
+                                                  atom1Info->id[2] = AtomInfoCheckUniqueID(G, obj3->AtomInfo + at3);
+                                                  atom1Info->id[3] = AtomInfoCheckUniqueID(G, obj4->AtomInfo + at4);
+
+						  atom1Info->offset = nv;  /* offset into this DSet's Coord */
+
+						  atom1Info->state[0] = state1;  /* state1 of sel1 */
+						  atom1Info->state[1] = state2;
+						  atom1Info->state[2] = state3;
+						  atom1Info->state[3] = state4;
+
+						  atom1Info->measureType = cRepDihedral;
+
+						  ListPrepend(ds->MeasureInfo, atom1Info, next);
+
+                                                  angle = get_dihedral3f(v1, v2, v3, v4);
+
+                                                  (*angle_sum) += angle;
+                                                  (*angle_cnt)++;
+
+                                                  VLACheck(vv, float, (nv * 3) + 17);
+                                                  vv0 = vv + (nv * 3);
+                                                  ObjectMoleculeGetAtomTxfVertex(obj1,
+                                                                                 state1,
+                                                                                 at1,
+                                                                                 vv0);
+                                                  ObjectMoleculeGetAtomTxfVertex(obj2,
+                                                                                 state2,
+                                                                                 at2,
+                                                                                 vv0 + 3);
+                                                  ObjectMoleculeGetAtomTxfVertex(obj3,
+                                                                                 state3,
+                                                                                 at3,
+                                                                                 vv0 + 6);
+                                                  ObjectMoleculeGetAtomTxfVertex(obj4,
+                                                                                 state4,
+                                                                                 at4,
+                                                                                 vv0 + 9);
+                                                  vv0 += 12;
+                                                  *(vv0++) = (float) !bonded12;
+                                                  *(vv0++) = (float) !bonded23;
+                                                  *(vv0++) = (float) !bonded34;
+                                                  *(vv0++) = 0.0F;      /* label x relative to v2+v3/2 */
+                                                  *(vv0++) = 0.0F;      /* label y relative to v2+v3/2 */
+                                                  *(vv0++) = 0.0F;      /* label z relative to v2+v3/2 */
+                                                  nv += 6;
+                                                }
+                                              }
+                                            }
+                                          }
+                                        }
+                                      }
+                                    }
+                                }
+                              }
+                            }
+                          }
+                      }
+                    }
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+    VLAFreeP(list1);
+    VLAFreeP(list2);
+    VLAFreeP(list3);
+    VLAFreeP(list4);
+  }
+
+  if(vv)
+    VLASize(vv, float, (nv + 1) * 3);
+  ds->NDihedralIndex = nv;
+  ds->DihedralCoord = vv;
+  return (ds);
+}
+
+
+/*========================================================================*/
+
+
+/*
+
+example selections
+cas
+backbone
+(model 1 and backbone)
+(name ca)
+(resi 123)
+(resi 200:400 and chain A)
+(model a)
+
+ */
+
+
+/* In order for selections to be robust during atom insertions
+   deletions, they are stored not as lists of selected atoms, but
+   rather in the inverse - as atoms with selection membership
+   information */
+
+
+/* Each atom points into the selection heap, a series of linked
+   entries where each member is selection index */
+
+
+/* Definition of the selection language:
+
+	<sele> = [(] [<not>] <prop> <val-range> [<qual> [<qual-range>] ] [)] { <SEL1> <sele> }
+
+	Example selections:
+	
+   name ca
+	( name ca )
+	name ca around 5 {all atoms within 5 angstroms of any ca atom) }
+	( resi 10 ) 
+	resi 10:50
+	resi 10A:50A
+	resi 10,50
+	chain A
+	segi A
+	model 1 and segi B
+	model a and segi B
+	not name ca
+
+*/
+
+
+/* Selection processing, left to right by default, but with parenthesis for grouping
+	stack based functional language processing
+	each stack level has a full selection matrix
+	logical binary operators (or,and) and negation SEL1ation solely on these matrices.
+*/
+
+
+/*
+
+(not (name ca or name c) and (name s around 5 and (name c) )) around 6
+
+0:
+1: not
+2: name 
+2: ca
+
+0:
+
+1: not
+2:<name ca>
+not name ca around 5
+
+force compute
+
+0:
+1: not
+
+attrib b < 0 
+
+*/
diff -upNr pymol-open-source-2.3.0/layer4/Cmd.cpp pymol-open-source-2.3.3/layer4/Cmd.cpp
--- pymol-open-source-2.3.0/layer4/Cmd.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer4/Cmd.cpp	2019-08-22 10:24:47.750600902 +0200
@@ -63,6 +63,7 @@ Z* -------------------------------------
 #include"ObjectSurface.h"
 #include"ObjectSlice.h"
 #include"Executive.h"
+#include"ExecutivePython.h"
 #include"Selector.h"
 #include"main.h"
 #include"Scene.h"
@@ -85,7 +86,6 @@ Z* -------------------------------------
 #include"PlugIOManager.h"
 #include"Seeker.h"
 #include"ListMacros.h"
-#include"MacPyMOL.h"
 #include"ObjectAlignment.h"
 
 #include "MovieScene.h"
@@ -773,9 +773,9 @@ static PyObject* GetRawAlignment(PyMOLGl
     for (int id; (id = vla[i]); ++i) {
       auto eoo = ExecutiveUniqueIDAtomDictGet(G, id);
       if (eoo
-          && (!active_only || eoo->obj->Obj.Enabled)
-          && (!hide_underscore || eoo->obj->Obj.Name[0] != '_')) {
-        PyObject * idx = Py_BuildValue("si", eoo->obj->Obj.Name, eoo->atm + 1);
+          && (!active_only || eoo->obj->Enabled)
+          && (!hide_underscore || eoo->obj->Name[0] != '_')) {
+        PyObject * idx = Py_BuildValue("si", eoo->obj->Name, eoo->atm + 1);
         PyList_Append(col, idx);
         Py_DECREF(idx);
       }
@@ -2060,7 +2060,7 @@ static PyObject *CmdGetVersion(PyObject
 #ifdef _PyMOL_BUILD_DATE
       _PyMOL_BUILD_DATE,
       _PYMOL_BUILD_GIT_SHA,
-      _PyMOL_BUILD_SVN_REV
+      0
 #else
       0, "", 0
 #endif
@@ -2344,7 +2344,7 @@ static PyObject *CmdGetPhiPsi(PyObject *
       for(a = 0; a < l; a++) {
         key = PyTuple_New(2);
         PyTuple_SetItem(key, 1, PyInt_FromLong(*(i++) + 1));    /* +1 for index */
-        PyTuple_SetItem(key, 0, PyString_FromString((*(o++))->Obj.Name));
+        PyTuple_SetItem(key, 0, PyString_FromString((*(o++))->Name));
         value = PyTuple_New(2);
         PyTuple_SetItem(value, 0, PyFloat_FromDouble(*(p++)));  /* +1 for index */
         PyTuple_SetItem(value, 1, PyFloat_FromDouble(*(s++)));
@@ -2394,7 +2394,7 @@ static PyObject *CmdAlign(PyObject * sel
     if((ok = APIEnterNotModal(G))) {
       ok = ((SelectorGetTmp(G, str2, s2) >= 0) && (SelectorGetTmp(G, str3, s3) >= 0));
       if(ok) {
-        ExecutiveAlign(G, s2, s3,
+        ok = ExecutiveAlign(G, s2, s3,
                        mfile, gap, extend, max_gap,
                        max_skip, cutoff,
                        cycles, quiet, oname, state1, state2,
@@ -3127,19 +3127,19 @@ static PyObject *CmdSetFeedbackMask(PyOb
   if(ok && (ok = APIEnterNotModal(G))) {
     switch (i1) {               /* TODO STATUS */
     case 0:
-      FeedbackSetMask(G, i2, (uchar) i3);
+      G->Feedback->setMask(i2, (uchar) i3);
       break;
     case 1:
-      FeedbackEnable(G, i2, (uchar) i3);
+      G->Feedback->enable(i2, (uchar) i3);
       break;
     case 2:
-      FeedbackDisable(G, i2, (uchar) i3);
+      G->Feedback->disable(i2, (uchar) i3);
       break;
     case 3:
-      FeedbackPush(G);
+      G->Feedback->push();
       break;
     case 4:
-      FeedbackPop(G);
+      G->Feedback->pop();
       break;
     }
     APIExit(G);
@@ -4398,7 +4398,7 @@ static PyObject *Cmd_New(PyObject * self
         PyMOLGlobals *G = PyMOL_GetGlobals(I);
         if(I) {
 
-          G->P_inst = Calloc(CP_inst, 1);
+          G->P_inst = pymol::calloc<CP_inst>(1);
           G->P_inst->obj = pymol;
           G->P_inst->dict = PyObject_GetAttrString(pymol, "__dict__");
           Py_DECREF(G->P_inst->dict); // borrow reference
@@ -4764,7 +4764,7 @@ static PyObject *CmdIdentify(PyObject *
         for(a = 0; a < l; a++) {
           tuple = PyTuple_New(2);
           PyTuple_SetItem(tuple, 1, PyInt_FromLong(*(i++)));
-          PyTuple_SetItem(tuple, 0, PyString_FromString((*(o++))->Obj.Name));
+          PyTuple_SetItem(tuple, 0, PyString_FromString((*(o++))->Name));
           PyList_SetItem(result, a, tuple);
         }
       }
@@ -4815,7 +4815,7 @@ static PyObject *CmdIndex(PyObject * sel
       for(a = 0; a < l; a++) {
         tuple = PyTuple_New(2);
         PyTuple_SetItem(tuple, 1, PyInt_FromLong(*(i++) + 1));  /* +1 for index */
-        PyTuple_SetItem(tuple, 0, PyString_FromString((*(o++))->Obj.Name));
+        PyTuple_SetItem(tuple, 0, PyString_FromString((*(o++))->Name));
         PyList_SetItem(result, a, tuple);
       }
     } else {
@@ -4877,10 +4877,10 @@ static PyObject *CmdFindPairs(PyObject *
       o = oVLA;
       for(a = 0; a < l; a++) {
         tuple1 = PyTuple_New(2);
-        PyTuple_SetItem(tuple1, 0, PyString_FromString((*(o++))->Obj.Name));
+        PyTuple_SetItem(tuple1, 0, PyString_FromString((*(o++))->Name));
         PyTuple_SetItem(tuple1, 1, PyInt_FromLong(*(i++) + 1)); /* +1 for index */
         tuple2 = PyTuple_New(2);
-        PyTuple_SetItem(tuple2, 0, PyString_FromString((*(o++))->Obj.Name));
+        PyTuple_SetItem(tuple2, 0, PyString_FromString((*(o++))->Name));
         PyTuple_SetItem(tuple2, 1, PyInt_FromLong(*(i++) + 1)); /* +1 for index */
         tuple = PyTuple_New(2);
         PyTuple_SetItem(tuple, 0, tuple1);
@@ -5149,7 +5149,7 @@ static PyObject *CmdFitPairs(PyObject *
       ok = false;
 
     if(ok) {
-      word = Alloc(WordType, ln);
+      word = pymol::malloc<WordType>(ln);
 
       a = 0;
       while(a < ln) {
@@ -5346,7 +5346,7 @@ static PyObject *CmdGetObjectList(PyObje
       if(result) {
         unsigned int a;
         for(a = 0; a < size; a++) {
-          PyList_SetItem(result, a, PyString_FromString(list[a]->Obj.Name));
+          PyList_SetItem(result, a, PyString_FromString(list[a]->Name));
         }
       }
       VLAFreeP(list);
@@ -6965,26 +6965,6 @@ static PyObject *CmdFullScreen(PyObject
   return APIResultOk(ok);
 }
 
-static PyObject *CmdUngroup(PyObject * self, PyObject * args)
-{
-  PyMOLGlobals *G = NULL;
-  char *gname, *names;
-  int quiet;
-  int ok = false;
-  ok = PyArg_ParseTuple(args, "Ossi", &self, &gname, &names, &quiet);
-  if(ok) {
-    API_SETUP_PYMOL_GLOBALS;
-    ok = (G != NULL);
-  } else {
-    API_HANDLE_ERROR;
-  }
-  if(ok && (ok = APIEnterNotModal(G))) {
-    /*    ExecutiveGroup(G,gname,names,NULL,quiet,NULL); */
-    APIExit(G);
-  }
-  return APIResultOk(ok);
-}
-
 static PyObject *CmdGroup(PyObject * self, PyObject * args)
 {
   PyMOLGlobals *G = NULL;
@@ -7075,8 +7055,6 @@ static PyObject *CmdLoadObject(PyObject
   PyMOLGlobals *G = NULL;
   char *oname;
   PyObject *model;
-  CObject *origObj = NULL, *obj;
-  OrthoLineType buf;
   int frame, type;
   int finish, discrete;
   int quiet;
@@ -7091,136 +7069,7 @@ static PyObject *CmdLoadObject(PyObject
     API_HANDLE_ERROR;
   }
   if(ok && (ok = APIEnterNotModal(G))) {
-    ObjectNameType valid_name = "";
-  
-    buf[0] = 0;
-    ExecutiveProcessObjectName(G, oname, valid_name);
-
-    origObj = ExecutiveFindObjectByName(G, valid_name);
-
-    /* TODO check for existing object of wrong type */
-
-    switch (type) {
-    case cLoadTypeChemPyModel:
-      if(origObj){
-        if(origObj->type != cObjectMolecule) {
-          ExecutiveDelete(G, valid_name);
-          origObj = NULL;
-        } else {
-	  discrete = 1;
-	}
-      }
-      PBlock(G);                /*PBlockAndUnlockAPI(); */
-      obj = (CObject *) ObjectMoleculeLoadChemPyModel(G, (ObjectMolecule *)
-                                                      origObj, model, frame, discrete);
-      PUnblock(G);              /*PLockAPIAndUnblock(); */
-      if(!origObj) {
-        if(obj) {
-          ObjectSetName(obj, valid_name);
-          ExecutiveManageObject(G, obj, zoom, quiet);
-          if(frame < 0)
-            frame = ((ObjectMolecule *) obj)->NCSet - 1;
-          sprintf(buf, " CmdLoad: ChemPy-model loaded into object \"%s\", state %d.\n",
-                  valid_name, frame + 1);
-        }
-      } else if(origObj) {
-        if(finish)
-          ExecutiveUpdateObjectSelection(G, origObj);
-        if(frame < 0)
-          frame = ((ObjectMolecule *) origObj)->NCSet - 1;
-        sprintf(buf, " CmdLoad: ChemPy-model appended into object \"%s\", state %d.\n",
-                valid_name, frame + 1);
-      }
-      break;
-    case cLoadTypeChemPyBrick:
-      if(origObj)
-        if(origObj->type != cObjectMap) {
-          ExecutiveDelete(G, valid_name);
-          origObj = NULL;
-        }
-      PBlock(G);                /*PBlockAndUnlockAPI(); */
-      obj =
-        (CObject *) ObjectMapLoadChemPyBrick(G, (ObjectMap *) origObj, model, frame,
-                                             discrete, quiet);
-      PUnblock(G);              /*PLockAPIAndUnblock(); */
-      if(!origObj) {
-        if(obj) {
-          ObjectSetName(obj, valid_name);
-          ExecutiveManageObject(G, obj, zoom, quiet);
-          sprintf(buf, " CmdLoad: chempy.brick loaded into object \"%s\"\n", valid_name);
-        }
-      } else if(origObj) {
-        sprintf(buf, " CmdLoad: chempy.brick appended into object \"%s\"\n", valid_name);
-      }
-      break;
-    case cLoadTypeChemPyMap:
-      if(origObj)
-        if(origObj->type != cObjectMap) {
-          ExecutiveDelete(G, valid_name);
-          origObj = NULL;
-        }
-      PBlock(G);                /*PBlockAndUnlockAPI(); */
-      obj =
-        (CObject *) ObjectMapLoadChemPyMap(G, (ObjectMap *) origObj, model, frame,
-                                           discrete, quiet);
-      PUnblock(G);              /*PLockAPIAndUnblock(); */
-      if(!origObj) {
-        if(obj) {
-          ObjectSetName(obj, valid_name);
-          ExecutiveManageObject(G, obj, zoom, quiet);
-          sprintf(buf, " CmdLoad: chempy.map loaded into object \"%s\"\n", valid_name);
-        }
-      } else if(origObj) {
-        sprintf(buf, " CmdLoad: chempy.map appended into object \"%s\"\n", valid_name);
-      }
-      break;
-    case cLoadTypeCallback:
-      if(origObj)
-        if(origObj->type != cObjectCallback) {
-          ExecutiveDelete(G, valid_name);
-          origObj = NULL;
-        }
-      PBlock(G);                /*PBlockAndUnlockAPI(); */
-      obj = (CObject *) ObjectCallbackDefine(G, (ObjectCallback *) origObj, model, frame);
-      PUnblock(G);              /*PLockAPIAndUnblock(); */
-      if(!origObj) {
-        if(obj) {
-          ObjectSetName(obj, valid_name);
-          ExecutiveManageObject(G, obj, zoom, quiet);
-          sprintf(buf, " CmdLoad: pymol.callback loaded into object \"%s\"\n",
-                  valid_name);
-        }
-      } else if(origObj) {
-        sprintf(buf, " CmdLoad: pymol.callback appended into object \"%s\"\n",
-                valid_name);
-      }
-      break;
-    case cLoadTypeCGO:
-      if(origObj)
-        if(origObj->type != cObjectCGO) {
-          ExecutiveDelete(G, valid_name);
-          origObj = NULL;
-        }
-      PBlock(G);                /*PBlockAndUnlockAPI(); */
-      obj = (CObject *) ObjectCGODefine(G, (ObjectCGO *) origObj, model, frame);
-      PUnblock(G);              /*PLockAPIAndUnblock(); */
-      if(!origObj) {
-        if(obj) {
-          ObjectSetName(obj, valid_name);
-          ExecutiveManageObject(G, obj, zoom, quiet);
-          sprintf(buf, " CmdLoad: CGO loaded into object \"%s\"\n", valid_name);
-        }
-      } else if(origObj) {
-        sprintf(buf, " CmdLoad: CGO appended into object \"%s\"\n", valid_name);
-      }
-      break;
-
-    }
-    if(origObj && !quiet) {
-      PRINTFB(G, FB_Executive, FB_Actions)
-        "%s", buf ENDFB(G);
-      OrthoRestorePrompt(G);
-    }
+    ExecutiveLoadObject(G, oname, model, frame, type, finish, discrete, quiet, zoom);
     APIExit(G);
   }
   return APIResultOk(ok);
@@ -8159,11 +8008,6 @@ static PyObject *CmdWindow(PyObject * se
         MainCheckWindowFit(G);
       break;
 #endif
-#ifdef _MACPYMOL_XCODE
-    default:
-      MacPyMOL_doWindow(int1, x, y, width, height);
-      break;
-#endif
     }
 
     APIExit(G);
@@ -8171,10 +8015,6 @@ static PyObject *CmdWindow(PyObject * se
   return APIResultOk(ok);
 }
 
-#ifdef _PYMOL_IP_EXTRAS
-#include "IncentiveCopyToClipboard.h"
-#endif
-
 static PyObject *CmdCopyImage(PyObject * self, PyObject * args)
 {                               /* should come in as GLUT thread just to be safe... */
   PyMOLGlobals *G = NULL;
@@ -8189,15 +8029,8 @@ static PyObject *CmdCopyImage(PyObject *
   }
   if(ok) {
     if(G->HaveGUI) {
-
-#ifdef _PYMOL_IP_EXTRAS
-      ok = IncentiveCopyToClipboard(G, quiet);
-#else
-#ifdef PYMOL_EVAL
       PRINTFB(G, FB_Scene, FB_Warnings)
-        " Warning: Clipboard image transfers disabled in Evaluation Builds.\n" ENDFB(G);
-#endif
-#endif
+        " Warning: %s Implementation removed.\n", __func__ ENDFB(G);
     } else {
       ok = false;
     }
@@ -8755,7 +8588,6 @@ static PyMethodDef Cmd_methods[] = {
   {"volume", CmdVolume, METH_VARARGS},
   {"volume_color", CmdVolumeColor, METH_VARARGS},
   {"undo", CmdUndo, METH_VARARGS},
-  {"ungroup", CmdUngroup, METH_VARARGS},
   {"unpick", CmdUnpick, METH_VARARGS},
   {"unset", CmdUnset, METH_VARARGS},
   {"unset_bond", CmdUnsetBond, METH_VARARGS},
diff -upNr pymol-open-source-2.3.0/layer4/Export.cpp pymol-open-source-2.3.3/layer4/Export.cpp
--- pymol-open-source-2.3.0/layer4/Export.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer4/Export.cpp	2019-08-22 10:24:47.750600902 +0200
@@ -52,11 +52,11 @@ ExportCoords *ExportCoordsExport(PyMOLGl
   if(obj && (state >= 0) && (state < obj->NCSet) && (!obj->DiscreteFlag)
      && obj->CSet[state]) {
     cs = obj->CSet[state];
-    io = (ExportCoords *) mmalloc(sizeof(ExportCoords));
+    io = pymol::malloc<ExportCoords>(1);
 
     if(io) {
       io->nAtom = cs->NIndex;
-      io->coord = Alloc(float, cs->NIndex * 3);
+      io->coord = pymol::malloc<float>(cs->NIndex * 3);
 
       if(io->coord) {
         crd0 = cs->Coord;
@@ -183,7 +183,7 @@ ExportDotsObj *ExportDots(PyMOLGlobals *
     if(!rep)
       ok = ErrMessage(G, "ExportDots", "Couldn't get dot representation.");
     else {
-      result = Alloc(ExportDotsObj, 1);
+      result = pymol::malloc<ExportDotsObj>(1);
       ErrChkPtr(G, result);
       result->export_.fFree = (void (*)(struct Export *)) ExportDotsObjFree;
       /* cannabilize the data structures */
diff -upNr pymol-open-source-2.3.0/layer4/PopUp.cpp pymol-open-source-2.3.3/layer4/PopUp.cpp
--- pymol-open-source-2.3.0/layer4/PopUp.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer4/PopUp.cpp	2019-08-22 10:24:47.750600902 +0200
@@ -218,8 +218,8 @@ Block *PopUpNew(PyMOLGlobals * G, int x,
   dim[1] = mx + 1;
   I->Command = (char **) UtilArrayCalloc((unsigned int *) (void *) dim, 2, 1);
 
-  I->Code = Alloc(int, I->NLine + 1);
-  I->Sub = Calloc(PyObject *, I->NLine + 1);
+  I->Code = pymol::malloc<int>(I->NLine + 1);
+  I->Sub = pymol::calloc<PyObject *>(I->NLine + 1);
 
   for(a = 0; a < I->NLine; a++) {
     PyObject *command;
diff -upNr pymol-open-source-2.3.0/layer5/MacPyMOL.h pymol-open-source-2.3.3/layer5/MacPyMOL.h
--- pymol-open-source-2.3.0/layer5/MacPyMOL.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer5/MacPyMOL.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-/*
- * MacPyMOL functions called from pymol repository
- *
- * (c) 2014 Schrodinger, Inc.
- */
-
-#ifndef _H_MACPYMOL
-#define _H_MACPYMOL
-
-#ifdef _MACPYMOL_XCODE
-void MacPyMOL_SetProgress(float value);
-int MacPyMOL_doWindow(int code, int x,int y,int w, int h);
-int MacPyMOL_fullScreenActive();
-#endif
-
-#ifdef _PYMOL_IOS
-float IOS_getContentScaleFactor();
-#define getContentScaleFactor IOS_getContentScaleFactor
-#endif
-
-#endif
diff -upNr pymol-open-source-2.3.0/layer5/main.cpp pymol-open-source-2.3.3/layer5/main.cpp
--- pymol-open-source-2.3.0/layer5/main.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer5/main.cpp	2019-08-22 10:24:47.754601554 +0200
@@ -61,176 +61,6 @@ int MainSavingUnderWhileIdle(void)
   return 0;
 }
 
-#ifdef _MACPYMOL_XCODE
-
-void MainBlock(void)
-{
-  PyMOLGlobals *G = SingletonPyMOLGlobals;
-  PBlock(G);
-}
-
-void MainUnblock(void)
-{
-  PyMOLGlobals *G = SingletonPyMOLGlobals;
-  PUnblock(G);
-}
-
-int MainLockAPIAsGlut(int a)
-{
-  PyMOLGlobals *G = SingletonPyMOLGlobals;
-  return PLockAPIAsGlut(G, a);
-}
-
-void MainUnlockAPIAsGlut()
-{
-  PyMOLGlobals *G = SingletonPyMOLGlobals;
-  PUnlockAPIAsGlut(G);
-}
-
-int MainFeedbackOut(char *st)
-{
-  PyMOLGlobals *G = SingletonPyMOLGlobals;
-  return OrthoFeedbackOut(G, *G->Ortho);
-}
-
-void MainRunCommand(const char *str1)
-{
-  PyMOLGlobals *G = SingletonPyMOLGlobals;
-
-  if(PLockAPIAsGlut(G, true)) {
-
-    if(str1[0] != '_') {        /* suppress internal call-backs */
-      if(strncmp(str1, "cmd._", 5)) {
-        OrthoAddOutput(G, "PyMOL>");
-        OrthoAddOutput(G, str1);
-        OrthoNewLine(G, NULL, true);
-        if(WordMatch(G, str1, "quit", true) == 0)       /* don't log quit */
-          PLog(G, str1, cPLog_pml);
-      }
-      PParse(G, str1);
-    } else if(str1[1] == ' ') { /* "_ command" suppresses echoing of command, but it is still logged */
-      if(WordMatch(G, str1 + 2, "quit", true) >= 0)     /* don't log quit */
-        PLog(G, str1 + 2, cPLog_pml);
-      PParse(G, str1 + 2);
-    } else {
-      PParse(G, str1);
-    }
-    PUnlockAPIAsGlut(G);
-  }
-}
-
-PyObject *MainGetStringResult(const char *str)
-{
-  PyMOLGlobals *G = SingletonPyMOLGlobals;
-  PyObject *result;
-  result = PyRun_String(str, Py_eval_input, G->P_inst->dict, G->P_inst->dict);
-  return (result);
-}
-
-void MainRunString(const char *str)
-{
-  PyMOLGlobals *G = SingletonPyMOLGlobals;
-  PBlock(G);
-  PLockStatus(G);
-  PRunStringModule(G, str);
-  PUnlockStatus(G);
-  PUnblock(G);
-}
-
-void MainMovieCopyPrepare(int *width, int *height, int *length)
-{
-  PyMOLGlobals *G = SingletonPyMOLGlobals;
-  if(PLockAPIAsGlut(G, true)) {
-    MovieCopyPrepare(G, width, height, length);
-    MovieSetRealtime(G, false);
-    PUnlockAPIAsGlut(G);
-  }
-}
-
-int MainMovieCopyFrame(int frame, int width, int height, int rowbytes, void *ptr)
-{
-  PyMOLGlobals *G = SingletonPyMOLGlobals;
-  int result = false;
-  if(PLockAPIAsGlut(G, true)) {
-    result = MovieCopyFrame(G, frame, width, height, rowbytes, ptr);
-    PUnlockAPIAsGlut(G);
-  }
-  return result;
-}
-
-int MainMoviePurgeFrame(int frame)
-{
-  PyMOLGlobals *G = SingletonPyMOLGlobals;
-  int result = false;
-  if(PLockAPIAsGlut(G, true)) {
-    result = MoviePurgeFrame(G, frame);
-    PUnlockAPIAsGlut(G);
-  }
-  return result;
-}
-
-void MainMovieCopyFinish(void)
-{
-  PyMOLGlobals *G = SingletonPyMOLGlobals;
-  if(PLockAPIAsGlut(G, true)) {
-    MovieCopyFinish(G);
-    MovieSetRealtime(G, true);
-    PUnlockAPIAsGlut(G);
-  }
-}
-
-void MainFlushAsync(void)
-{
-  PyMOLGlobals *G = SingletonPyMOLGlobals;
-  if(PLockAPIAsGlut(G, true)) {
-    PFlush(G);
-    PUnlockAPIAsGlut(G);
-  }
-}
-
-int MainCheckRedundantOpen(char *file)
-{
-  int result = false;
-#ifndef _PYMOL_NOPY
-  PyMOLGlobals *G = SingletonPyMOLGlobals;
-  PBlock(G);
-  result = PTruthCallStr(G->P_inst->cmd, "check_redundant_open", file);
-  PUnblock(G);
-#endif
-  return result;
-}
-
-void MainSceneGetSize(int *width, int *height)
-{
-  PyMOLGlobals *G = SingletonPyMOLGlobals;
-  if(PLockAPIAsGlut(G, true)) {
-    SceneGetImageSize(G, width, height);
-    PUnlockAPIAsGlut(G);
-  }
-}
-
-int MainSceneCopy(int width, int height, int rowbytes, void *ptr)
-{
-  PyMOLGlobals *G = SingletonPyMOLGlobals;
-
-  int result = false;
-  if(PLockAPIAsGlut(G, true)) {
-    result = SceneCopyExternal(G, width, height, rowbytes, (unsigned char *) ptr, 0x1);
-    PUnlockAPIAsGlut(G);
-  }
-  return result;
-}
-
-PyObject *MainComplete(const char *str)
-{
-  PyMOLGlobals *G = SingletonPyMOLGlobals;
-  PyObject *result = NULL;
-  result = PYOBJECT_CALLFUNCTION(G->P_inst->complete, "s", str);
-  return (result);
-}
-
-#endif
-
 #else
 
 
@@ -1025,7 +855,7 @@ void MainDoReshape(int width, int height
 static void MainInit(PyMOLGlobals * G)
 {
 
-  CMain *I = (G->Main = Calloc(CMain, 1));
+  CMain *I = (G->Main = pymol::calloc<CMain>(1));
   /* Data structure is zeroed on start...no need for explicit zero inits */
 
   I->DeferReshapeDeferral = 1;
@@ -1439,13 +1269,6 @@ static void launch(CPyMOLOptions * optio
   PyMOLInstance = PyMOL_NewWithOptions(options);
   G = PyMOL_GetGlobals(PyMOLInstance);
 
-  /* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in "os_proprietary.h") */
-#ifdef _MACPYMOL_XCODE
-  MacPyMOLOption = G->Option;
-  MacPyMOLReady = &G->Ready;
-#endif
-  /* END PROPRIETARY CODE SEGMENT */
-
   if(G->Option->multisample)
     multisample_mask = P_GLUT_MULTISAMPLE;
 
diff -upNr pymol-open-source-2.3.0/layer5/main.h pymol-open-source-2.3.3/layer5/main.h
--- pymol-open-source-2.3.0/layer5/main.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer5/main.h	2019-08-22 10:24:47.754601554 +0200
@@ -42,27 +42,6 @@ void MainCheckWindowFit(PyMOLGlobals * G
 
 #endif
 
-/* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in "os_proprietary.h") */
-#ifdef _MACPYMOL_XCODE
-void MainUnblock(void);
-int MainCheckRedundantOpen(char *file);
-void MainRunString(const char *str);
-PyObject *MainGetStringResult(const char *str);
-void MainDoCommand(const char *str1);
-int MainFeedbackOut(char *st);
-void MainRunCommand(const char *str1);
-void MainMoviePrepareCopy(int *width, int *height, int *length);
-int MainMovieCopy(int frame, int width, int height, int rowbytes, void *ptr);
-void MainMovieCopyPrepare(int *width, int *height, int *length);
-int MainMovieCopyFrame(int frame, int width, int height, int rowbytes, void *ptr);
-int MainMoviePurgeFrame(int frame);
-void MainMovieCopyFinish(void);
-void MainSceneGetSize(int *width, int *height);
-int MainSceneCopy(int width, int height, int rowbytes, void *ptr);
-#endif
-
-/* END PROPRIETARY CODE SEGMENT */
-
 #define PYMOL_MAX_OPT_STR  1025
 
 int main_exec(int, char **);
diff -upNr pymol-open-source-2.3.0/layer5/PyMOL.cpp pymol-open-source-2.3.3/layer5/PyMOL.cpp
--- pymol-open-source-2.3.0/layer5/PyMOL.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer5/PyMOL.cpp	2019-08-22 10:24:47.750600902 +0200
@@ -76,28 +76,6 @@
 PyMOLGlobals *SingletonPyMOLGlobals = NULL;
 #endif
 
-
-/* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in "os_proprietary.h") */
-#ifndef _PYMOL_NOPY
-#ifdef _MACPYMOL_XCODE
-extern int *MacPyMOLReady;
-extern CPyMOLOptions *MacPyMOLOption;
-#endif
-#endif
-
-/* END PROPRIETARY CODE SEGMENT */
-
-#ifdef _MACPYMOL_XCODE
-
-/* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in "os_proprietary.h") */
-#define PYMOL_API_LOCK if((I->PythonInitStage) && (!I->ModalDraw) && PLockAPIAsGlut(I->G,true)) {
-#define PYMOL_API_LOCK_MODAL if((I->PythonInitStage) && PLockAPIAsGlut(I->G,true)) {
-#define PYMOL_API_TRYLOCK PYMOL_API_LOCK
-#define PYMOL_API_UNLOCK PUnlockAPIAsGlut(I->G); }
-#define PYMOL_API_UNLOCK_NO_FLUSH PUnlockAPIAsGlutNoFlush(I->G); }
-
-/* END PROPRIETARY CODE SEGMENT */
-#else
 #ifdef _PYMOL_LIB_HAS_PYTHON
 #define PYMOL_API_LOCK if(I->PythonInitStage && (!I->ModalDraw)) { PLockAPIAndUnblock(I->G); {
 #define PYMOL_API_LOCK_MODAL if(I->PythonInitStage) { PLockAPIAndUnblock(I->G); {
@@ -111,7 +89,6 @@ extern CPyMOLOptions *MacPyMOLOption;
 #define PYMOL_API_UNLOCK }
 #define PYMOL_API_UNLOCK_NO_FLUSH }
 #endif
-#endif
 #define IDLE_AND_READY 3
 
 #ifdef __cplusplus
@@ -230,13 +207,7 @@ typedef struct _CPyMOL {
 
 /* convenience functions -- inline */
 
-#ifdef _PYMOL_INLINE
-#define CC_INLINE __inline__
-#else
-#define CC_INLINE
-#endif
-
-CC_INLINE static PyMOLstatus get_status_ok(int ok)
+inline PyMOLstatus get_status_ok(int ok)
 {
   if(ok)
     return PyMOLstatus_SUCCESS;
@@ -244,14 +215,14 @@ CC_INLINE static PyMOLstatus get_status_
     return PyMOLstatus_FAILURE;
 }
 
-CC_INLINE static PyMOLreturn_status return_status_ok(int ok)
+inline PyMOLreturn_status return_status_ok(int ok)
 {
   PyMOLreturn_status result;
   result.status = get_status_ok(ok);
   return result;
 }
 
-CC_INLINE static PyMOLreturn_status return_status(int status)
+inline PyMOLreturn_status return_status(int status)
 {
   PyMOLreturn_status result;
   result.status = status;
@@ -1775,19 +1746,19 @@ PyMOLreturn_status PyMOL_CmdSetFeedbackM
   PYMOL_API_LOCK PyMOLGlobals * G = I->G;
   switch (action){
   case 0:
-    FeedbackSetMask(G, module, (uchar) mask);
+    G->Feedback->setMask(module, (uchar) mask);
     break;
   case 1:
-    FeedbackEnable(G, module, (uchar) mask);
+    G->Feedback->enable(module, (uchar) mask);
     break;
   case 2:
-    FeedbackDisable(G, module, (uchar) mask);
+    G->Feedback->disable(module, (uchar) mask);
     break;
   case 3:
-    FeedbackPush(G);
+    G->Feedback->push();
     break;
   case 4:
-    FeedbackPop(G);
+    G->Feedback->pop();
     break;
   }
   PYMOL_API_UNLOCK return result;
@@ -1844,7 +1815,7 @@ static const CPyMOLOptions Defaults = {
 CPyMOLOptions *PyMOLOptions_New(void)
 {
   CPyMOLOptions *result = NULL;
-  result = Calloc(CPyMOLOptions, 1);
+  result = pymol::calloc<CPyMOLOptions>(1);
   if(result)
     *result = Defaults;
   return result;
@@ -1862,21 +1833,6 @@ static void init_python(int argc, char *
 #endif
   }
 
-
-/* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in "os_proprietary.h") */
-#ifdef _MACPYMOL_XCODE
-  /* there appears to be a bug or a race collection in the garbage
-     collector of the Python version that ships with Mac OS --
-     better to potentially leak a little RAM than crash unexpectedly
-     in a _PyObject_GC_Del call.
-     BTW: PyMOL doesn't itself need the GC, but end-user code
-     might. */
-  PyRun_SimpleString("import gc");
-  PyRun_SimpleString("gc.disable()");
-#endif
-
-/* END PROPRIETARY CODE SEGMENT */
-
   PyEval_InitThreads();
 
   PyRun_SimpleString("import sys");
@@ -1962,9 +1918,9 @@ static CPyMOL *_PyMOL_New(void)
 
   /* allocate global container */
 
-  if((result = Calloc(CPyMOL, 1))) {    /* all values initialized to zero */
+  if((result = pymol::calloc<CPyMOL>(1))) {    /* all values initialized to zero */
 
-    if((result->G = Calloc(PyMOLGlobals, 1))) {
+    if((result->G = pymol::calloc<PyMOLGlobals>(1))) {
 
       result->G->PyMOL = result;        /* store the instance pointer */
 
@@ -2006,7 +1962,7 @@ CPyMOL *PyMOL_New(void)
 {
   CPyMOL *result = _PyMOL_New();
   if(result && result->G) {
-    result->G->Option = Calloc(CPyMOLOptions, 1);
+    result->G->Option = pymol::calloc<CPyMOLOptions>(1);
     if(result->G->Option)
       (*result->G->Option) = Defaults;
     _PyMOL_Config(result);
@@ -2018,7 +1974,7 @@ CPyMOL *PyMOL_NewWithOptions(const CPyMO
 {
   CPyMOL *result = _PyMOL_New();
   if(result && result->G) {
-    result->G->Option = Calloc(CPyMOLOptions, 1);
+    result->G->Option = pymol::calloc<CPyMOLOptions>(1);
     if(result->G->Option)
       *(result->G->Option) = *option;
     _PyMOL_Config(result);
@@ -2046,7 +2002,7 @@ void PyMOL_Start(CPyMOL * I)
 #define LEX_CONSTANTS_IMPL
 #include "lex_constants.h"
 
-  FeedbackInit(G, G->Option->quiet);
+  G->Feedback = new CFeedback(G, G->Option->quiet);
   WordInit(G);
   UtilInit(G);
   ColorInit(G);
@@ -2082,18 +2038,6 @@ void PyMOL_Start(CPyMOL * I)
   TrackerUnitTest(G);
 #endif
 
-
-/* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in "os_proprietary.h") */
-#ifdef _MACPYMOL_XCODE
-  SettingSetGlobal_b(G, cSetting_stereo_double_pump_mono, true);
-  if(G->Option->stereo_capable) {
-    SettingSetGlobal_i(G, cSetting_stereo_mode, cStereo_quadbuffer);
-  }
-  /*       SettingSetGlobal_i(G,cSetting_show_progress, 0);  */
-#endif
-
-/* END PROPRIETARY CODE SEGMENT */
-
   I->DrawnFlag = false;
   I->RedisplayFlag = true;
   G->Ready = true;
@@ -2123,23 +2067,11 @@ void PyMOL_StartWithPython(CPyMOL * I)
 
   /* now locate all the C to Python function hooks and objects we need */
 
-#ifdef _MACPYMOL_XCODE
-  PInit(I->G, true);
-#else
   PInit(I->G, false);
-#endif
 
   /* and begin the initialization sequence */
 
   I->PythonInitStage = 1;
-
-
-/* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in "os_proprietary.h") */
-#ifdef _MACPYMOL_XCODE
-  MacPyMOLOption = I->G->Option;
-  MacPyMOLReady = &I->G->Ready;
-#endif
-/* END PROPRIETARY CODE SEGMENT */
 }
 
 #endif
@@ -2178,7 +2110,7 @@ void PyMOL_Stop(CPyMOL * I)
   ColorFree(G);
   UtilFree(G);
   WordFree(G);
-  FeedbackFree(G);
+  delete G->Feedback;
 
   PyMOL_PurgeAPI(I);
   /*    printf("%d \n", OVLexicon_GetNActive(G->Lexicon)); */
@@ -2301,14 +2233,14 @@ static void PyMOL_LaunchStatus_Feedback(
         " OpenGL quad-buffer stereo 3D detected and enabled.\n");;
   } else {
     if(G->LaunchStatus & cPyMOLGlobals_LaunchStatus_StereoFailed) {
-      FeedbackAddColored(G,
+      G->Feedback->addColored(
           "Error: The requested stereo 3D visualization mode is not available.\n",
           FB_Errors);
     }
   }
 
   if(G->LaunchStatus & cPyMOLGlobals_LaunchStatus_MultisampleFailed) {
-    FeedbackAddColored(G,
+    G->Feedback->addColored(
         "Error: The requested multisampling mode is not available.\n",
         FB_Errors);
   }
@@ -2427,16 +2359,6 @@ void PyMOL_DrawWithoutLock(CPyMOL * I)
 
       setup_gl_state();
 
-      /* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in "os_proprietary.h") */
-#ifdef _MACPYMOL_XCODE
-      {                         /* on a mac, this can change if we've switched contexts... */
-        GLboolean state;
-        glGetBooleanv(GL_STEREO, &state);
-        G->StereoCapable = (int) state;
-      }
-#endif
-      /* END PROPRIETARY CODE SEGMENT */
-
       if(!I->DrawnFlag) {
         SceneSetCardInfo(G, (char *) glGetString(GL_VENDOR),
                          (char *) glGetString(GL_RENDERER),
@@ -2576,14 +2498,6 @@ int PyMOL_Idle(CPyMOL * I)
     } else {
       I->PythonInitStage = -1;
       PBlock(G);
-      /* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in "os_proprietary.h") */
-#ifdef _MACPYMOL_XCODE
-      /* restore working directory if asked to */
-      PRunStringModule(G,
-                       "if 'PYMOL_WD' in os.environ: os.chdir(os.environ['PYMOL_WD'])");
-      PXDecRef(PYOBJECT_CALLMETHOD(G->P_inst->obj, "launch_gui", "O", G->P_inst->obj));
-#endif
-      /* END PROPRIETARY CODE SEGMENT */
 
       PXDecRef(PYOBJECT_CALLMETHOD
                (G->P_inst->obj, "adapt_to_hardware", "O", G->P_inst->obj));
@@ -2780,7 +2694,7 @@ char *PyMOL_GetClickString(CPyMOL * I, i
   if(reset)
     I->ClickReadyFlag = false;
   if(ready) {
-    result = Alloc(char, OrthoLineLength + 1);
+    result = pymol::malloc<char>(OrthoLineLength + 1);
     if(result) {
       WordType butstr = "left", modstr = "", posstr = "";
       result[0] = 0;
@@ -3131,7 +3045,7 @@ void PyMOL_SetDefaultMouse(CPyMOL * I)
     }
 
   }
-  G->Feedback->Mask[FB_Scene] &= ~(FB_Results); /* suppress click messages */
+  G->Feedback->currentMask(FB_Scene) &= ~(FB_Results); /* suppress click messages */
 PYMOL_API_UNLOCK}
 
 PyMOLreturn_status PyMOL_CmdRock(CPyMOL * I, int mode){
diff -upNr pymol-open-source-2.3.0/layer5/PyMOL.h pymol-open-source-2.3.3/layer5/PyMOL.h
--- pymol-open-source-2.3.0/layer5/PyMOL.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer5/PyMOL.h	2019-08-22 10:24:47.750600902 +0200
@@ -305,9 +305,6 @@ int PyMOL_GetIdleAndReady(CPyMOL * I);
 
 PyMOLreturn_int_array PyMOL_GetReshapeInfo(CPyMOL * I, int reset);
 
-/*PyMOLreturn_int_array PyMOL_GetStereoInfo(CPyMOL *I,int reset);  * to come for MacPyMOL -- blue line, etc */
-
-
 /* string results */
 
 char *PyMOL_GetClickString(CPyMOL * I, int reset);
diff -upNr pymol-open-source-2.3.0/layer5/TestPyMOL.cpp pymol-open-source-2.3.3/layer5/TestPyMOL.cpp
--- pymol-open-source-2.3.0/layer5/TestPyMOL.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/layer5/TestPyMOL.cpp	2019-08-22 10:24:47.750600902 +0200
@@ -79,7 +79,7 @@ static char *get_st(const char array[][S
     l += strlen(array[c]);
     c++;
   }
-  result = Alloc(char, l + 1);
+  result = pymol::malloc<char>(l + 1);
 
   l = 0;
   c = 0;
diff -upNr pymol-open-source-2.3.0/modules/cealign/src/ccealignmodule.cpp pymol-open-source-2.3.3/modules/cealign/src/ccealignmodule.cpp
--- pymol-open-source-2.3.0/modules/cealign/src/ccealignmodule.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/cealign/src/ccealignmodule.cpp	2019-08-22 10:24:47.754601554 +0200
@@ -610,13 +610,6 @@ PyObject* findBest( pcePoint coordsA, pc
     std::cout << "ERROR: Best RMSD found was 1e6.  Broken.\n";
     return NULL;
   }
-	
-  // list of list of pairs	
-  PyObject* rVal = PyList_New(0);
-
-  PyObject* pyRMSD = Py_BuildValue( "f", bestRMSD );
-
-  PyObject* pyAliLen = Py_BuildValue( "i", bestLen );
 
   PyObject* pyU = Py_BuildValue( "[f,f,f,f, f,f,f,f, f,f,f,f, f,f,f,f]",
 				 bestU[0][0], bestU[1][0], bestU[2][0], bestCOM1[0],
@@ -627,17 +620,15 @@ PyObject* findBest( pcePoint coordsA, pc
   PyObject* pyPathA = PyList_New(0);
   PyObject* pyPathB = PyList_New(0);
   for (int j = 0; j < smaller && paths[bestO][j].first != -1; j++) {
-    PyList_Append(pyPathA, Py_BuildValue("i", paths[bestO][j].first));
-    PyList_Append(pyPathB, Py_BuildValue("i", paths[bestO][j].second));
+    PyObject* v = Py_BuildValue("i", paths[bestO][j].first);
+    PyList_Append(pyPathA, v);
+    Py_DECREF(v);
+    v = Py_BuildValue("i", paths[bestO][j].second);
+    PyList_Append(pyPathB, v);
+    Py_DECREF(v);
   }
 
-  PyList_Append(rVal, pyAliLen);
-  PyList_Append(rVal, pyRMSD);
-  PyList_Append(rVal, pyU );
-  PyList_Append(rVal, pyPathA );
-  PyList_Append(rVal, pyPathB );
-
-  return (PyObject*) rVal;
+  return Py_BuildValue("[ifNNN]", bestLen, bestRMSD, pyU, pyPathA, pyPathB);
 }
 
 
diff -upNr pymol-open-source-2.3.0/modules/chempy/arc.py pymol-open-source-2.3.3/modules/chempy/arc.py
--- pymol-open-source-2.3.0/modules/chempy/arc.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/arc.py	2019-08-22 10:24:47.754601554 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -18,7 +18,7 @@ import string
 import copy
 
 class ARC(Storage):
-    
+
 #---------------------------------------------------------------------------------
     def fromFile(self,fname):
         list = []
@@ -35,8 +35,3 @@ class ARC(Storage):
                 list.append(lst)
         f.close()
         return list
-    
-    
-
-
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/bmin/commands.py pymol-open-source-2.3.3/modules/chempy/bmin/commands.py
--- pymol-open-source-2.3.0/modules/chempy/bmin/commands.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/bmin/commands.py	2019-08-22 10:24:47.754601554 +0200
@@ -29,15 +29,14 @@ def bmin_sync(object,iter=500,grad=0.1,i
                       solvation=solvation,
                       rest_flag=2,
                       fix_flag=3)
-    
+
 def pmin():
     cmd.delete('min')
     realtime.assign('lig')
     cmd.create('min','(lig|prot)')
     bmin('min')
-    
+
 cmd.extend('bmin',bmin)
 cmd.extend('bmin_sync',bmin_sync)
 cmd.extend('amin',amin)
 cmd.extend('pmin',pmin)
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/bmin/__init__.py pymol-open-source-2.3.3/modules/chempy/bmin/__init__.py
--- pymol-open-source-2.3.0/modules/chempy/bmin/__init__.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/bmin/__init__.py	2019-08-22 10:24:47.754601554 +0200
@@ -35,7 +35,7 @@ def do(run_prefix):
         time.sleep(0.1)
     if feedback['bmin']:
         os.system("cat bmintmp.log")
-        print(" "+str(__name__)+': bmin job complete. ') 
+        print(" "+str(__name__)+': bmin job complete. ')
         if hasattr(sys.stdout,"flush"):
             sys.stdout.flush()
 
@@ -47,4 +47,3 @@ if 'SCHRODINGER' in os.environ:
 #   bmin_path = os.environ['MMOD_EXEC']+"/bmin"
 else:
     bmin_path = "bmin"
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/bmin/realtime.py pymol-open-source-2.3.3/modules/chempy/bmin/realtime.py
--- pymol-open-source-2.3.0/modules/chempy/bmin/realtime.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/bmin/realtime.py	2019-08-22 10:24:47.754601554 +0200
@@ -20,7 +20,7 @@ def assign(sele,preserve=0):
     import rules
 
     result = 1
-    
+
     state = State()
 
     model = cmd.get_model(sele)
@@ -30,12 +30,12 @@ def assign(sele,preserve=0):
 
     ruleSet.fromList(rules.mmff_types)
     ruleSet.mappingFromList(rules.mmff_mapping)
-    
+
     mobj = MolObj()
     mobj.fromChemPyModel(model)
 
     typed = Typer(molObj = mobj)
-    
+
     print(" realtime: assigning atom types")
     typed.applyRules(ruleSet)
 
@@ -62,10 +62,10 @@ def assign(sele,preserve=0):
     return result
 
 def setup(sele,preserve=0):
-    
+
     global state
     global model
-    
+
     state = State()
     model = cmd.get_model(sele)
 
@@ -80,7 +80,7 @@ def setup(sele,preserve=0):
 def check(obj='check'):
     global state
     global model
-    
+
     if not state:
         if not model:
             print(" realtime.reload: please run setup first.")
@@ -115,7 +115,7 @@ def mini(total_steps=500,
                 cmd.delete(object)
                 cmd.load_model(state.model,object,1)
                 cmd.refresh()
-                if finish!=None:
+                if finish is not None:
                     finish[0](*finish[1], **finish[2])
         except:
             cmd.load_model(state.model,'ref')
@@ -128,7 +128,3 @@ def mini_threaded(*args,**kwargs):
                                 kwargs=kwargs)
     t.setDaemon(1)
     t.start()
-    
-
-
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/bmin/state.py pymol-open-source-2.3.3/modules/chempy/bmin/state.py
--- pymol-open-source-2.3.0/modules/chempy/bmin/state.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/bmin/state.py	2019-08-22 10:24:47.754601554 +0200
@@ -17,13 +17,13 @@ class State:
         self.model = None
         self.counter = 0
         self.prefix = "bmintmp"
-        
+
     def minimize(self,max_iter=100,fix_flag=None,rest_flag=None,
                      rest_coeff = 100.0,solvation=None):
         if feedback['actions']:
             print(' '+str(self.__class__)+': starting minimization run...')
         io.mmd.toFile(self.model,self.prefix+".dat")
-        
+
         f = open(self.prefix+".com",'w')
         # get home-relative path
 #      pth = os.getcwd()
@@ -37,7 +37,7 @@ class State:
         # select forcefield treatments
         if not solvation: # no solvent, constant dielectric
             f.write(" FFLD      10      1      0      1     1.0000     0.0000     0.0000     0.0000\n")
-        else: 
+        else:
             f.write(''' FFLD      10      1      0      1     1.0000     0.0000     0.0000     0.0000
  SOLV       3      1      0      0     0.0000     0.0000     0.0000     0.0000
  EXNB       0      0      0      0     0.0000     0.0000     0.0000     0.0000
@@ -45,7 +45,7 @@ class State:
         # read files
         f.write(" READ       0      0      0      0     0.0000     0.0000     0.0000     0.0000\n")
         # fix/restrain atoms according to flags provided
-        if fix_flag!=None: # are we fixing any atoms?
+        if fix_flag is not None: # are we fixing any atoms?
             c = 0
             mask= 2 ** fix_flag
             for a in self.model.atom:
@@ -53,7 +53,7 @@ class State:
                 if mask&a.flags:
                     f.write(" FXAT  %6d      0      0      0    -1.0000     0.0000     0.0000     0.0000\n"%
                               c)
-        if rest_flag!=None: # are we restraining any atoms?
+        if rest_flag is not None: # are we restraining any atoms?
             c = 0
             mask= 2 ** rest_flag
             for a in self.model.atom:
@@ -67,7 +67,7 @@ class State:
  DEBG 6
  '''%(max_iter))
         f.close()
-        
+
         bmin.do(self.prefix)
         io.mmd.updateFromFile(self.model,self.prefix+".out")
         if hasattr(self.model.molecule,'energy'):
@@ -76,8 +76,3 @@ class State:
         if feedback['verbose']:
             print(' '+str(self.__class__)+': new model loaded.')
         self.model = a
-
-
-
-
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/bmin/util.py pymol-open-source-2.3.3/modules/chempy/bmin/util.py
--- pymol-open-source-2.3.0/modules/chempy/bmin/util.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/bmin/util.py	2019-08-22 10:24:47.754601554 +0200
@@ -10,7 +10,7 @@ import random
 
 def cap(object):
     from pymol import cmd
-    
+
     model = cmd.get_model(object)
     # guarantee identical ordering
     cmd.delete(object)
@@ -57,5 +57,3 @@ def cap(object):
     cmd.delete(object)
     cmd.load_model(model,object)
     cmd.sort(object)
-    
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/bond_amber.py pymol-open-source-2.3.3/modules/chempy/bond_amber.py
--- pymol-open-source-2.3.0/modules/chempy/bond_amber.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/bond_amber.py	2019-08-22 10:24:47.754601554 +0200
@@ -1,20 +1,20 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
 # bond lengths and other information useful for simply building atoms
 #
-# compatible with parm94, 96, or 99 
+# compatible with parm94, 96, or 99
 
 length = {
     ( 'OW', 'HW' ) : 0.9572,
@@ -137,12 +137,12 @@ length = {
 
 for a in list(length.keys()):
     length[(a[1],a[0])]=length[a]
-             
+
 nonlinear = {
     'OW' : 1 ,
     'OH' : 1 ,
     'OS' : 1 ,
-    'P'  : 1 ,   
+    'P'  : 1 ,
     'S'  : 1 ,
     'SH' : 1 ,
 }
@@ -150,7 +150,7 @@ nonlinear = {
 tetrahedral = {
     'CT' : 1 ,
     'N3' : 1 ,
-    'NT' : 1 ,   
+    'NT' : 1 ,
     }
 
 planer = {
@@ -169,7 +169,7 @@ planer = {
     'CW' : 1 ,
     'N'  : 1 ,
     'N*' : 1 ,
-    'N2' : 1 ,   
+    'N2' : 1 ,
     'NA' : 1 ,
     'NB' : 1 ,
     'NC' : 1 ,
diff -upNr pymol-open-source-2.3.0/modules/chempy/bond_mmff.py pymol-open-source-2.3.3/modules/chempy/bond_mmff.py
--- pymol-open-source-2.3.0/modules/chempy/bond_mmff.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/bond_mmff.py	2019-08-22 10:24:47.754601554 +0200
@@ -1,20 +1,20 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
 # bond lengths and other information useful for simply building atoms
 #
-# 
+#
 
 length = {
     ( 'C3', 'H1') : 1.0900,
@@ -151,7 +151,7 @@ tetrahedral = {
 
 planer = {
     'C2' : 1,
-    'CP' : 1, 
+    'CP' : 1,
     'CM' : 1, # ?
     'CR' : 1, # ?
     'O2' : 1,
@@ -163,7 +163,7 @@ planer = {
     '' : 1,
     '' : 1,
     '' : 1,
-    
-    
+
+
     'O2' : 1,
 }
diff -upNr pymol-open-source-2.3.0/modules/chempy/bonds.py pymol-open-source-2.3.3/modules/chempy/bonds.py
--- pymol-open-source-2.3.0/modules/chempy/bonds.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/bonds.py	2019-08-22 10:24:47.754601554 +0200
@@ -1,26 +1,26 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
 bonds = {
 'ACE': [
    { ### names ###
-   '1HH3':0, '3HA' :0, 'HH31':0, 
-   '1HA' :1, '2HH3':1, 'HH32':1, 
-   '2HA' :2, '3HH3':2, 'HH33':2, 
-   'C'   :3, 
-   'CA'  :4, 'CH3' :4, 
-   'O'   :5, 
+   '1HH3':0, '3HA' :0, 'HH31':0,
+   '1HA' :1, '2HH3':1, 'HH32':1,
+   '2HA' :2, '3HH3':2, 'HH33':2,
+   'C'   :3,
+   'CA'  :4, 'CH3' :4,
+   'O'   :5,
    },
    [ ### bonds ###
    ( 0,  4,  1 ),
@@ -31,20 +31,20 @@ bonds = {
    ]],
 'ALA': [
    { ### names ###
-   '1HB' :0, 'HB1' :0, 
-   '1H'  :1, '1HT' :1, 'H1'  :1, 'HT1' :1, 
-   '2HB' :2, 'HB2' :2, 
-   '2H'  :3, '2HT' :3, 'H2'  :3, 'HT2' :3, 
-   '3HB' :4, 'HB3' :4, 
-   '3H'  :5, '3HT' :5, 'H3'  :5, 'HT3' :5, 
-   'C'   :6, 
-   'CA'  :7, 
-   'CB'  :8, 
-   'H'   :9, 'HN'  :9, 
-   'HA'  :10, 'HA2' :10, 
-   'N'   :11, 
-   'O'   :12, 'O1'  :12, 'OT1' :12, 
-   'O2'  :13, 'OT'  :13, 'OT2' :13, 'OXT' :13, 
+   '1HB' :0, 'HB1' :0,
+   '1H'  :1, '1HT' :1, 'H1'  :1, 'HT1' :1,
+   '2HB' :2, 'HB2' :2,
+   '2H'  :3, '2HT' :3, 'H2'  :3, 'HT2' :3,
+   '3HB' :4, 'HB3' :4,
+   '3H'  :5, '3HT' :5, 'H3'  :5, 'HT3' :5,
+   'C'   :6,
+   'CA'  :7,
+   'CB'  :8,
+   'H'   :9, 'HN'  :9,
+   'HA'  :10, 'HA2' :10,
+   'N'   :11,
+   'O'   :12, 'O1'  :12, 'OT1' :12,
+   'O2'  :13, 'OT'  :13, 'OT2' :13, 'OXT' :13,
    },
    [ ### bonds ###
    ( 0,  8,  1 ),
@@ -62,34 +62,34 @@ bonds = {
    ]],
 'ARG': [
    { ### names ###
-   '1HH1':0, 'HH11':0, 
-   '1HH2':1, 'HH21':1, 
-   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2, 
-   '2HB' :3, 'HB2' :3, 
-   '2HD' :4, 'HD2' :4, 
-   '2HG' :5, 'HG2' :5, 
-   '2HH1':6, 'HH12':6, 
-   '2HH2':7, 'HH22':7, 
-   '2H'  :8, '2HT' :8, 'H2'  :8, 'HT2' :8, 
-   '1HB' :9, '3HB' :9, 'HB1' :9, 'HB3' :9, 
-   '1HD' :10, '3HD' :10, 'HD1' :10, 'HD3' :10, 
-   '1HG' :11, '3HG' :11, 'HG1' :11, 'HG3' :11, 
-   '3H'  :12, '3HT' :12, 'H3'  :12, 'HT3' :12, 
-   'C'   :13, 
-   'CA'  :14, 
-   'CB'  :15, 
-   'CD'  :16, 
-   'CG'  :17, 
-   'CZ'  :18, 
-   'H'   :19, 'HN'  :19, 
-   'HA'  :20, 'HA2' :20, 
-   'HE'  :21, 
-   'N'   :22, 
-   'NE'  :23, 
-   'NH1' :24, 
-   'NH2' :25, 
-   'O'   :26, 'O1'  :26, 'OT1' :26, 
-   'O2'  :27, 'OT'  :27, 'OT2' :27, 'OXT' :27, 
+   '1HH1':0, 'HH11':0,
+   '1HH2':1, 'HH21':1,
+   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2,
+   '2HB' :3, 'HB2' :3,
+   '2HD' :4, 'HD2' :4,
+   '2HG' :5, 'HG2' :5,
+   '2HH1':6, 'HH12':6,
+   '2HH2':7, 'HH22':7,
+   '2H'  :8, '2HT' :8, 'H2'  :8, 'HT2' :8,
+   '1HB' :9, '3HB' :9, 'HB1' :9, 'HB3' :9,
+   '1HD' :10, '3HD' :10, 'HD1' :10, 'HD3' :10,
+   '1HG' :11, '3HG' :11, 'HG1' :11, 'HG3' :11,
+   '3H'  :12, '3HT' :12, 'H3'  :12, 'HT3' :12,
+   'C'   :13,
+   'CA'  :14,
+   'CB'  :15,
+   'CD'  :16,
+   'CG'  :17,
+   'CZ'  :18,
+   'H'   :19, 'HN'  :19,
+   'HA'  :20, 'HA2' :20,
+   'HE'  :21,
+   'N'   :22,
+   'NE'  :23,
+   'NH1' :24,
+   'NH2' :25,
+   'O'   :26, 'O1'  :26, 'OT1' :26,
+   'O2'  :27, 'OT'  :27, 'OT2' :27, 'OXT' :27,
    },
    [ ### bonds ###
    ( 0, 24,  1 ),
@@ -121,23 +121,23 @@ bonds = {
    ]],
 'ASH': [
    { ### names ###
-   '1H'  :0, '1HT' :0, 'H1'  :0, 'HT1' :0, 
-   '2HB' :1, 'HB2' :1, 
-   '2H'  :2, '2HT' :2, 'H2'  :2, 'HT2' :2, 
-   '1HB' :3, '3HB' :3, 'HB1' :3, 'HB3' :3, 
-   '3H'  :4, '3HT' :4, 'H3'  :4, 'HT3' :4, 
-   'C'   :5, 
-   'CA'  :6, 
-   'CB'  :7, 
-   'CG'  :8, 
-   'H'   :9, 'HN'  :9, 
-   'HA'  :10, 'HA2' :10, 
-   'HD2' :11, 
-   'N'   :12, 
-   'O'   :13, 'O1'  :13, 'OT1' :13, 
-   'OD1' :14, 
-   'OD2' :15, 
-   'O2'  :16, 'OT'  :16, 'OT2' :16, 'OXT' :16, 
+   '1H'  :0, '1HT' :0, 'H1'  :0, 'HT1' :0,
+   '2HB' :1, 'HB2' :1,
+   '2H'  :2, '2HT' :2, 'H2'  :2, 'HT2' :2,
+   '1HB' :3, '3HB' :3, 'HB1' :3, 'HB3' :3,
+   '3H'  :4, '3HT' :4, 'H3'  :4, 'HT3' :4,
+   'C'   :5,
+   'CA'  :6,
+   'CB'  :7,
+   'CG'  :8,
+   'H'   :9, 'HN'  :9,
+   'HA'  :10, 'HA2' :10,
+   'HD2' :11,
+   'N'   :12,
+   'O'   :13, 'O1'  :13, 'OT1' :13,
+   'OD1' :14,
+   'OD2' :15,
+   'O2'  :16, 'OT'  :16, 'OT2' :16, 'OXT' :16,
    },
    [ ### bonds ###
    ( 0, 12,  1 ),
@@ -158,24 +158,24 @@ bonds = {
    ]],
 'ASN': [
    { ### names ###
-   '1HD2':0, 'HD21':0, 
-   '1H'  :1, '1HT' :1, 'H1'  :1, 'HT1' :1, 
-   '2HB' :2, 'HB2' :2, 
-   '2HD2':3, 'HD22':3, 
-   '2H'  :4, '2HT' :4, 'H2'  :4, 'HT2' :4, 
-   '1HB' :5, '3HB' :5, 'HB1' :5, 'HB3' :5, 
-   '3H'  :6, '3HT' :6, 'H3'  :6, 'HT3' :6, 
-   'C'   :7, 
-   'CA'  :8, 
-   'CB'  :9, 
-   'CG'  :10, 
-   'H'   :11, 'HN'  :11, 
-   'HA'  :12, 'HA2' :12, 
-   'N'   :13, 
-   'ND2' :14, 
-   'O'   :15, 'O1'  :15, 'OT1' :15, 
-   'OD1' :16, 
-   'O2'  :17, 'OT'  :17, 'OT2' :17, 'OXT' :17, 
+   '1HD2':0, 'HD21':0,
+   '1H'  :1, '1HT' :1, 'H1'  :1, 'HT1' :1,
+   '2HB' :2, 'HB2' :2,
+   '2HD2':3, 'HD22':3,
+   '2H'  :4, '2HT' :4, 'H2'  :4, 'HT2' :4,
+   '1HB' :5, '3HB' :5, 'HB1' :5, 'HB3' :5,
+   '3H'  :6, '3HT' :6, 'H3'  :6, 'HT3' :6,
+   'C'   :7,
+   'CA'  :8,
+   'CB'  :9,
+   'CG'  :10,
+   'H'   :11, 'HN'  :11,
+   'HA'  :12, 'HA2' :12,
+   'N'   :13,
+   'ND2' :14,
+   'O'   :15, 'O1'  :15, 'OT1' :15,
+   'OD1' :16,
+   'O2'  :17, 'OT'  :17, 'OT2' :17, 'OXT' :17,
    },
    [ ### bonds ###
    ( 0, 14,  1 ),
@@ -197,22 +197,22 @@ bonds = {
    ]],
 'ASP': [
    { ### names ###
-   '1H'  :0, '1HT' :0, 'H1'  :0, 'HT1' :0, 
-   '2HB' :1, 'HB2' :1, 
-   '2H'  :2, '2HT' :2, 'H2'  :2, 'HT2' :2, 
-   '1HB' :3, '3HB' :3, 'HB1' :3, 'HB3' :3, 
-   '3H'  :4, '3HT' :4, 'H3'  :4, 'HT3' :4, 
-   'C'   :5, 
-   'CA'  :6, 
-   'CB'  :7, 
-   'CG'  :8, 
-   'H'   :9, 'HN'  :9, 
-   'HA'  :10, 'HA2' :10, 
-   'N'   :11, 
-   'O'   :12, 'O1'  :12, 'OT1' :12, 
-   'OD1' :13, 
-   'OD2' :14, 
-   'O2'  :15, 'OT'  :15, 'OT2' :15, 'OXT' :15, 
+   '1H'  :0, '1HT' :0, 'H1'  :0, 'HT1' :0,
+   '2HB' :1, 'HB2' :1,
+   '2H'  :2, '2HT' :2, 'H2'  :2, 'HT2' :2,
+   '1HB' :3, '3HB' :3, 'HB1' :3, 'HB3' :3,
+   '3H'  :4, '3HT' :4, 'H3'  :4, 'HT3' :4,
+   'C'   :5,
+   'CA'  :6,
+   'CB'  :7,
+   'CG'  :8,
+   'H'   :9, 'HN'  :9,
+   'HA'  :10, 'HA2' :10,
+   'N'   :11,
+   'O'   :12, 'O1'  :12, 'OT1' :12,
+   'OD1' :13,
+   'OD2' :14,
+   'O2'  :15, 'OT'  :15, 'OT2' :15, 'OXT' :15,
    },
    [ ### bonds ###
    ( 0, 11,  1 ),
@@ -232,16 +232,16 @@ bonds = {
    ]],
 'CYM': [
    { ### names ###
-   '2HB' :0, 'HB2' :0, 
-   '3HB' :1, 'HB3' :1, 
-   'C'   :2, 
-   'CA'  :3, 
-   'CB'  :4, 
-   'H'   :5, 'HN'  :5, 
-   'HA'  :6, 'HA2' :6, 
-   'N'   :7, 
-   'O'   :8, 
-   'SG'  :9, 
+   '2HB' :0, 'HB2' :0,
+   '3HB' :1, 'HB3' :1,
+   'C'   :2,
+   'CA'  :3,
+   'CB'  :4,
+   'H'   :5, 'HN'  :5,
+   'HA'  :6, 'HA2' :6,
+   'N'   :7,
+   'O'   :8,
+   'SG'  :9,
    },
    [ ### bonds ###
    ( 0,  4,  1 ),
@@ -256,21 +256,21 @@ bonds = {
    ]],
 'CYS': [
    { ### names ###
-   '1H'  :0, '1HT' :0, 'H1'  :0, 'HT1' :0, 
-   '2HB' :1, 'HB2' :1, 
-   '2H'  :2, '2HT' :2, 'H2'  :2, 'HT2' :2, 
-   '1HB' :3, '3HB' :3, 'HB1' :3, 'HB3' :3, 
-   '3H'  :4, '3HT' :4, 'H3'  :4, 'HT3' :4, 
-   'C'   :5, 
-   'CA'  :6, 
-   'CB'  :7, 
-   'H'   :8, 'HN'  :8, 
-   'HA'  :9, 'HA2' :9, 
-   'HG'  :10, 'HG1' :10, 
-   'N'   :11, 
-   'O'   :12, 'O1'  :12, 'OT1' :12, 
-   'O2'  :13, 'OT'  :13, 'OT2' :13, 'OXT' :13, 
-   'SG'  :14, 
+   '1H'  :0, '1HT' :0, 'H1'  :0, 'HT1' :0,
+   '2HB' :1, 'HB2' :1,
+   '2H'  :2, '2HT' :2, 'H2'  :2, 'HT2' :2,
+   '1HB' :3, '3HB' :3, 'HB1' :3, 'HB3' :3,
+   '3H'  :4, '3HT' :4, 'H3'  :4, 'HT3' :4,
+   'C'   :5,
+   'CA'  :6,
+   'CB'  :7,
+   'H'   :8, 'HN'  :8,
+   'HA'  :9, 'HA2' :9,
+   'HG'  :10, 'HG1' :10,
+   'N'   :11,
+   'O'   :12, 'O1'  :12, 'OT1' :12,
+   'O2'  :13, 'OT'  :13, 'OT2' :13, 'OXT' :13,
+   'SG'  :14,
    },
    [ ### bonds ###
    ( 0, 11,  1 ),
@@ -289,20 +289,20 @@ bonds = {
    ]],
 'CYX': [
    { ### names ###
-   '1H'  :0, '1HT' :0, 'H1'  :0, 'HT1' :0, 
-   '2HB' :1, 'HB2' :1, 
-   '2H'  :2, '2HT' :2, 'H2'  :2, 'HT2' :2, 
-   '1HB' :3, '3HB' :3, 'HB1' :3, 'HB3' :3, 
-   '3H'  :4, '3HT' :4, 'H3'  :4, 'HT3' :4, 
-   'C'   :5, 
-   'CA'  :6, 
-   'CB'  :7, 
-   'H'   :8, 'HN'  :8, 
-   'HA'  :9, 'HA2' :9, 
-   'N'   :10, 
-   'O'   :11, 'O1'  :11, 'OT1' :11, 
-   'O2'  :12, 'OT'  :12, 'OT2' :12, 'OXT' :12, 
-   'SG'  :13, 
+   '1H'  :0, '1HT' :0, 'H1'  :0, 'HT1' :0,
+   '2HB' :1, 'HB2' :1,
+   '2H'  :2, '2HT' :2, 'H2'  :2, 'HT2' :2,
+   '1HB' :3, '3HB' :3, 'HB1' :3, 'HB3' :3,
+   '3H'  :4, '3HT' :4, 'H3'  :4, 'HT3' :4,
+   'C'   :5,
+   'CA'  :6,
+   'CB'  :7,
+   'H'   :8, 'HN'  :8,
+   'HA'  :9, 'HA2' :9,
+   'N'   :10,
+   'O'   :11, 'O1'  :11, 'OT1' :11,
+   'O2'  :12, 'OT'  :12, 'OT2' :12, 'OXT' :12,
+   'SG'  :13,
    },
    [ ### bonds ###
    ( 0, 10,  1 ),
@@ -320,27 +320,27 @@ bonds = {
    ]],
 'GLN': [
    { ### names ###
-   '1HE2':0, 'HE21':0, 
-   '1H'  :1, '1HT' :1, 'H1'  :1, 'HT1' :1, 
-   '2HB' :2, 'HB2' :2, 
-   '2HE2':3, 'HE22':3, 
-   '2HG' :4, 'HG2' :4, 
-   '2H'  :5, '2HT' :5, 'H2'  :5, 'HT2' :5, 
-   '1HB' :6, '3HB' :6, 'HB1' :6, 'HB3' :6, 
-   '1HG' :7, '3HG' :7, 'HG1' :7, 'HG3' :7, 
-   '3H'  :8, '3HT' :8, 'H3'  :8, 'HT3' :8, 
-   'C'   :9, 
-   'CA'  :10, 
-   'CB'  :11, 
-   'CD'  :12, 
-   'CG'  :13, 
-   'H'   :14, 'HN'  :14, 
-   'HA'  :15, 'HA2' :15, 
-   'N'   :16, 
-   'NE2' :17, 
-   'O'   :18, 'O1'  :18, 'OT1' :18, 
-   'OE1' :19, 
-   'O2'  :20, 'OT'  :20, 'OT2' :20, 'OXT' :20, 
+   '1HE2':0, 'HE21':0,
+   '1H'  :1, '1HT' :1, 'H1'  :1, 'HT1' :1,
+   '2HB' :2, 'HB2' :2,
+   '2HE2':3, 'HE22':3,
+   '2HG' :4, 'HG2' :4,
+   '2H'  :5, '2HT' :5, 'H2'  :5, 'HT2' :5,
+   '1HB' :6, '3HB' :6, 'HB1' :6, 'HB3' :6,
+   '1HG' :7, '3HG' :7, 'HG1' :7, 'HG3' :7,
+   '3H'  :8, '3HT' :8, 'H3'  :8, 'HT3' :8,
+   'C'   :9,
+   'CA'  :10,
+   'CB'  :11,
+   'CD'  :12,
+   'CG'  :13,
+   'H'   :14, 'HN'  :14,
+   'HA'  :15, 'HA2' :15,
+   'N'   :16,
+   'NE2' :17,
+   'O'   :18, 'O1'  :18, 'OT1' :18,
+   'OE1' :19,
+   'O2'  :20, 'OT'  :20, 'OT2' :20, 'OXT' :20,
    },
    [ ### bonds ###
    ( 0, 17,  1 ),
@@ -365,26 +365,26 @@ bonds = {
    ]],
 'GLP': [
    { ### names ###
-   '1H'  :0, '1HT' :0, 'H1'  :0, 'HT1' :0, 
-   '2HB' :1, 'HB2' :1, 
-   '2HG' :2, 'HG2' :2, 
-   '2H'  :3, '2HT' :3, 'H2'  :3, 'HT2' :3, 
-   '1HB' :4, '3HB' :4, 'HB1' :4, 'HB3' :4, 
-   '1HG' :5, '3HG' :5, 'HG1' :5, 'HG3' :5, 
-   '3H'  :6, '3HT' :6, 'H3'  :6, 'HT3' :6, 
-   'C'   :7, 
-   'CA'  :8, 
-   'CB'  :9, 
-   'CD'  :10, 
-   'CG'  :11, 
-   'H'   :12, 'HN'  :12, 
-   'HA'  :13, 'HA2' :13, 
-   'HE2' :14, 
-   'N'   :15, 
-   'O'   :16, 'O1'  :16, 'OT1' :16, 
-   'OE1' :17, 
-   'OE2' :18, 
-   'O2'  :19, 'OT'  :19, 'OT2' :19, 'OXT' :19, 
+   '1H'  :0, '1HT' :0, 'H1'  :0, 'HT1' :0,
+   '2HB' :1, 'HB2' :1,
+   '2HG' :2, 'HG2' :2,
+   '2H'  :3, '2HT' :3, 'H2'  :3, 'HT2' :3,
+   '1HB' :4, '3HB' :4, 'HB1' :4, 'HB3' :4,
+   '1HG' :5, '3HG' :5, 'HG1' :5, 'HG3' :5,
+   '3H'  :6, '3HT' :6, 'H3'  :6, 'HT3' :6,
+   'C'   :7,
+   'CA'  :8,
+   'CB'  :9,
+   'CD'  :10,
+   'CG'  :11,
+   'H'   :12, 'HN'  :12,
+   'HA'  :13, 'HA2' :13,
+   'HE2' :14,
+   'N'   :15,
+   'O'   :16, 'O1'  :16, 'OT1' :16,
+   'OE1' :17,
+   'OE2' :18,
+   'O2'  :19, 'OT'  :19, 'OT2' :19, 'OXT' :19,
    },
    [ ### bonds ###
    ( 0, 15,  1 ),
@@ -408,25 +408,25 @@ bonds = {
    ]],
 'GLU': [
    { ### names ###
-   '1H'  :0, '1HT' :0, 'H1'  :0, 'HT1' :0, 
-   '2HB' :1, 'HB2' :1, 
-   '2HG' :2, 'HG2' :2, 
-   '2H'  :3, '2HT' :3, 'H2'  :3, 'HT2' :3, 
-   '1HB' :4, '3HB' :4, 'HB1' :4, 'HB3' :4, 
-   '1HG' :5, '3HG' :5, 'HG1' :5, 'HG3' :5, 
-   '3H'  :6, '3HT' :6, 'H3'  :6, 'HT3' :6, 
-   'C'   :7, 
-   'CA'  :8, 
-   'CB'  :9, 
-   'CD'  :10, 
-   'CG'  :11, 
-   'H'   :12, 'HN'  :12, 
-   'HA'  :13, 'HA2' :13, 
-   'N'   :14, 
-   'O'   :15, 'O1'  :15, 'OT1' :15, 
-   'OE1' :16, 
-   'OE2' :17, 
-   'O2'  :18, 'OT'  :18, 'OT2' :18, 'OXT' :18, 
+   '1H'  :0, '1HT' :0, 'H1'  :0, 'HT1' :0,
+   '2HB' :1, 'HB2' :1,
+   '2HG' :2, 'HG2' :2,
+   '2H'  :3, '2HT' :3, 'H2'  :3, 'HT2' :3,
+   '1HB' :4, '3HB' :4, 'HB1' :4, 'HB3' :4,
+   '1HG' :5, '3HG' :5, 'HG1' :5, 'HG3' :5,
+   '3H'  :6, '3HT' :6, 'H3'  :6, 'HT3' :6,
+   'C'   :7,
+   'CA'  :8,
+   'CB'  :9,
+   'CD'  :10,
+   'CG'  :11,
+   'H'   :12, 'HN'  :12,
+   'HA'  :13, 'HA2' :13,
+   'N'   :14,
+   'O'   :15, 'O1'  :15, 'OT1' :15,
+   'OE1' :16,
+   'OE2' :17,
+   'O2'  :18, 'OT'  :18, 'OT2' :18, 'OXT' :18,
    },
    [ ### bonds ###
    ( 0, 14,  1 ),
@@ -449,17 +449,17 @@ bonds = {
    ]],
 'GLY': [
    { ### names ###
-   '1H'  :0, '1HT' :0, 'H1'  :0, 'HT1' :0, 
-   '2H'  :1, '2HT' :1, 'H2'  :1, 'HT2' :1, 
-   '1HA' :2, '3HA' :2, 'HA1' :2, 'HA3' :2, 
-   '3H'  :3, '3HT' :3, 'H3'  :3, 'HT3' :3, 
-   'C'   :4, 
-   'CA'  :5, 
-   'H'   :6, 'HN'  :6, 
-   '2HA' :7, 'HA'  :7, 'HA2' :7, 
-   'N'   :8, 
-   'O'   :9, 'O1'  :9, 'OT1' :9, 
-   'O2'  :10, 'OT'  :10, 'OT2' :10, 'OXT' :10, 
+   '1H'  :0, '1HT' :0, 'H1'  :0, 'HT1' :0,
+   '2H'  :1, '2HT' :1, 'H2'  :1, 'HT2' :1,
+   '1HA' :2, '3HA' :2, 'HA1' :2, 'HA3' :2,
+   '3H'  :3, '3HT' :3, 'H3'  :3, 'HT3' :3,
+   'C'   :4,
+   'CA'  :5,
+   'H'   :6, 'HN'  :6,
+   '2HA' :7, 'HA'  :7, 'HA2' :7,
+   'N'   :8,
+   'O'   :9, 'O1'  :9, 'OT1' :9,
+   'O2'  :10, 'OT'  :10, 'OT2' :10, 'OXT' :10,
    },
    [ ### bonds ###
    ( 0,  8,  1 ),
@@ -474,27 +474,27 @@ bonds = {
    ]],
 'HID': [
    { ### names ###
-   '1HD' :0, 'HD1' :0, 
-   '1HE' :1, 'HE1' :1, 
-   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2, 
-   '2HB' :3, 'HB2' :3, 
-   '2HD' :4, 'HD2' :4, 
-   '2H'  :5, '2HT' :5, 'H2'  :5, 'HT2' :5, 
-   '1HB' :6, '3HB' :6, 'HB1' :6, 'HB3' :6, 
-   '3H'  :7, '3HT' :7, 'H3'  :7, 'HT3' :7, 
-   'C'   :8, 
-   'CA'  :9, 
-   'CB'  :10, 
-   'CD2' :11, 
-   'CE1' :12, 
-   'CG'  :13, 
-   'H'   :14, 'HN'  :14, 
-   'HA'  :15, 'HA2' :15, 
-   'N'   :16, 
-   'ND1' :17, 
-   'NE2' :18, 
-   'O'   :19, 'O1'  :19, 'OT1' :19, 
-   'O2'  :20, 'OT'  :20, 'OT2' :20, 'OXT' :20, 
+   '1HD' :0, 'HD1' :0,
+   '1HE' :1, 'HE1' :1,
+   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2,
+   '2HB' :3, 'HB2' :3,
+   '2HD' :4, 'HD2' :4,
+   '2H'  :5, '2HT' :5, 'H2'  :5, 'HT2' :5,
+   '1HB' :6, '3HB' :6, 'HB1' :6, 'HB3' :6,
+   '3H'  :7, '3HT' :7, 'H3'  :7, 'HT3' :7,
+   'C'   :8,
+   'CA'  :9,
+   'CB'  :10,
+   'CD2' :11,
+   'CE1' :12,
+   'CG'  :13,
+   'H'   :14, 'HN'  :14,
+   'HA'  :15, 'HA2' :15,
+   'N'   :16,
+   'ND1' :17,
+   'NE2' :18,
+   'O'   :19, 'O1'  :19, 'OT1' :19,
+   'O2'  :20, 'OT'  :20, 'OT2' :20, 'OXT' :20,
    },
    [ ### bonds ###
    ( 0, 17,  1 ),
@@ -520,27 +520,27 @@ bonds = {
    ]],
 'HIE': [
    { ### names ###
-   '1HE' :0, 'HE1' :0, 
-   '1H'  :1, '1HT' :1, 'H1'  :1, 'HT1' :1, 
-   '2HB' :2, 'HB2' :2, 
-   '2HD' :3, 'HD1' :3, 'HD2' :3, 
-   '2HE' :4, 'HE2' :4, 
-   '2H'  :5, '2HT' :5, 'H2'  :5, 'HT2' :5, 
-   '1HB' :6, '3HB' :6, 'HB1' :6, 'HB3' :6, 
-   '3H'  :7, '3HT' :7, 'H3'  :7, 'HT3' :7, 
-   'C'   :8, 
-   'CA'  :9, 
-   'CB'  :10, 
-   'CD2' :11, 
-   'CE1' :12, 
-   'CG'  :13, 
-   'H'   :14, 'HN'  :14, 
-   'HA'  :15, 'HA2' :15, 
-   'N'   :16, 
-   'ND1' :17, 
-   'NE2' :18, 
-   'O'   :19, 'O1'  :19, 'OT1' :19, 
-   'O2'  :20, 'OT'  :20, 'OT2' :20, 'OXT' :20, 
+   '1HE' :0, 'HE1' :0,
+   '1H'  :1, '1HT' :1, 'H1'  :1, 'HT1' :1,
+   '2HB' :2, 'HB2' :2,
+   '2HD' :3, 'HD1' :3, 'HD2' :3,
+   '2HE' :4, 'HE2' :4,
+   '2H'  :5, '2HT' :5, 'H2'  :5, 'HT2' :5,
+   '1HB' :6, '3HB' :6, 'HB1' :6, 'HB3' :6,
+   '3H'  :7, '3HT' :7, 'H3'  :7, 'HT3' :7,
+   'C'   :8,
+   'CA'  :9,
+   'CB'  :10,
+   'CD2' :11,
+   'CE1' :12,
+   'CG'  :13,
+   'H'   :14, 'HN'  :14,
+   'HA'  :15, 'HA2' :15,
+   'N'   :16,
+   'ND1' :17,
+   'NE2' :18,
+   'O'   :19, 'O1'  :19, 'OT1' :19,
+   'O2'  :20, 'OT'  :20, 'OT2' :20, 'OXT' :20,
    },
    [ ### bonds ###
    ( 0, 12,  1 ),
@@ -566,28 +566,28 @@ bonds = {
    ]],
 'HIP': [
    { ### names ###
-   '1HD' :0, 'HD1' :0, 
-   '1HE' :1, 'HE1' :1, 
-   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2, 
-   '2HB' :3, 'HB2' :3, 
-   '2HD' :4, 'HD2' :4, 
-   '2HE' :5, 'HE2' :5, 
-   '2H'  :6, '2HT' :6, 'H2'  :6, 'HT2' :6, 
-   '1HB' :7, '3HB' :7, 'HB1' :7, 'HB3' :7, 
-   '3H'  :8, '3HT' :8, 'H3'  :8, 'HT3' :8, 
-   'C'   :9, 
-   'CA'  :10, 
-   'CB'  :11, 
-   'CD2' :12, 
-   'CE1' :13, 
-   'CG'  :14, 
-   'H'   :15, 'HN'  :15, 
-   'HA'  :16, 'HA2' :16, 
-   'N'   :17, 
-   'ND1' :18, 
-   'NE2' :19, 
-   'O'   :20, 'O1'  :20, 'OT1' :20, 
-   'O2'  :21, 'OT'  :21, 'OT2' :21, 'OXT' :21, 
+   '1HD' :0, 'HD1' :0,
+   '1HE' :1, 'HE1' :1,
+   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2,
+   '2HB' :3, 'HB2' :3,
+   '2HD' :4, 'HD2' :4,
+   '2HE' :5, 'HE2' :5,
+   '2H'  :6, '2HT' :6, 'H2'  :6, 'HT2' :6,
+   '1HB' :7, '3HB' :7, 'HB1' :7, 'HB3' :7,
+   '3H'  :8, '3HT' :8, 'H3'  :8, 'HT3' :8,
+   'C'   :9,
+   'CA'  :10,
+   'CB'  :11,
+   'CD2' :12,
+   'CE1' :13,
+   'CG'  :14,
+   'H'   :15, 'HN'  :15,
+   'HA'  :16, 'HA2' :16,
+   'N'   :17,
+   'ND1' :18,
+   'NE2' :19,
+   'O'   :20, 'O1'  :20, 'OT1' :20,
+   'O2'  :21, 'OT'  :21, 'OT2' :21, 'OXT' :21,
    },
    [ ### bonds ###
    ( 0, 18,  1 ),
@@ -614,29 +614,29 @@ bonds = {
    ]],
 'ILE': [
    { ### names ###
-   '1HD1':0, 'HD1' :0, 'HD11':0, 
-   '1HG2':1, 'HG21':1, 
-   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2, 
-   '2HD1':3, 'HD12':3, 'HD2' :3, 
-   '2HG1':4, 'HG12':4, 
-   '2HG2':5, 'HG22':5, 
-   '2H'  :6, '2HT' :6, 'H2'  :6, 'HT2' :6, 
-   '3HD1':7, 'HD13':7, 'HD3' :7, 
-   '1HG1':8, '3HG1':8, 'HG11':8, 'HG13':8, 
-   '3HG2':9, 'HG23':9, 
-   '3H'  :10, '3HT' :10, 'H3'  :10, 'HT3' :10, 
-   'C'   :11, 
-   'CA'  :12, 
-   'CB'  :13, 
-   'CD'  :14, 'CD1' :14, 
-   'CG1' :15, 
-   'CG2' :16, 
-   'H'   :17, 'HN'  :17, 
-   'HA'  :18, 'HA2' :18, 
-   'HB'  :19, 
-   'N'   :20, 
-   'O'   :21, 'O1'  :21, 'OT1' :21, 
-   'O2'  :22, 'OT'  :22, 'OT2' :22, 'OXT' :22, 
+   '1HD1':0, 'HD1' :0, 'HD11':0,
+   '1HG2':1, 'HG21':1,
+   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2,
+   '2HD1':3, 'HD12':3, 'HD2' :3,
+   '2HG1':4, 'HG12':4,
+   '2HG2':5, 'HG22':5,
+   '2H'  :6, '2HT' :6, 'H2'  :6, 'HT2' :6,
+   '3HD1':7, 'HD13':7, 'HD3' :7,
+   '1HG1':8, '3HG1':8, 'HG11':8, 'HG13':8,
+   '3HG2':9, 'HG23':9,
+   '3H'  :10, '3HT' :10, 'H3'  :10, 'HT3' :10,
+   'C'   :11,
+   'CA'  :12,
+   'CB'  :13,
+   'CD'  :14, 'CD1' :14,
+   'CG1' :15,
+   'CG2' :16,
+   'H'   :17, 'HN'  :17,
+   'HA'  :18, 'HA2' :18,
+   'HB'  :19,
+   'N'   :20,
+   'O'   :21, 'O1'  :21, 'OT1' :21,
+   'O2'  :22, 'OT'  :22, 'OT2' :22, 'OXT' :22,
    },
    [ ### bonds ###
    ( 0, 14,  1 ),
@@ -663,29 +663,29 @@ bonds = {
    ]],
 'LEU': [
    { ### names ###
-   '1HD1':0, 'HD11':0, 
-   '1HD2':1, 'HD21':1, 
-   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2, 
-   '2HB' :3, 'HB2' :3, 
-   '2HD1':4, 'HD12':4, 
-   '2HD2':5, 'HD22':5, 
-   '2H'  :6, '2HT' :6, 'H2'  :6, 'HT2' :6, 
-   '1HB' :7, '3HB' :7, 'HB1' :7, 'HB3' :7, 
-   '3HD1':8, 'HD13':8, 
-   '3HD2':9, 'HD23':9, 
-   '3H'  :10, '3HT' :10, 'H3'  :10, 'HT3' :10, 
-   'C'   :11, 
-   'CA'  :12, 
-   'CB'  :13, 
-   'CD1' :14, 
-   'CD2' :15, 
-   'CG'  :16, 
-   'H'   :17, 'HN'  :17, 
-   'HA'  :18, 'HA2' :18, 
-   'HG'  :19, 
-   'N'   :20, 
-   'O'   :21, 'O1'  :21, 'OT1' :21, 
-   'O2'  :22, 'OT'  :22, 'OT2' :22, 'OXT' :22, 
+   '1HD1':0, 'HD11':0,
+   '1HD2':1, 'HD21':1,
+   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2,
+   '2HB' :3, 'HB2' :3,
+   '2HD1':4, 'HD12':4,
+   '2HD2':5, 'HD22':5,
+   '2H'  :6, '2HT' :6, 'H2'  :6, 'HT2' :6,
+   '1HB' :7, '3HB' :7, 'HB1' :7, 'HB3' :7,
+   '3HD1':8, 'HD13':8,
+   '3HD2':9, 'HD23':9,
+   '3H'  :10, '3HT' :10, 'H3'  :10, 'HT3' :10,
+   'C'   :11,
+   'CA'  :12,
+   'CB'  :13,
+   'CD1' :14,
+   'CD2' :15,
+   'CG'  :16,
+   'H'   :17, 'HN'  :17,
+   'HA'  :18, 'HA2' :18,
+   'HG'  :19,
+   'N'   :20,
+   'O'   :21, 'O1'  :21, 'OT1' :21,
+   'O2'  :22, 'OT'  :22, 'OT2' :22, 'OXT' :22,
    },
    [ ### bonds ###
    ( 0, 14,  1 ),
@@ -712,32 +712,32 @@ bonds = {
    ]],
 'LYS': [
    { ### names ###
-   '1H'  :0, '1HT' :0, 'H1'  :0, 'HT1' :0, 
-   '1HZ' :1, 'HZ1' :1, 
-   '2HB' :2, 'HB2' :2, 
-   '2HD' :3, 'HD2' :3, 
-   '2HE' :4, 'HE2' :4, 
-   '2HG' :5, 'HG2' :5, 
-   '2H'  :6, '2HT' :6, 'H2'  :6, 'HT2' :6, 
-   '2HZ' :7, 'HZ2' :7, 
-   '1HB' :8, '3HB' :8, 'HB1' :8, 'HB3' :8, 
-   '1HD' :9, '3HD' :9, 'HD1' :9, 'HD3' :9, 
-   '1HE' :10, '3HE' :10, 'HE1' :10, 'HE3' :10, 
-   '1HG' :11, '3HG' :11, 'HG1' :11, 'HG3' :11, 
-   '3H'  :12, '3HT' :12, 'H3'  :12, 'HT3' :12, 
-   '3HZ' :13, 'HZ3' :13, 
-   'C'   :14, 
-   'CA'  :15, 
-   'CB'  :16, 
-   'CD'  :17, 
-   'CE'  :18, 
-   'CG'  :19, 
-   'H'   :20, 'HN'  :20, 
-   'HA'  :21, 'HA2' :21, 
-   'N'   :22, 
-   'NZ'  :23, 
-   'O'   :24, 'O1'  :24, 'OT1' :24, 
-   'O2'  :25, 'OT'  :25, 'OT2' :25, 'OXT' :25, 
+   '1H'  :0, '1HT' :0, 'H1'  :0, 'HT1' :0,
+   '1HZ' :1, 'HZ1' :1,
+   '2HB' :2, 'HB2' :2,
+   '2HD' :3, 'HD2' :3,
+   '2HE' :4, 'HE2' :4,
+   '2HG' :5, 'HG2' :5,
+   '2H'  :6, '2HT' :6, 'H2'  :6, 'HT2' :6,
+   '2HZ' :7, 'HZ2' :7,
+   '1HB' :8, '3HB' :8, 'HB1' :8, 'HB3' :8,
+   '1HD' :9, '3HD' :9, 'HD1' :9, 'HD3' :9,
+   '1HE' :10, '3HE' :10, 'HE1' :10, 'HE3' :10,
+   '1HG' :11, '3HG' :11, 'HG1' :11, 'HG3' :11,
+   '3H'  :12, '3HT' :12, 'H3'  :12, 'HT3' :12,
+   '3HZ' :13, 'HZ3' :13,
+   'C'   :14,
+   'CA'  :15,
+   'CB'  :16,
+   'CD'  :17,
+   'CE'  :18,
+   'CG'  :19,
+   'H'   :20, 'HN'  :20,
+   'HA'  :21, 'HA2' :21,
+   'N'   :22,
+   'NZ'  :23,
+   'O'   :24, 'O1'  :24, 'OT1' :24,
+   'O2'  :25, 'OT'  :25, 'OT2' :25, 'OXT' :25,
    },
    [ ### bonds ###
    ( 0, 22,  1 ),
@@ -767,27 +767,27 @@ bonds = {
    ]],
 'MET': [
    { ### names ###
-   '1HE' :0, 'HE1' :0, 
-   '1H'  :1, '1HT' :1, 'H1'  :1, 'HT1' :1, 
-   '2HB' :2, 'HB2' :2, 
-   '2HE' :3, 'HE2' :3, 
-   '2HG' :4, 'HG2' :4, 
-   '2H'  :5, '2HT' :5, 'H2'  :5, 'HT2' :5, 
-   '1HB' :6, '3HB' :6, 'HB1' :6, 'HB3' :6, 
-   '3HE' :7, 'HE3' :7, 
-   '1HG' :8, '3HG' :8, 'HG1' :8, 'HG3' :8, 
-   '3H'  :9, '3HT' :9, 'H3'  :9, 'HT3' :9, 
-   'C'   :10, 
-   'CA'  :11, 
-   'CB'  :12, 
-   'CE'  :13, 
-   'CG'  :14, 
-   'H'   :15, 'HN'  :15, 
-   'HA'  :16, 'HA2' :16, 
-   'N'   :17, 
-   'O'   :18, 'O1'  :18, 'OT1' :18, 
-   'O2'  :19, 'OT'  :19, 'OT2' :19, 'OXT' :19, 
-   'SD'  :20, 
+   '1HE' :0, 'HE1' :0,
+   '1H'  :1, '1HT' :1, 'H1'  :1, 'HT1' :1,
+   '2HB' :2, 'HB2' :2,
+   '2HE' :3, 'HE2' :3,
+   '2HG' :4, 'HG2' :4,
+   '2H'  :5, '2HT' :5, 'H2'  :5, 'HT2' :5,
+   '1HB' :6, '3HB' :6, 'HB1' :6, 'HB3' :6,
+   '3HE' :7, 'HE3' :7,
+   '1HG' :8, '3HG' :8, 'HG1' :8, 'HG3' :8,
+   '3H'  :9, '3HT' :9, 'H3'  :9, 'HT3' :9,
+   'C'   :10,
+   'CA'  :11,
+   'CB'  :12,
+   'CE'  :13,
+   'CG'  :14,
+   'H'   :15, 'HN'  :15,
+   'HA'  :16, 'HA2' :16,
+   'N'   :17,
+   'O'   :18, 'O1'  :18, 'OT1' :18,
+   'O2'  :19, 'OT'  :19, 'OT2' :19, 'OXT' :19,
+   'SD'  :20,
    },
    [ ### bonds ###
    ( 0, 13,  1 ),
@@ -812,12 +812,12 @@ bonds = {
    ]],
 'NME': [
    { ### names ###
-   '1HA' :0, '1HH3':0, 'H02' :0, 'HH31':0, 
-   '2HA' :1, '2HH3':1, 'H03' :1, 'HH32':1, 
-   '3HA' :2, '3HH3':2, 'H04' :2, 'HH33':2, 
-   'C01' :3, 'CA'  :3, 'CH3' :3, 
-   'H'   :4, 'H01' :4, 'HN'  :4, 
-   'N'   :5, 'N01' :5, 
+   '1HA' :0, '1HH3':0, 'H02' :0, 'HH31':0,
+   '2HA' :1, '2HH3':1, 'H03' :1, 'HH32':1,
+   '3HA' :2, '3HH3':2, 'H04' :2, 'HH33':2,
+   'C01' :3, 'CA'  :3, 'CH3' :3,
+   'H'   :4, 'H01' :4, 'HN'  :4,
+   'N'   :5, 'N01' :5,
    },
    [ ### bonds ###
    ( 0,  3,  1 ),
@@ -828,30 +828,30 @@ bonds = {
    ]],
 'PHE': [
    { ### names ###
-   '1HD' :0, 'HD1' :0, 
-   '1HE' :1, 'HE1' :1, 
-   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2, 
-   '2HB' :3, 'HB2' :3, 
-   '2HD' :4, 'HD2' :4, 
-   '2HE' :5, 'HE2' :5, 
-   '2H'  :6, '2HT' :6, 'H2'  :6, 'HT2' :6, 
-   '1HB' :7, '3HB' :7, 'HB1' :7, 'HB3' :7, 
-   '3H'  :8, '3HT' :8, 'H3'  :8, 'HT3' :8, 
-   'C'   :9, 
-   'CA'  :10, 
-   'CB'  :11, 
-   'CD1' :12, 
-   'CD2' :13, 
-   'CE1' :14, 
-   'CE2' :15, 
-   'CG'  :16, 
-   'CZ'  :17, 
-   'H'   :18, 'HN'  :18, 
-   'HA'  :19, 'HA2' :19, 
-   'HZ'  :20, 
-   'N'   :21, 
-   'O'   :22, 'O1'  :22, 'OT1' :22, 
-   'O2'  :23, 'OT'  :23, 'OT2' :23, 'OXT' :23, 
+   '1HD' :0, 'HD1' :0,
+   '1HE' :1, 'HE1' :1,
+   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2,
+   '2HB' :3, 'HB2' :3,
+   '2HD' :4, 'HD2' :4,
+   '2HE' :5, 'HE2' :5,
+   '2H'  :6, '2HT' :6, 'H2'  :6, 'HT2' :6,
+   '1HB' :7, '3HB' :7, 'HB1' :7, 'HB3' :7,
+   '3H'  :8, '3HT' :8, 'H3'  :8, 'HT3' :8,
+   'C'   :9,
+   'CA'  :10,
+   'CB'  :11,
+   'CD1' :12,
+   'CD2' :13,
+   'CE1' :14,
+   'CE2' :15,
+   'CG'  :16,
+   'CZ'  :17,
+   'H'   :18, 'HN'  :18,
+   'HA'  :19, 'HA2' :19,
+   'HZ'  :20,
+   'N'   :21,
+   'O'   :22, 'O1'  :22, 'OT1' :22,
+   'O2'  :23, 'OT'  :23, 'OT2' :23, 'OXT' :23,
    },
    [ ### bonds ###
    ( 0, 12,  1 ),
@@ -880,23 +880,23 @@ bonds = {
    ]],
 'PRO': [
    { ### names ###
-   '2H'  :0, 'H2'  :0, 
-   '2HB' :1, 'HB2' :1, 
-   '2HD' :2, 'HD2' :2, 
-   '2HG' :3, 'HG2' :3, 
-   '1H'  :4, '3H'  :4, 'H3'  :4, 
-   '1HB' :5, '3HB' :5, 'HB1' :5, 'HB3' :5, 
-   '1HD' :6, '3HD' :6, 'HD1' :6, 'HD3' :6, 
-   '1HG' :7, '3HG' :7, 'HG1' :7, 'HG3' :7, 
-   'C'   :8, 
-   'CA'  :9, 
-   'CB'  :10, 
-   'CD'  :11, 
-   'CG'  :12, 
-   'HA'  :13, 
-   'N'   :14, 
-   'O'   :15, 'O1'  :15, 'OT1' :15, 
-   'O2'  :16, 'OT'  :16, 'OT2' :16, 'OXT' :16, 
+   '2H'  :0, 'H2'  :0,
+   '2HB' :1, 'HB2' :1,
+   '2HD' :2, 'HD2' :2,
+   '2HG' :3, 'HG2' :3,
+   '1H'  :4, '3H'  :4, 'H3'  :4,
+   '1HB' :5, '3HB' :5, 'HB1' :5, 'HB3' :5,
+   '1HD' :6, '3HD' :6, 'HD1' :6, 'HD3' :6,
+   '1HG' :7, '3HG' :7, 'HG1' :7, 'HG3' :7,
+   'C'   :8,
+   'CA'  :9,
+   'CB'  :10,
+   'CD'  :11,
+   'CG'  :12,
+   'HA'  :13,
+   'N'   :14,
+   'O'   :15, 'O1'  :15, 'OT1' :15,
+   'O2'  :16, 'OT'  :16, 'OT2' :16, 'OXT' :16,
    },
    [ ### bonds ###
    ( 0, 14,  1 ),
@@ -918,21 +918,21 @@ bonds = {
    ]],
 'SER': [
    { ### names ###
-   '1H'  :0, '1HT' :0, 'H1'  :0, 'HT1' :0, 
-   '2HB' :1, 'HB2' :1, 
-   '2H'  :2, '2HT' :2, 'H2'  :2, 'HT2' :2, 
-   '1HB' :3, '3HB' :3, 'HB1' :3, 'HB3' :3, 
-   '3H'  :4, '3HT' :4, 'H3'  :4, 'HT3' :4, 
-   'C'   :5, 
-   'CA'  :6, 
-   'CB'  :7, 
-   'H'   :8, 'HN'  :8, 
-   'HA'  :9, 'HA2' :9, 
-   'HG'  :10, 'HG1' :10, 
-   'N'   :11, 
-   'O'   :12, 'O1'  :12, 'OT1' :12, 
-   'OG'  :13, 
-   'O2'  :14, 'OT'  :14, 'OT2' :14, 'OXT' :14, 
+   '1H'  :0, '1HT' :0, 'H1'  :0, 'HT1' :0,
+   '2HB' :1, 'HB2' :1,
+   '2H'  :2, '2HT' :2, 'H2'  :2, 'HT2' :2,
+   '1HB' :3, '3HB' :3, 'HB1' :3, 'HB3' :3,
+   '3H'  :4, '3HT' :4, 'H3'  :4, 'HT3' :4,
+   'C'   :5,
+   'CA'  :6,
+   'CB'  :7,
+   'H'   :8, 'HN'  :8,
+   'HA'  :9, 'HA2' :9,
+   'HG'  :10, 'HG1' :10,
+   'N'   :11,
+   'O'   :12, 'O1'  :12, 'OT1' :12,
+   'OG'  :13,
+   'O2'  :14, 'OT'  :14, 'OT2' :14, 'OXT' :14,
    },
    [ ### bonds ###
    ( 0, 11,  1 ),
@@ -951,24 +951,24 @@ bonds = {
    ]],
 'THR': [
    { ### names ###
-   '1HG' :0, 'HG1' :0, 
-   '1HG2':1, 'HG21':1, 
-   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2, 
-   '2HG2':3, 'HG22':3, 
-   '2H'  :4, '2HT' :4, 'H2'  :4, 'HT2' :4, 
-   '3HG2':5, 'HG23':5, 
-   '3H'  :6, '3HT' :6, 'H3'  :6, 'HT3' :6, 
-   'C'   :7, 
-   'CA'  :8, 
-   'CB'  :9, 
-   'CG2' :10, 
-   'H'   :11, 'HN'  :11, 
-   'HA'  :12, 'HA2' :12, 
-   'HB'  :13, 
-   'N'   :14, 
-   'O'   :15, 'O1'  :15, 'OT1' :15, 
-   'OG1' :16, 
-   'O2'  :17, 'OT'  :17, 'OT2' :17, 'OXT' :17, 
+   '1HG' :0, 'HG1' :0,
+   '1HG2':1, 'HG21':1,
+   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2,
+   '2HG2':3, 'HG22':3,
+   '2H'  :4, '2HT' :4, 'H2'  :4, 'HT2' :4,
+   '3HG2':5, 'HG23':5,
+   '3H'  :6, '3HT' :6, 'H3'  :6, 'HT3' :6,
+   'C'   :7,
+   'CA'  :8,
+   'CB'  :9,
+   'CG2' :10,
+   'H'   :11, 'HN'  :11,
+   'HA'  :12, 'HA2' :12,
+   'HB'  :13,
+   'N'   :14,
+   'O'   :15, 'O1'  :15, 'OT1' :15,
+   'OG1' :16,
+   'O2'  :17, 'OT'  :17, 'OT2' :17, 'OXT' :17,
    },
    [ ### bonds ###
    ( 0, 16,  1 ),
@@ -990,34 +990,34 @@ bonds = {
    ]],
 'TRP': [
    { ### names ###
-   '1HD' :0, 'HD1' :0, 
-   '1HE' :1, 'HE1' :1, 
-   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2, 
-   '2HB' :3, 'HB2' :3, 
-   '2HH' :4, 'HH2' :4, 
-   '2H'  :5, '2HT' :5, 'H2'  :5, 'HT2' :5, 
-   '2HZ' :6, 'HZ2' :6, 
-   '1HB' :7, '3HB' :7, 'HB1' :7, 'HB3' :7, 
-   '3HE' :8, 'HE3' :8, 
-   '3H'  :9, '3HT' :9, 'H3'  :9, 'HT3' :9, 
-   '1HZ' :10, '3HZ' :10, 'HZ3' :10, 
-   'C'   :11, 
-   'CA'  :12, 
-   'CB'  :13, 
-   'CD1' :14, 
-   'CD2' :15, 
-   'CE2' :16, 
-   'CE3' :17, 
-   'CG'  :18, 
-   'CH2' :19, 
-   'CZ2' :20, 
-   'CZ3' :21, 
-   'H'   :22, 'HN'  :22, 
-   'HA'  :23, 'HA2' :23, 
-   'N'   :24, 
-   'NE1' :25, 
-   'O'   :26, 'O1'  :26, 'OT1' :26, 
-   'O2'  :27, 'OT'  :27, 'OT2' :27, 'OXT' :27, 
+   '1HD' :0, 'HD1' :0,
+   '1HE' :1, 'HE1' :1,
+   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2,
+   '2HB' :3, 'HB2' :3,
+   '2HH' :4, 'HH2' :4,
+   '2H'  :5, '2HT' :5, 'H2'  :5, 'HT2' :5,
+   '2HZ' :6, 'HZ2' :6,
+   '1HB' :7, '3HB' :7, 'HB1' :7, 'HB3' :7,
+   '3HE' :8, 'HE3' :8,
+   '3H'  :9, '3HT' :9, 'H3'  :9, 'HT3' :9,
+   '1HZ' :10, '3HZ' :10, 'HZ3' :10,
+   'C'   :11,
+   'CA'  :12,
+   'CB'  :13,
+   'CD1' :14,
+   'CD2' :15,
+   'CE2' :16,
+   'CE3' :17,
+   'CG'  :18,
+   'CH2' :19,
+   'CZ2' :20,
+   'CZ3' :21,
+   'H'   :22, 'HN'  :22,
+   'HA'  :23, 'HA2' :23,
+   'N'   :24,
+   'NE1' :25,
+   'O'   :26, 'O1'  :26, 'OT1' :26,
+   'O2'  :27, 'OT'  :27, 'OT2' :27, 'OXT' :27,
    },
    [ ### bonds ###
    ( 0, 14,  1 ),
@@ -1051,31 +1051,31 @@ bonds = {
    ]],
 'TYR': [
    { ### names ###
-   '1HD' :0, 'HD1' :0, 
-   '1HE' :1, 'HE1' :1, 
-   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2, 
-   '2HB' :3, 'HB2' :3, 
-   '2HD' :4, 'HD2' :4, 
-   '2HE' :5, 'HE2' :5, 
-   '2H'  :6, '2HT' :6, 'H2'  :6, 'HT2' :6, 
-   '1HB' :7, '3HB' :7, 'HB1' :7, 'HB3' :7, 
-   '3H'  :8, '3HT' :8, 'H3'  :8, 'HT3' :8, 
-   'C'   :9, 
-   'CA'  :10, 
-   'CB'  :11, 
-   'CD1' :12, 
-   'CD2' :13, 
-   'CE1' :14, 
-   'CE2' :15, 
-   'CG'  :16, 
-   'CZ'  :17, 
-   'H'   :18, 'HN'  :18, 
-   'HA'  :19, 'HA2' :19, 
-   'HH'  :20, 
-   'N'   :21, 
-   'O'   :22, 'O1'  :22, 'OT1' :22, 
-   'OH'  :23, 
-   'O2'  :24, 'OT'  :24, 'OT2' :24, 'OXT' :24, 
+   '1HD' :0, 'HD1' :0,
+   '1HE' :1, 'HE1' :1,
+   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2,
+   '2HB' :3, 'HB2' :3,
+   '2HD' :4, 'HD2' :4,
+   '2HE' :5, 'HE2' :5,
+   '2H'  :6, '2HT' :6, 'H2'  :6, 'HT2' :6,
+   '1HB' :7, '3HB' :7, 'HB1' :7, 'HB3' :7,
+   '3H'  :8, '3HT' :8, 'H3'  :8, 'HT3' :8,
+   'C'   :9,
+   'CA'  :10,
+   'CB'  :11,
+   'CD1' :12,
+   'CD2' :13,
+   'CE1' :14,
+   'CE2' :15,
+   'CG'  :16,
+   'CZ'  :17,
+   'H'   :18, 'HN'  :18,
+   'HA'  :19, 'HA2' :19,
+   'HH'  :20,
+   'N'   :21,
+   'O'   :22, 'O1'  :22, 'OT1' :22,
+   'OH'  :23,
+   'O2'  :24, 'OT'  :24, 'OT2' :24, 'OXT' :24,
    },
    [ ### bonds ###
    ( 0, 12,  1 ),
@@ -1105,26 +1105,26 @@ bonds = {
    ]],
 'VAL': [
    { ### names ###
-   '1HG1':0, 'HG11':0, 
-   '1HG2':1, 'HG21':1, 
-   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2, 
-   '2HG1':3, 'HG12':3, 
-   '2HG2':4, 'HG22':4, 
-   '2H'  :5, '2HT' :5, 'H2'  :5, 'HT2' :5, 
-   '3HG1':6, 'HG13':6, 
-   '3HG2':7, 'HG23':7, 
-   '3H'  :8, '3HT' :8, 'H3'  :8, 'HT3' :8, 
-   'C'   :9, 
-   'CA'  :10, 
-   'CB'  :11, 
-   'CG1' :12, 
-   'CG2' :13, 
-   'H'   :14, 'HN'  :14, 
-   'HA'  :15, 'HA2' :15, 
-   'HB'  :16, 
-   'N'   :17, 
-   'O'   :18, 'O1'  :18, 'OT1' :18, 
-   'O2'  :19, 'OT'  :19, 'OT2' :19, 'OXT' :19, 
+   '1HG1':0, 'HG11':0,
+   '1HG2':1, 'HG21':1,
+   '1H'  :2, '1HT' :2, 'H1'  :2, 'HT1' :2,
+   '2HG1':3, 'HG12':3,
+   '2HG2':4, 'HG22':4,
+   '2H'  :5, '2HT' :5, 'H2'  :5, 'HT2' :5,
+   '3HG1':6, 'HG13':6,
+   '3HG2':7, 'HG23':7,
+   '3H'  :8, '3HT' :8, 'H3'  :8, 'HT3' :8,
+   'C'   :9,
+   'CA'  :10,
+   'CB'  :11,
+   'CG1' :12,
+   'CG2' :13,
+   'H'   :14, 'HN'  :14,
+   'HA'  :15, 'HA2' :15,
+   'HB'  :16,
+   'N'   :17,
+   'O'   :18, 'O1'  :18, 'OT1' :18,
+   'O2'  :19, 'OT'  :19, 'OT2' :19, 'OXT' :19,
    },
    [ ### bonds ###
    ( 0, 12,  1 ),
diff -upNr pymol-open-source-2.3.0/modules/chempy/brick.py pymol-open-source-2.3.3/modules/chempy/brick.py
--- pymol-open-source-2.3.0/modules/chempy/brick.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/brick.py	2019-08-22 10:24:47.754601554 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -20,7 +20,7 @@ class Brick(object):
 
     >>> pymol.importing.load_brick(brickinstance, "name")
     '''
-    
+
     def __init__(self):
         self.valid = None
 
@@ -63,6 +63,3 @@ class Brick(object):
             ]
         self.grid = list(grid)
         self.lvl = numpy.zeros(self.dim,float)
-        
-        
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/cc1.py pymol-open-source-2.3.3/modules/chempy/cc1.py
--- pymol-open-source-2.3.0/modules/chempy/cc1.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/cc1.py	2019-08-22 10:24:47.754601554 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -34,7 +34,7 @@ class CC1(Storage): # ChemDraw3D 5.0 std
             at = Atom()
             at.index = cnt
             id_dict[string.strip(molList[irec][3:8])] = at.index
-            at.coord = [float(molList[irec][8:20]), 
+            at.coord = [float(molList[irec][8:20]),
                 float(molList[irec][20:32]),float(molList[irec][32:44])]
             at.symbol = string.strip(molList[irec][0:3])
             at.numeric_type = int(molList[irec][44:49])
@@ -43,7 +43,7 @@ class CC1(Storage): # ChemDraw3D 5.0 std
             irec = irec + 1
             cnt = cnt + 1
             model.atom.append(at)
-            
+
         # interpret bonds
         cnt = 0
         for a in model.atom:
@@ -64,4 +64,3 @@ class CC1(Storage): # ChemDraw3D 5.0 std
         return []
 
         # not implemented yet
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/cex.py pymol-open-source-2.3.3/modules/chempy/cex.py
--- pymol-open-source-2.3.0/modules/chempy/cex.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/cex.py	2019-08-22 10:24:47.758602205 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
 #-* Scott Dixon, Metaphorics, LLC
-#-* 
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -75,13 +75,13 @@ class CEXstream:
                         return ("|","")
                     else:
                         return (None, None)
-            else: break    
+            else: break
         s = str.find("<")
         if s < 0:
             return (None, None)
         else:
             return (str[:s],str[s+1:-1])
-        
+
 class CEXsmilesError(Exception):
     def __init__(self,smiles,p,msg):
         self.args=("Smiles error: " + msg + "\n" + smiles + "\n" + p*" " + "^",)
@@ -91,7 +91,7 @@ class CEXsmilesParser:
     CEX toolkit"""
     MX_NESTING=4096
     MX_RINGS=1000
-    ptab = {"*":0, 
+    ptab = {"*":0,
    "H":1, "He":2, "Li":3, "Be":4, "B":5, "C":6, "N":7, "O":8, "F":9, "Ne":10,
    "Na":11, "Mg":12, "Al":13, "Si":14, "P":15, "S":16, "Cl":17, "Ar":18, "K":19, "Ca":20,
    "Sc:":21, "Ti":22, "V":23, "Cr":24, "Mn":25, "Fe":26, "Co":27, "Ni":28, "Cu":29, "Zn":30,
@@ -103,7 +103,7 @@ class CEXsmilesParser:
    "Tl":81, "Pb":82, "Bi":83, "Po":84, "At":85, "Rn":86, "Fr":87, "Ra":88, "Ac":89, "Th":90,
    "Pa":91, "U":92, "Np":93, "Pu":94, "Am":95, "Cm":96, "Bk":97, "Cf":98, "Es":99, "Fm":100,
    "Md":101, "No":102, "Lr":103, "Rf":104, "Ha":105}
-    stab = {0:"*", 
+    stab = {0:"*",
    1:"H", 2:"He", 3:"Li", 4:"Be", 5:"B", 6:"C", 7:"N", 8:"O", 9:"F", 10:"Ne",
    11:"Na", 12:"Mg", 13:"Al", 14:"Si", 15:"P", 16:"S", 17:"Cl", 18:"Ar", 19:"K", 20:"Ca",
    21:"Sc:", 22:"Ti", 23:"V", 24:"Cr", 25:"Mn", 26:"Fe", 27:"Co", 28:"Ni", 29:"Cu", 30:"Zn",
@@ -300,7 +300,7 @@ class CEXprop:
         self.value = value
     def __str__(self):
         return self.name + "<" + self.value + ">"
-        
+
 class CEXchild(CEXprop):
     def __init__(self, tag, value):
         CEXprop.__init__(self, tag, value)
@@ -329,7 +329,7 @@ class CEXroot(CEXchild):
         for p in self.children():
             str = str + "\n" + p.__str__()
         return str
-    
+
 def readTree(cxstream):
     """Read tree of CEX object from stream"""
     (tag, value) = cxstream.readEntry()
@@ -337,10 +337,10 @@ def readTree(cxstream):
     if tag[0] != "$": return None
     root = CEXroot(tag,value)
     (tag, value) = cxstream.readEntry()
-    if tag == None: return None
+    if tag is None: return None
     while 1:
         if tag == "|": break
-        if tag == None: break
+        if tag is None: break
         if tag[0] == "/":
             root.addProp(CEXprop(tag, value))
             (tag, value) = cxstream.readEntry()
@@ -350,7 +350,7 @@ def readTree(cxstream):
             while 1:
                 (tag, value) = cxstream.readEntry()
                 if tag == "|": break
-                if tag == None: break
+                if tag is None: break
                 if tag[0] == "/":
                     child.addProp(CEXprop(tag, value))
                     continue
@@ -453,4 +453,3 @@ if __name__ == "__main__":
     test3("C%1CC%1")
     test3("C^12CC^12")
     test3("[NH2+]")
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/champ/amber99.py pymol-open-source-2.3.3/modules/chempy/champ/amber99.py
--- pymol-open-source-2.3.0/modules/chempy/champ/amber99.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/champ/amber99.py	2019-08-22 10:24:47.758602205 +0200
@@ -19,7 +19,7 @@ amber99_dict = {
          3: ('HH31', 'HC'  ,    0.0976,    1.3870),
          4: ('HH32', 'HC'  ,    0.0976,    1.3870),
          5: ('HH33', 'HC'  ,    0.0976,    1.3870),
-         
+
       },
    ),
 ],
@@ -1660,8 +1660,8 @@ amber99_dict = {
          2: ('H2'  , 'HW'  ,    0.4170,    0.0000),
       },
    ),
-], 
-'HOH': [ 
+],
+'HOH': [
    (
       'O<0>([H]<1>)[H]<2>',
       {
@@ -1671,7 +1671,7 @@ amber99_dict = {
       },
    ),
 ],
-'TIP': [ 
+'TIP': [
    (
       'O<0>([H]<1>)[H]<2>',
       {
@@ -1684,7 +1684,7 @@ amber99_dict = {
 
 }
 
-# also want commong residues like PTyr, PSer, 
+# also want commong residues like PTyr, PSer,
 
 # missing neutrals GLUH/GLUN,GLH, ASPH/ASH/ASPN, LYSN, ARGN
 
diff -upNr pymol-open-source-2.3.0/modules/chempy/champ/assign.py pymol-open-source-2.3.3/modules/chempy/champ/assign.py
--- pymol-open-source-2.3.0/modules/chempy/champ/assign.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/champ/assign.py	2019-08-22 10:24:47.758602205 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -24,7 +24,7 @@ from pymol import cmd
 def missing_c_termini(selection="(all)",quiet=0,_self=cmd):
     cmd=_self
     # assumes that hydogens are not present!
-    
+
     sele_list = []
     ch=Champ()
     model = cmd.get_model(selection)
@@ -43,30 +43,30 @@ def missing_c_termini(selection="(all)",
         cmd.attach("O",1,1,"OXT",quiet=1)
         cmd.unpick()
     cmd.delete(tmp_sele1)
-    
-    
+
+
 def formal_charges(selection="(all)",quiet=0,_self=cmd):
     cmd=_self
     result = 1
     # assumes that hydogens are not present!
-    
+
     # first, set all formal charges to zero
-    
+
     cmd.alter(selection,"formal_charge=0")
 
     # next, flag all atoms so that we'll be able to detect what we miss
-    
+
     cmd.flag(23,selection,'set')
 
     # get the residue dictionary for formal charges
-    
+
     if not hasattr(champ,'formal_charge_dict'):
         from chempy.champ.formal_charges import formal_charge_dict
         champ.formal_charge_dict = formal_charge_dict
 
     # iterate through the residue dictionary matching each residue based on chemistry
     # and generating the expressions for reassigning formal charges
-    
+
     alter_list = []
     for resn in champ.formal_charge_dict.keys():
         if cmd.select(tmp_sele1,"(%s) and resn %s"%(selection,resn))>0:
@@ -74,7 +74,7 @@ def formal_charges(selection="(all)",qui
             for rule in entry:
                 model = cmd.get_model(tmp_sele1)
                 ch = Champ()
-                model_pat = ch.insert_model(model)         
+                model_pat = ch.insert_model(model)
                 assn_pat = ch.insert_pattern_string(rule[0])
                 ch.pattern_clear_tags(model_pat)
                 if ch.match_1v1_n(assn_pat,model_pat,10000,2)>0:
@@ -88,7 +88,7 @@ def formal_charges(selection="(all)",qui
                                                      "formal_charge=%d;flags=flags&-8388609"%formal_charge])
 
     if 1: # n-terminal amine
-        # non-proline 
+        # non-proline
         ch=Champ()
         model = cmd.get_model(selection)
         model_pat = ch.insert_model(model)
@@ -116,7 +116,7 @@ def formal_charges(selection="(all)",qui
                             # the following expression both changes the formal charge and resets flag 23
                             alter_list.append([atom_tag[0],
                                                      "formal_charge=1;flags=flags&-8388609"])
-                                    
+
     if 1: # c-terminal acid
         ch=Champ()
         model = cmd.get_model(selection)
@@ -131,8 +131,8 @@ def formal_charges(selection="(all)",qui
                             # the following expression both changes the formal charge and resets flag 23
                             alter_list.append([atom_tag[0],
                                                      "formal_charge=-1;flags=flags&-8388609"])
-        
-    # now evaluate all of these expressions efficiently en-masse 
+
+    # now evaluate all of these expressions efficiently en-masse
     cmd.alter_list(selection,alter_list)
 
     # see if we missed any atoms
@@ -144,9 +144,9 @@ def formal_charges(selection="(all)",qui
             print(" WARNING: %d atoms did not have formal charges assigned"%missed_count)
         result = 0
     # remove the temporary selection we used to select appropriate residues
-    
+
     cmd.delete(tmp_sele1)
-    
+
     return result
 
 def amber99(selection="(all)",quiet=0,_self=cmd):
@@ -159,18 +159,18 @@ def amber99(selection="(all)",quiet=0,_s
     cmd.alter(selection,"text_type=''")
 
     # next, flag all atoms so that we'll be able to detect what we miss
-    
+
     cmd.flag(23,selection,'set')
 
     # get the amber99 dictionary
-    
+
     if not hasattr(champ,'amber99_dict'):
         from chempy.champ.amber99 import amber99_dict
         champ.amber99_dict = amber99_dict
 
     # iterate through the residue dictionary matching each residue based on chemistry
     # and generating the expressions for reassigning formal charges
-    
+
     alter_list = []
     for resn in champ.amber99_dict.keys():
         if cmd.select(tmp_sele1,"(%s) and resn %s"%(selection,resn))>0:
@@ -192,7 +192,7 @@ def amber99(selection="(all)",quiet=0,_s
                             alter_list.append([atom_tag[0],
             "name='''%s''';text_type='''%s''';partial_charge=%f;elec_radius=%f;flags=flags&-8388609"%prop_list])
 
-    # now evaluate all of these expressions efficiently en-masse 
+    # now evaluate all of these expressions efficiently en-masse
     cmd.alter_list(selection,alter_list)
 
     # see if we missed any atoms
@@ -205,9 +205,7 @@ def amber99(selection="(all)",quiet=0,_s
         result = 0
 
     # remove the temporary selection we used to select appropriate residues
-    
+
     cmd.delete(tmp_sele1)
 
     return result
-
-    
diff -upNr pymol-open-source-2.3.0/modules/chempy/champ/formal_charges.py pymol-open-source-2.3.3/modules/chempy/champ/formal_charges.py
--- pymol-open-source-2.3.0/modules/chempy/champ/formal_charges.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/champ/formal_charges.py	2019-08-22 10:24:47.758602205 +0200
@@ -417,4 +417,3 @@ for alias in (
     ( 'ARGP', 'ARG'), # default +1
     ):
     formal_charge_dict[alias[0]] = formal_charge_dict[alias[1]]
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/champ/__init__.py pymol-open-source-2.3.3/modules/chempy/champ/__init__.py
--- pymol-open-source-2.3.0/modules/chempy/champ/__init__.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/champ/__init__.py	2019-08-22 10:24:47.758602205 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -21,7 +21,7 @@ except ImportError:
 
 # okay, this module is going to take some planning, since Champ
 # has the potential to evolve into a full-blown
-# chemical informatics system 
+# chemical informatics system
 
 # what do we need to be prepared to handle?
 #
@@ -74,8 +74,8 @@ class Champ:
         (e,r) = _champ.pattern_clear_tags(self._champ,int(index))
         if e: raise RuntimeError
         return r
-        
-    
+
+
     def pattern_get_string(self,index):
         '''
         retrieves the smiles string for a given pattern index
@@ -115,7 +115,7 @@ class Champ:
         (e,r) = _champ.list_prepend_pattern_index(self._champ,int(handle),int(index))
         if e: raise RuntimeError
         return r
-    
+
     def list_new(self):
         '''
         returns a new list handle
@@ -187,7 +187,7 @@ class Champ:
         if e: raise RuntimeError
         return r
 
-        
+
     def match_1vN_n(self,pattern,handle):
         '''
         returns count of how many times pattern occurs in list
@@ -208,7 +208,7 @@ class Champ:
                                     int(pattern),int(handle))
         if e: raise RuntimeError
         return r
-        
+
     def memory_dump(self):
         '''
         dump bulk memory information
@@ -248,7 +248,7 @@ class Champ:
         (e,r) = _champ.pattern_get_tag_masks(self._champ,int(index))
         if e: raise RuntimeError
         return r
-    
+
     def pattern_get_tags(self,index):
         '''
         get tags (numeric lists)
@@ -312,5 +312,3 @@ class Champ:
         (e,r) = _champ.pattern_generalize(self._champ,int(index))
         if e: raise RuntimeError
         return r
-
-        
diff -upNr pymol-open-source-2.3.0/modules/chempy/charge.py pymol-open-source-2.3.3/modules/chempy/charge.py
--- pymol-open-source-2.3.0/modules/chempy/charge.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/charge.py	2019-08-22 10:24:47.758602205 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -30,7 +30,7 @@ def combine_fragments(*arg,**kw):
     calculations (you can use PyMOL to rename these if they
     happen to coincide).
 '''
-    
+
     if 'net_charge' in kw:
         net_charge = kw['net_charge']
     else:
@@ -43,7 +43,7 @@ def combine_fragments(*arg,**kw):
     n_dst_atm = len(dst.atom)
 
     # create dictionary/indices for shared atoms
-    
+
     n_tot = 0
     dst_dict = {}
     for a in dst.atom:
@@ -52,11 +52,11 @@ def combine_fragments(*arg,**kw):
         n_tot = n_tot + 1
 
     # create fragment membership list for destination atoms
-    
+
     members = []
     for a in range(n_tot):
         members.append([])
-    
+
     # create indices for unique atoms
 
     for fragment in frg_lst:
@@ -75,22 +75,22 @@ def combine_fragments(*arg,**kw):
                         attached = fragment.atom[b.index[1]]
                     elif b.index[1]==c:
                         attached = fragment.atom[b.index[0]]
-                    if attached!=None:
+                    if attached is not None:
                         if attached.name in dst_dict:
                             attached_index = dst_dict[attached.name]
                             break
                 a.chg_index = n_tot
-                if attached_index!=None:
+                if attached_index is not None:
                     a.attached_index = attached_index
                 n_tot = n_tot + 1
             c = c + 1
-                
+
     # create array for charges
-    
+
     chg = []
     for a in range(n_frg):
         chg.append([0.0] * n_tot)
-    
+
     # now load and count measurements
 
     cnt = [0] * n_tot
@@ -117,22 +117,21 @@ def combine_fragments(*arg,**kw):
             avg.append(sum(tmp_lst)/cnt[index])
         else:
             avg.append(0.0)
-        
+
     # correct total charge
 
     chg_sum = sum(avg)
 
     print("chg_sum",chg_sum)
-    if net_charge != None:
+    if net_charge is not None:
         chg_diff = net_charge - chg_sum
         chg_adjust = chg_diff / n_dst_atm
     else:
         chg_adjust = 0.0
-        
+
     c = 0
     for a in dst.atom:
         a.partial_charge = avg[c] + chg_adjust
         c = c + 1
 
     return dst
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/cif.py pymol-open-source-2.3.3/modules/chempy/cif.py
--- pymol-open-source-2.3.0/modules/chempy/cif.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/cif.py	2019-08-22 10:24:47.758602205 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -189,7 +189,7 @@ class CIFData:
 
     def to_str(self, key):
         return self._get(key, '', unquote)
-    
+
     def index_to_int(self, index, value):
         return _row_get(value, index, 0, int)
 
@@ -260,13 +260,13 @@ class CIFRec(CIFData):
         partial_charge = field_dict.get('_chem_comp_atom_partial_charge',None)
         formal_charge = field_dict.get('chem_comp_atom_charge',None)
         str_fields = []
-        if symbol != None: str_fields.append( ('symbol',symbol) )
-        if name != None: str_fields.append( ('name',name) )
-        if resn != None: str_fields.append( ('resn',resn) )
+        if symbol is not None: str_fields.append( ('symbol',symbol) )
+        if name is not None: str_fields.append( ('name',name) )
+        if resn is not None: str_fields.append( ('resn',resn) )
         float_fields = []
-        if partial_charge != None: float_fields.append( ('partial_charge',partial_charge) )
+        if partial_charge is not None: float_fields.append( ('partial_charge',partial_charge) )
         int_fields = []
-        if formal_charge != None: int_fields.append( ('formal_charge',formal_charge) ) 
+        if formal_charge is not None: int_fields.append( ('formal_charge',formal_charge) )
         for value in values:
             atom = Atom()
             atom.coord = [
@@ -300,12 +300,12 @@ class CIFRec(CIFData):
         name = field_dict.get('_atom_site_label',None)
         if name is None:
             name = field_dict.get('_atom_site_id',None)
-        u = field_dict.get('_atom_site_u_iso_or_equiv',None)                
+        u = field_dict.get('_atom_site_u_iso_or_equiv',None)
         str_fields = []
-        if symbol != None: str_fields.append( ('symbol',symbol) )
-        if name != None: str_fields.append( ('name',name) )
+        if symbol is not None: str_fields.append( ('symbol',symbol) )
+        if name is not None: str_fields.append( ('name',name) )
         float_fields = []
-        if u != None: float_fields.append( ('u', u))
+        if u is not None: float_fields.append( ('u', u))
         int_fields = []
         for value in values:
             atom = Atom()
@@ -342,30 +342,30 @@ class CIFRec(CIFData):
         auth_resn = field_dict.get('_atom_site_auth_comp_id',None)
         auth_resi = field_dict.get('_atom_site_auth_seq_id',None)
         auth_name = field_dict.get('_atom_site_auth_atom_id',None)
-        auth_chain = field_dict.get('_atom_site_auth_asym_id',None)        
-        if auth_resn != None: resn = auth_resn
-        if auth_resi != None: resi = auth_resi
-        if auth_name != None: name = auth_name
-        if auth_chain != None: chain = auth_chain
-        b = field_dict.get('_atom_site_b_iso_or_equiv',None)        
+        auth_chain = field_dict.get('_atom_site_auth_asym_id',None)
+        if auth_resn is not None: resn = auth_resn
+        if auth_resi is not None: resi = auth_resi
+        if auth_name is not None: name = auth_name
+        if auth_chain is not None: chain = auth_chain
+        b = field_dict.get('_atom_site_b_iso_or_equiv',None)
         q = field_dict.get('_atom_site_occupancy',None)
         ID = field_dict.get('_atom_site_id',None)
         str_fields = []
-        if symbol != None: str_fields.append( ('symbol',symbol) )
-        if name != None: str_fields.append( ('name',name) )
-        if resn != None: str_fields.append( ('resn',resn) )
-        if resi != None: str_fields.append( ('resi',resi) )
-        if chain != None:
+        if symbol is not None: str_fields.append( ('symbol',symbol) )
+        if name is not None: str_fields.append( ('name',name) )
+        if resn is not None: str_fields.append( ('resn',resn) )
+        if resi is not None: str_fields.append( ('resi',resi) )
+        if chain is not None:
             str_fields.append( ('chain',chain) )
             if ASYM_ID_AS_SEGI:
                 str_fields.append( ('segi',chain) )
-        if alt != None: str_fields.append( ('alt',alt) )
-        if ins_code != None: str_fields.append( ('ins_code',ins_code) )
+        if alt is not None: str_fields.append( ('alt',alt) )
+        if ins_code is not None: str_fields.append( ('ins_code',ins_code) )
         float_fields = []
-        if q != None: float_fields.append( ('q',q) )
-        if b != None: float_fields.append( ('b',b) )
+        if q is not None: float_fields.append( ('q',q) )
+        if b is not None: float_fields.append( ('b',b) )
         int_fields = []
-        if ID != None: int_fields.append( ('id',ID) )                                
+        if ID is not None: int_fields.append( ('id',ID) )
 
         first_model_num = self.index_to_int(model_num, values[0])
 
@@ -384,7 +384,7 @@ class CIFRec(CIFData):
             atom = Atom()
             atom.coord = coord
             self.model.atom.append(atom)
-            if group_pdb != None:
+            if group_pdb is not None:
                 if value[group_pdb] == 'ATOM':
                     atom.hetatm = 0
                 else:
@@ -550,7 +550,7 @@ class CIFRec(CIFData):
             if self.read_geom_bond_atom_site_labels(None, loop.keys, loop.rows):
                 return True
         return False
-    
+
     def read_chem_comp_bond_atom_ids(self,fields,field_dict,values):
         try:
             label_1 = field_dict['_chem_comp_bond_atom_id_1']
@@ -575,7 +575,7 @@ class CIFRec(CIFData):
                 continue
             bond = Bond()
             bond.index = index
-            if order != None:
+            if order is not None:
                 order_string = self.index_to_str(order,value).lower()
                 bond.order = order_table.get(order_string[0:4],1)
             else:
@@ -669,7 +669,7 @@ class CIFRec(CIFData):
 
 
 class CIF:
-    
+
     def __init__(self, fname, mode='r'):
         if mode not in ('r','pf'):
             print(" CIF: bad mode")
diff -upNr pymol-open-source-2.3.0/modules/chempy/cpv.py pymol-open-source-2.3.3/modules/chempy/cpv.py
--- pymol-open-source-2.3.0/modules/chempy/cpv.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/cpv.py	2019-08-22 10:24:47.758602205 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 # Generic vector and matrix routines for 3-Space
@@ -31,7 +31,7 @@ RSMALL4 = 0.0001
 def get_null():
     return [0.0,0.0,0.0]
 
-#------------------------------------------------------------------------------   
+#------------------------------------------------------------------------------
 def get_identity():
     return [[1.0,0.0,0.0],[0.0,1.0,0.0],[0.0,0.0,1.0]]
 
@@ -141,7 +141,7 @@ def multiply(m1,m2): # HAVEN'T YET VERIF
                 m1[2][0]*m2[0][2] + m1[2][1]*m2[1][2] + m1[2][2]*m2[2][2]]]
 
 #------------------------------------------------------------------------------
-def transpose(m1): 
+def transpose(m1):
     return [[m1[0][0],
              m1[1][0],
              m1[2][0]],
@@ -196,11 +196,11 @@ def get_angle_formed_by(p1,p2,p3): # ang
     r1 = distance(p1,p2)
     r2 = distance(p2,p3)
     r3 = distance(p1,p3)
-    
+
     small = 1.0e-10
-    
+
     if (r1 + r2 - r3) < small:
-        # This seems to happen occasionally for 180 angles 
+        # This seems to happen occasionally for 180 angles
         theta = math.pi
     else:
         theta = math.acos( (r1*r1 + r2*r2  - r3*r3) / (2.0 * r1*r2) )
@@ -238,11 +238,11 @@ def normalize_failsafe(v):
 
 #------------------------------------------------------------------------------
 def rotation_matrix(angle,axis):
-    
+
     x=axis[0]
     y=axis[1]
     z=axis[2]
-    
+
     s = math.sin(angle)
     c = math.cos(angle)
 
@@ -250,11 +250,11 @@ def rotation_matrix(angle,axis):
 
     if abs(mag)<RSMALL4:
         return get_identity()
-    
+
     x = x / mag
     y = y / mag
     z = z / mag
- 
+
     xx = x * x
     yy = y * y
     zz = z * z
@@ -265,7 +265,7 @@ def rotation_matrix(angle,axis):
     ys = y * s
     zs = z * s
     one_c = 1.0 - c
- 
+
     return [[ (one_c * xx) + c , (one_c * xy) - zs, (one_c * zx) + ys],
               [ (one_c * xy) + zs, (one_c * yy) + c , (one_c * yz) - xs],
               [ (one_c * zx) - ys, (one_c * yz) + xs, (one_c * zz) + c ]]
@@ -405,4 +405,3 @@ def fit(target_array, source_array):
 # Too many iterations; something wrong.
     print ("Error: Too many iterations in RMS fit.")
     raise ValueError
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/dictdb.py pymol-open-source-2.3.3/modules/chempy/dictdb.py
--- pymol-open-source-2.3.0/modules/chempy/dictdb.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/dictdb.py	2019-08-22 10:24:47.758602205 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -51,25 +51,25 @@ class DictDBInfo:
     def __init__(self):
         self.used = 0   # bytes containing data
         self.wasted = 0 # bytes wasted (from deleted/overwitten records)
-        
+
 class DictDBLocal:
 
     __magic__ = b'*8#~'  # 32-bit record stamp for record
     __delete_magic__ = b'*8#@'  # 32-bit record stamp for deleted record
-    
+
 
     def __init__(self,prefix,bin=1,read_only=0):
 
         # store important information
-        self.index_file = prefix + ".dbi"  # database information (can be reconstructed from .dbf) 
-        self.data_file = prefix + ".dbf"   # database data 
+        self.index_file = prefix + ".dbi"  # database information (can be reconstructed from .dbf)
+        self.data_file = prefix + ".dbf"   # database data
         self.bin = bin
         self.changed = 0
         self.read_only = read_only
-        
+
         # create lock
         self.lock = threading.RLock() # NOTE: recursive for convenience
-        
+
         # restore indexed into memory
         self._restore()
 
@@ -93,7 +93,7 @@ class DictDBLocal:
     def has_key(self,key):
         result = None
 
-        # restore dictionary (if nec.)      
+        # restore dictionary (if nec.)
         if not hasattr(self,'rec'):
             self._restore()
         try:
@@ -108,12 +108,12 @@ class DictDBLocal:
     def keys(self):
         result = None
 
-        # restore dictionary (if nec.)      
+        # restore dictionary (if nec.)
         if not hasattr(self,'rec'):
             self._restore()
         try:
             self.lock.acquire()
-            
+
             # get list of keys (thread safe...result is a new object)
             result = list(self.rec.keys())
         finally:
@@ -123,13 +123,13 @@ class DictDBLocal:
 
     def __delitem__(self,key):
         result = None
-        # restore dictionary (if nec.)      
+        # restore dictionary (if nec.)
         if not hasattr(self,'rec'):
             self._restore()
         try:
             self.lock.acquire()
             if key in self.rec:
-                
+
                 # account for space
                 if key in self.rec:
                     self.info.wasted = self.info.wasted + self.rec[key][1]
@@ -140,15 +140,15 @@ class DictDBLocal:
                 if not self.read_only:
                     # write delete magic to data file for recovery
                     f=open(self.data_file,'ab')
-                    f.write(self.__delete_magic__) 
-                    cPickle.dump(key,f,self.bin) 
+                    f.write(self.__delete_magic__)
+                    cPickle.dump(key,f,self.bin)
                     f.close()
 
                     # write blank index to index file
                     f=open(self.index_file,'ab')
                     cPickle.dump((key,None),f,self.bin)
                     f.close()
-                
+
                 # note change
                 self.changed = 1
             else:
@@ -165,13 +165,13 @@ class DictDBLocal:
         if hasattr(self,'rec') and not self.read_only:
             try:
                 self.lock.acquire()
-                
+
                 # write index file
                 f=open(self.index_file,'wb')
                 cPickle.dump(self.info,f,self.bin)
                 cPickle.dump(self.rec,f,self.bin)
                 f.close()
-                
+
                 # free memory
                 del self.rec
                 del self.info
@@ -194,16 +194,16 @@ class DictDBLocal:
                 f.close()
 
             # new database information
-            
+
             self.info = DictDBInfo()
             self.rec = {}
             self.changed = 1
             self.standby() # write out blank indexes (important)
-            
+
         finally:
             self.lock.release()
         return result
-        
+
     def purge(self):
         result = None
         # restore dictionary (if nec.)
@@ -231,8 +231,8 @@ class DictDBLocal:
                 f.close()
                 g.close()
 
-                # now perform the switch-over 
-                os.unlink(self.index_file) # delete old index file...         
+                # now perform the switch-over
+                os.unlink(self.index_file) # delete old index file...
                 os.unlink(self.data_file)  # delete old data file
                 os.rename(tmp_data,self.data_file) # move new data file over old
 
@@ -282,7 +282,7 @@ class DictDBLocal:
             self.lock.acquire()
             if key in self.rec:
 
-                # locate and retrieve string            
+                # locate and retrieve string
                 f=open(self.data_file,'rb')
                 f.seek(self.rec[key][0])
                 result = f.read(self.rec[key][1])
@@ -299,7 +299,7 @@ class DictDBLocal:
             self._restore()
         try:
             self.lock.acquire()
-            
+
             # append data onto data file
             f=open(self.data_file,'ab')
             f.write(self.__magic__) # for recovery
@@ -308,7 +308,7 @@ class DictDBLocal:
             cPickle.dump(object,f,self.bin)
             record_info = (start,f.tell()-start)
             f.close()
-            
+
             # account for space (if replacing)
             if key in self.rec:
                 self.info.wasted = self.info.wasted + self.rec[key][1]
@@ -318,12 +318,12 @@ class DictDBLocal:
 
             # account for space
             self.info.used = self.info.used + record_info[1]
-            
+
             # append new record  onto index file
             f=open(self.index_file,'ab')
             cPickle.dump((key,record_info),f,self.bin)
             f.close()
-            
+
             # note change
             self.changed = 1
         finally:
@@ -341,7 +341,7 @@ class DictDBLocal:
             self.changed = 1
 
             if not self.read_only:
-                # append data onto data file         
+                # append data onto data file
                 f=open(self.data_file,'ab')
                 f.write(self.__magic__) # for recovery
                 cPickle.dump(key,f,self.bin) # for recovery
@@ -350,11 +350,11 @@ class DictDBLocal:
                 record_info = (start,f.tell()-start)
                 f.close()
 
-            # account for space (if replacing)       
+            # account for space (if replacing)
             if key in self.rec:
                 self.info.wasted = self.info.wasted + self.rec[key][1]
 
-            # update record info            
+            # update record info
             self.rec[key] = record_info
 
             # account for space
@@ -379,7 +379,7 @@ class DictDBLocal:
             try:
                 self.lock.acquire()
                 f=open(self.data_file,'rb')
-                
+
                 # find length of file
                 f.seek(0,2)
                 eof = f.tell()
@@ -395,10 +395,10 @@ class DictDBLocal:
                         start = f.tell()
                         data = cPickle.load(f)
                         record_info = (start,f.tell()-start)
-                        
+
                         # account for space (if replacing)
                         if key in rec:
-                            self_info.wasted = self_info.wasted + rec[key][1]                  
+                            self_info.wasted = self_info.wasted + rec[key][1]
                         rec[key] = record_info
 
                         # account for psace
@@ -424,7 +424,7 @@ class DictDBLocal:
         finally:
             self.lock.release()
         return result
-    
+
 
     def _restore(self):
         result = None
@@ -455,14 +455,14 @@ class DictDBLocal:
                 self.info = cPickle.load(f)
                 self.rec = cPickle.load(f)
 
-                # use locals for better performance 
+                # use locals for better performance
                 rec = self.rec
                 cPickle_load = cPickle.load
                 self_info = self.info
-                
+
                 while f.tell()!=eof:
                     key, info = cPickle_load(f)
-                    if info!=None:
+                    if info is not None:
 
                         # account for space (if replacing)
                         if key in rec:
@@ -498,7 +498,7 @@ class DictDBClient:
 
     def _remote_call(self,meth,args,kwds):
         result = None
-        if self.sock == None:
+        if self.sock is None:
             self.sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
             self.sock.connect((self.host,self.port))
             self.send = self.sock.makefile('w')
@@ -530,9 +530,9 @@ class DictDBClient:
     def standby(self):
         return self._remote_call('standby',(),{})
 
-    def shutdown(self): 
+    def shutdown(self):
         try:
-            # multiple connections are sometimes required...         
+            # multiple connections are sometimes required...
             self._remote_call('shutdown',(),{})
             self.sock=None
             self._remote_call('shutdown',(),{})
@@ -568,10 +568,10 @@ class DictDBServer:
     def __init__(self,prefix,port=''):
 
         sys.setcheckinterval(0)
-        
+
         server_address = ('', port)
 
-        ddbs = _DictDBServer(server_address, DictDBRequestHandler)  
+        ddbs = _DictDBServer(server_address, DictDBRequestHandler)
 
         # assign dict database to this server
         ddbs.dictdb = DictDBLocal(prefix)
@@ -580,7 +580,7 @@ class DictDBServer:
         ddbs.keep_alive = 1
         while ddbs.keep_alive:
             ddbs.handle_request()
-        
+
 class _DictDBServer(SocketServer.ThreadingTCPServer):
 
      def server_bind(self):
@@ -611,7 +611,7 @@ class DictDBRequestHandler(SocketServer.
 
              if method == 'shutdown':
                  self.server.keep_alive = 0
-                 
+
              # get arguments from client
              args = cPickle.load(self.rfile)
              kw = cPickle.load(self.rfile)
@@ -623,7 +623,7 @@ class DictDBRequestHandler(SocketServer.
              # call method and return result
              cPickle.dump(meth_obj(*args, **kw),self.wfile,1) # binary by default
              self.wfile.flush()
-             
+
 def server_test(port = 8000,prefix='test_dictdb'):
     print('Testing DictDBServer on port',str(port))
     fp = DictDBServer(prefix,port=port) # socket servers don't terminate
@@ -649,7 +649,7 @@ def client_test(host,port=8000):
 
 if __name__=='__main__':
     import os
-    
+
     print('***Testing DictDB***:')
 
     ddb = DictDBLocal('test_dictdb')
@@ -658,13 +658,13 @@ if __name__=='__main__':
     print(ddb['test'])
     ddb['another']='another data object'
     print(ddb['another'])
-    ddb['test']='some updated data object'   
+    ddb['test']='some updated data object'
     print(ddb['test'])
     del ddb
 
     ddb = DictDBLocal('test_dictdb')
     ddb['whoa']='whoa data object'
-    print(ddb['test']) 
+    print(ddb['test'])
     ddb['dude']='dude data object'
     print(ddb['dude'])
     ddb['number'] = 9999
@@ -688,7 +688,7 @@ if __name__=='__main__':
     info = ddb.get_info()
     print(info.used,info.wasted,info.used-info.wasted)
     del ddb
-    
+
     os.unlink("test_dictdb.dbi")
     ddb = DictDBLocal('test_dictdb')
     info = ddb.get_info()
@@ -722,7 +722,7 @@ if __name__=='__main__':
         del ddb['nonexistent']
     except KeyError:
         print(" key error 2 as expected")
-    
+
     print("purge test:")
     info = ddb.get_info()
     print(info.used,info.wasted,info.used-info.wasted)
@@ -749,12 +749,12 @@ if __name__=='__main__':
     del ddb['hello']
 
     try:
-        print(ddb['hello'])       
+        print(ddb['hello'])
     except KeyError:
         print(' got expected key error 1')
 
     try:
-        del ddb['hello']       
+        del ddb['hello']
     except KeyError:
         print(' got expected key error 2')
 
@@ -766,7 +766,7 @@ if __name__=='__main__':
     print(ddb['green'])
 
     import random
-    
+
     ddc=DictDBLocal('test_dictdb')
 
     print("loading...")
@@ -813,7 +813,7 @@ if __name__=='__main__':
 
     os.unlink("test_dictdb.dbi")
     print("unlink test")
-    
+
     ddc=DictDBLocal('test_dictdb')
 
     info = ddc.get_info()
@@ -863,14 +863,11 @@ if __name__=='__main__':
     print('used:',info.used,'wasted:',info.wasted,'extant:',info.used-info.wasted)
 
     print(list(ddc.keys()))
-    
+
     ddc.reset()
-    
+
     del ddc
     ddc=DictDBLocal('test_dictdb')
 
     info = ddc.get_info()
     print('used:',info.used,'wasted:',info.wasted,'extant:',info.used-info.wasted)
-
-
-    
diff -upNr pymol-open-source-2.3.0/modules/chempy/fast/__init__.py pymol-open-source-2.3.3/modules/chempy/fast/__init__.py
--- pymol-open-source-2.3.0/modules/chempy/fast/__init__.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/fast/__init__.py	2019-08-22 10:24:47.758602205 +0200
@@ -54,10 +54,10 @@ class FastModel:
 
 #------------------------------------------------------------------------------
     def convert_to_indexed(self):
-        
+
         model = Indexed()
         model.molecule = copy.deepcopy(self.molecule)
-        
+
         for c in range(self.nAtom):
             at = chempy.Atom()
             txta = self.txta[c]
@@ -81,9 +81,9 @@ class FastModel:
 
             # probably need to add some checking here to eliminate values
             # which come back as defaults
-            
+
             model.atom.append(at)
-            
+
         for c in range(self.nBond):
             bnd = chempy.Bond()
             bnda = self.bnda[c]
@@ -93,7 +93,7 @@ class FastModel:
             model.bond.append(bnd)
 
         return model
-    
+
 #------------------------------------------------------------------------------
 
 # text properties
@@ -176,5 +176,3 @@ bi_index1         = 1
 bi_order          = 2
 bi_stereo         = 3
 bi_width          = 4
-
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/fragments/__init__.py pymol-open-source-2.3.3/modules/chempy/fragments/__init__.py
--- pymol-open-source-2.3.0/modules/chempy/fragments/__init__.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/fragments/__init__.py	2019-08-22 10:24:47.758602205 +0200
@@ -6,4 +6,3 @@ path = chempy.path + 'fragments/'
 
 def get(name):
     return io.pkl.fromFile(path+name+'.pkl')
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/gamess1.py pymol-open-source-2.3.3/modules/chempy/gamess1.py
--- pymol-open-source-2.3.0/modules/chempy/gamess1.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/gamess1.py	2019-08-22 10:24:47.758602205 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -16,7 +16,7 @@
 # knows very little about the program (WLD) - hence the version 1 identifier...
 
 # by the way, most of the below is untested...
-        
+
 from __future__ import print_function
 
 import os
@@ -49,7 +49,7 @@ def do(input,run_prefix=None,echo=None,
     if not skip:
         if feedback['gamess']:
             print(" "+str(__name__)+': creating temporary files "%s.*"' % (run_prefix))
-            print(" "+str(__name__)+': launching gamess...') 
+            print(" "+str(__name__)+': launching gamess...')
         try:
             for a in glob.glob(run_prefix+".*"):
                 os.unlink(a)
@@ -62,7 +62,7 @@ def do(input,run_prefix=None,echo=None,
         if echo:
             os.system(rungms_path+' '+run_prefix+" 2>&1 | tee "+run_prefix+".out")
         else:
-            os.system(rungms_path+' '+run_prefix+" > "+run_prefix+".out 2>&1")      
+            os.system(rungms_path+' '+run_prefix+" > "+run_prefix+".out 2>&1")
 # NFS workaround (flushes the directory cache so that glob will work)
         try: os.unlink(".sync")
         except: pass
@@ -98,7 +98,7 @@ class State:
         self.model = None
         self.data = None
         self.vec = None
-        
+
     def load_model(self,model):
         self.model = model
 
@@ -107,12 +107,12 @@ class State:
         for z in self.model.get_internal_tuples():
             lst.append(z[0])
         return lst
-    
+
     def get_data_group(self,basis = None,zmat = 1):
         model = self.model
-            
+
         gmsList = []
-        
+
         # write header records
         gmsList.append(" $DATA\n")
         gmsList.append(model.molecule.title+" from "+str(__name__)+"\n")
@@ -134,7 +134,7 @@ class State:
         gmsList.append(" $END\n")
         return gmsList
 
-    def get_ordered_data_group(self): 
+    def get_ordered_data_group(self):
         gmsList = self.data[0:3]
         flag = 1
         c = 3
@@ -146,7 +146,7 @@ class State:
                 flag = 1
             c = c + 1
         return gmsList
-    
+
     def get_contrl_group(self,
                                 scftyp='RHF',
                                 runtyp='ENERGY',
@@ -232,7 +232,7 @@ class State:
             self.model.molecule.energy = float(l[38:58].strip())*627.5095
             if feedback['gamess']:
                 print(" "+str(__name__)+': energy updated %12.6f.' % self.model.molecule.energy)
-            
+
     def read_punch_list(self,list):
         ll = len(list)
         c = 0
@@ -292,7 +292,7 @@ class State:
                 if not a.strip():
                     flag = 1
                 c = c + 1
-    
+
     def read_density_list(self,list,brick,z_step):
         ll = len(list)
         c = 0
@@ -307,7 +307,7 @@ class State:
             for x in range(brick.dim[0]):
                 for y in range(brick.dim[1]):
                     brick.lvl[x][y][z_step] = float(list[a][36:51])
-                    a = a + 1 
+                    a = a + 1
             if feedback['gamess']:
                 print(" "+str(__name__)+': read density slice %d of %d.' %(
                     z_step+1,brick.dim[2]))
@@ -364,7 +364,7 @@ class State:
         # requires list of dihedrals from tinker.amber
         #
         from pymol import cmd
-        from .tinker.amber import Topology      
+        from .tinker.amber import Topology
 
         cmd.load_model(self.model,'_gamess1')
         model = self.model
@@ -494,20 +494,20 @@ class State:
             return zmat_ext
         else:
             return None
-        
+
     def get_zmat_group(self,auto=1,dlc=1,zmat_extend=None):
         gmsList = []
         if auto and dlc:
-            if zmat_extend == None:
+            if zmat_extend is None:
                 gmsList.append(" $ZMAT DLC=.TRUE. AUTO=.TRUE. $END\n")
             else:
                 gmsList.append(" $ZMAT DLC=.TRUE. AUTO=.TRUE.\n")
                 gmsList.extend(zmat_extend)
-                gmsList.append(" $END\n")            
+                gmsList.append(" $END\n")
         else:
             raise RuntimeError
         return gmsList
-    
+
     def get_eldens_group(self,morb=0):
         gmsList = []
         gmsList.append(" $ELDENS IEDEN=1 MORB=%i \n" % morb)
@@ -522,7 +522,7 @@ class State:
 
     def get_guess_group(self,guess='HUCKEL'):
         return [" $GUESS GUESS=%s $END\n"%guess]
-    
+
     def get_grid_group(self,brick,z_step):
         origin = (
             brick.origin[0],
@@ -544,7 +544,7 @@ class State:
             " $END\n"
             ]
         return gmsList
-    
+
     def get_scf(self,dirscf=1):
         gmsList = []
         if dirscf:
@@ -560,7 +560,7 @@ class State:
         gmsList.extend(self.get_zmat_group(zmat_extend=zmat_extend))
         gmsList.append(" $STATPT NSTEP=50 $END\n")
         return gmsList
-            
+
     def get_optimize_charge_job(self):
         gmsList = self.get_optimize_job()
         gmsList.append(" $ELPOT IEPOT=1 WHERE=PDC $END\n")
@@ -572,7 +572,7 @@ class State:
         gmsList.append(" $ELPOT IEPOT=1 WHERE=PDC $END\n")
         gmsList.append(" $PDC PTSEL=GEODESIC CONSTR=CHARGE $END\n")
         return gmsList
-    
+
     def get_prop_job(self):
         gmsList = []
         gmsList.extend(self.get_contrl_group(runtyp = 'PROP',
@@ -582,7 +582,7 @@ class State:
         gmsList.extend(self.data)
         gmsList.extend(self.vec)
         return gmsList
-        
+
     def get_energy_job(self):
         gmsList=[]
         gmsList.extend(self.get_contrl_group(
@@ -668,9 +668,3 @@ if 'GAMESS' in os.environ:
 else:
     base = ''
     rungms_path = ''
-
-
-
-
-
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/gms.py pymol-open-source-2.3.3/modules/chempy/gms.py
--- pymol-open-source-2.3.0/modules/chempy/gms.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/gms.py	2019-08-22 10:24:47.758602205 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -39,7 +39,7 @@ class GMS(Storage):
     def toList(self,model,runtyp='OPTIMIZE',exetyp='RUN',
                   gbasis='N31',ngauss=6,ndfunc=1,dirscf=1):
 
-            
+
         gmsList = []
 
         # write header records
@@ -59,7 +59,7 @@ class GMS(Storage):
             else:
                 diffsp=''
         gmsList.append(
-            " $CONTRL RUNTYP=%s COORD=UNIQUE EXETYP=%s NZVAR=%d %s $END\n" % 
+            " $CONTRL RUNTYP=%s COORD=UNIQUE EXETYP=%s NZVAR=%d %s $END\n" %
             (runtyp,exetyp,nzvar,icharg))
         if ndfunc>0:
             gmsList.append(" $BASIS GBASIS=%s NGAUSS=%d NDFUNC=%d %s $END\n" %
@@ -92,12 +92,5 @@ class GMS(Storage):
             gmsList.append(" $STATPT NPRT=-2 NPUN=-2 NSTEP=50 $END\n")
         gmsList.append(" $ELPOT IEPOT=1 WHERE=PDC $END\n")
         gmsList.append(" $PDC PTSEL=GEODESIC CONSTR=CHARGE $END\n")
-                            
-        return(gmsList)
-
-
-
-
-
-
 
+        return(gmsList)
diff -upNr pymol-open-source-2.3.0/modules/chempy/hetatm.py pymol-open-source-2.3.3/modules/chempy/hetatm.py
--- pymol-open-source-2.3.0/modules/chempy/hetatm.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/hetatm.py	2019-08-22 10:24:47.762602856 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -27,7 +27,7 @@ PEPT_CUTOFF = 1.7
 
 #---------------------------------------------------------------------------------
 def generate(model, topology= None, forcefield = None ):
-    
+
     add_bonds(model,topology=topology,forcefield=forcefield)
     connected = model.convert_to_connected()
     add_hydrogens(connected,topology=topology,forcefield=forcefield)
@@ -106,9 +106,9 @@ def add_bonds(model, topology = None, fo
                             bnd.index = [ dict[b[0]], dict[b[1]] ]
                             bnd.order = bonds[b]['order']
                             mbond.append(bnd)
-                            
+
 #---------------------------------------------------------------------------------
-def add_hydrogens(model,topology=None,forcefield=None):  
+def add_hydrogens(model,topology=None,forcefield=None):
     if not isinstance(model, chempy.models.Connected):
         raise ValueError('model is not a "Connected" model object')
     nAtom = model.nAtom
@@ -172,4 +172,3 @@ def add_hydrogens(model,topology=None,fo
                                     bnd.order = bonds[b]['order']
                                     mbond[idx1].append(bnd)
                                     mbond[idx2].append(bnd)
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/__init__.py pymol-open-source-2.3.3/modules/chempy/__init__.py
--- pymol-open-source-2.3.0/modules/chempy/__init__.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/__init__.py	2019-08-22 10:24:47.754601554 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -80,7 +80,7 @@ class Atom(object):
     ss                  = ''
 
     def get_mass(self):
-        '''Given the chemical symbol the atomic mass is returned'''      
+        '''Given the chemical symbol the atomic mass is returned'''
         return atomic_mass[self.symbol]
 
     def get_number(self):
@@ -97,9 +97,9 @@ class Atom(object):
             print("unknown implicit_valence for", self.symbol)
             return 0
         return max(0, maxfree - npaired + self.formal_charge)
-    
+
     def has(self,attr):
-        return attr in self.__dict__ 
+        return attr in self.__dict__
 
     def in_same_residue(self,other):
         if self.resi == other.resi:
@@ -122,7 +122,7 @@ class Atom(object):
     def get_signature(self):
         return ':'.join([self.segi, self.chain, self.resn,
             self.resi, self.symbol, self.name])
-    
+
     def __cmp__(self,other):
         return \
                 cmp(type(self), type(other)) or \
@@ -161,7 +161,7 @@ class Bond:
     stereo  = 0
 
     def has(self,attr):
-        return attr in self.__dict__ 
+        return attr in self.__dict__
 
 class Molecule:
 
@@ -179,10 +179,10 @@ class Molecule:
             return Molecule.defaults[attr]
         else:
             raise AttributeError(attr)
-        
+
     def has(self,attr):
-        return attr in self.__dict__ 
-    
+        return attr in self.__dict__
+
 class Storage:
 
     def my_open(self,fname,mode='r'):
@@ -197,13 +197,13 @@ class Storage:
             return gzip.open(fname, mode)
         else:
             return open(fname,mode)
-        
+
     def updateFromList(self,indexed,**params):
         return NotImplementedError
-    
+
     def fromList(self,**params):
         return NotImplementedError
-    
+
     def toList(self,indexed,**params):
         return NotImplementedError
 
@@ -235,7 +235,7 @@ class PseudoFile:
 
     def write(self,st):
         self.list.append(str(st))
-    
+
     def readline(self):
         try:
             return self.list.pop(0)
@@ -244,25 +244,25 @@ class PseudoFile:
 
     def close(self):
         self.list = None
-  
+
 feedback = { 'warnings': 1,
                  'terse'   : 1,
                  'io'      : 1,
                  'actions' : 1,
                  'tinker'  : 1,
-                 'gamess'  : 1,             
+                 'gamess'  : 1,
                  'atoms'   : 0,
-                 'bonds'   : 0,                          
+                 'bonds'   : 0,
                  'verbose' : 0,
                  'bmin'    : 1,
                  }
 
-if 'CHEMPY_DATA' in os.environ:  # 
+if 'CHEMPY_DATA' in os.environ:  #
     path = os.environ['CHEMPY_DATA'] + '/'
 elif 'PYMOL_DATA' in os.environ:
     path = os.environ['PYMOL_DATA'] + '/chempy/'
 elif 'PYMOL_PATH' in os.environ:
-    path = os.environ['PYMOL_PATH'] + '/data/chempy/'   
+    path = os.environ['PYMOL_PATH'] + '/data/chempy/'
 elif 'FREEMOL_MODULES' in os.environ:
     path = os.environ['FREEMOL_MODULES'] + '/chempy/'
 else:
@@ -332,7 +332,7 @@ atomic_mass = {
     'Se' :  78.96,
     'SE' :  78.96,
     'Br' :  79.904,
-    'BR' :  79.904,   
+    'BR' :  79.904,
     'Kr' :  83.80,
     'KR' :  83.80,
     'Rb' :  85.4678,
diff -upNr pymol-open-source-2.3.0/modules/chempy/io.py pymol-open-source-2.3.3/modules/chempy/io.py
--- pymol-open-source-2.3.0/modules/chempy/io.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/io.py	2019-08-22 10:24:47.762602856 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -40,4 +40,3 @@ gms = GMS() # OBSOLETE - PLEASE DO NOT U
 mmd = MMD()
 mae = MAE()
 cc1 = CC1()
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/lst.py pymol-open-source-2.3.3/modules/chempy/lst.py
--- pymol-open-source-2.3.0/modules/chempy/lst.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/lst.py	2019-08-22 10:24:47.762602856 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -31,5 +31,3 @@ class LST(Storage):
             for a in list:
                 fp.write(str(a)+"\n")
         fp.close()
-        
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/mae.py pymol-open-source-2.3.3/modules/chempy/mae.py
--- pymol-open-source-2.3.0/modules/chempy/mae.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/mae.py	2019-08-22 10:24:47.762602856 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -33,8 +33,8 @@ class MAEParser:
 
     def __init__(self,lst=None):
         self.i = 0 # index in list
-        self.t = [] # token list 
-        self.d = [] # hiearchy of data read 
+        self.t = [] # token list
+        self.d = [] # hiearchy of data read
         self.lst = lst
         self.lst_len = len(lst)
 
@@ -60,14 +60,14 @@ class MAEParser:
 
     def push_tok(self,tok):
         self.t.insert(0,tok)
-        
+
     def parse_top(self):
         dct = {}
         stk = [] # keyword stack
         mode = 0 # 0 = definition, 1 = data
         while 1:
             tok = self.nxt_tok()
-            if tok==None:
+            if tok is None:
                 break
             if tok==':::':
                 mode = 1
@@ -93,7 +93,7 @@ class MAEParser:
         cc = 0
         while 1:
             tok = self.nxt_tok()
-            if tok==None:
+            if tok is None:
                 break
             if tok=='}':
                 break
@@ -118,20 +118,20 @@ class MAEParser:
                     c = 0
                     for c in range(n_fld):
                         tok = self.nxt_tok()
-                        if tok==None:
+                        if tok is None:
                             break
                         data[c].append(coer[c](*(tok,)))
                         if tok=='}':
                             break
         return (n_rec,dct,data) # return a tuple
-        
+
     def parse_m_ct(self):
         dct = {}
         stk = [] # keyword stack
         mode = 0 # 0 = definition, 1 = data
         while 1:
             tok = self.nxt_tok()
-            if tok==None:
+            if tok is None:
                 break
             if tok==':::':
                 mode = 1
@@ -154,11 +154,11 @@ class MAEParser:
             if tok=='}':
                 break
         return dct
-        
+
     def parse(self):
         while 1:
             tok = self.nxt_tok()
-            if tok==None:
+            if tok is None:
                 break
             if tok=='{':
                 self.d.append('top',self.parse_top())
@@ -166,24 +166,24 @@ class MAEParser:
                 self.nxt_tok() # skip '{'
                 self.d.append(tok,self.parse_m_ct())
         return self.d
-    
+
 class MAE(Storage):
 
     def _read_m_atom(self,m_atom,model):
         ma = model.atom
         at_ent = m_atom[1]
         at_dat = m_atom[2]
-        
-        nAtom = m_atom[0]      
+
+        nAtom = m_atom[0]
         if 'i_m_mmod_type' in at_ent:
             a1 = at_dat[at_ent['i_m_mmod_type']]
-            
+
             for b in range(nAtom):
                 nt = a1[b]
-                ma[b].numeric_type = nt 
+                ma[b].numeric_type = nt
                 ma[b].symbol = MMOD_atom_data[nt][1]
                 ma[b].text_type = MMOD_atom_data[nt][0]
-                
+
         if 'r_m_x_coord' in at_ent and \
             'r_m_y_coord' in at_ent and \
             'r_m_z_coord' in at_ent:
@@ -192,53 +192,53 @@ class MAE(Storage):
             a3 = at_dat[at_ent['r_m_z_coord']]
             for b in range(nAtom):
                 ma[b].coord = [a1[b],a2[b],a3[b] ]
-                
+
         if 'i_m_residue_number' in at_ent:
             a1 = at_dat[at_ent['i_m_residue_number']]
             for b in range(nAtom):
                 resi = a1[b]
                 ma[b].resi = str(resi)
                 ma[b].resi_number = resi
-                
+
         if 's_m_mmod_res' in at_ent:
             a1 = at_dat[at_ent['s_m_mmod_res']]
-            for b in range(nAtom):         
+            for b in range(nAtom):
                 ma[b].resi_code = a1[b]
-                
+
         if 's_m_chain_name' in at_ent:
             a1 = at_dat[at_ent['s_m_chain_name']]
             for b in range(nAtom):
                 ma[b].chain = a1[b]
-                
+
         if 'i_m_color' in at_ent:
             a1 = at_dat[at_ent['i_m_color']]
             for b in range(nAtom):
                 ma[b].color_code = a1[b]
-                
+
         if 'r_m_charge1' in at_ent:
             a1 = at_dat[at_ent['r_m_charge1']]
             for b in range(nAtom):
                 ma[b].partial_charge = a1[b]
-                
+
         if 's_m_pdb_residue_name' in at_ent:
             a1 = at_dat[at_ent['s_m_pdb_residue_name']]
             for b in range(nAtom):
                 resn = a1[b].strip()
                 if len(resn):
                     ma[b].resn = resn
-                    
+
         if 'i_m_formal_charge' in at_ent:
             a1 = at_dat[at_ent['i_m_formal_charge']]
             for b in range(nAtom):
                 ma[b].formal_charge = a1[b]
-                
+
         if 's_m_atom_name' in at_ent:
             a1 = at_dat[at_ent['s_m_atom_name']]
             for b in range(nAtom):
                 nam = a1[b].strip()
                 if len(nam):
                     ma[b].name = nam
-                
+
         if 's_m_pdb_atom_name' in at_ent:
             a1 = at_dat[at_ent['s_m_pdb_atom_name']]
             for b in range(nAtom):
@@ -249,8 +249,8 @@ class MAE(Storage):
     def _read_m_bond(self,m_bond,model):
         bd_ent = m_bond[1]
         bd_dat = m_bond[2]
-        
-        nBond = m_bond[0]      
+
+        nBond = m_bond[0]
 
         if len(bd_dat[0]): # not empty right?
             if 'i_m_from' in bd_ent and \
@@ -269,7 +269,7 @@ class MAE(Storage):
                         bnd.index = [ bd1,bd2 ]
                         bnd.order = bd3
                         model.bond.append(bnd)
-                        
+
 #---------------------------------------------------------------------------------
     def fromList(self,MMODList): # returns a list of indexed models
 
@@ -278,7 +278,7 @@ class MAE(Storage):
 
         full_model = None
         result = []
-        
+
         for mp_ent in mp_rec:
             if mp_ent[0] == 'f_m_ct':
                 f_m_ct = mp_ent[1]
@@ -298,8 +298,8 @@ class MAE(Storage):
                     self._read_m_bond(m_bond,model)
                 full_model = model
                 result.append(model)
-                
-            elif mp_ent[0]=='p_m_ct' and full_model!=None:
+
+            elif mp_ent[0]=='p_m_ct' and full_model is not None:
                 model = copy.deepcopy(full_model)
                 f_m_ct = mp_ent[1]
                 if 's_m_title' in f_m_ct:
@@ -379,4 +379,3 @@ MMOD_atom_data = {
   62: ['Du','Du','unk',-1, 0],
   63: ['Lp','Lp','unk', 1, 0],
   64: ['Du','Du','unk',-1, 0]};
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/map.py pymol-open-source-2.3.3/modules/chempy/map.py
--- pymol-open-source-2.3.0/modules/chempy/map.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/map.py	2019-08-22 10:24:47.762602856 +0200
@@ -1,19 +1,19 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
 class Map:
-    
+
     def __init__(self):
         self.cell_dim = [ 1.0, 1.0, 1.0]
         self.cell_ang = [ 90.0, 90.0, 90.0 ]
@@ -21,7 +21,7 @@ class Map:
         self.first = [ 0, 0, 0 ] # first slice on each axis
         self.last = [ 9, 9, 9 ] # last slice on each axis
         self.format = 'Empty'
-        
+
     def from_c_object(self,cobj,format,cell_dim,cell_ang,cell_div,first,last):
         # pack with defined types
         self.format = str(format)
@@ -41,5 +41,3 @@ class Map:
         self.last = [ int(last[0]),
                           int(last[1]),
                           int(last[2])]
-        
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/mass.py pymol-open-source-2.3.3/modules/chempy/mass.py
--- pymol-open-source-2.3.0/modules/chempy/mass.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/mass.py	2019-08-22 10:24:47.762602856 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -31,7 +31,7 @@ implicit_valence = {
 def implicit_mass(indexed):
     valence = [0]*len(indexed.atom)
     implicit = [0]*len(indexed.atom)
-    
+
     for a in indexed.bond:
         ai0 = a.index[0]
         ai1 = a.index[1]
@@ -42,4 +42,3 @@ def implicit_mass(indexed):
         valence[c] = valence[c] - a.formal_charge
         implicit[c] = implicit_valence[a.symbol][valence[c]]
     c = c + 1
-    
diff -upNr pymol-open-source-2.3.0/modules/chempy/mmd.py pymol-open-source-2.3.3/modules/chempy/mmd.py
--- pymol-open-source-2.3.0/modules/chempy/mmd.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/mmd.py	2019-08-22 10:24:47.762602856 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -21,12 +21,12 @@ import string
 import copy
 
 class MMD(Storage):
-    
+
 #---------------------------------------------------------------------------------
     def fromList(self,MMODList):
 
         model = Connected()
-        
+
 # get header information
         nAtom = int(MMODList[0][1:6])
         model.molecule.title = string.strip(MMODList[0][8:])
@@ -36,7 +36,7 @@ class MMD(Storage):
         cnt = 0
         for a in range(nAtom):
             model.bond.append([])
-            
+
         for a in range(nAtom):
             at = Atom()
             at.numeric_type = int(MMODList[irec][1:4])
@@ -54,12 +54,12 @@ class MMD(Storage):
                         b.index = [cnt,a2]
                         b.order = int(tokens[2*i+1])
                         model.bond[b.index[0]].append(b) # note two refs to same object
-                        model.bond[b.index[1]].append(b) # note two refs to same object 
+                        model.bond[b.index[1]].append(b) # note two refs to same object
                 else:
                     break
-            
+
 # extract other information
-            at.coord = [float(MMODList[irec][53:64]), 
+            at.coord = [float(MMODList[irec][53:64]),
                 float(MMODList[irec][65:76]), float(MMODList[irec][77:88])]
             at.resi = string.strip(MMODList[irec][89:94])
             at.resi_number = int(at.resi)
@@ -79,7 +79,7 @@ class MMD(Storage):
             model.atom.append(at)
             irec = irec + 1
             cnt = cnt + 1
-            
+
 # fill in remaining datatypes
         cnt = 1
         for a in model.atom:
@@ -87,7 +87,7 @@ class MMD(Storage):
             a.symbol = MMOD_atom_data[a.numeric_type][1]
             a.formal_charge = MMOD_atom_data[a.numeric_type][4]
             cnt = cnt + 1
-            
+
         return(model.convert_to_indexed())
 
 #---------------------------------------------------------------------------------
@@ -103,23 +103,23 @@ class MMD(Storage):
         c = 0
         for a in list[1:]:
             mac = model.atom[c]
-            mac.coord = [float(a[53:64]), 
+            mac.coord = [float(a[53:64]),
                 float(a[65:76]), float(a[77:88])]
-            mac.partial_charge = float(a[100:109])         
+            mac.partial_charge = float(a[100:109])
             c = c + 1
-            
+
 #---------------------------------------------------------------------------------
     def toList(self,model,no_blank_names=1):
 
         conn = copy.deepcopy(model)
         conn = conn.convert_to_connected()
-        
+
         MMODList = []
         MMODList.append(" %5d  %-70s\n" %(conn.nAtom,conn.molecule.title))
         c = 0
         neighbors_len = 6
         for i in conn.atom:
-            
+
 # construct neighbor list
             neighbors = [0] * neighbors_len
             bondorders = [0] * neighbors_len
@@ -132,7 +132,7 @@ class MMD(Storage):
                     n = b.index[1]
                 neighbors[j] = n + 1
                 bondorders[j] = b.order
-                
+
 # assemble output line
             if i.numeric_type>0:
                 tline = " %3d" % (i.numeric_type)
@@ -140,7 +140,7 @@ class MMD(Storage):
                 tline = " %3d" % 64
             for j in range(neighbors_len):
                 tline = tline + " %5d %1d" % (neighbors[j], bondorders[j])
-            tline = tline + " %11.6f %11.6f %11.6f " % (i.coord[0], 
+            tline = tline + " %11.6f %11.6f %11.6f " % (i.coord[0],
                 i.coord[1], i.coord[2])
             name = i.name
             if not len(name):
@@ -152,7 +152,7 @@ class MMD(Storage):
                  i.partial_charge, i.partial_charge, i.resn, name)
             MMODList.append(tline)
             c = c + 1
-            
+
         return(MMODList)
 
 
@@ -217,4 +217,3 @@ MMOD_atom_data = {
   62: ['Du','Du','unk',-1, 0],
   63: ['Lp','Lp','unk', 1, 0],
   64: ['Du','Du','unk',-1, 0]};
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/models.py pymol-open-source-2.3.3/modules/chempy/models.py
--- pymol-open-source-2.3.0/modules/chempy/models.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/models.py	2019-08-22 10:24:47.762602856 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -38,7 +38,7 @@ class Base:
         for a in self.atom:
             idx[id(a)] = c
             c = c + 1
-            
+
 #------------------------------------------------------------------------------
     def get_residues(self):
         list = []
@@ -85,13 +85,13 @@ class Base:
             print(a.symbol, a.name,  a.coord)
         for a in self.bond:
             print(a.index)
-            
+
 #------------------------------------------------------------------------------
     def get_implicit_mass(self):
         # mass calculation for implicit models
 
         valence = [0]*len(self.atom)
-        
+
         for a in self.bond:
             v = 1.5 if a.order == 4 else a.order
             valence[a.index[0]] += v
@@ -138,7 +138,7 @@ class Indexed(Base):
 #------------------------------------------------------------------------------
     def __init__(self):
         self.reset()
-        
+
 #------------------------------------------------------------------------------
     def reset(self):
         self.index = None
@@ -162,7 +162,7 @@ class Indexed(Base):
             return [mn,mx]
         else:
             return [[0.0,0.0,0.0],[0.0,0.0,0.0]]
-        
+
 #------------------------------------------------------------------------------
     def merge(self,other): # steals atom objects from 'other' and resets 'other'
         if chempy.feedback['actions']:
@@ -181,7 +181,7 @@ class Indexed(Base):
     def delete_atom(self,index):
         if chempy.feedback['atoms']:
             print(" "+str(self.__class__)+": deleting atom %d." % index)
-    
+
         nAtom=self.nAtom
 
 # update index if it exists
@@ -208,9 +208,9 @@ class Indexed(Base):
 
 # re-index bond table
         for b in self.bond:
-            if b.index[0] > index: 
+            if b.index[0] > index:
                 b.index[0] = b.index[0] - 1
-            if b.index[1] > index: 
+            if b.index[1] > index:
                 b.index[1] = b.index[1] - 1
 
 #--------------------------------------------------------------------------------
@@ -224,9 +224,9 @@ class Indexed(Base):
         lrev = copy.deepcopy(list)
         lrev.sort()
         lrev.reverse()
-        
+
         # generate cross-reference tables
-    
+
         o2n = {} # old to new
         if len(lrev):
             nxt = lrev.pop()
@@ -254,10 +254,10 @@ class Indexed(Base):
                 if o2n[i]>=0:
                     new_atom.append(self.atom[i])
             self.atom = new_atom
-            
-            # delete bonds 
 
-            new_bond = []   
+            # delete bonds
+
+            new_bond = []
             for b in self.bond:
                 b0 = b.index[0]
                 b1 = b.index[1]
@@ -284,12 +284,12 @@ class Indexed(Base):
 
         nAtom=self.nAtom
         self.atom.insert(index,atom)
-        
+
 # re-index bond table
         for b in self.bond:
-            if b.index[0] >= index: 
+            if b.index[0] >= index:
                 b.index[0] = b.index[0] + 1
-            if b.index[1] >= index: 
+            if b.index[1] >= index:
                 b.index[1] = b.index[1] + 1
 
 # update index if it exists
@@ -299,7 +299,7 @@ class Indexed(Base):
                 if idx[k] >= index:
                     idx[k] = idx[k] + 1
             idx[id(atom)] = index
-            
+
 #------------------------------------------------------------------------------
     def index_atom(self,atom):
         c = 0
@@ -309,7 +309,7 @@ class Indexed(Base):
                 return c
             c = c + 1
         return -1
-        
+
 #------------------------------------------------------------------------------
     def add_atom(self,atom):
         if chempy.feedback['atoms']:
@@ -325,7 +325,7 @@ class Indexed(Base):
         if chempy.feedback['bonds']:
             print(" "+str(self.__class__)+": adding bond (%d,%d)." % \
                     (bond.index[0],bond.index[1]))
-        self.bond.append(bond)      
+        self.bond.append(bond)
 
 #------------------------------------------------------------------------------
     def remove_bond(self,index):
@@ -333,8 +333,8 @@ class Indexed(Base):
             print(" "+str(self.__class__)+": removing bond %d." % index)
         nBond=len(self.Bond)
         del self.bond[index]
-        
-    
+
+
 #------------------------------------------------------------------------------
     def convert_to_connected(self):
         if chempy.feedback['verbose']:
@@ -348,11 +348,11 @@ class Indexed(Base):
             model.bond.append([])
         for b in self.bond:
             model.bond[b.index[0]].append(b) # note two refs to same object
-            model.bond[b.index[1]].append(b) # note two refs to same object 
+            model.bond[b.index[1]].append(b) # note two refs to same object
         self.reset()
         return model
 #------------------------------------------------------------------------------
-    def from_molobj(self,molobj): 
+    def from_molobj(self,molobj):
         self.reset()
         mol = self.molecule
         if len(molobj.title):
@@ -406,7 +406,7 @@ class Indexed(Base):
         if not self.index:
             self.update_index()
         old_index = self.index
-        self.atom.sort()      
+        self.atom.sort()
         self.update_index()
         xref = {}
         new_index = self.index
@@ -501,40 +501,40 @@ class Indexed(Base):
                 for b in model.bond: # use bond as center of torsion
                     a1 = b.index[0]
                     a2 = b.index[1]
-                    for c in cmodel.bond[a1]: 
-                        a0 = c.index[0] 
+                    for c in cmodel.bond[a1]:
+                        a0 = c.index[0]
                         if a0 not in (a1,a2): # outside atom
                             for d in cmodel.bond[a2]:
-                                a3 = d.index[0] 
+                                a3 = d.index[0]
                                 if a3 not in (a0,a1,a2): # outside atom
                                     if a0 < a3:
                                         to = (a0,a1,a2,a3)
                                     else:
-                                        to = (a3,a2,a1,a0)                        
+                                        to = (a3,a2,a1,a0)
                                     tors[to] = 1
-                                a3 = d.index[1] 
+                                a3 = d.index[1]
                                 if a3 not in (a0,a1,a2): # outside atom
                                     if a0 < a3:
                                         to = (a0,a1,a2,a3)
                                     else:
                                         to = (a3,a2,a1,a0)
                                     tors[to] = 1
-                        a0 = c.index[1] 
+                        a0 = c.index[1]
                         if a0 not in (a1,a2): # outside atom
                             for d in cmodel.bond[a2]:
-                                a3 = d.index[0] 
+                                a3 = d.index[0]
                                 if a3 not in (a0,a1,a2): # outside atom
                                     if a0 < a3:
                                         to = (a0,a1,a2,a3)
                                     else:
-                                        to = (a3,a2,a1,a0)                        
+                                        to = (a3,a2,a1,a0)
                                     tors[to] = 1
-                                a3 = d.index[1] 
+                                a3 = d.index[1]
                                 if a3 not in (a0,a1,a2): # outside atom
                                     if a0 < a3:
                                         to = (a0,a1,a2,a3)
                                     else:
-                                        to = (a3,a2,a1,a0)                        
+                                        to = (a3,a2,a1,a0)
                                     tors[to] = 1
                 if len(tors):
                     # choose remaining atoms based on existing atoms using torsion
@@ -576,14 +576,14 @@ class Connected(Base):
 #------------------------------------------------------------------------------
     def __init__(self):
         self.reset()
-  
+
 #------------------------------------------------------------------------------
     def reset(self):
         self.index = None
         self.molecule = chempy.Molecule()
         self.atom = []
         self.bond = []
-        
+
 #------------------------------------------------------------------------------
     def convert_to_indexed(self):
         if chempy.feedback['verbose']:
@@ -591,7 +591,7 @@ class Connected(Base):
         indexed = Indexed()
         indexed.atom = self.atom
         indexed.molecule = self.molecule
-        c = 0 
+        c = 0
         for a in self.bond:
             for b in a:
                 if b.index[0] == c:
@@ -608,7 +608,7 @@ class Connected(Base):
 
         nAtom=self.nAtom
         self.atom.insert(index,atom)
-        
+
 # re-index bond table
         for a in self.bonds:
             for b in a:
@@ -660,9 +660,9 @@ class Connected(Base):
 
 # re-index bond table
         for b in self.bond:
-            if b.index[0] > index: 
+            if b.index[0] > index:
                 b.index[0] = b.index[0] - 1
-            if b.index[1] > index: 
+            if b.index[1] > index:
                 b.index[1] = b.index[1] - 1
 
 #------------------------------------------------------------------------------
@@ -683,7 +683,7 @@ class Connected(Base):
         if not self.index:
             self.update_index()
         old_index = self.index
-        self.atom.sort()      
+        self.atom.sort()
         self.update_index()
         xref = {}
         new_index = self.index
@@ -705,7 +705,3 @@ class Connected(Base):
         self.bond = new_bond
         del old_index
         del xref
-        
-
-
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/mol2.py pymol-open-source-2.3.3/modules/chempy/mol2.py
--- pymol-open-source-2.3.0/modules/chempy/mol2.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/mol2.py	2019-08-22 10:24:47.762602856 +0200
@@ -4,11 +4,11 @@
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
diff -upNr pymol-open-source-2.3.0/modules/chempy/mol.py pymol-open-source-2.3.3/modules/chempy/mol.py
--- pymol-open-source-2.3.0/modules/chempy/mol.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/mol.py	2019-08-22 10:24:47.762602856 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -46,7 +46,7 @@ class MOL(Storage):
         for a in range(nAtom):
             at = Atom()
             at.index = cnt
-            at.coord = [float(molList[irec][0:10]), 
+            at.coord = [float(molList[irec][0:10]),
                 float(molList[irec][10:20]),float(molList[irec][20:30])]
             at.symbol = string.strip(molList[irec][31:33])
             try:
@@ -110,7 +110,7 @@ class MOL(Storage):
 
             # write bond records
         for b in model.bond:
-            molList.append("%3d%3d%3d%3d  0  0  0\n" % (b.index[0]+1, 
+            molList.append("%3d%3d%3d%3d  0  0  0\n" % (b.index[0]+1,
                 b.index[1]+1, b.order,b.stereo))
 
             # if necessary, write M  CHG records for charged atoms
@@ -133,5 +133,3 @@ class MOL(Storage):
                 molList.append(tline + "\n")
         molList.append("M  END\n")
         return(molList)
-
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/neighbor.py pymol-open-source-2.3.3/modules/chempy/neighbor.py
--- pymol-open-source-2.3.0/modules/chempy/neighbor.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/neighbor.py	2019-08-22 10:24:47.762602856 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -53,7 +53,7 @@ class Neighbor:
             return self.voxel[k]
         else:
             return []
-        
+
     def get_neighbors(self,vect):
         if self.neighbor:
             k = self.address(vect)
@@ -72,5 +72,3 @@ class Neighbor:
                         if k2 in voxel:
                             lst.extend(voxel[k2])
             return lst
-            
-            
diff -upNr pymol-open-source-2.3.0/modules/chempy/pdb.py pymol-open-source-2.3.3/modules/chempy/pdb.py
--- pymol-open-source-2.3.0/modules/chempy/pdb.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/pdb.py	2019-08-22 10:24:47.762602856 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -17,12 +17,12 @@ from chempy.models import Indexed
 import string
 
 class PDB(Storage):
-    
+
 #---------------------------------------------------------------------------------
-    def fromList(self,list):   # currently no handling of conect records 
+    def fromList(self,list):   # currently no handling of conect records
 
         model = Indexed()
-        
+
 # read atoms
         cnt = 0
         at = None
@@ -37,14 +37,14 @@ class PDB(Storage):
                 at.chain = string.strip(rec[21:22])
                 at.resi = string.strip(rec[22:27]) # note: insertion is part of resi
                 at.resi_number = int(rec[22:26])
-                at.coord = [float(rec[30:38]), 
+                at.coord = [float(rec[30:38]),
                                 float(rec[38:46]),
                                 float(rec[46:54])]
                 try:
                     at.q = float(rec[54:60])
                 except ValueError:
                     at.q = 1.0
-                try:               
+                try:
                     at.b = float(rec[60:66])
                 except ValueError:
                     at.b = 0.0
@@ -87,7 +87,7 @@ class PDB(Storage):
                 else:
                     resi=at.resi
             list.append(
-                "%6s%5i %-4s%1s%3s %1s%5s   %8.3f%8.3f%8.3f%6.2f%6.2f      %-4s%2s\n" % 
+                "%6s%5i %-4s%1s%3s %1s%5s   %8.3f%8.3f%8.3f%6.2f%6.2f      %-4s%2s\n" %
                 (het,cnt,name,at.alt,at.resn,at.chain,resi,
                 at.coord[0],at.coord[1],at.coord[2],at.q,at.b,at.segi,at.symbol))
             if hasattr(at,'ter'):
@@ -99,4 +99,3 @@ class PDB(Storage):
             cnt = cnt + 1
         list.append("END\n")
         return(list)
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/pkl.py pymol-open-source-2.3.3/modules/chempy/pkl.py
--- pymol-open-source-2.3.0/modules/chempy/pkl.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/pkl.py	2019-08-22 10:24:47.762602856 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -85,7 +85,7 @@ class PKL(Storage):
         if 'bin' not in params:
             result = cPickle.dump(indexed,fp,1)
         else:
-            result = cPickle.dump(indexed,fp,params['bin'])         
+            result = cPickle.dump(indexed,fp,params['bin'])
         fp.close()
 
 #---------------------------------------------------------------------------
@@ -100,8 +100,8 @@ class PKL(Storage):
         if 'bin' not in params:
             result = cPickle.dump(indexed,fp,1)
         else:
-            result = cPickle.dump(indexed,fp,params['bin'])         
- 
+            result = cPickle.dump(indexed,fp,params['bin'])
+
 #---------------------------------------------------------------------------
     def fromString(self,st):
         return cPickle.loads(st)
@@ -109,4 +109,3 @@ class PKL(Storage):
 #---------------------------------------------------------------------------
     def toString(self,model):
         return cPickle.dumps(model)
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/place.py pymol-open-source-2.3.3/modules/chempy/place.py
--- pymol-open-source-2.3.0/modules/chempy/place.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/place.py	2019-08-22 10:24:47.762602856 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 #
@@ -99,7 +99,7 @@ def simple_unknowns(model,bondfield=bond
                             p0 = normalize(d1)
                             d2 = sub(at4.coord,at3.coord)
                             p1 = normalize(cross_product(d2,p0))
-                            p2 = normalize(cross_product(p0,p1))                     
+                            p2 = normalize(cross_product(p0,p1))
                             v = scale(p2,TRI_TAN)
                             v = normalize(add(p0,v))
                             at2.coord = add(at1.coord,scale(v,
@@ -153,7 +153,7 @@ def simple_unknowns(model,bondfield=bond
                         v = scale(p2,TRI_TAN)
                         v = normalize(add(p0,v))
                         at2.coord = add(at1.coord,scale(v,
-                          bnd_len[(at1.text_type,at2.text_type)]))                                                         
+                          bnd_len[(at1.text_type,at2.text_type)]))
                         at2 = model.atom[a[1][1]]
                         v = scale(p2,-TRI_TAN)
                         v = normalize(add(p0,v))
@@ -163,7 +163,7 @@ def simple_unknowns(model,bondfield=bond
                         d2 = [1.0,0,0]
                         at3 = model.atom[know[0]]
                         d1 = sub(at1.coord,at3.coord)
-                        p0 = normalize(d1)                  
+                        p0 = normalize(d1)
                         p1 = normalize(cross_product(d2,p0))
                         p2 = normalize(cross_product(p0,p1))
                         v = scale(p2,TRI_TAN)
@@ -191,17 +191,17 @@ def simple_unknowns(model,bondfield=bond
                     v = normalize(add(p0,v))
                     at2.coord = add(at1.coord,scale(v,
                             bnd_len[(at1.text_type,at2.text_type)]))
-                    at2 = model.atom[a[1][1]]               
+                    at2 = model.atom[a[1][1]]
                     v = scale(p1,-TET_TAN)
                     v = normalize(add(p0,v))
                     at2.coord = add(at1.coord,scale(v,
                             bnd_len[(at1.text_type,at2.text_type)]))
                 else:
-                    if len(know): # sulfonamide? 
+                    if len(know): # sulfonamide?
                         d2 = [1.0,0,0]
                         at3 = model.atom[know[0]]
                         d1 = sub(at1.coord,at3.coord)
-                        p0 = normalize(d1)                                    
+                        p0 = normalize(d1)
                         p1 = normalize(cross_product(d2,p0))
                         v = scale(p1,TET_TAN)
                         v = normalize(add(p0,v))
@@ -244,7 +244,7 @@ def simple_unknowns(model,bondfield=bond
                     v = scale(p2,-TET_TAN)
                     v = normalize(add(p0,v))
                     at2.coord = add(at1.coord,scale(v,
-                          bnd_len[(at1.text_type,at2.text_type)]))                                                         
+                          bnd_len[(at1.text_type,at2.text_type)]))
                     at4 = at2
                     at2 = model.atom[a[1][1]]
                     d1 = sub(at1.coord,at3.coord)
@@ -256,14 +256,14 @@ def simple_unknowns(model,bondfield=bond
                     v = normalize(add(p0,v))
                     at2.coord = add(at1.coord,scale(v,
                             bnd_len[(at1.text_type,at2.text_type)]))
-                    at2 = model.atom[a[1][2]]               
+                    at2 = model.atom[a[1][2]]
                     v = scale(p1,-TET_TAN)
                     v = normalize(add(p0,v))
                     at2.coord = add(at1.coord,scale(v,
                             bnd_len[(at1.text_type,at2.text_type)]))
                 elif len(know): # fall-back
                     d2 = [1.0,0,0]
-                    at3 = model.atom[know[0]]                  
+                    at3 = model.atom[know[0]]
 
                     # 2013-08-14 added by thomas, not sure if this is correct
                     d1 = sub(at1.coord,at3.coord)
@@ -335,5 +335,3 @@ def test_random():
                 del a.coord
         simple_unknowns(m)
         cmd.load_model(m.convert_to_indexed(), 'm' + str(i + 1))
-
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/protein_amber99.py pymol-open-source-2.3.3/modules/chempy/protein_amber99.py
--- pymol-open-source-2.3.0/modules/chempy/protein_amber99.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/protein_amber99.py	2019-08-22 10:24:47.762602856 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
diff -upNr pymol-open-source-2.3.0/modules/chempy/protein_amber.py pymol-open-source-2.3.3/modules/chempy/protein_amber.py
--- pymol-open-source-2.3.0/modules/chempy/protein_amber.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/protein_amber.py	2019-08-22 10:24:47.762602856 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
diff -upNr pymol-open-source-2.3.0/modules/chempy/protein_mmff.py pymol-open-source-2.3.3/modules/chempy/protein_mmff.py
--- pymol-open-source-2.3.0/modules/chempy/protein_mmff.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/protein_mmff.py	2019-08-22 10:24:47.766603508 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -1223,7 +1223,7 @@ for a in normal.keys():
     na = normal[a]
     na['type'] = numeric_map[int(na['type'])]
 
-for a in n_terminal.keys():   
+for a in n_terminal.keys():
     na = n_terminal[a]
     na['type'] = numeric_map[int(na['type'])]
 
@@ -1238,8 +1238,7 @@ def check_sum(dct):
         if a[0] not in sm:
             sm[a[0]] = dct[a]['charge']
         else:
-            sm[a[0]] = sm[a[0]]+ dct[a]['charge']         
+            sm[a[0]] = sm[a[0]]+ dct[a]['charge']
 
     for a in sm.keys():
         print(a,'%7.4f'%sm[a])
-        
diff -upNr pymol-open-source-2.3.0/modules/chempy/protein.py pymol-open-source-2.3.3/modules/chempy/protein.py
--- pymol-open-source-2.3.0/modules/chempy/protein.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/protein.py	2019-08-22 10:24:47.762602856 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -44,7 +44,7 @@ def generate(model, forcefield = protein
                  skip_sort=None, bondfield = bond_amber ):
 
     strip_atom_bonds(model) # remove bonds between non-hetatms (ATOM)
-    add_bonds(model,forcefield=forcefield)   
+    add_bonds(model,forcefield=forcefield)
     connected = model.convert_to_connected()
     add_hydrogens(connected,forcefield=forcefield,skip_sort=skip_sort)
     place.simple_unknowns(connected,bondfield = bondfield)
@@ -58,7 +58,7 @@ def strip_atom_bonds(model):
         if matom[a.index[0]].hetatm or matom[a.index[1]].hetatm:
             new_bond.append(a)
     model.bond = new_bond
-    
+
 #---------------------------------------------------------------------------------
 def assign_types(model, forcefield = protein_amber, histidine = 'HIE' ):
     '''   
@@ -82,7 +82,7 @@ but does not add any bonds!
                         for c in range(a[0],a[1]): # this residue
                             model.atom[c].resn = histidine
                         resn = histidine
-                    if resn == 'N-M': # N-methyl from Insight II, 
+                    if resn == 'N-M': # N-methyl from Insight II,
                         for c in range(a[0],a[1]): # this residue
                             model.atom[c].resn = 'NME'
                         resn = 'NME'
@@ -153,7 +153,7 @@ but does not add any bonds!
                                                                 atx.resn = 'CYX'
                                                                 # since b>cur, assume assignment later on
                                             break
-    
+
 #---------------------------------------------------------------------------------
 def add_bonds(model, forcefield = protein_amber, histidine = 'HIE' ):
     '''
@@ -180,7 +180,7 @@ add_bonds(model, forcefield = protein_am
                         for c in range(a[0],a[1]): # this residue
                             model.atom[c].resn = histidine
                         resn = histidine
-                    if resn == 'N-M': # N-methyl from Insight II, 
+                    if resn == 'N-M': # N-methyl from Insight II,
                         for c in range(a[0],a[1]): # this residue
                             model.atom[c].resn = 'NME'
                         resn = 'NME'
@@ -271,14 +271,14 @@ add_bonds(model, forcefield = protein_am
                                                             atx.partial_charge = ffld[k]['charge']
                                                         else:
                                                             raise RuntimeError("no parameters for '"+str(k)+"'")
-                                                    for d in res_list: 
+                                                    for d in res_list:
                                                         if (b>=d[0]) and (b<d[1]): # find other residue
                                                             for c in range(d[0],d[1]):
                                                                 atx = model.atom[c]
                                                                 atx.resn = 'CYX'
                                                                 # since b>cur, assume assignment later on
                                                 break
-                            
+
 #---------------------------------------------------------------------------------
 def add_hydrogens(model,forcefield=protein_amber,skip_sort=None):
     # assumes no bonds between non-hetatms
diff -upNr pymol-open-source-2.3.0/modules/chempy/protein_residues.py pymol-open-source-2.3.3/modules/chempy/protein_residues.py
--- pymol-open-source-2.3.0/modules/chempy/protein_residues.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/protein_residues.py	2019-08-22 10:24:47.766603508 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -1298,11 +1298,11 @@ normal = {
       'CA'   : 'CH3'  ,
       'N01'  : 'N'    ,
       'H01'  : 'H'    ,
-      'HN'   : 'H'    ,      
-      'H02'  : '1HH3' ,      
+      'HN'   : 'H'    ,
+      'H02'  : '1HH3' ,
       'H03'  : '2HH3' ,
       'H04'  : '3HH3' ,
-      '1HA'  : '1HH3' ,      
+      '1HA'  : '1HH3' ,
       '2HA'  : '2HH3' ,
       '3HA'  : '3HH3' ,
       } ,
@@ -1367,7 +1367,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -1412,7 +1412,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -1457,7 +1457,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -1505,7 +1505,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -1555,7 +1555,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -1609,7 +1609,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -1669,7 +1669,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -1738,7 +1738,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -1780,7 +1780,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -1790,7 +1790,7 @@ n_terminal = {
       '1HA'  : '3HA'  ,
       '2HA'  : 'HA'   ,
       'HA1'  : '3HA'  ,
-      'HA2'  : 'HA'   ,      
+      'HA2'  : 'HA'   ,
       'HA3'  : '3HA'  ,
       } ,
    } ,
@@ -1842,7 +1842,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -1905,7 +1905,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -1968,7 +1968,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -2033,7 +2033,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -2111,7 +2111,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -2188,7 +2188,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -2252,7 +2252,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -2311,7 +2311,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -2366,7 +2366,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '3H'  ,
       '2H'   : '2H'  ,
-      '3H'   : '3H'  ,      
+      '3H'   : '3H'  ,
       'H3'   : '3H'   ,
       'H2'   : '2H'   ,
       'HB2'  : '2HB'  ,
@@ -2428,7 +2428,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -2506,7 +2506,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -2564,7 +2564,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -2617,7 +2617,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -2673,7 +2673,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -2749,7 +2749,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
@@ -2823,7 +2823,7 @@ n_terminal = {
    'aliases' : {
       '1H'   : '1HT'  ,
       '2H'   : '2HT'  ,
-      '3H'   : '3HT'  ,      
+      '3H'   : '3HT'  ,
       'HT1'  : '1HT'  ,
       'HT2'  : '2HT'  ,
       'HT3'  : '3HT'  ,
diff -upNr pymol-open-source-2.3.0/modules/chempy/sdf.py pymol-open-source-2.3.3/modules/chempy/sdf.py
--- pymol-open-source-2.3.0/modules/chempy/sdf.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/sdf.py	2019-08-22 10:24:47.766603508 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -21,7 +21,7 @@ import copy
 from chempy import io
 
 class SDFRec:
-    
+
     def __init__(self,sdflist):
         getkee = re.compile("^>\s+<([^>]*)>")
         gettag = re.compile("^>\s+<[^>]*>\s+\((.*)\)")
@@ -81,7 +81,7 @@ class SDFRec:
                 if self.ref_code[k]!='':
                     r.append(">  <"+k+"> ("+self.ref_code[k]+")\n")
                 else:
-                    r.append(">  <"+k+">\n")               
+                    r.append(">  <"+k+">\n")
             for a in self.data[k]:
                 r.append(a)
             if k!='MOL':
@@ -103,21 +103,21 @@ class SDFRec:
                 return None
         else:
             return None
-            
+
     def set_single(self,kee,data,ref_code=None): # adds LF
         self.set(kee,[data+'\n'],ref_code)
-        
+
     def get_model(self):
         return io.mol.fromList(self.get('MOL'))
-        
+
     def set_model(self,model):
         self.set('MOL',io.mol.toList(model))
-                    
+
     def set(self,kee,data,ref_code=None):
         if kee not in self.kees:
             self.kees.append(kee)
             self.ref_code[kee]=''
-        if ref_code!=None:
+        if ref_code is not None:
             self.ref_code[kee]=ref_code
         self.data[kee] = copy.deepcopy(data)
 
@@ -126,7 +126,7 @@ class SDFRec:
         del self.data[kee]
 
 class SDF:
-    
+
     def __init__(*args):
         mode = 'r'
         if len(args)<2:
@@ -157,7 +157,7 @@ class SDF:
         for a in lst:
             self.file.write(a)
         self.file.write('$$$$\n')
-        
+
     def read(self): # returns SDFRec or None at end of file
         cur = []
         while 1:
@@ -171,5 +171,3 @@ class SDF:
 
     def close(self):
         self.file.close()
-        
-    
diff -upNr pymol-open-source-2.3.0/modules/chempy/solvate.py pymol-open-source-2.3.3/modules/chempy/solvate.py
--- pymol-open-source-2.3.0/modules/chempy/solvate.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/solvate.py	2019-08-22 10:24:47.766603508 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -56,5 +56,3 @@ def fill_box(area,water=None,box=18.7743
             y = y + box
         x = x + box
     return solv_box
-
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/tinker/amber.py pymol-open-source-2.3.3/modules/chempy/tinker/amber.py
--- pymol-open-source-2.3.0/modules/chempy/tinker/amber.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/tinker/amber.py	2019-08-22 10:24:47.766603508 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
 #-* Scott Dixon, Metaphorics, LLC
-#-* 
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -22,9 +22,9 @@ import copy
 default_extra = { # atomic number, and normal valency (for tinker)
     # NOTE: THIS SET IS ONLY USED IF THERE ARE NO TINKER RECORDS
     # IN THE PARAMETER FILE
-    # bromine 
+    # bromine
     'BR' : [                 35 ,               1 ],
-    # carbon                           
+    # carbon
     'C'  : [                  6 ,               3 ],
     'CA' : [                  6 ,               3 ],
     'CB' : [                  6 ,               3 ],
@@ -37,7 +37,7 @@ default_extra = { # atomic number, and n
     'CR' : [                  6 ,               3 ],
     'CT' : [                  6 ,               4 ],
     'CV' : [                  6 ,               3 ],
-    'CW' : [                  6 ,               3 ], 
+    'CW' : [                  6 ,               3 ],
     'CY' : [                  6 ,               2 ],
     'CX' : [                  6 ,               2 ],
     'C5' : [                  6 ,               3 ],
@@ -45,7 +45,7 @@ default_extra = { # atomic number, and n
     # calcium
     'C0' : [                 20 ,               3 ],
     # chloride
-    'Cl' : [                 17 ,               1 ], 
+    'Cl' : [                 17 ,               1 ],
     # fluorine
     'F'  : [                  9 ,               1 ],
     # hydrogen
@@ -86,7 +86,7 @@ default_extra = { # atomic number, and n
     'O'  : [                  8 ,               1 ],
     'O2' : [                  8 ,               1 ],
     'OM' : [                  8 ,               1 ],
-    'OZ' : [                  8 ,               1 ],   
+    'OZ' : [                  8 ,               1 ],
     'P'  : [                 15 ,               4 ],
     'S'  : [                 16 ,               2 ],
     'SO'  : [                16 ,               4 ],
@@ -149,7 +149,7 @@ class Parameters:
             a5 = l[0:8]
             self.angle[a5] = [float(l[8:16]),float(l[16:28]),
                                   string.strip(l[28:])]
-        # read torsion 
+        # read torsion
         self.torsion = {}
         while 1:
             l = string.strip(f.readline())
@@ -182,7 +182,7 @@ class Parameters:
         while 1:
             l = string.strip(f.readline())
             if not len(l): break
-        # read vdw equivalents 
+        # read vdw equivalents
         self.vdw_eq = {}
         while 1:
             l = string.strip(f.readline())
@@ -204,7 +204,7 @@ class Parameters:
             self.vdw[a4] =  [float(l[4:20]),
                                   float(l[20:37]),
                                   string.strip(l[37:])]
-            
+
         # read extra tinker information if present
         self.extra = {}
         while 1:
@@ -225,7 +225,7 @@ class Parameters:
         for a in list(self.angle.keys()):
             k = a[6:8]+'-'+a[3:5]+'-'+a[0:2]
             self.angle[k] = self.angle[a]
-            
+
     def dump(self):
         for b in self.type:
             print(b)
@@ -261,7 +261,7 @@ class Parameters:
         kees.sort()
         for b in kees:
             print(b,self.vdw[b])
-            
+
 
 class Topology:
 
@@ -291,34 +291,34 @@ class Topology:
             a0 = b.index[0]
             a1 = b.index[1]
             for c in cmodel.bond[a0]: # a0 in center
-                a2 = c.index[0] 
+                a2 = c.index[0]
                 if a2 not in (a0,a1): # outside atom
                     if a1 < a2:
                         an = (a1,a0,a2)
                     else:
-                        an = (a2,a0,a1)                  
+                        an = (a2,a0,a1)
                     ang[an] = 1
                 a2 = c.index[1]
                 if a2 not in (a0,a1): # outside atom
                     if a1 < a2:
                         an = (a1,a0,a2)
                     else:
-                        an = (a2,a0,a1)                  
+                        an = (a2,a0,a1)
                     ang[an] = 1
             for c in cmodel.bond[a1]: # a1 in center
-                a2 = c.index[0] 
+                a2 = c.index[0]
                 if a2 not in (a0,a1): # outside atom
                     if a0 < a2:
                         an = (a0,a1,a2)
                     else:
-                        an = (a2,a1,a0)                  
+                        an = (a2,a1,a0)
                     ang[an] = 1
                 a2 = c.index[1]
                 if a2 not in (a0,a1): # outside atom
                     if a0 < a2:
                         an = (a0,a1,a2)
                     else:
-                        an = (a2,a1,a0)                  
+                        an = (a2,a1,a0)
                     ang[an] = 1
         # find torsions
         self.torsion = {}
@@ -326,46 +326,46 @@ class Topology:
         for b in model.bond: # use bond as center of torsion
             a1 = b.index[0]
             a2 = b.index[1]
-            for c in cmodel.bond[a1]: 
-                a0 = c.index[0] 
+            for c in cmodel.bond[a1]:
+                a0 = c.index[0]
                 if a0 not in (a1,a2): # outside atom
                     for d in cmodel.bond[a2]:
-                        a3 = d.index[0] 
+                        a3 = d.index[0]
                         if a3 not in (a0,a1,a2): # outside atom
                             if a0 < a3:
                                 to = (a0,a1,a2,a3)
                             else:
-                                to = (a3,a2,a1,a0)                        
+                                to = (a3,a2,a1,a0)
                             tors[to] = 1
-                        a3 = d.index[1] 
+                        a3 = d.index[1]
                         if a3 not in (a0,a1,a2): # outside atom
                             if a0 < a3:
                                 to = (a0,a1,a2,a3)
                             else:
                                 to = (a3,a2,a1,a0)
                             tors[to] = 1
-                a0 = c.index[1] 
+                a0 = c.index[1]
                 if a0 not in (a1,a2): # outside atom
                     for d in cmodel.bond[a2]:
-                        a3 = d.index[0] 
+                        a3 = d.index[0]
                         if a3 not in (a0,a1,a2): # outside atom
                             if a0 < a3:
                                 to = (a0,a1,a2,a3)
                             else:
-                                to = (a3,a2,a1,a0)                        
+                                to = (a3,a2,a1,a0)
                             tors[to] = 1
-                        a3 = d.index[1] 
+                        a3 = d.index[1]
                         if a3 not in (a0,a1,a2): # outside atom
                             if a0 < a3:
                                 to = (a0,a1,a2,a3)
                             else:
-                                to = (a3,a2,a1,a0)                        
+                                to = (a3,a2,a1,a0)
                             tors[to] = 1
         # find impropers (only autogenerates for atoms with 3 bonds)
         self.improper = {}
         impr = self.improper
         a2 = 0
-        for a in model.atom: # a2 is the center atom 
+        for a in model.atom: # a2 is the center atom
             bnd = cmodel.bond[a2]
             if len(bnd) == 3:
                 lst = []
@@ -377,7 +377,7 @@ class Topology:
                 lst.sort()
                 impr[(lst[0],lst[1],a2,lst[2])] = 1
             a2 = a2 + 1
-            
+
         if feedback['actions']:
             print(' '+str(self.__class__)+': found:')
             print(' '+str(self.__class__)+':    types       %6d' % (
@@ -420,7 +420,7 @@ class Topology:
                   list(self.improper.keys())]
 
 class Subset:
-    
+
     def __init__(self,par,top):
         if feedback['actions']:
             print(' '+str(self.__class__)+': applying parameter set to topology...')
@@ -451,7 +451,7 @@ class Subset:
                 s_mw[kee] = p_mw[kee]
             else:
                 self.miss_mw.append(kee)
-                
+
         # van der waals
         self.miss_vdw = []
         self.vdw = {}
@@ -487,7 +487,7 @@ class Subset:
                 s_angle[kee] = p_angle[kee]
             else:
                 self.miss_angle.append((a,kee))
-        # torsions      
+        # torsions
         self.miss_torsion = []
         self.torsion = {}
         s_torsion = self.torsion
@@ -512,12 +512,12 @@ class Subset:
                     s_torsion[kee1] = p_torsion[kee]
                     break
                 kee = "X -%-2s-%-2s-X " % (at2,at1)
-                if kee in p_torsion: 
+                if kee in p_torsion:
                     s_torsion[kee2] = p_torsion[kee]
                     break
                 self.miss_torsion.append((a,kee1))
                 break
-        # impropers      
+        # impropers
         self.miss_improper = []
         self.improper = {}
         s_improper = self.improper
@@ -613,7 +613,7 @@ class Subset:
                 len(self.miss_improper)))
             print(' '+str(self.__class__)+':    extra tinker info %6d' % (
                 len(self.miss_extra)))
-        
+
     def dump(self):
         kees = list(self.mw.keys())
         kees.sort()
@@ -691,10 +691,10 @@ class Subset:
             label.append(st)
             type.append(a)
             map[a] = st
-        # assign numeric types 
+        # assign numeric types
         for a in self.model.atom:
             a.numeric_type = map[a.text_type]
-        
+
     def write_tinker_prm(self,fname,proofread=None,smooth=None):
         c = 0
         self.mapping = {}
@@ -770,7 +770,7 @@ dielectric              1.0
         for a in list(self.angle.keys()):
             kee = (map[string.strip(a[0:2])],
                      map[string.strip(a[3:5])],
-                     map[string.strip(a[6:8])],                
+                     map[string.strip(a[6:8])],
                      )
             angle[kee] = a
         kees = list(angle.keys())
@@ -786,7 +786,7 @@ dielectric              1.0
                 kee = (map[string.strip(a[0:2])],
                          map[string.strip(a[3:5])],
                          map[string.strip(a[6:8])],
-                         map[string.strip(a[9:11])],                                
+                         map[string.strip(a[9:11])],
                          )
                 improper[kee] = a
             kees = list(improper.keys())
@@ -802,7 +802,7 @@ dielectric              1.0
                 kee = (map[string.strip(a[0:2])],
                          map[string.strip(a[3:5])],
                          map[string.strip(a[6:8])],
-                         map[string.strip(a[9:11])],                                
+                         map[string.strip(a[9:11])],
                          )
                 improper[kee] = a
             kees = list(improper.keys())
@@ -817,7 +817,7 @@ dielectric              1.0
             kee = (map[string.strip(a[0:2])],
                      map[string.strip(a[3:5])],
                      map[string.strip(a[6:8])],
-                     map[string.strip(a[9:11])],                                
+                     map[string.strip(a[9:11])],
                      )
             torsion[kee] = a
         kees = list(torsion.keys())
@@ -890,7 +890,7 @@ dielectric              1.0
         for a in self.angle.keys():
             kee = (map[string.strip(a[0:2])],
                      map[string.strip(a[3:5])],
-                     map[string.strip(a[6:8])],                
+                     map[string.strip(a[6:8])],
                      )
             angle[kee] = a
         kees = list(angle.keys())
@@ -906,7 +906,7 @@ dielectric              1.0
             kee = (map[string.strip(a[0:2])],
                      map[string.strip(a[3:5])],
                      map[string.strip(a[6:8])],
-                     map[string.strip(a[9:11])],                                
+                     map[string.strip(a[9:11])],
                      )
             improper[kee] = a
         kees = list(improper.keys())
@@ -923,7 +923,7 @@ dielectric              1.0
             kee = (map[string.strip(a[0:2])],
                      map[string.strip(a[3:5])],
                      map[string.strip(a[6:8])],
-                     map[string.strip(a[9:11])],                                
+                     map[string.strip(a[9:11])],
                      )
             torsion[kee] = a
         kees = list(torsion.keys())
diff -upNr pymol-open-source-2.3.0/modules/chempy/tinker/__init__.py pymol-open-source-2.3.3/modules/chempy/tinker/__init__.py
--- pymol-open-source-2.3.0/modules/chempy/tinker/__init__.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/tinker/__init__.py	2019-08-22 10:24:47.766603508 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
 #-* Scott Dixon, Metaphorics, LLC
-#-* 
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -17,10 +17,7 @@ from __future__ import print_function
 import os
 import shutil
 import glob
-import re
-import string
 import sys
-import time
 
 from chempy import feedback
 
@@ -41,13 +38,13 @@ def do(command,in_prefix,run_prefix,out_
     for a in glob.glob(out_prefix+".*"):
         os.unlink(a)
     for src in glob.glob(in_prefix+".*"):
-        dst = string.split(src,'.')
+        dst = src.split('.')
         dst = run_prefix+'.'+dst[len(dst)-1]
         shutil.copyfile(src,dst)
     if capture==1:
-        pipe = os.popen(bin_path+command+"> "+run_prefix+".out","w")      
+        pipe = os.popen(bin_path+command+"> "+run_prefix+".out","w")
     elif capture==2:
-        pipe = os.popen(bin_path+command+" | tee "+run_prefix+".out","w")      
+        pipe = os.popen(bin_path+command+" | tee "+run_prefix+".out","w")
     else:
         pipe = os.popen(bin_path+command,"w")
     if not pipe:
@@ -63,7 +60,7 @@ def do(command,in_prefix,run_prefix,out_
     f.close()
 #
     for src in glob.glob(run_prefix+".*_2"):
-        dst = string.replace(src,'_2','')
+        dst = src.replace('_2','')
         if os.path.exists(dst):
             os.unlink(dst)
 #      os.rename(src,dst)    rename can fail over NFS (remote action)
@@ -71,11 +68,11 @@ def do(command,in_prefix,run_prefix,out_
 # sloppy workaround for buggy NFS on linux
         os.unlink(src)
     for src in glob.glob(run_prefix+".*"):
-        dst = string.split(src,'.')
+        dst = src.split('.')
         dst = out_prefix+'.'+dst[len(dst)-1]
         if os.path.exists(dst):
             os.unlink(dst)
-#      os.rename(src,dst)    rename can fail over NFS (remote action)  
+#      os.rename(src,dst)    rename can fail over NFS (remote action)
         shutil.copy(src,dst)
         os.unlink(src)
     for a in glob.glob(in_prefix+".*"):
@@ -103,11 +100,11 @@ def run(command,in_prefix,out_prefix,tok
     for a in glob.glob(out_prefix+".*"):
         os.unlink(a)
     for src in glob.glob(in_prefix+".*"):
-        dst = string.split(src,'.')
+        dst = src.split('.')
         dst = prefix+'.'+dst[len(dst)-1]
         shutil.copyfile(src,dst)
     if capture:
-        pipe = os.popen(bin_path+command+"> "+out_prefix+".out","w")      
+        pipe = os.popen(bin_path+command+"> "+out_prefix+".out","w")
     else:
         pipe = os.popen(bin_path+command,"w")
     if not pipe:
@@ -117,18 +114,18 @@ def run(command,in_prefix,out_prefix,tok
         pipe.write(a+"\n")
     pipe.close()
     for src in glob.glob(prefix+".*_2"):
-        dst = string.replace(src,'_2','')
+        dst = src.replace('_2','')
         if os.path.exists(dst):
             os.unlink(dst)
-#      os.rename(src,dst)    rename can fail over NFS (remote action)  
+#      os.rename(src,dst)    rename can fail over NFS (remote action)
         shutil.copy(src,dst)
         os.unlink(src)
     for src in glob.glob(prefix+".*"):
-        dst = string.split(src,'.')
+        dst = src.split('.')
         dst = out_prefix+'.'+dst[len(dst)-1]
         if os.path.exists(dst):
             os.unlink(dst)
-#      os.rename(src,dst)    rename can fail over NFS (remote action)  
+#      os.rename(src,dst)    rename can fail over NFS (remote action)
         shutil.copy(src,dst)
     if feedback['tinker']:
         print(" "+str(__name__)+': %s job complete. ' % command)
@@ -152,4 +149,3 @@ if 'PYMOL_PATH' in os.environ:
     test_path = pymol_path + '/data/chempy/tinker/'
     if os.path.exists(test_path):
         params_path = test_path
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/tinker/keyword.py pymol-open-source-2.3.3/modules/chempy/tinker/keyword.py
--- pymol-open-source-2.3.0/modules/chempy/tinker/keyword.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/tinker/keyword.py	2019-08-22 10:24:47.766603508 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
 #-* Scott Dixon, Metaphorics, LLC
-#-* 
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -40,7 +40,7 @@ def get_restrain_positions(model,flag,w_
         c = c + 1
     if chempy.feedback['actions']:
         print(' '+str(__name__)+': %d atoms restrained using flag %d ...' % (n,flag))
-        
+
     return list
 
 def get_inactive(model,flag):
@@ -56,4 +56,3 @@ def get_inactive(model,flag):
     if chempy.feedback['actions']:
         print(' '+str(__name__)+': %d atoms fixed using flag %d ...' % (n,flag))
     return list
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/tinker/realtime.py pymol-open-source-2.3.3/modules/chempy/tinker/realtime.py
--- pymol-open-source-2.3.0/modules/chempy/tinker/realtime.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/tinker/realtime.py	2019-08-22 10:24:47.766603508 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
 #-* Scott Dixon, Metaphorics, LLC
-#-* 
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -42,7 +42,7 @@ def assign(sele,preserve=0):
     global model
 
     result = 1
-    
+
     state = State()
 
     model = cmd.get_model(sele)
@@ -57,7 +57,7 @@ def assign(sele,preserve=0):
     mobj.fromChemPyModel(model)
 
     typed = Typer(molObj = mobj)
-    
+
     print(" realtime: assigning atom types")
     typed.applyRules(ruleSet)
 
@@ -90,10 +90,10 @@ def assign(sele,preserve=0):
 #   param = Parameters("simple_parm.dat")
 
 def setup(sele,preserve=0):
-    
+
     global state
     global model
-    
+
     state = State()
 
     model = cmd.get_model(sele)
@@ -164,7 +164,7 @@ def dyna(steps,iter=1):
 def check(obj='check'):
     global state
     global model
-    
+
     if not state:
         if not model:
             print(" realtime.reload: please run setup first.")
@@ -174,7 +174,7 @@ def check(obj='check'):
         model = state.model
         cmd.load_model(model,obj,1)
 
-    
+
 def mini(total_step=100,gradient=0.001,interval=100,obj='rt'):
 
     global state
@@ -211,10 +211,6 @@ def mini(total_step=100,gradient=0.001,i
             for a in state.summary:
                 print(a)
             if state.summary[-1][7]=='SmallGrad':
-                break;         
+                break;
         io.pkl.toFile(model,"realtime.pkl")
         print(" realtime.mini: terminated after %d steps." % state.counter)
-
-
-
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/tinker/state.py pymol-open-source-2.3.3/modules/chempy/tinker/state.py
--- pymol-open-source-2.3.0/modules/chempy/tinker/state.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/tinker/state.py	2019-08-22 10:24:47.766603508 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
 #-* Scott Dixon, Metaphorics, LLC
-#-* 
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -33,7 +33,7 @@ class State:
 
         self.keywords = {}
         self.keywords['verbose'] = ''
-        self.keywords['cutoff'] = 8.0      
+        self.keywords['cutoff'] = 8.0
         self.keywords['randomseed'] = 1234567890
 
         self.mapping = None
@@ -45,7 +45,7 @@ class State:
     def reset_fragile(self):
         self.restart = None
         self.frames = None
-        
+
     def __write_keys(self,list):
         f=open(self.prefix+"_inp.key",'w')
         f.writelines(list)
@@ -160,7 +160,7 @@ class State:
              self.energy = self.summary[-1][1]
         else:
              self.energy = None
-            
+
     def dynamics(self,steps=100,
                      timestep=None,
                      interval=None,
@@ -177,7 +177,7 @@ class State:
             f.close()
             if feedback['actions']:
                 print(' '+str(self.__class__)+': using restart information...')
-#         
+#
         kw_list = [ "parameters "+self.params+"\n" ]
         for a in self.keywords.keys():
             kw_list.append("%s %s\n" % ( a,str(self.keywords[a])))
@@ -248,14 +248,9 @@ class State:
         else:
             self.energy = None
 
-        
+
     def load_model(self,a):
         if feedback['verbose']:
             print(' '+str(self.__class__)+': new model loaded.')
         self.model = a
         self.reset_fragile()
-
-
-
-
-
diff -upNr pymol-open-source-2.3.0/modules/chempy/water_amber.py pymol-open-source-2.3.3/modules/chempy/water_amber.py
--- pymol-open-source-2.3.0/modules/chempy/water_amber.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/water_amber.py	2019-08-22 10:24:47.766603508 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
diff -upNr pymol-open-source-2.3.0/modules/chempy/water_residues.py pymol-open-source-2.3.3/modules/chempy/water_residues.py
--- pymol-open-source-2.3.0/modules/chempy/water_residues.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/water_residues.py	2019-08-22 10:24:47.766603508 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
diff -upNr pymol-open-source-2.3.0/modules/chempy/xyz.py pymol-open-source-2.3.3/modules/chempy/xyz.py
--- pymol-open-source-2.3.0/modules/chempy/xyz.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/chempy/xyz.py	2019-08-22 10:24:47.766603508 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+#C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -63,13 +63,13 @@ generics =  {
 }
 
 class XYZ(Storage):
-    
+
 #------------------------------------------------------------------------------
     def toList(self,model,mapping=None):
 
         conn = copy.deepcopy(model)
         conn = conn.convert_to_connected()
-        
+
         list = []
 
         if len(model.atom):
@@ -107,4 +107,3 @@ class XYZ(Storage):
         for a in list[1:]:
             model.atom[c].coord = [ float(a[11:23]),float(a[23:35]),float(a[35:47])]
             c = c + 1
-
diff -upNr pymol-open-source-2.3.0/modules/compile_pymol.py pymol-open-source-2.3.3/modules/compile_pymol.py
--- pymol-open-source-2.3.0/modules/compile_pymol.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/compile_pymol.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,6 +0,0 @@
-from compileall import compile_dir
-
-compile_dir("modules",force=True)
-compile_dir("epymol/modules",force=True)
-#compile_dir("ipymol/modules",force=True)
-
diff -upNr pymol-open-source-2.3.0/modules/launch_pymol.py pymol-open-source-2.3.3/modules/launch_pymol.py
--- pymol-open-source-2.3.0/modules/launch_pymol.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/launch_pymol.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-# NOTE: This file is now obsolete.  However it has been left functional
-# and intact in order to promote backwards compatibility with existing
-# PyMOL installs.
-#
-# Future installations should launch pymol by running:
-#   "python $PYMOL_PATH/modules/pymol/__init__.py" instead.
-# or
-#   by importing "pymol" from within a standalone Python script
-#   followed immediately by a call to pymol.finish_launching()
-
-import thread 
-import threading 
-import os
-import sys
-import time
-import __main__
-
-# let pymol/__init__.py known that we're launching using the old way
-
-__main__.pymol_launch = 0 
-
-if hasattr(__main__,"pymol_argv"):
-    pymol_argv = __main__.pymol_argv
-else:
-    pymol_argv = sys.argv
-
-modules_path = os.environ['PYMOL_PATH']+'/modules'
-
-if modules_path not in sys.path:
-    sys.path.append(modules_path)
-
-import pymol
-
-pymol.invocation.parse_args(pymol_argv)
-
-pymol.start_pymol()
-
-
-
-
-
diff -upNr pymol-open-source-2.3.0/modules/pmg_qt/builder.py pymol-open-source-2.3.3/modules/pmg_qt/builder.py
--- pymol-open-source-2.3.0/modules/pmg_qt/builder.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pmg_qt/builder.py	2019-08-22 10:24:47.822612628 +0200
@@ -50,7 +50,7 @@ class ActionWizard(Wizard):
     def activateOrDismiss(self):
         activate_flag = 1
         cur_wiz = self.cmd.get_wizard()
-        if cur_wiz != None:
+        if cur_wiz is not None:
             if cur_wiz.__class__ == self.__class__:
                 if cur_wiz.actionHash == self.actionHash:
                     activate_flag = 0
@@ -157,7 +157,7 @@ class SculptWizard(ActionWizard):
                 print("Error: cannot sculpt more than one object at a time")
 
     def sculpt_deactivate(self):
-        if ((self.sculpt_object != None) and
+        if ((self.sculpt_object is not None) and
             self.sculpt_object in self.cmd.get_names()):
             self.cmd.set("sculpt_vdw_vis_mode","0",self.sculpt_object)
             self.cmd.sculpt_iterate(self.sculpt_object,self.cmd.get_state(),0)
@@ -167,7 +167,7 @@ class SculptWizard(ActionWizard):
             self.cmd.refresh_wizard()
 
     def do_pick(self, bondFlag):
-        if self.sculpt_object == None:
+        if self.sculpt_object is None:
             self.cmd.select(active_sele, "byobj pk1")
             self.sculpt_activate()
         else:
@@ -179,7 +179,7 @@ class SculptWizard(ActionWizard):
                 self.sculpt_activate()
 
     def get_prompt(self):
-        if self.sculpt_object == None:
+        if self.sculpt_object is None:
             return ["Pick object to sculpt..."]
         else:
             return ["Sculpting %s..."%self.sculpt_object]
@@ -243,7 +243,7 @@ class RepeatableActionWizard(ActionWizar
     def activateRepeatOrDismiss(self):
         activate_flag = 1
         cur_wiz = self.cmd.get_wizard()
-        if cur_wiz != None:
+        if cur_wiz is not None:
             if cur_wiz.__class__ == self.__class__:
                 if cur_wiz.actionHash == self.actionHash:
                     if cur_wiz.getRepeating():
@@ -502,7 +502,7 @@ class ChargeWizard(RepeatableActionWizar
 
     @undoablemethod("bymol ?pk1")
     def do_pick(self, bondFlag):
-        self.cmd.select(active_sele, "bymol pk1") 
+        self.cmd.select(active_sele, "bymol pk1")
         self.cmd.alter("pk1","formal_charge=%s" % self.charge)
         self.cmd.h_fill()
         if abs(float(self.charge))>0.0001:
@@ -832,10 +832,10 @@ class AtomFlagWizard(ActionWizard):
     def do_less(self,mode):
         if active_sele in self.cmd.get_names("selections"):
             if mode == 0:
-                self.cmd.flag(self.flag,"(( byobj " + active_sele + 
+                self.cmd.flag(self.flag,"(( byobj " + active_sele +
                               " ) and not flag %d) extend 1"%self.flag,"clear")
             elif mode == 1:
-                self.cmd.flag(self.flag,"byres ((( byobj " + active_sele + 
+                self.cmd.flag(self.flag,"byres ((( byobj " + active_sele +
                               " ) and not flag %d) extend 1)"%self.flag,"clear")
             self.update_display()
 
@@ -1203,7 +1203,7 @@ class _BuilderPanel(QtWidgets.QWidget):
             index = new_list.pop()
             try:
                 self.cmd.edit("%s`%d" % index)
-                if self.cmd.get_wizard()!=None:
+                if self.cmd.get_wizard() is not None:
                     self.cmd.do("_ cmd.get_wizard().do_pick(0)")
             except pymol.CmdException:
                 print(" doAutoPick-Error: exception")
@@ -1365,4 +1365,3 @@ def BuilderPanelDocked(parent, *args, **
     window.setWidget(widget)
     window.setFloating(True)
     return window
-
diff -upNr pymol-open-source-2.3.0/modules/pmg_qt/file_dialogs.py pymol-open-source-2.3.3/modules/pmg_qt/file_dialogs.py
--- pymol-open-source-2.3.0/modules/pmg_qt/file_dialogs.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pmg_qt/file_dialogs.py	2019-08-22 10:24:47.822612628 +0200
@@ -27,7 +27,7 @@ def load_dialog(parent, fname, **kwargs)
 
     format = pymol.importing.filename_to_format(fname)[2]
 
-    if fname[-4:] in ['.dcd', '.dtr']:
+    if fname[-4:] in ['.dcd', '.dtr', '.xtc', '.trr']:
         load_traj_dialog(parent, fname)
     elif format in ('aln', 'fasta'):
         load_aln_dialog(parent, fname)
@@ -54,9 +54,14 @@ def load_dialog(parent, fname, **kwargs)
 
         # auto-load desmond trajectory
         if fname.endswith('-out.cms'):
-            traj = os.path.join(fname[:-8] + '_trj', 'clickme.dtr')
-            if os.path.exists(traj):
-                load_traj_dialog(parent, traj)
+            for suffix in [
+                ('_trj', 'clickme.dtr'),
+                ('.xtc',),
+            ]:
+                traj = os.path.join(fname[:-8] + suffix[0], *suffix[1:])
+                if os.path.exists(traj):
+                    load_traj_dialog(parent, traj)
+                    break
 
     return True
 
diff -upNr pymol-open-source-2.3.0/modules/pmg_qt/mimic_tk.py pymol-open-source-2.3.3/modules/pmg_qt/mimic_tk.py
--- pymol-open-source-2.3.0/modules/pmg_qt/mimic_tk.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pmg_qt/mimic_tk.py	2019-08-22 10:24:47.822612628 +0200
@@ -127,17 +127,23 @@ class _qtFileDialog:
                 options.get('initialdir', ''))
 
 
+qtMessageBox = _qtMessageBox()
+qtFileDialog = _qtFileDialog()
+
+# for all Python versions - allows plugin manager to import this with Python 3
+# without importing "tkinter"
+sys.modules['tkMessageBox'] = qtMessageBox
+sys.modules['tkFileDialog'] = qtFileDialog
+
 if sys.version_info[0] < 3:
-    sys.modules['tkMessageBox'] = _qtMessageBox()
-    sys.modules['tkFileDialog'] = _qtFileDialog()
     sys.modules['tkSimpleDialog'] = _qtSimpleDialog()
 else:
     # injecting 'X.Y' into sys.modules without assigning the attribute
     # (import X;X.Y = ...) doesn't work. Use a meta_path solution instead.
 
     mapping = {
-        'tkinter.messagebox': _qtMessageBox(),
-        'tkinter.filedialog': _qtFileDialog(),
+        'tkinter.messagebox': qtMessageBox,
+        'tkinter.filedialog': qtFileDialog,
     }
 
     class MimicTkImporter:
diff -upNr pymol-open-source-2.3.0/modules/pmg_qt/pymol_qt_gui.py pymol-open-source-2.3.3/modules/pmg_qt/pymol_qt_gui.py
--- pymol-open-source-2.3.0/modules/pmg_qt/pymol_qt_gui.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pmg_qt/pymol_qt_gui.py	2019-08-22 12:54:56.670855382 +0200
@@ -848,7 +848,7 @@ PyMOL> color ye<TAB>    (will autocomple
         msg = [
             'The PyMOL Molecular Graphics System\n',
             'Version %s' % (self.cmd.get_version()[0]),
-            'Copyright (C) Schrodinger LLC.',
+            u'Copyright (C) Schr\xF6dinger LLC.',
             'All rights reserved.\n',
             'License information:',
         ]
@@ -1081,6 +1081,15 @@ class PyMOLApplication(QtWidgets.QApplic
         if ev.type() != QtCore.QEvent.FileOpen:
             return False
 
+        # When double clicking a file in Finder, open it in a new instance
+        if not pymol.invocation.options.reuse_helper and pymol.cmd.get_names():
+            window.new_window([ev.file()])
+            return True
+
+        # pymol -I -U
+        if pymol.invocation.options.auto_reinitialize:
+            pymol.cmd.reinitialize()
+
         # PyMOL Show
         if ev.file().endswith('.psw'):
             pymol.cmd.set('presentation')
@@ -1142,6 +1151,12 @@ def execapp():
             for v in ['QT_SCALE_FACTOR', 'QT_SCREEN_SCALE_FACTORS']):
         QtCore.QCoreApplication.setAttribute(Qt.AA_EnableHighDpiScaling)
 
+    # native dialogs broken on macOS 10.15 (attribute new in Qt 5.7)
+    import platform
+    if pymol.IS_MACOS and platform.mac_ver()[0] >= '10.15' and hasattr(
+            Qt, 'AA_DontUseNativeDialogs'):
+        QtCore.QCoreApplication.setAttribute(Qt.AA_DontUseNativeDialogs)
+
     # fix Windows taskbar icon
     if pymol.IS_WINDOWS:
         import ctypes
diff -upNr pymol-open-source-2.3.0/modules/pmg_qt/pymol_qt_gui.py.orig pymol-open-source-2.3.3/modules/pmg_qt/pymol_qt_gui.py.orig
--- pymol-open-source-2.3.0/modules/pmg_qt/pymol_qt_gui.py.orig	1970-01-01 01:00:00.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pmg_qt/pymol_qt_gui.py.orig	2019-08-22 10:24:47.826613279 +0200
@@ -0,0 +1,1194 @@
+"""
+Contains main class for PyMOL QT GUI
+"""
+
+
+from __future__ import absolute_import
+from __future__ import print_function
+from collections import defaultdict
+import os
+import re
+import sys
+
+import pymol
+import pymol._gui
+from pymol import colorprinting
+
+from pymol.Qt import QtGui, QtCore, QtWidgets
+from pymol.Qt.utils import (getSaveFileNameWithExt, UpdateLock, WidgetMenu,
+        PopupOnException,
+        connectFontContextMenu, getMonospaceFont)
+
+from .pymol_gl_widget import PyMOLGLWidget
+from . import keymapping
+
+from pmg_qt import properties_dialog, file_dialogs
+
+Qt = QtCore.Qt
+QFileDialog = QtWidgets.QFileDialog
+getOpenFileNames = QFileDialog.getOpenFileNames
+
+
+class PyMOLQtGUI(QtWidgets.QMainWindow, pymol._gui.PyMOLDesktopGUI):
+    '''
+    PyMOL QMainWindow GUI
+    '''
+
+    from pmg_qt.file_dialogs import (
+            load_dialog,
+            load_mae_dialog,
+            file_fetch_pdb,
+            file_save_png,
+            file_save_mpeg,
+            file_save_map,
+            file_save_aln,
+            file_save
+    )
+
+    _ext_window_visible = True
+    _initialdir = ''
+
+    def keyPressEvent(self, ev):
+        args = keymapping.keyPressEventToPyMOLButtonArgs(ev)
+
+        if args is not None:
+            self.pymolwidget.pymol.button(*args)
+
+    def closeEvent(self, event):
+        self.cmd.quit()
+
+    # for thread-safe viewport command
+    viewportsignal = QtCore.Signal(int, int)
+
+    def pymolviewport(self, w, h):
+        cw, ch = self.cmd.get_viewport()
+        pw = self.pymolwidget
+        scale = pw.fb_scale
+
+        # maintain aspect ratio
+        if h < 1:
+            if w < 1:
+                pw.pymol.reshape(int(scale * pw.width()),
+                                 int(scale * pw.height()), True)
+                return
+            h = (w * ch) / cw
+        if w < 1:
+            w = (h * cw) / ch
+
+        win_size = self.size()
+        delta = QtCore.QSize(w - cw, h - ch) / scale
+
+        # window resize
+        self.resize(delta + win_size)
+
+    def get_view(self):
+        self.cmd.get_view(2, quiet=0)
+        QtWidgets.QApplication.clipboard().setText(self.cmd.get_view(3))
+        print(" get_view: matrix copied to clipboard.")
+
+    def __init__(self):  # noqa
+        QtWidgets.QMainWindow.__init__(self)
+        self.setDockOptions(QtWidgets.QMainWindow.AllowTabbedDocks |
+                            QtWidgets.QMainWindow.AllowNestedDocks)
+
+        # resize Window before it is shown
+        options = pymol.invocation.options
+        self.resize(
+            options.win_x + (220 if options.internal_gui else 0),
+            options.win_y + (246 if options.external_gui else 18))
+
+        # for thread-safe viewport command
+        self.viewportsignal.connect(self.pymolviewport)
+
+        # reusable dialogs
+        self.dialog_png = None
+        self.advanced_settings_dialog = None
+        self.props_dialog = None
+        self.builder = None
+
+        # setting index -> callable
+        self.setting_callbacks = defaultdict(list)
+
+        # "session_file" setting in window title
+        self.setting_callbacks[440].append(
+            lambda v: self.setWindowTitle("PyMOL (" + os.path.basename(v) + ")")
+        )
+
+        # "External" Command Line and Loggin Widget
+        self._setup_history()
+        self.lineedit = CommandLineEdit()
+        self.lineedit.setObjectName("command_line")
+        self.browser = QtWidgets.QPlainTextEdit()
+        self.browser.setObjectName("feedback_browser")
+        self.browser.setReadOnly(True)
+
+        # convenience: clicking into feedback browser gives focus to command
+        # line. Drawback: Copying with CTRL+C doesn't work in feedback
+        # browser -> clear focus proxy while text selected
+        self.browser.setFocusProxy(self.lineedit)
+
+        @self.browser.copyAvailable.connect
+        def _(yes):
+            self.browser.setFocusProxy(None if yes else self.lineedit)
+            self.browser.setFocus()
+
+        # Font
+        self.browser.setFont(getMonospaceFont())
+        connectFontContextMenu(self.browser)
+
+        lineeditlayout = QtWidgets.QHBoxLayout()
+        command_label = QtWidgets.QLabel("PyMOL>")
+        command_label.setObjectName("command_label")
+        lineeditlayout.addWidget(command_label)
+        lineeditlayout.addWidget(self.lineedit)
+        self.lineedit.setToolTip('''Command Input Area
+
+Get the list of commands by hitting <TAB>
+
+Get the list of arguments for one command with a question mark:
+PyMOL> color ?
+
+Read the online help for a command with "help":
+PyMOL> help color
+
+Get autocompletion for many arguments by hitting <TAB>
+PyMOL> color ye<TAB>    (will autocomplete "yellow")
+''')
+
+        layout = QtWidgets.QVBoxLayout()
+        layout.addWidget(self.browser)
+        layout.addLayout(lineeditlayout)
+
+        quickbuttonslayout = QtWidgets.QVBoxLayout()
+        quickbuttonslayout.setSpacing(2)
+
+        extguilayout = QtWidgets.QBoxLayout(QtWidgets.QBoxLayout.LeftToRight)
+        extguilayout.setContentsMargins(2, 2, 2, 2)
+        extguilayout.addLayout(layout)
+        extguilayout.addLayout(quickbuttonslayout)
+
+        class ExtGuiFrame(QtWidgets.QFrame):
+            def mouseDoubleClickEvent(_, event):
+                self.toggle_ext_window_dockable(True)
+
+        dockWidgetContents = ExtGuiFrame(self)
+        dockWidgetContents.setLayout(extguilayout)
+        dockWidgetContents.setObjectName("extgui")
+
+        self.ext_window = \
+            dockWidget = QtWidgets.QDockWidget(self)
+        dockWidget.setWindowTitle("External GUI")
+        dockWidget.setWidget(dockWidgetContents)
+        if options.external_gui:
+            dockWidget.setTitleBarWidget(QtWidgets.QWidget())
+        else:
+            dockWidget.hide()
+
+        self.addDockWidget(Qt.TopDockWidgetArea, dockWidget)
+
+        # rearrange vertically if docking left or right
+        @dockWidget.dockLocationChanged.connect
+        def _(area):
+            if area == Qt.LeftDockWidgetArea or area == Qt.RightDockWidgetArea:
+                extguilayout.setDirection(QtWidgets.QBoxLayout.BottomToTop)
+                quickbuttonslayout.takeAt(quickbuttons_stretch_index)
+            else:
+                extguilayout.setDirection(QtWidgets.QBoxLayout.LeftToRight)
+                if quickbuttons_stretch_index >= quickbuttonslayout.count():
+                    quickbuttonslayout.addStretch()
+
+        # OpenGL Widget
+        self.pymolwidget = PyMOLGLWidget(self)
+        self.setCentralWidget(self.pymolwidget)
+
+        cmd = self.cmd = self.pymolwidget.cmd
+
+        '''
+        # command completion
+        completer = QtWidgets.QCompleter(cmd.kwhash.keywords, self)
+        self.lineedit.setCompleter(completer)
+        '''
+
+        # overload <Tab> action
+        self.lineedit.installEventFilter(self)
+        self.pymolwidget.installEventFilter(self)
+
+        # Quick Buttons
+        for row in [
+            [
+                ('Reset', cmd.reset),
+                ('Zoom', lambda: cmd.zoom(animate=1.0)),
+                ('Orient', lambda: cmd.orient(animate=1.0)),
+
+                # render dialog will be constructed when the menu is shown
+                # for the first time. This way it's populated with the current
+                # viewport and settings. Also defers parsing of the ui file.
+                ('Draw/Ray', WidgetMenu(self).setSetupUi(self.render_dialog)),
+            ],
+            [
+                ('Unpick', cmd.unpick),
+                ('Deselect', cmd.deselect),
+                ('Rock', cmd.rock),
+                ('Get View', self.get_view),
+            ],
+            [
+                ('|<', cmd.rewind),
+                ('<', cmd.backward),
+                ('Stop', cmd.mstop),
+                ('Play', cmd.mplay),
+                ('>', cmd.forward),
+                ('>|', cmd.ending),
+                ('MClear', cmd.mclear),
+            ],
+            [
+                ('Builder', self.open_builder_panel),
+                ('Properties', self.open_props_dialog),
+                ('Rebuild', cmd.rebuild),
+            ],
+        ]:
+            hbox = QtWidgets.QHBoxLayout()
+            hbox.setSpacing(2)
+
+            for name, callback in row:
+                btn = QtWidgets.QPushButton(name)
+                btn.setProperty("quickbutton", True)
+                btn.setAttribute(Qt.WA_LayoutUsesWidgetRect) # OS X workaround
+                hbox.addWidget(btn)
+
+                if callback is None:
+                    btn.setEnabled(False)
+                elif isinstance(callback, QtWidgets.QMenu):
+                    btn.setMenu(callback)
+                else:
+                    btn.released.connect(callback)
+
+            quickbuttonslayout.addLayout(hbox)
+
+        quickbuttonslayout.addStretch()
+        quickbuttons_stretch_index = quickbuttonslayout.count() - 1
+
+        # menu top level
+        self.menubar = menubar = self.menuBar()
+
+        # action groups
+        actiongroups = {}
+
+        def _addmenu(data, menu):
+            '''Fill a menu from "data"'''
+            menu.setTearOffEnabled(True)
+            menu.setWindowTitle(menu.title())  # needed for Windows
+            for item in data:
+                if item[0] == 'separator':
+                    menu.addSeparator()
+                elif item[0] == 'menu':
+                    _addmenu(item[2], menu.addMenu(item[1].replace('&', '&&')))
+                elif item[0] == 'command':
+                    command = item[2]
+                    if command is None:
+                        print('warning: skipping', item)
+                    else:
+                        if isinstance(command, str):
+                            command = lambda c=command: cmd.do(c)
+                        menu.addAction(item[1], command)
+                elif item[0] == 'check':
+                    if len(item) > 4:
+                        menu.addAction(
+                            SettingAction(self, cmd, item[2], item[1],
+                                          item[3], item[4]))
+                    else:
+                        menu.addAction(
+                            SettingAction(self, cmd, item[2], item[1]))
+                elif item[0] == 'radio':
+                    label, name, value = item[1:4]
+                    try:
+                        group, type_, values = actiongroups[item[2]]
+                    except KeyError:
+                        group = QtWidgets.QActionGroup(self)
+                        type_, values = cmd.get_setting_tuple(name)
+                        actiongroups[item[2]] = group, type_, values
+                    action = QtWidgets.QAction(label, self)
+                    action.triggered.connect(lambda _=0, args=(name, value):
+                                             cmd.set(*args, log=1, quiet=0))
+
+                    self.setting_callbacks[cmd.setting._get_index(
+                        name)].append(
+                            lambda v, V=value, a=action: a.setChecked(v == V))
+
+                    group.addAction(action)
+                    menu.addAction(action)
+                    action.setCheckable(True)
+                    if values[0] == value:
+                        action.setChecked(True)
+                elif item[0] == 'open_recent_menu':
+                    self.open_recent_menu = menu.addMenu('Open Recent...')
+                else:
+                    print('error:', item)
+
+        # recent files menu
+        self.open_recent_menu = None
+
+        # for plugins
+        self.menudict = {'': menubar}
+
+        # menu
+        for _, label, data in self.get_menudata(cmd):
+            assert _ == 'menu'
+            menu = menubar.addMenu(label)
+            self.menudict[label] = menu
+            _addmenu(data, menu)
+
+        # hack for macOS to hide "Edit > Start Dictation"
+        # https://bugreports.qt.io/browse/QTBUG-43217
+        if pymol.IS_MACOS:
+            self.menudict['Edit'].setTitle('Edit_')
+            QtCore.QTimer.singleShot(10, lambda:
+                    self.menudict['Edit'].setTitle('Edit'))
+
+        # recent files menu
+        if self.open_recent_menu:
+            @self.open_recent_menu.aboutToShow.connect
+            def _():
+                self.open_recent_menu.clear()
+                for fname in self.recent_filenames:
+                    self.open_recent_menu.addAction(
+                            fname if len(fname) < 128 else '...' + fname[-120:],
+                            lambda fname=fname: self.load_dialog(fname))
+
+        # some experimental window control
+        menu = self.menudict['Display'].addSeparator()
+        menu = self.menudict['Display'].addMenu('External GUI')
+        menu.addAction('Toggle floating', self.toggle_ext_window_dockable,
+                       QtGui.QKeySequence('Ctrl+E'))
+        ext_vis_action = self.ext_window.toggleViewAction()
+        ext_vis_action.setText('Visible')
+        menu.addAction(ext_vis_action)
+
+        # extra key mappings (MacPyMOL compatible)
+        QtWidgets.QShortcut(QtGui.QKeySequence('Ctrl+O'), self).activated.connect(self.file_open)
+        QtWidgets.QShortcut(QtGui.QKeySequence('Ctrl+S'), self).activated.connect(self.session_save)
+
+        # feedback
+        self.feedback_timer = QtCore.QTimer()
+        self.feedback_timer.setSingleShot(True)
+        self.feedback_timer.timeout.connect(self.update_feedback)
+        self.feedback_timer.start(100)
+
+        # legacy plugin system
+        self.menudict['Plugin'].addAction(
+            'Initialize Plugin System', self.initializePlugins)
+
+        # focus in command line
+        if options.external_gui:
+            self.lineedit.setFocus()
+        else:
+            self.pymolwidget.setFocus()
+
+        # Apply PyMOL stylesheet
+        try:
+            with open(cmd.exp_path('$PYMOL_DATA/pmg_qt/styles/pymol.sty')) as f:
+                style = f.read()
+        except IOError:
+            print('Could not read PyMOL stylesheet.')
+            print('DEBUG: PYMOL_DATA=' + repr(os.getenv('PYMOL_DATA')))
+            style = ""
+
+        if style:
+            self.setStyleSheet(style)
+
+    def lineeditKeyPressEventFilter(self, watched, event):
+        key = event.key()
+        if key == Qt.Key_Tab:
+            self.complete()
+        elif key == Qt.Key_Up:
+            if event.modifiers() & Qt.ControlModifier:
+                self.back_search()
+            else:
+                self.back()
+        elif key == Qt.Key_Down:
+            self.forward()
+        elif key == Qt.Key_Return or key == Qt.Key_Enter:
+            # filter out "Return" instead of binding lineedit.returnPressed,
+            # because otherwise OrthoKey would capture it as well.
+            self.doPrompt()
+        else:
+            return False
+        return True
+
+    def eventFilter(self, watched, event):
+        '''
+        Filter out <Tab> event to do tab-completion instead of move focus
+        '''
+        type_ = event.type()
+        if type_ == QtCore.QEvent.KeyRelease:
+            if event.key() == Qt.Key_Tab:
+                # silently skip tab release
+                return True
+        elif type_ == QtCore.QEvent.KeyPress:
+            if watched is self.lineedit:
+                return self.lineeditKeyPressEventFilter(watched, event)
+            elif event.key() == Qt.Key_Tab:
+                self.keyPressEvent(event)
+                return True
+        return False
+
+    def toggle_ext_window_dockable(self, neverfloat=False):
+        '''
+        Toggle whether the "external" GUI is dockable
+        '''
+        dockWidget = self.ext_window
+
+        if dockWidget.titleBarWidget() is None:
+            tbw = QtWidgets.QWidget()
+        else:
+            tbw = None
+
+        dockWidget.setFloating(tbw is None and not neverfloat)
+        dockWidget.setTitleBarWidget(tbw)
+        dockWidget.show()
+
+    def toggle_fullscreen(self, toggle=-1):
+        '''
+        Full screen
+        '''
+        is_fullscreen = self.windowState() == Qt.WindowFullScreen
+
+        if toggle == -1:
+            toggle = not is_fullscreen
+
+        if not is_fullscreen:
+            self._ext_window_visible = self.ext_window.isVisible()
+
+        if toggle:
+            self.menubar.hide()
+            self.ext_window.hide()
+            self.showFullScreen()
+            self.pymolwidget.setFocus()
+        else:
+            self.menubar.show()
+            if self._ext_window_visible:
+                self.ext_window.show()
+            self.showNormal()
+
+    @property
+    def initialdir(self):
+        '''
+        Be in sync with cd/pwd on the console until the first file has been
+        browsed, then remember the last directory.
+        '''
+        return self._initialdir or os.getcwd()
+
+    @initialdir.setter
+    def initialdir(self, value):
+        self._initialdir = value
+
+    ##################
+    # UI Forms
+    ##################
+
+    def load_form(self, name, dialog=None):
+        '''Load a form from pmg_qt/forms/{name}.py'''
+        import importlib
+        if dialog is None:
+            dialog = QtWidgets.QDialog(self)
+            widget = dialog
+        elif dialog == 'floating':
+            widget = QtWidgets.QWidget(self)
+        else:
+            widget = dialog
+
+        try:
+            m = importlib.import_module('.forms.' + name, 'pmg_qt')
+        except ImportError as e:
+            if pymol.Qt.DEBUG:
+                print('load_form import failed (%s)' % (e,))
+            uifile = os.path.join(os.path.dirname(__file__), 'forms', '%s.ui' % name)
+            form = pymol.Qt.utils.loadUi(uifile, widget)
+        else:
+            if hasattr(m, 'Ui_Form'):
+                form = m.Ui_Form()
+            else:
+                form = m.Ui_Dialog()
+
+            form.setupUi(widget)
+
+        if dialog == 'floating':
+            dialog = QtWidgets.QDockWidget(widget.windowTitle(), self)
+            dialog.setFloating(True)
+            dialog.setWidget(widget)
+            dialog.resize(widget.size())
+
+        form._dialog = dialog
+        return form
+
+    def open_props_dialog(self):  #noqa
+        if not self.props_dialog:
+            self.props_dialog = properties_dialog.props_dialog(self)
+
+        self.props_dialog.show()
+        self.props_dialog.raise_()
+
+    def edit_colors_dialog(self):
+        form = self.load_form('colors')
+        form.list_colors.setSortingEnabled(True)
+
+        # populate list with named colors
+        for color_index in self.cmd.get_color_indices():
+            form.list_colors.addItem(color_index[0])
+
+        # update spinboxes for given color
+        def load_color(name):
+            index = self.cmd.get_color_index(name)
+            if index == -1:
+                return
+            rgb = self.cmd.get_color_tuple(index)
+            form.input_R.setValue(rgb[0])
+            form.input_G.setValue(rgb[1])
+            form.input_B.setValue(rgb[2])
+
+        # update spinbox from slider
+        spinbox_lock = [False]
+        def update_spinbox(spinbox, value):
+            if not spinbox_lock[0]:
+                spinbox.setValue(value / 100.)
+
+        # update sliders and colored frame
+        def update_gui(*args):
+            spinbox_lock[0] = True
+            R = form.input_R.value()
+            G = form.input_G.value()
+            B = form.input_B.value()
+            form.slider_R.setValue(R * 100)
+            form.slider_G.setValue(G * 100)
+            form.slider_B.setValue(B * 100)
+            form.frame_color.setStyleSheet(
+                "background-color: rgb(%d,%d,%d)" % (
+                    R * 0xFF, G * 0xFF, B * 0xFF))
+            spinbox_lock[0] = False
+
+        def run():
+            name  = form.input_name.text()
+            R = form.input_R.value()
+            G = form.input_G.value()
+            B = form.input_B.value()
+
+            self.cmd.do('set_color %s, [%.2f, %.2f, %.2f]\nrecolor' %
+                        (name, R, G, B))
+
+            # if new color, insert and make current row
+            if not form.list_colors.findItems(name, Qt.MatchExactly):
+                form.list_colors.addItem(name)
+                form.list_colors.setCurrentItem(
+                    form.list_colors.findItems(name, Qt.MatchExactly)[0])
+
+        # hook up events
+        form.slider_R.valueChanged.connect(lambda v: update_spinbox(form.input_R, v))
+        form.slider_G.valueChanged.connect(lambda v: update_spinbox(form.input_G, v))
+        form.slider_B.valueChanged.connect(lambda v: update_spinbox(form.input_B, v))
+        form.input_R.valueChanged.connect(update_gui)
+        form.input_G.valueChanged.connect(update_gui)
+        form.input_B.valueChanged.connect(update_gui)
+        form.input_name.textChanged.connect(load_color)
+        form.list_colors.currentTextChanged.connect(form.input_name.setText)
+        form.button_apply.clicked.connect(run)
+
+        form._dialog.show()
+
+    def open_builder_panel(self):
+        from pmg_qt.builder import BuilderPanelDocked
+        from pymol import plugins
+
+        app = plugins.get_pmgapp()
+        if not self.builder:
+            self.builder = BuilderPanelDocked(self, app)
+            self.addDockWidget(Qt.TopDockWidgetArea, self.builder)
+
+        self.builder.show()
+        self.builder.raise_()
+
+    def edit_pymolrc(self):
+        from . import TextEditor
+        from pymol import plugins
+        TextEditor.edit_pymolrc(plugins.get_pmgapp())
+
+    ##################
+    # Menu callbacks
+    ##################
+
+    def file_open(self):
+        fnames = getOpenFileNames(self, 'Open file', self.initialdir)[0]
+        partial = 0
+        for fname in fnames:
+            if not self.load_dialog(fname, partial=partial):
+                break
+            partial = 1
+
+    def session_save(self):
+        fname = self.cmd.get('session_file')
+        fname = self.cmd.as_pathstr(fname)
+        return self.session_save_as(fname)
+
+    @PopupOnException.decorator
+    def session_save_as(self, fname=''):
+        formats = [
+            'PyMOL Session File (*.pse *.pze *.pse.gz)',
+            'PyMOL Show File (*.psw *.pzw *.psw.gz)',
+        ]
+        if not fname:
+            fname = getSaveFileNameWithExt(
+                self,
+                'Save Session As...',
+                self.initialdir,
+                filter=';;'.join(formats))
+        if fname:
+            self.initialdir = os.path.dirname(fname)
+            self.cmd.save(fname, format='pse', quiet=0)
+            self.recent_filenames_add(fname)
+
+    def render_dialog(self, widget=None):
+        form = self.load_form('render', widget)
+        lock = UpdateLock([ZeroDivisionError])
+
+        def get_factor():
+            units = form.input_units.currentText()
+            factor = 1.0 if units == 'inch' else 2.54
+            return factor / float(form.input_dpi.currentText())
+
+        @lock.skipIfCircular
+        def update_units(*args):
+            width = form.input_width.value()
+            height = form.input_height.value()
+            factor = get_factor()
+            form.input_width_units.setValue(width * factor)
+            form.input_height_units.setValue(height * factor)
+
+        @lock.skipIfCircular
+        def update_pixels(*args):
+            width = form.input_width_units.value()
+            height = form.input_height_units.value()
+            factor = get_factor()
+            form.input_width.setValue(width / factor)
+            form.input_height.setValue(height / factor)
+
+        @lock.skipIfCircular
+        def update_width(*args):
+            if form.aspectratio > 0:
+                width = form.input_height.value() * form.aspectratio
+                form.input_width.setValue(int(width))
+                form.input_width_units.setValue(width * get_factor())
+
+        @lock.skipIfCircular
+        def update_height(*args):
+            if form.aspectratio > 0:
+                height = form.input_width.value() / form.aspectratio
+                form.input_height.setValue(int(height))
+                form.input_height_units.setValue(height * get_factor())
+
+        def update_aspectratio(checked=True):
+            if checked:
+                try:
+                    form.aspectratio = (
+                            float(form.input_width.value()) /
+                            float(form.input_height.value()))
+                except ZeroDivisionError:
+                    form.button_lock.setChecked(False)
+            else:
+                form.aspectratio = 0
+
+        def update_from_viewport():
+            w, h = self.cmd.get_viewport()
+            form.aspectratio = 0
+            form.input_width.setValue(w)
+            form.input_height.setValue(h)
+            update_aspectratio(form.button_lock.isChecked())
+
+        def run_draw(ray=False):
+            width = form.input_width.value()
+            height = form.input_height.value()
+            if ray:
+                self.cmd.set('opaque_background',
+                        not form.input_transparent.isChecked())
+                self.cmd.do('ray %d, %d' % (width, height))
+            else:
+                self.cmd.do('draw %d, %d' % (width, height))
+            form.stack.setCurrentIndex(1)
+
+        def run_ray():
+            run_draw(ray=True)
+
+        def run_save():
+            fname = getSaveFileNameWithExt(self, 'Save As...', self.initialdir,
+                    filter='PNG File (*.png)')
+            if not fname:
+                return
+            self.initialdir = os.path.dirname(fname)
+            self.cmd.png(fname, prior=1, dpi=form.input_dpi.currentText())
+
+        def run_copy_clipboard():
+            with PopupOnException():
+                _copy_image(self.cmd, False, form.input_dpi.currentText())
+
+        dpi = self.cmd.get_setting_int('image_dots_per_inch')
+        if dpi > 0:
+            form.input_dpi.setEditText(str(dpi))
+        form.input_dpi.setValidator(QtGui.QIntValidator())
+
+        form.input_units.currentIndexChanged.connect(update_units)
+        form.input_dpi.editTextChanged.connect(update_pixels)
+        form.input_width.valueChanged.connect(update_units)
+        form.input_height.valueChanged.connect(update_units)
+        form.input_width_units.valueChanged.connect(update_pixels)
+        form.input_height_units.valueChanged.connect(update_pixels)
+
+        # set values before connecting mutual width<->height updates
+        update_from_viewport()
+
+        form.input_width.valueChanged.connect(update_height)
+        form.input_height.valueChanged.connect(update_width)
+        form.input_width_units.valueChanged.connect(update_height)
+        form.input_height_units.valueChanged.connect(update_width)
+        form.button_lock.toggled.connect(update_aspectratio)
+
+        form.button_draw.clicked.connect(run_draw)
+        form.button_ray.clicked.connect(run_ray)
+        form.button_current.clicked.connect(update_from_viewport)
+        form.button_back.clicked.connect(lambda: form.stack.setCurrentIndex(0))
+        form.button_clip.clicked.connect(run_copy_clipboard)
+        form.button_save.clicked.connect(run_save)
+
+        if widget is None:
+            form._dialog.show()
+
+    def _file_save(self, filter, format):
+        fname = getSaveFileNameWithExt(
+            self,
+            'Save As...',
+            self.initialdir,
+            filter=filter)
+        if fname:
+            self.cmd.save(fname, format=format, quiet=0)
+
+    def file_save_wrl(self):
+        self._file_save('VRML 2 WRL File (*.wrl)', 'wrl')
+
+    def file_save_dae(self):
+        self._file_save('COLLADA File (*.dae)', 'dae')
+
+    def file_save_pov(self):
+        self._file_save('POV File (*.pov)', 'pov')
+
+    def file_save_mpng(self):
+        self.file_save_mpeg('png')
+
+    def file_save_mov(self):
+        self.file_save_mpeg('mov')
+
+    LOG_FORMATS = [
+        'PyMOL Script (*.pml)',
+        'Python Script (*.py *.pym)',
+        'All (*)',
+    ]
+
+    def log_open(self, fname='', mode='w'):
+        if not fname:
+            fname = getSaveFileNameWithExt(self, 'Open Logfile...', self.initialdir,
+                                    filter=';;'.join(self.LOG_FORMATS))
+        if fname:
+            self.initialdir = os.path.dirname(fname)
+            self.cmd.log_open(fname, mode)
+
+    def log_append(self):
+        return self.log_open(mode='a')
+
+    def log_resume(self):
+        fname = getSaveFileNameWithExt(self, 'Open Logfile...', self.initialdir,
+                                filter=';;'.join(self.LOG_FORMATS))
+        if fname:
+            self.initialdir = os.path.dirname(fname)
+            self.cmd.resume(fname)
+
+    def file_run(self):
+        formats = [
+            'All Runnable (*.pml *.py *.pym)',
+            'PyMOL Command Script (*.pml)',
+            'PyMOL Command Script (*.txt)',
+            'Python Script (*.py *.pym)',
+            'Python Script (*.txt)',
+            'All Files(*)',
+        ]
+        fnames, selectedfilter = getOpenFileNames(
+            self, 'Open file', self.initialdir, filter=';;'.join(formats))
+        is_py = selectedfilter.startswith('Python')
+
+        with PopupOnException():
+            for fname in fnames:
+                self.initialdir = os.path.dirname(fname)
+                self.cmd.cd(self.initialdir, quiet=0)
+                # detect: .py, .pym, .pyc, .pyo, .py.txt
+                if is_py or re.search(r'\.py(|m|c|o|\.txt)$', fname, re.I):
+                    self.cmd.run(fname)
+                else:
+                    self.cmd.do("@" + fname)
+
+    def cd_dialog(self):
+        dname = QFileDialog.getExistingDirectory(
+            self, "Change Working Directory", self.initialdir)
+        self.cmd.cd(dname or '.', quiet=0)
+
+    def confirm_quit(self):
+        QtWidgets.qApp.quit()
+
+    def settings_edit_all_dialog(self):
+        from .advanced_settings_gui import PyMOLAdvancedSettings
+        if self.advanced_settings_dialog is None:
+            self.advanced_settings_dialog = PyMOLAdvancedSettings(self,
+                                                                  self.cmd)
+        self.advanced_settings_dialog.show()
+
+    def show_about(self):
+        msg = [
+            'The PyMOL Molecular Graphics System\n',
+            'Version %s' % (self.cmd.get_version()[0]),
+            u'Copyright (C) Schr\xF6dinger LLC.',
+            'All rights reserved.\n',
+            'License information:',
+        ]
+
+        msg.append('Open-Source Build')
+
+        msg += [
+            '',
+            'For more information:',
+            'https://pymol.org',
+            'sales@schrodinger.com',
+        ]
+        QtWidgets.QMessageBox.about(self, "About PyMOL", '\n'.join(msg))
+
+    #################
+    # GUI callbacks
+    #################
+
+    if sys.version_info[0] < 3:
+        def command_get(self):
+            return self.lineedit.text().encode('utf-8')
+    else:
+        def command_get(self):
+            return self.lineedit.text()
+
+    def command_set(self, v):
+        return self.lineedit.setText(v)
+
+    def command_set_cursor(self, i):
+        return self.lineedit.setCursorPosition(i)
+
+    def update_feedback(self):
+        feedback = self.cmd._get_feedback()
+        if feedback:
+            html = colorprinting.text2html('\n'.join(feedback))
+            self.browser.appendHtml(html)
+
+            scrollbar = self.browser.verticalScrollBar()
+            scrollbar.setValue(scrollbar.maximum())
+
+        for setting in self.cmd.get_setting_updates() or ():
+            if setting in self.setting_callbacks:
+                current_value = self.cmd.get_setting_tuple(setting)[1][0]
+                for callback in self.setting_callbacks[setting]:
+                    callback(current_value)
+
+        self.feedback_timer.start(500)
+
+    def doPrompt(self):
+        self.doTypedCommand(self.command_get())
+        self.pymolwidget._pymolProcess()
+        self.lineedit.clear()
+        self.feedback_timer.start(0)
+
+    ##########################
+    # legacy plugin system
+    ##########################
+
+    @PopupOnException.decorator
+    def initializePlugins(self):
+        from pymol import plugins
+        from . import mimic_tk
+
+        self.menudict['Plugin'].clear()
+
+        app = plugins.get_pmgapp()
+
+        plugins.legacysupport.addPluginManagerMenuItem()
+
+        # Redirect to Legacy submenu
+        self.menudict['PluginQt'] = self.menudict['Plugin']
+        self.menudict['Plugin'] = self.menudict['PluginQt'].addMenu('Legacy Plugins')
+        self.menudict['Plugin'].setTearOffEnabled(True)
+        self.menudict['PluginQt'].addSeparator()
+
+        plugins.HAVE_QT = True
+        plugins.initialize(app)
+
+    def createlegacypmgapp(self):
+        from . import mimic_pmg_tk as mimic
+        pmgapp = mimic.PMGApp()
+        pmgapp.menuBar = mimic.PmwMenuBar(self.menudict)
+        return pmgapp
+
+    def window_cmd(self, action, x, y, w, h):
+        if action == 0: # hide
+            self.hide()
+        elif action == 1: # show
+            self.show()
+        elif action == 2: # position
+            self.move(x, y)
+        elif action == 3: # size (first two arguments)
+            self.resize(x, y)
+        elif action == 4: # box
+            self.move(x, y)
+            self.resize(w, h)
+        elif action == 5: # maximize
+            self.showMaximized()
+        elif action == 6: # fit
+            if hasattr(QtGui, 'QWindow') and self.windowHandle().visibility() in (
+                    QtGui.QWindow.Maximized, QtGui.QWindow.FullScreen):
+                return
+            a = QtWidgets.QApplication.desktop().availableGeometry(self)
+            g = self.geometry()
+            f = self.frameGeometry()
+            w = min(f.width(), a.width())
+            h = min(f.height(), a.height())
+            x = max(min(f.x(), a.right() - w), a.x())
+            y = max(min(f.y(), a.bottom() - h), a.y())
+            self.setGeometry(
+                x - f.x() + g.x(),
+                y - f.y() + g.y(),
+                w - f.width() + g.width(),
+                h - f.height() + g.height(),
+            )
+        elif action == 7: # focus
+            self.setFocus(Qt.OtherFocusReason)
+        elif action == 8: # defocus
+            self.clearFocus()
+
+
+def commandoverloaddecorator(func):
+    name = func.__name__
+    func.__doc__ = getattr(pymol.cmd, name).__doc__
+    setattr(pymol.cmd, name, func)
+    pymol.cmd.extend(func)
+    return func
+
+
+def SettingAction(parent, cmd, name, label='', true_value=1, false_value=0,
+                  command=None):
+    '''
+    Menu toggle action for a PyMOL setting
+
+    parent: parent QObject
+    cmd: PyMOL instance
+    name: setting name
+    label: menu item text
+    '''
+    if not label:
+        label = name
+
+    index = cmd.setting._get_index(name)
+    type_, values = cmd.get_setting_tuple(index)
+    action = QtWidgets.QAction(label, parent)
+
+    if not command:
+        command = lambda: cmd.set(
+            index,
+            true_value if action.isChecked() else false_value,
+            log=1,
+            quiet=0)
+
+    parent.setting_callbacks[index].append(
+        lambda v: action.setChecked(v != false_value))
+
+    if type_ in (
+            1,  # bool
+            2,  # int
+            3,  # float
+            5,  # color
+            6,  # str
+    ):
+        action.setCheckable(True)
+        if values[0] == true_value:
+            action.setChecked(True)
+    else:
+        print('TODO', type_, name)
+
+    action.triggered.connect(command)
+    return action
+
+window = None
+
+
+class CommandLineEdit(QtWidgets.QLineEdit):
+    '''
+    Line edit widget with instant text insert on drag-enter
+    '''
+    _saved_pos = -1
+
+    def dragMoveEvent(self, event):
+        pass
+
+    def dropEvent(self, event):
+        if event.mimeData().hasText():
+            event.acceptProposedAction()
+
+    def dragEnterEvent(self, event):
+        if not event.mimeData().hasText():
+            self._saved_pos = -1
+            return
+
+        event.acceptProposedAction()
+
+        urls = event.mimeData().urls()
+        if urls and urls[0].isLocalFile():
+            droppedtext = urls[0].toLocalFile()
+        else:
+            droppedtext = event.mimeData().text()
+
+        pos = self.cursorPosition()
+        text = self.text()
+        self._saved_pos = pos
+        self._saved_text = text
+
+        self.setText(text[:pos] + droppedtext + text[pos:])
+        self.setSelection(pos, len(droppedtext))
+
+    def dragLeaveEvent(self, event):
+        if self._saved_pos != -1:
+            self.setText(self._saved_text)
+            self.setCursorPosition(self._saved_pos)
+
+
+class PyMOLApplication(QtWidgets.QApplication):
+    '''
+    Catch drop events on app icon
+    '''
+    # FileOpen event is only activated after the first
+    # application state change, otherwise sys.argv would be
+    # handled by Qt, we don't want that.
+
+    def handle_file_open(self, ev):
+        if ev.type() == QtCore.QEvent.ApplicationActivate:
+            self.handle_file_open = self.handle_file_open_active
+        return False
+
+    def handle_file_open_active(self, ev):
+        if ev.type() != QtCore.QEvent.FileOpen:
+            return False
+
+        # When double clicking a file in Finder, open it in a new instance
+        if not pymol.invocation.options.reuse_helper and pymol.cmd.get_names():
+            window.new_window([ev.file()])
+            return True
+
+        # pymol -I -U
+        if pymol.invocation.options.auto_reinitialize:
+            pymol.cmd.reinitialize()
+
+        # PyMOL Show
+        if ev.file().endswith('.psw'):
+            pymol.cmd.set('presentation')
+            pymol.cmd.set('internal_gui', 0)
+            pymol.cmd.set('internal_feedback', 0)
+            pymol.cmd.full_screen('on')
+
+        window.load_dialog(ev.file())
+        return True
+
+    def event(self, ev):
+        if self.handle_file_open(ev):
+            return True
+        return super(PyMOLApplication, self).event(ev)
+
+
+# like pymol.internal._copy_image
+def _copy_image(_self=pymol.cmd, quiet=1, dpi=-1):
+    import tempfile
+    fname = tempfile.mktemp('.png')
+
+    if not _self.png(fname, prior=1, dpi=dpi):
+        print("no prior image")
+        return
+
+    try:
+        qim = QtGui.QImage(fname)
+        QtWidgets.QApplication.clipboard().setImage(qim)
+    finally:
+        os.unlink(fname)
+
+    if not quiet:
+        print(" Image copied to clipboard")
+
+
+def make_pymol_qicon():
+    icons_dir = os.path.expandvars('$PYMOL_DATA/pymol/icons')
+    return QtGui.QIcon(os.path.join(icons_dir, 'icon2.svg'))
+
+
+def execapp():
+    '''
+    Run PyMOL as a Qt application
+    '''
+    global window
+    global pymol
+
+    # don't let exceptions stop PyMOL
+    import traceback
+    sys.excepthook = traceback.print_exception
+
+    # use QT_OPENGL=desktop (auto-detection may fail on Windows)
+    if hasattr(Qt, 'AA_UseDesktopOpenGL') and pymol.IS_WINDOWS:
+        QtCore.QCoreApplication.setAttribute(Qt.AA_UseDesktopOpenGL)
+
+    # enable 4K scaling on Windows and Linux
+    if hasattr(Qt, 'AA_EnableHighDpiScaling') and not any(
+            v in os.environ
+            for v in ['QT_SCALE_FACTOR', 'QT_SCREEN_SCALE_FACTORS']):
+        QtCore.QCoreApplication.setAttribute(Qt.AA_EnableHighDpiScaling)
+
+    # fix Windows taskbar icon
+    if pymol.IS_WINDOWS:
+        import ctypes
+        ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(
+                u'com.schrodinger.pymol')
+
+    app = PyMOLApplication(['PyMOL'])
+    app.setWindowIcon(make_pymol_qicon())
+
+    window = PyMOLQtGUI()
+    window.setWindowTitle("PyMOL")
+
+    @commandoverloaddecorator
+    def viewport(w=-1, h=-1, _self=None):
+        window.viewportsignal.emit(int(w), int(h))
+
+    @commandoverloaddecorator
+    def full_screen(toggle=-1, _self=None):
+        from pymol import viewing as v
+        toggle = v.toggle_dict[v.toggle_sc.auto_err(str(toggle), 'toggle')]
+        window.toggle_fullscreen(toggle)
+
+    import pymol.gui
+    pymol.gui.createlegacypmgapp = window.createlegacypmgapp
+
+    pymol.cmd._copy_image = _copy_image
+
+    window.show()
+    window.raise_()
+
+    # window size according to -W -H options
+    options = pymol.invocation.options
+    if options.win_xy_set:
+        scale = window.pymolwidget.fb_scale
+        viewport(scale * options.win_x, scale * options.win_y)
+
+    # load plugins
+    if options.plugins:
+        window.initializePlugins()
+
+    app.exec_()
diff -upNr pymol-open-source-2.3.0/modules/pmg_qt/volume.py pymol-open-source-2.3.3/modules/pmg_qt/volume.py
--- pymol-open-source-2.3.0/modules/pmg_qt/volume.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pmg_qt/volume.py	2019-08-22 10:24:47.826613279 +0200
@@ -19,6 +19,7 @@ except NameError:
 Qt = QtCore.Qt
 
 DOT_RADIUS = 5
+ALPHA_LOG_BASE = 10.0
 
 DEFAULT_COLORS = [
     (1., 1., 0.),
@@ -471,7 +472,7 @@ class VolumeEditorWidget(QtWidgets.QWidg
         """
         Converts <0, 1> normalized Y position to alpha value.
         """
-        y = (10.0**y - 1.0) / 9.0
+        y = (ALPHA_LOG_BASE**y - 1.0) / (ALPHA_LOG_BASE - 1.0)
         return y * self.amax
 
     def alphaToY(self, a):
@@ -481,7 +482,7 @@ class VolumeEditorWidget(QtWidgets.QWidg
         if self.amax == 0.0:
             return 0.0
         y = a / self.amax
-        return math.log(1.0 + 9.0 * y, 10.0)
+        return math.log(1.0 + (ALPHA_LOG_BASE - 1.0) * y, ALPHA_LOG_BASE)
 
     def updateVolumeColors(self):
         """
@@ -682,15 +683,23 @@ class VolumeEditorWidget(QtWidgets.QWidg
         self.original_vmin = self.vmin
         self.original_vmax = self.vmax
         self.path = []
-        if len(histogram[4:]) == 0:
+
+        hist = histogram[4:]
+        N = len(hist)
+        if N == 0:
             return
-        xstep = 1.0 / len(histogram[4:])
-        max_value = max(histogram[4:])
+
+        # cut extreme peaks in distribution
+        shist = sorted(hist)
+        q90 = shist[int(N * 0.9)]
+        max_value = min(q90 * 4, shist[N - 1])
         if max_value == 0.0:
             return
+
+        xstep = 1.0 / N
         ynorm = 1.0 / max_value
         x = 0.0
-        for v in histogram[4:]:
+        for v in hist:
             x += xstep
             y = v * ynorm
             self.path.append((x, y))
diff -upNr pymol-open-source-2.3.0/modules/pmg_tk/ColorEditor.py pymol-open-source-2.3.3/modules/pmg_tk/ColorEditor.py
--- pymol-open-source-2.3.0/modules/pmg_tk/ColorEditor.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pmg_tk/ColorEditor.py	2019-08-22 10:24:47.826613279 +0200
@@ -27,8 +27,6 @@ else:
     import tkinter.colorchooser as tkColorChooser
 
 import Pmw
-import string
-import copy
 
 class NewColor:
     def __init__(self,app,parent):
@@ -56,7 +54,7 @@ class NewColor:
 
     def command(self,result=None):
         if result=='Create':
-            st = string.strip(self.entry.get())
+            st = self.entry.get().strip()
             if len(st):
                 self.parent.update(st)
             self.app.my_deactivate(self.dialog)
@@ -140,7 +138,7 @@ class ColorEditor:
         elif result=='Edit':
             sels = self.dialog.getcurselection()
             if len(sels)!=0:
-                color = string.strip(sels[0])
+                color = sels[0].strip()
                 ColorEdit(self.app,color,self,self.cmd.get_color_tuple(color))
         else:
             NewColor(self.app,self)
diff -upNr pymol-open-source-2.3.0/modules/pymol/api.py pymol-open-source-2.3.3/modules/pymol/api.py
--- pymol-open-source-2.3.0/modules/pymol/api.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/api.py	2019-08-22 10:24:47.834614582 +0200
@@ -25,7 +25,7 @@ from .importing import \
       read_xplorstr,      \
       fetch,              \
       set_session,        \
-      space              
+      space
 
 #--------------------------------------------------------------------
 from . import creating
@@ -175,7 +175,7 @@ from .exporting import \
       multifilenamegen,   \
       multisave,          \
       png,                \
-      save               
+      save
 
 #--------------------------------------------------------------------
 from . import editing
@@ -247,11 +247,11 @@ from .editing import \
       unpick,             \
       update,             \
       valence,            \
-      vdw_fit 
+      vdw_fit
 
 from .editor import \
       fab
-      
+
 from .computing import \
       clean
 
@@ -291,7 +291,7 @@ from .fitting import \
       intra_rms,         \
       intra_rms_cur,     \
       cealign,          \
-      pair_fit          
+      pair_fit
 
 #--------------------------------------------------------------------
 # ARE ALL OF THESE UNUSED AND/OR DEPRECATED (?)
@@ -336,7 +336,7 @@ from .moving import \
       get_movie_playing, \
       set_frame,         \
       get_state,         \
-      get_frame         
+      get_frame
 
 #--------------------------------------------------------------------
 from . import viewing
@@ -453,19 +453,8 @@ from .stereochemistry import \
       assign_stereo
 
 #--------------------------------------------------------------------
-#from m4x import \
-#     metaphorics
-
-#--------------------------------------------------------------------
 # Modules which contain programs used explicity as "module.xxx"
 
 from . import util
 from . import movie
 from . import gui
-
-# dang! Python 2.6 will break PyMOL's "as" method. 
-# Proposal:
-#  1. stick with Python <=2.5 for as long as possible
-#  2. convert API method to cmd.show_as() and leave "as" in the scripting langauge
-#  3. allow "show_as" in the scripting language
-globals()['as'] = show_as
diff -upNr pymol-open-source-2.3.0/modules/pymol/callback.py pymol-open-source-2.3.3/modules/pymol/callback.py
--- pymol-open-source-2.3.0/modules/pymol/callback.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/callback.py	2019-08-22 10:24:47.834614582 +0200
@@ -8,12 +8,12 @@
 # in order to get useful information:
 #
 #    cmd.get_frame()
-#    cmd.get_state() 
+#    cmd.get_state()
 
 class Callback(object):
     def __call__(self):
         pass
 
     def get_extent(self):
-        # should return [ [min_x, min_y, min_z], [ max_x, max_y, max_z ] ] 
+        # should return [ [min_x, min_y, min_z], [ max_x, max_y, max_z ] ]
         return None
diff -upNr pymol-open-source-2.3.0/modules/pymol/cgo.py pymol-open-source-2.3.3/modules/pymol/cgo.py
--- pymol-open-source-2.3.0/modules/pymol/cgo.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/cgo.py	2019-08-22 10:24:47.834614582 +0200
@@ -1,20 +1,19 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
 from __future__ import print_function
 
-import string
 from chempy import cpv
 #import popen2
 import os
@@ -30,7 +29,7 @@ TRIANGLE_STRIP     = 5.0
 TRIANGLE_FAN       = 6.0
 #QUADS              = 7.0
 #QUAD_STRIP         = 8.0
-#POLYGON            = 9.0                                                            
+#POLYGON            = 9.0
 
 STOP               =  0.0
 NULL               =  1.0
@@ -65,7 +64,7 @@ CHAR               = 23.0
 
 ALPHA              = 25.0
 QUADRIC            = 26.0 # NOTE: Only works with ellipsoids and disks
-CONE               = 27.0 
+CONE               = 27.0
 
 LIGHTING           = float(0x0B50)
 
@@ -89,14 +88,6 @@ def molauto(*arg,**kw):
     f.close()
     _self.load_cgo(rr.obj,name)
 
-# the following implementation causes full-blown system crashes on some machines.
-#   (stdout,stdin) = popen2.popen2("molauto %s -nocentre molauto.pdb | molscript -r > molauto.r3d"%marg)
-#
-#   if stdin:
-#      stdin.close()
-#      rr = RenderReader(stdout)
-#      cmd.load_cgo(rr.obj,name)
-
 def measure_text(font,text,
                       axes=[[1.0,0.0,0.0],[0.0,1.0,0.0],[0.0,0.0,1.0]]):
     w = 0
@@ -129,7 +120,7 @@ def wire_text(cgo,font,pos,text,
                 cgo.append(VERTEX)
                 cgo.append(pos[0]+x[0]*ax+y[0]*ay)
                 cgo.append(pos[1]+x[1]*ax+y[1]*ay)
-                cgo.append(pos[2]+x[2]*ax+y[2]*ay)         
+                cgo.append(pos[2]+x[2]*ax+y[2]*ay)
                 c = c + 3
             pos[0] = pos[0] + w*x[0]
             pos[1] = pos[1] + w*x[1]
@@ -174,7 +165,7 @@ def cyl_text(cgo,font,pos,text,radius=0.
 def from_r3d(fname):
     result = DEFAULT_ERROR
     input = None
-    if string.find(fname,':')>1:
+    if '://' in fname:
         try:
             from urllib import urlopen
         except ImportError:
@@ -193,7 +184,7 @@ class RenderReader:
         if self.app_fn:
             self.app_fn()
             self.app_fn=None
-        
+
     def append_tri(self):
         if self.l_vert:
             d0 = cpv.sub(self.l_vert[0],self.l_vert[1])
@@ -258,7 +249,7 @@ class RenderReader:
         l = f.readline()
         if l:
             self.app_fn=self.append_tri
-            s = string.split(l)
+            s = l.split()
             self.l_vert = [[float(s[0]),float(s[1]),float(s[2])],
                         [float(s[3]),float(s[4]),float(s[5])],
                         [float(s[6]),float(s[7]),float(s[8])]]
@@ -268,7 +259,7 @@ class RenderReader:
     def tri_normal(self,f):
         l = f.readline()
         if l:
-            s = string.split(l)
+            s = l.split()
             self.l_norm = [[float(s[0]),float(s[1]),float(s[2])],
                         [float(s[3]),float(s[4]),float(s[5])],
                         [float(s[6]),float(s[7]),float(s[8])]]
@@ -278,7 +269,7 @@ class RenderReader:
         l = f.readline()
         if l:
             self.app_fn = self.append_cyl
-            s = string.split(l)
+            s = l.split()
             self.l_vert = [[float(s[0]),float(s[1]),float(s[2])],
                         [float(s[4]),float(s[5]),float(s[6])]]
             self.l_radi = float(s[3])
@@ -289,7 +280,7 @@ class RenderReader:
         self.append_last()
         l = f.readline()
         if l:
-            s = string.split(l)
+            s = l.split()
             self.obj.append(COLOR)
             self.obj.extend([float(s[4]),float(s[5]),float(s[6])])
             self.obj.append(SPHERE)
@@ -299,24 +290,24 @@ class RenderReader:
         self.append_last()
         l = f.readline()
         if l:
-            s = string.split(l)
+            s = l.split()
             self.obj.append(COLOR)
             self.obj.extend([float(s[4]),float(s[5]),float(s[6])])
             self.obj.append(QUADRIC)
             self.obj.extend([float(s[0]),float(s[1]),float(s[2]),float(s[3])])
         l = f.readline()
         if l:
-            s = string.split(l)
+            s = l.split()
             self.obj.extend([float(s[0]),float(s[1]),float(s[2]),
                              float(s[3]),float(s[4]),float(s[5]),
                              float(s[6]),float(s[7]),float(s[8]),float(s[9])])
-        
+
     def mat_prop(self,f):
         self.append_last()
         l = f.readline()
         print("mat_prop"+l)
         if l:
-            s = string.split(l)
+            s = l.split()
             (mphong, mspec, sr, sg, sb, clrity) = map(float,s[0:6])
             if clrity>0.999:
                 clrity=0.999
@@ -332,7 +323,7 @@ class RenderReader:
 
     def reset(self,f):
         pass
-    
+
     def __init__(self,input):
         # Author: Warren DeLano
         # Modifications: Robert Campbell
@@ -371,7 +362,7 @@ class RenderReader:
             if not l:
                 break
             if l[0] != '#':
-                v = string.split(l)
+                v = l.split()
                 n=int(v[0])
                 if(n<ld):
                     dd = dispatch[n]
diff -upNr pymol-open-source-2.3.0/modules/pymol/cmd.py pymol-open-source-2.3.3/modules/pymol/cmd.py
--- pymol-open-source-2.3.0/modules/pymol/cmd.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/cmd.py	2019-08-22 10:24:47.834614582 +0200
@@ -1,22 +1,22 @@
 
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
-# cmd.py 
+# cmd.py
 # Python interface module for PyMol
 #
-# **This is the only module which should be/need be imported by 
+# **This is the only module which should be/need be imported by
 # ** PyMol API Based Programs
 
 # NEW CALL RETURN CONVENTIONS for _cmd.so C-layer
@@ -35,7 +35,7 @@
 
 #     ==> Failure should return a negative number as follows:
 #        -1 = a general, unspecified failure
-          
+
 #     Upon an error, exceptions will be raised by the Python wrapper
 #     layer if the "raise_exceptions" setting is on.
 
@@ -89,7 +89,7 @@ def _deferred_init_pymol_internals(_pymo
     _pymol._view_dict_sc = Shortcut({})
     _pymol._scene_dict_sc = Shortcut({})
 
-    # 
+    #
 if True:
 
     import sys
@@ -99,7 +99,7 @@ if True:
     _weakrefproxy = sys.modules[__name__]
 
     if True:
-        
+
         import re
         from pymol import _cmd
         import string
@@ -110,7 +110,7 @@ if True:
         import time
 
         _pymol = pymol
-        
+
         from .shortcut import Shortcut
 
         from chempy import io
@@ -129,23 +129,23 @@ if True:
 
         from .checking import *
         from .checking import _raising
-        
+
         #-------------------------------------------------------------------
         # path expansion, including our fixes for Win32
 
         def _nt_expandvars(path): # allow for //share/folder$/file
             path = nt_hidden_path_re.sub(r"$$\\",path)
             return os.path.expandvars(path)
-        
+
         if "nt" in sys.builtin_module_names:
             _expandvars = _nt_expandvars
         else:
             _expandvars = os.path.expandvars
-        
+
         def exp_path(path):
             path = as_pathstr(path)
             return _expandvars(os.path.expanduser(path))
-        
+
         def as_pathstr(path):
             # On Windows, always work with unicode file names. On Unix,
             # UTF-8 byte strings seem to be fine, so keep them for now.
@@ -163,23 +163,23 @@ if True:
         reaper = None
 
         # the following locks are used by both C and Python to insure that no more than
-        # one active thread enters PyMOL at a given time. 
-        
+        # one active thread enters PyMOL at a given time.
+
         lock_api = pymol.lock_api
         lock_api_c = pymol.lock_api_c
         lock_api_status = pymol.lock_api_status
         lock_api_glut = pymol.lock_api_glut
         lock_api_data = pymol.lock_api_data
         lock_api_allow_flush = 1
-        
+
         from .locking import *
         lockcm = LockCM()
 
         #--------------------------------------------------------------------
         # status monitoring
-        
+
         from .monitoring import *
-        
+
         #--------------------------------------------------------------------
         # Feedback
 
@@ -223,11 +223,7 @@ if True:
         _cache_purge = internal._cache_purge
         _cache_mark = internal._cache_mark
         _sdof = internal._sdof
-        
-        # when adding, remember to also edit cmd2.py
 
-        get_feedback = _get_feedback # legacy
-        
         #######################################################################
         # now import modules which depend on the above
         #######################################################################
@@ -237,7 +233,7 @@ if True:
         #######################################################################
         # cmd module functions...
         #######################################################################
-            
+
         # for extending the language
 
         from .commanding import extend, extendaa, alias
@@ -245,7 +241,7 @@ if True:
         # for documentation etc
 
         from .helping import python_help
-                
+
         def write_html_ref(file):
             '''Write the PyMOL Command Reference to an HTML file'''
             f=open(file,'w')
@@ -347,7 +343,7 @@ with a slash (/) forces the interpreter
 
             print("PyMOL Command Reference written to %s" % (os.path.abspath(file)))
 
-        
+
         #####################################################################
         # Here is where the PyMOL Command Language and API are built.
         #####################################################################
@@ -359,17 +355,17 @@ with a slash (/) forces the interpreter
         # deferred initialization
 
         _deferred_init_pymol_internals(pymol)
-        
+
         # now we create the command langauge
-        
+
         from . import keywords
         keyword = keywords.get_command_keywords()
         kw_list = list(keyword.keys())
-        
+
         keywords.fix_list(kw_list)
         kwhash = Shortcut(kw_list)
         keywords.fix_dict(keyword)
-        
+
         # informational or API-only functions which don't exist in the
         # PyMOL command language namespace
 
@@ -377,7 +373,7 @@ with a slash (/) forces the interpreter
         help_sc = Shortcut(list(keyword.keys())+list(help_only.keys()))
 
         # keyboard configuration
-        
+
         from . import keyboard
 
         key_mappings = keyboard.get_default_keys()
@@ -410,11 +406,11 @@ with a slash (/) forces the interpreter
         map_sc = lambda sc=Shortcut,gnot=get_names_of_type:sc(gnot('object:map'))
         contour_sc =  lambda sc=Shortcut,gnot=get_names_of_type:sc(gnot('object:mesh')+gnot('object:surface'))
         group_sc = lambda sc=Shortcut,gnot=get_names_of_type:sc(gnot('object:group'))
-        
+
         # Table for argument autocompletion
 
         from . import completing
-        
+
         auto_arg = completing.get_auto_arg_list()
 
         color_sc = None
diff -upNr pymol-open-source-2.3.0/modules/pymol/commanding.py pymol-open-source-2.3.3/modules/pymol/commanding.py
--- pymol-open-source-2.3.0/modules/pymol/commanding.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/commanding.py	2019-08-22 10:24:47.834614582 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -33,7 +33,7 @@ if True:
     from . import parsing
     cmd = sys.modules["pymol.cmd"]
     import pymol
-    
+
     from .cmd import _cmd, Shortcut, QuietException, \
           fb_module, fb_mask, is_list, \
           DEFAULT_ERROR, DEFAULT_SUCCESS, is_ok, is_error, is_string
@@ -92,7 +92,7 @@ SEE ALSO
         def write(self, s):
             s = re_fetch.sub(self._append_async0, s)
             file.write(self, s.encode())
- 
+
     def log_open(filename='log.pml', mode='w', _self=cmd):
         '''
 DESCRIPTION
@@ -101,7 +101,13 @@ DESCRIPTION
 
 USAGE
 
-    log_open filename
+    log_open [ filename [, mode ]]
+
+ARGUMENTS
+
+    filename = str: file to write to (.pml or .py) {default: log.pml}
+
+    mode = w/a: "w" to open an empty log file, "a" to append {default: w}
 
 SEE ALSO
 
@@ -116,7 +122,7 @@ SEE ALSO
             try:
                 try:
                     if hasattr(pymol,"_log_file"):
-                        if pymol._log_file!=None:
+                        if pymol._log_file is not None:
                             pymol._log_file.close()
                             del pymol._log_file
                 except:
@@ -201,17 +207,17 @@ SEE ALSO
     log, log_open
     
         '''
-        pymol=_self._pymol        
+        pymol=_self._pymol
         cmd=_self
         if hasattr(pymol,"_log_file"):
-            if pymol._log_file!=None:
+            if pymol._log_file is not None:
                 pymol._log_file.close()
                 del pymol._log_file
                 _self.set("logging",0,quiet=1)
                 if _self._feedback(fb_module.cmd,fb_mask.details): # redundant
                     print(" Cmd: log closed.")
 
-    def cls(_self=cmd): 
+    def cls(_self=cmd):
         '''
 DESCRIPTION
 
@@ -337,7 +343,7 @@ USAGE
         'original_settings' : 3,
         'purge_defaults' : 4,
     }
-    
+
     reinit_sc = Shortcut(reinit_code.keys())
 
     def reinitialize(what='everything', object='', _self=cmd):
@@ -394,7 +400,7 @@ SEE ALSO
                 del e
                 if (timeout>=0.0) and ((time.time()-now)>timeout):
                     break
-        if _cmd.wait_deferred(_self._COb): 
+        if _cmd.wait_deferred(_self._COb):
             # deferred tasks waiting for a display event?
             if thread.get_ident() == pymol.glutThread:
                 _self.refresh()
@@ -417,7 +423,7 @@ SEE ALSO
             del e
             if (timeout>=0.0) and ((time.time()-now)>timeout):
                 break
-                    
+
     def do(commands,log=1,echo=1,flush=0,_self=cmd):
         # WARNING: don't call this routine if you already have the API lock
         # use cmd._do instead
@@ -537,15 +543,15 @@ SEE ALSO
         '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.delete(_self._COb,str(name))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException      
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def extend(name, function=None, _self=cmd):
-        
+
         '''
 DESCRIPTION
 
@@ -616,7 +622,7 @@ EXAMPLE
             return func
         return wrapper
 
-    def alias(name, command, _self=cmd): 
+    def alias(name, command, _self=cmd):
         '''
 DESCRIPTION
 
@@ -648,7 +654,7 @@ SEE ALSO
 
     cmd.extend, api
             '''
-        _self.keyword[name] = [eval("lambda :do('''%s ''')"%command.replace("'''","")), 
+        _self.keyword[name] = [eval("lambda :do('''%s ''')"%command.replace("'''","")),
                                0,0,',',parsing.STRICT]
         _self.kwhash.append(name)
 
diff -upNr pymol-open-source-2.3.0/modules/pymol/completing.py pymol-open-source-2.3.3/modules/pymol/completing.py
--- pymol-open-source-2.3.0/modules/pymol/completing.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/completing.py	2019-08-22 10:24:47.834614582 +0200
@@ -22,6 +22,8 @@ expr_sc = ExprShortcut([
     'p.', 's.',
     'elec_radius',
     'oneletter',
+    'model', 'resv', 'type', 'stereo', 'rank', 'index', 'ss', 'color', 'reps',
+    'protons', 'label', 'geom', 'valence', 'flags', 'cartoon',
 ])
 
 
@@ -83,7 +85,7 @@ def get_auto_arg_list(self_cmd=cmd):
         'assign_stereo'  : aa_sel_e,
         'bond'           : aa_sel_e,
         'as'             : aa_rem_c,
-        'bg_color'       : [ lambda c=self_cmd:c._get_color_sc(c), 'color'       , ''   ],      
+        'bg_color'       : [ lambda c=self_cmd:c._get_color_sc(c), 'color'       , ''   ],
         'button'         : [ self_cmd.controlling.button_sc  , 'button'          , ', ' ],
         'cartoon'        : [ self_cmd.viewing.cartoon_sc     , 'cartoon'         , ', ' ],
         'cache'          : [ self_cmd.exporting.cache_action_sc , 'cache mode'   , ', ' ],
@@ -161,12 +163,12 @@ def get_auto_arg_list(self_cmd=cmd):
         'set_title'      : aa_obj_c,
         'show'           : aa_rem_c,
         'smooth'         : aa_sel_e,
-        'space'          : [ self_cmd.space_sc               , 'space'           , ''   ],      
+        'space'          : [ self_cmd.space_sc               , 'space'           , ''   ],
         'spectrum'       : aa_exp_e,
         'split_chains'   : aa_sel_e,
         'split_states'   : aa_obj_c,
         'super'          : aa_sel_c,
-        'stereo'         : [ self_cmd.stereo_sc              , 'option'          , ''   ],      
+        'stereo'         : [ self_cmd.stereo_sc              , 'option'          , ''   ],
         'symmetry_copy'  : aa_obj_c,
         'toggle'         : aa_rem_c,
         'uniquify'       : [ expr_sc                         , 'identifier'      , ', ' ],
@@ -178,8 +180,8 @@ def get_auto_arg_list(self_cmd=cmd):
         'valence'        : [ self_cmd.editing.order_sc       , 'order'           , ', ' ],
         'volume_color'   : aa_vol_c,
         'volume_panel'   : aa_vol_c,
-        'view'           : [ self_cmd._pymol._view_dict_sc   , 'view'            , ''   ],         
-        'window'         : [ self_cmd.window_sc              , 'action'          , ', ' ],      
+        'view'           : [ self_cmd._pymol._view_dict_sc   , 'view'            , ''   ],
+        'window'         : [ self_cmd.window_sc              , 'action'          , ', ' ],
         'wizard'         : [ wizard_sc                       , 'wizard'          , ', '   ],
         'zoom'           : aa_sel_e,
         },
@@ -238,7 +240,7 @@ def get_auto_arg_list(self_cmd=cmd):
         'set_name'       : aa_nam_e,
         'show'           : aa_sel_e,
         'slice_new'      : aa_map_c,
-        'spectrum'       : [ self_cmd.palette_sc             , 'palette'         , ''   ],      
+        'spectrum'       : [ self_cmd.palette_sc             , 'palette'         , ''   ],
         'super'          : aa_sel_e,
         'symexp'         : aa_obj_c,
         'symmetry_copy'  : aa_obj_c,
@@ -260,7 +262,7 @@ def get_auto_arg_list(self_cmd=cmd):
         'callout'        : aa_sel_e,
         'distance'       : aa_sel_e,
         'extra_fit'      : aa_ali_e,
-        'feedback'       : [ self_cmd.fb_mask_sc             , 'mask'            , ''   ],            
+        'feedback'       : [ self_cmd.fb_mask_sc             , 'mask'            , ''   ],
         'flag'           : [ self_cmd.editing.flag_action_sc , 'flag action'     , ''   ],
         'get_bond'       : aa_sel_e,
         'group'          : [ self_cmd.creating.group_action_sc, 'group action'    , ''   ],
@@ -282,7 +284,7 @@ def get_auto_arg_list(self_cmd=cmd):
         },
 #4th
         {
-        'ramp_new'       : [ self_cmd.creating.ramp_spectrum_sc , 'ramp color spectrum' , ', ' ],      
+        'ramp_new'       : [ self_cmd.creating.ramp_spectrum_sc , 'ramp color spectrum' , ', ' ],
         'map_new'        : aa_sel_c,
         'isosurface'     : aa_sel_c,
         'volume'         : aa_sel_c,
diff -upNr pymol-open-source-2.3.0/modules/pymol/computing.py pymol-open-source-2.3.3/modules/pymol/computing.py
--- pymol-open-source-2.3.0/modules/pymol/computing.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/computing.py	2019-08-22 10:24:47.834614582 +0200
@@ -4,11 +4,11 @@
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -65,8 +65,6 @@ def model_to_sdf_list(self_cmd,model):
         sdf_list.append("| NONE\n")
         sdf_list.append("\n")
     sdf_list.append("$$$$\n")
-#    for line in sdf_list:
-#        print line,
     return (fit_flag, sdf_list)
 
 def get_energy_from_rec(rec):
@@ -84,7 +82,7 @@ def get_energy_from_rec(rec):
     except:
         traceback.print_exc()
     return result
-    
+
 class CleanJob:
     def __init__(self,self_cmd,sele,state=-1,message=None):
         self.cmd = self_cmd
@@ -116,14 +114,14 @@ class CleanJob:
             # we can't call warn because this is the not the tcl-tk gui thread
             # warn("Please be sure that FreeMOL is correctly installed.")
         else:
-            if message != None:
+            if message is not None:
                 self.cmd.do("_ cmd.wizard('message','''%s''')"%message)
             obj_list = self_cmd.get_object_list("bymol ("+sele+")")
             self.ok = 0
             result = None
             if is_list(obj_list) and (len(obj_list)==1):
                 obj_name = obj_list[0]
-                self_cmd.sculpt_deactivate(obj_name) 
+                self_cmd.sculpt_deactivate(obj_name)
                 # eliminate all sculpting information for object
                 self.cmd.sculpt_purge()
                 self.cmd.set("sculpting",0)
@@ -133,13 +131,12 @@ class CleanJob:
                 input_model = self_cmd.get_model(obj_name,state=state)
                 (fit_flag, sdf_list) = model_to_sdf_list(self_cmd,input_model)
                 input_sdf = ''.join(sdf_list)
-#                print input_sdf
 
                 if sys.version_info[0] > 2:
                     input_sdf = input_sdf.encode()
 
                 result = mengine.run(input_sdf)
-                if result != None:
+                if result is not None:
                     if len(result):
                         clean_sdf = result[0]
 
@@ -168,11 +165,11 @@ class CleanJob:
                                     self_cmd.push_undo(obj_name)
                                     self_cmd.update(obj_name, clean_name, matchmaker=0,
                                                     source_state=1, target_state=state)
-                                    self_cmd.sculpt_activate(obj_name) 
+                                    self_cmd.sculpt_activate(obj_name)
                                     self_cmd.sculpt_deactivate(obj_name)
                                     self.ok = 1
                                     message = "Clean: Finished. Energy = %3.2f" % self.energy
-                                    if message != None:
+                                    if message is not None:
                                         self.cmd.do("_ cmd.wizard('message','''%s''')"%message)
                                         self.cmd.do("_ wizard")
                         except ValueError:
@@ -182,7 +179,7 @@ class CleanJob:
                             self_cmd.unset("suspend_updates")
             if not self.ok:
                 # we can't call warn because this is the not the tcl-tk gui thread
-                if result != None:
+                if result is not None:
                     if len(result)>1:
                         print("\n=== mengine errors below === ")
                         print(result[1].replace("\n\n","\n"), end=' ')
@@ -202,8 +199,8 @@ class CleanJob:
                 except IOError:
                     print("Unabled to write '%s"%failed_file)
                 if aromatic:
-                    print("Clean-Warning: Please eliminate aromatic bonds and then try again.")                    
-        if message!=None:
+                    print("Clean-Warning: Please eliminate aromatic bonds and then try again.")
+        if message is not None:
             self_cmd.do("_ wizard")
 
 def _clean(selection, present='', state=-1, fix='', restrain='',
@@ -231,13 +228,13 @@ def _clean(selection, present='', state=
             self_cmd.create(clean_obj, clean2_sele, zoom=0, source_state=state,target_state=1)
             self_cmd.disable(clean_obj)
             self_cmd.unset("suspend_updates")
-            
+
             self_cmd.flag(3,clean_obj+" in ("+clean2_sele+" and not "+clean1_sele+")","set")
             # fix nearby atoms
 
             self_cmd.h_add(clean_obj) # fill any open valences
 
-            if message == None:
+            if message is None:
                 at_cnt = self_cmd.count_atoms(clean_obj)
                 message = 'Clean: Cleaning %d atoms.  Please wait...'%at_cnt
 
@@ -246,7 +243,7 @@ def _clean(selection, present='', state=
             if c.ok:
                 self_cmd.set("suspend_undo", suspend_undo, updates=0)
                 self_cmd.push_undo(selection)
-                self_cmd.update(clean1_sele, clean_obj, 
+                self_cmd.update(clean1_sele, clean_obj,
                                 source_state=1, target_state=state)
             self_cmd.set("suspend_undo", True, updates=0)
             self_cmd.delete(clean_obj)
@@ -284,5 +281,3 @@ def clean(selection, present='', state=-
         except:
             traceback.print_exc()
         return 0
-
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/constants_palette.py pymol-open-source-2.3.3/modules/pymol/constants_palette.py
--- pymol-open-source-2.3.0/modules/pymol/constants_palette.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/constants_palette.py	2019-08-22 10:24:47.838615233 +0200
@@ -1,22 +1,22 @@
 palette_dict = {
     'rainbow_cycle'           : ('o',3,0  ,999), # perceptive rainbow
-    'rainbow_cycle_rev'       : ('o',3,999,  0),      
+    'rainbow_cycle_rev'       : ('o',3,999,  0),
     'rainbow'                 : ('o',3,107,893),
     'rainbow_rev'             : ('o',3,893,107),
-    'rainbow2'                : ('s',3,167, 833), # cartesian rainbow 
+    'rainbow2'                : ('s',3,167, 833), # cartesian rainbow
     'rainbow2_rev'            : ('s',3,833,167),
 
     'gcbmry' : ('r',3,166,999),
     'yrmbcg' : ('r',3,999,166),
 
     'cbmr'   : ('r',3,166,833),
-    'rmbc'   : ('r',3,833,166),      
+    'rmbc'   : ('r',3,833,166),
 
     'green_yellow_red'        : ('s',3,500,833),
-    'red_yellow_green'        : ('s',3,833,500),      
+    'red_yellow_green'        : ('s',3,833,500),
 
     'yellow_white_blue'       : ('w',3,  0, 83),
-    'blue_white_yellow'       : ('w',3, 83,  0),      
+    'blue_white_yellow'       : ('w',3, 83,  0),
 
     'blue_white_red'          : ('w',3, 83,167),
     'red_white_blue'          : ('w',3,167, 83),
@@ -25,7 +25,7 @@ palette_dict = {
     'green_white_red'         : ('w',3,250,167),
 
     'green_white_magenta'     : ('w',3,250,333),
-    'magenta_white_green'     : ('w',3,333,250),      
+    'magenta_white_green'     : ('w',3,333,250),
 
     'magenta_white_cyan'      : ('w',3,333,417),
     'cyan_white_magenta'      : ('w',3,417,333),
@@ -37,7 +37,7 @@ palette_dict = {
     'green_white_yellow'      : ('w',3,583,500),
 
     'green_white_blue'        : ('w',3,583,667),
-    'blue_white_green'        : ('w',3,667,583),      
+    'blue_white_green'        : ('w',3,667,583),
 
     'blue_white_magenta'      : ('w',3,667,750),
     'magenta_white_blue'      : ('w',3,750,667),
@@ -49,10 +49,10 @@ palette_dict = {
     'red_white_yellow'        : ('w',3,817,833),
 
     'red_white_cyan'          : ('w',3,916,999),
-    'cyan_white_red'          : ('w',3,999,916),      
+    'cyan_white_red'          : ('w',3,999,916),
 
     'yellow_blue'       : ('c',3,  0, 83),
-    'blue_yellow'       : ('c',3, 83,  0),      
+    'blue_yellow'       : ('c',3, 83,  0),
 
     'blue_red'          : ('c',3, 83,167),
     'red_blue'          : ('c',3,167, 83),
@@ -61,7 +61,7 @@ palette_dict = {
     'green_red'         : ('c',3,250,167),
 
     'green_magenta'     : ('c',3,250,333),
-    'magenta_green'     : ('c',3,333,250),      
+    'magenta_green'     : ('c',3,333,250),
 
     'magenta_cyan'      : ('c',3,333,417),
     'cyan_magenta'      : ('c',3,417,333),
@@ -73,7 +73,7 @@ palette_dict = {
     'green_yellow'      : ('c',3,583,500),
 
     'green_blue'        : ('c',3,583,667),
-    'blue_green'        : ('c',3,667,583),      
+    'blue_green'        : ('c',3,667,583),
 
     'blue_magenta'      : ('c',3,667,750),
     'magenta_blue'      : ('c',3,750,667),
@@ -85,5 +85,5 @@ palette_dict = {
     'red_yellow'        : ('c',3,817,833),
 
     'red_cyan'          : ('c',3,916,999),
-    'cyan_red'          : ('c',3,999,916),      
+    'cyan_red'          : ('c',3,999,916),
     }
diff -upNr pymol-open-source-2.3.0/modules/pymol/constants.py pymol-open-source-2.3.3/modules/pymol/constants.py
--- pymol-open-source-2.3.0/modules/pymol/constants.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/constants.py	2019-08-22 10:24:47.838615233 +0200
@@ -1,77 +1,10 @@
 
-# constant objects 
+# constant objects
 
-cmd = __import__('sys').modules['pymol.cmd']
-
-from . import parsing
+from .parsing import QuietException
+from .shortcut import Shortcut
+from .constants_palette import palette_dict
 import re
-from .cmd import Shortcut
-
-# TODO remove (keep for now for eventual legacy uses in scripts)
-gz_ext_re = re.compile(r"(\.?gz|\.bz2)$", re.I)
-
-# TODO remove (keep for now for eventual legacy uses in scripts)
-file_ext_re = re.compile(''.join([
-    "\.pdb$|\.pdb1$|\.ent$|\.mol$|\.p5m$|",
-    r"\.mmtf$|"
-    r"\.vdb$|"
-    r"\.pdbml$|\.pdbqt$|\.cml$|",
-    r"\.mmod$|\.mmd$|\.dat$|\.out$|\.mol2$|",
-    r"\.xplor$|\.pkl$|\.sdf$|\.pqr|", 
-    r"\.r3d$|\.xyz$|\.xyz_[0-9]*$|", 
-    r"\.cc1$|\.cc2$|", # ChemDraw 3D
-    r"\.cif$|", # CIF/mmCIF
-    r"\.cube$|", # Gaussian Cube
-    r"\.dx$|", # DX files (APBS)
-    r"\.pse$|\.psw$|\.pze$|\.pzw$|", # PyMOL session (pickled dictionary) and gzipped
-    r"\.pmo$|", # Experimental molecular object format
-    r"\.moe$|", # MOE (proprietary)
-    r"\.mae$|", # MAE (proprietary)
-    r"\.cms$|", # CMS (proprietary)
-    r"\.idx$|", # Desmond Traj (proprietary)
-    r"\.spi$|\.spider$|", # Spider Map
-    r"\.ccp4$|\.mrc$|\.map$|", # CCP4
-    r"\.top$|", # AMBER Topology
-    r"\.trj$|", # AMBER Trajectory
-    r"\.crd$|", # AMBER coordinate file
-    r"\.rst7?$|", # AMBER restart
-    r"\.psf$|", # protein structure file
-    r"\.cex$|", # CEX format (used by metaphorics)
-    r"\.phi$|", # PHI format (delphi)
-    r"\.fld$|", # FLD format (AVS)
-    r"\.trj$|\.trr$|\.xtc$|\.gro$|\.g96$|\.dcd$|", # Trajectories
-    r"\.o$|\.omap$|\.dsn6$|\.brix$|", # BRIX/O format
-    r"\.grd$|", # InsightII Grid format
-    r"\.acnt$", # Tripos / Sybyl ACNT format
-    ]), re.I)
-
-# TODO remove (keep for now for eventual legacy uses in scripts)
-class _loadable_legacy:
-    r3d = 14      # r3d, only used within cmd.py
-    sdf1 = 16     # sdf, only used within cmd.py
-    cc1 = 17      # cc1 and cc2, only used within cmd.py
-    cex = 20      # cex format
-    pse = 25      # PyMOL session
-    png = 39      # png image
-    psw = 40      #
-    moe = 41      # Chemical Computing Group ".moe" format (proprietary)
-    xtc = 42      # xtc trajectory format (via plugin)
-    trr = 43      # trr trajectory format (via plugin)
-    gro = 44      # gro trajectory format (via plugin)
-    g96 = 46      # g96 trajectory format (via plugin)
-    dcd = 47      # dcd trajectory format (via plugin)
-    cube = 48     # cube volume file (via plugin)
-    cif1 = 50     # Python-based CIF parser
-    pim = 52      # General-purpose programmatic import (powerful, insecure)
-    pwg = 53      # PyMOL web gui launch script
-    aln = 54      # CLUSTALW alignment file
-    fasta = 55    # FASTA sequence file
-    dtr = 57      # DESRES / Desmond
-    pze = 58
-    pzw = 59
-    spider = 62   # spider map
-    cms = 63      # desmond topology ("mae" plugin)
-    mae1 = 68     # Python-based MAE parser (proprietary and obsolete)
 
 class _loadable:
     pdb = 0
@@ -81,7 +14,7 @@ class _loadable:
     mmodstr = 6
     xplor = 7
     model = 8
-    pdbstr = 9    
+    pdbstr = 9
     brick = 10    # chempy.brick object
     map = 11      # chempy.map object
     callback = 12 # pymol callback obejct
@@ -122,7 +55,7 @@ class _loadable:
     mmtf = 71
     mmtfstr = 72
 
-class loadable(_loadable, _loadable_legacy):
+class loadable(_loadable):
     @classmethod
     def _reverse_lookup(cls, number):
         for name in dir(cls):
@@ -143,32 +76,37 @@ _load2str = { loadable.pdb : loadable.pd
               loadable.xyz  : loadable.xyzstr,
               loadable.sdf2 : loadable.sdf2str}
 
-# TODO remove (keep for now for eventual legacy uses in scripts)
-safe_oname_re = re.compile(r"[ ()|&!,`]")  # TODO use get_legal_name
-sanitize_list_re = re.compile(r"[^0-9\.\-\[\]\,]+")
-
 sanitize_alpha_list_re = re.compile(r"[^a-zA-Z0-9_\'\"\.\-\[\]\,]+")
 nt_hidden_path_re = re.compile(r"\$[\/\\]")
-quote_alpha_list_re = re.compile(
-    r'''([\[\,]\s*)([a-zA-Z_][a-zA-Z0-9_\ ]*[a-zA-Z0-9_]*)(\s*[\,\]])''')
 
 def safe_alpha_list_eval(st):
+    '''Like `safe_eval` but removes most non-alpha-numeric characters.
+
+    >>> safe_alpha_list_eval("[A B/C, D+E:F]")
+    ['ABC', 'DEF']
+    '''
     st = sanitize_alpha_list_re.sub('',st)
-    st = quote_alpha_list_re.sub(r'\1"\2"\3',st) # need to do this twice
-    st = quote_alpha_list_re.sub(r'\1"\2"\3',st)
-    return eval(sanitize_alpha_list_re.sub('',st)) 
+    return safe_list_eval(st)
 
 class SafeEvalNS(object):
     def __getitem__(self, name):
         return name
 
 def safe_eval(st):
+    '''Safe version of "eval" which evaluates names to strings.
+
+    # "foo" is a string
+    >>> safe_eval('foo, 123, 4 + 5, "A B C", {}, "{}"')
+    ('foo', 123, 9, 'A B C', {}, '{}')
+
+    # no harmful code possible
+    >>> safe_eval('__import__("os").unlink("foo.txt")')
+    TypeError: 'str' object is not callable
+    '''
     return eval(st, {}, SafeEvalNS())
 
 safe_list_eval = safe_eval
 
-QuietException = parsing.QuietException
-
 DEFAULT_ERROR = -1
 DEFAULT_SUCCESS = None
 
@@ -179,10 +117,11 @@ toggle_dict = {'on':1,'off':0,'1':1,'0':
 toggle_sc = Shortcut(toggle_dict.keys())
 
 stereo_dict = {'on':-2,'off':0,'0':0,'1':-2,'swap':-1,
+               'chromadepth': -3,
                'quadbuffer':1,'crosseye':2,
                'walleye':3,'geowall':4,'sidebyside':5,
-               'byrow':6, 'bycolumn':7, 'checkerboard':8, 
-               'custom': 9, 'anaglyph' : 10, 
+               'byrow':6, 'bycolumn':7, 'checkerboard':8,
+               'custom': 9, 'anaglyph' : 10,
                'dynamic' : 11, 'clonedynamic': 12 }
 
 stereo_sc = Shortcut(stereo_dict.keys())
@@ -262,8 +201,6 @@ boolean_dict = {
 
 boolean_sc = Shortcut(boolean_dict.keys())
 
-from .constants_palette import palette_dict
-
 palette_sc = Shortcut(palette_dict.keys())
 
 
@@ -303,7 +240,7 @@ class fb_module:
     cgo                       =11
     feedback                  =12
     scene                     =13
-    threads                   =14  
+    threads                   =14
     symmetry                  =15
     ray                       =16
     setting                   =17
@@ -322,7 +259,7 @@ class fb_module:
     objectmolecule            =30
     objectmap                 =31
     objectmesh                =32
-    objectdist                =33 
+    objectdist                =33
     objectcgo                 =34
     objectcallback            =35
     objectsurface             =36
@@ -359,12 +296,12 @@ class fb_module:
     selector                  =71
     editor                    =72
     nag                       =73
-    
+
     export                    =75
     ccmd                      =76
-    api                       =77   
+    api                       =77
 
-    main                      =80  
+    main                      =80
 
 # This second set, with negative indices
 # represent "python-only" subsystems
@@ -382,4 +319,3 @@ class fb_mask:
     blather =             0x40
     debugging =           0x80
     everything =          0xFF
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/controlling.py pymol-open-source-2.3.3/modules/pymol/controlling.py
--- pymol-open-source-2.3.0/modules/pymol/controlling.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/controlling.py	2019-08-22 10:24:47.838615233 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -22,12 +22,12 @@ if True:
         from .cmd import _cmd, QuietException, is_string, \
              boolean_dict, boolean_sc, \
              DEFAULT_ERROR, DEFAULT_SUCCESS, is_ok, is_error, \
-             location_code, location_sc 
+             location_code, location_sc
         import pymol
     except:
         from shortcut import Shortcut
         cmd = None
-    
+
 
     button_code = {
         'left' : 0,
@@ -84,7 +84,7 @@ if True:
         'pktb' : 24 ,
         'slab' : 25 ,
         'movs' : 26 ,
-        
+
         'pk1'  : 27 ,
         'mova' : 28 ,
         'menu' : 29 ,
@@ -111,7 +111,7 @@ if True:
         'mvvz' : 47 ,
 
         # 48 for internal use only
-        
+
         'drgo' : 49 ,
 
         'imsz' : 50 ,
@@ -122,21 +122,21 @@ if True:
         'movl' : 55 ,
         'mvzl' : 56
         }
-    
+
     but_act_sc = Shortcut(but_act_code.keys())
 
     ring_dict = {
         'maestro' : [ 'three_button_maestro' ],
-        
+
         'three_button' : [ 'three_button_viewing',
                            'three_button_editing',
                          ], # LEGACY
-                        
+
         'three_button_viewing' : [ 'three_button_viewing',
                                    'three_button_editing',
                                  ],
-                                   
-        'three_button_editing' : [ 'three_button_editing', 
+
+        'three_button_editing' : [ 'three_button_editing',
                                    'three_button_viewing',
                                  ],
 
@@ -144,7 +144,7 @@ if True:
                          'two_button_selecting',
                        ],
 
-        'two_button_viewing' : [ 'two_button_viewing', 
+        'two_button_viewing' : [ 'two_button_viewing',
                                  'two_button_selecting',
                                ],
 
@@ -206,7 +206,7 @@ SEE ALSO
 
     mode_name_dict = {
         'three_button_lights'  : '3-Button Lights',
-        'three_button_maestro' : '3-Button Maestro',        
+        'three_button_maestro' : '3-Button Maestro',
         'three_button_viewing' : '3-Button Viewing',
         'three_button_editing' : '3-Button Editing',
         'three_button_motions' : '3-Button Motions',
@@ -222,13 +222,13 @@ SEE ALSO
         'three_button_viewing',
         'three_button_editing',
         'three_button_motions',
-        'three_button_maestro' ,        
+        'three_button_maestro' ,
         'two_button_viewing' ,
         'two_button_selecting' ,
         'two_button_editing',
         'two_button_lights',
-        'one_button_viewing' , 
-        'default' , 
+        'one_button_viewing' ,
+        'default' ,
         # okay to append new mode name, but don't insert: order & position matter
         ]
 
@@ -239,10 +239,10 @@ SEE ALSO
           ('r','none','movz'),
           ('l','shft','rotl'),
           ('m','shft','movl'),
-          ('r','shft','mvzl') ,                 
+          ('r','shft','mvzl') ,
           ('l','ctrl','none'),
           ('m','ctrl','none'),
-          ('r','ctrl','none'),                  
+          ('r','ctrl','none'),
           ('l','ctsh','none'),
           ('m','ctsh','none'),
           ('r','ctsh','none'),
@@ -267,10 +267,10 @@ SEE ALSO
           ('r','none','movz'),
           ('l','shft','rotl'),
           ('m','shft','none'),
-          ('r','shft','mvzl'),                 
+          ('r','shft','mvzl'),
           ('l','ctrl','movl'),
           ('m','ctrl','none'),
-          ('r','ctrl','none'),                 
+          ('r','ctrl','none'),
           ('l','ctsh','none'),
           ('m','ctsh','none'),
           ('r','ctsh','cent'),
@@ -282,7 +282,7 @@ SEE ALSO
           ('w','ctrl','none'),
           ('w','ctsh','none'),
           ('double_left','none','menu'),
-          ('double_middle','none','none'),                               
+          ('double_middle','none','none'),
           ('double_right','none','cent'),
           ('single_left','none','none'),
           ('single_middle','none','none'),
@@ -295,10 +295,10 @@ SEE ALSO
           ('r','none','move'),
           ('l','shft','+Box'),
           ('m','shft','-Box'),
-          ('r','shft','clip'),                 
+          ('r','shft','clip'),
           ('l','ctrl','+/-'),
           ('m','ctrl','irtz'),
-          ('r','ctrl','pk1'),                 
+          ('r','ctrl','pk1'),
           ('l','ctsh','Sele'),
           ('m','ctsh','orig'),
           ('r','ctsh','clip'),
@@ -324,10 +324,10 @@ SEE ALSO
           ('r','none','movz'),
           ('l','shft','+Box'),
           ('m','shft','-Box'),
-          ('r','shft','clip'),                 
+          ('r','shft','clip'),
           ('l','ctrl','move'),
           ('m','ctrl','pkat'),
-          ('r','ctrl','pk1'),                 
+          ('r','ctrl','pk1'),
           ('l','ctsh','Sele'),
           ('m','ctsh','orig'),
           ('r','ctsh','clip'),
@@ -353,10 +353,10 @@ SEE ALSO
           ('r','none','movz'),
           ('l','shft','roto'),
           ('m','shft','movo'),
-          ('r','shft','mvoz') ,                 
+          ('r','shft','mvoz') ,
           ('l','ctrl','torf'),
           ('m','ctrl','+/-'),
-          ('r','ctrl','pktb'),                  
+          ('r','ctrl','pktb'),
           ('l','ctsh','mova'),
           ('m','ctsh','orig'),
           ('r','ctsh','clip'),
@@ -382,10 +382,10 @@ SEE ALSO
           ('r','none','movz'),
           ('l','shft','rotv'),
           ('m','shft','movv'),
-          ('r','shft','mvvz') ,                 
+          ('r','shft','mvvz') ,
           ('l','ctrl','torf'),
           ('m','ctrl','pkat'),
-          ('r','ctrl','pktb'),                  
+          ('r','ctrl','pktb'),
           ('l','ctsh','mova'),
           ('m','ctsh','orig'),
           ('r','ctsh','clip'),
@@ -412,10 +412,10 @@ SEE ALSO
           ('r','none','movz'),
           ('l','shft','pk1'),
           ('m','shft','none'),
-          ('r','shft','clip'),                 
+          ('r','shft','clip'),
           ('l','ctrl','move'),
           ('m','ctrl','none'),
-          ('r','ctrl','pkat'),                 
+          ('r','ctrl','pkat'),
           ('l','ctsh','sele'),
           ('m','ctsh','none'),
           ('r','ctsh','cent'),
@@ -427,7 +427,7 @@ SEE ALSO
           ('w','ctrl','none'),
           ('w','ctsh','none'),
           ('double_left','none','menu'),
-          ('double_middle','none','none'),                               
+          ('double_middle','none','none'),
           ('double_right','none','cent'),
           ('single_left','none','pkat'),
           ('single_middle','none','none'),
@@ -440,10 +440,10 @@ SEE ALSO
           ('r','none','movz'),
           ('l','shft','+Box'),
           ('m','shft','none'),
-          ('r','shft','-Box'),                 
+          ('r','shft','-Box'),
           ('l','ctrl','+/-'),
           ('m','ctrl','none'),
-          ('r','ctrl','pkat'),                 
+          ('r','ctrl','pkat'),
           ('l','ctsh','sele'),
           ('m','ctsh','none'),
           ('r','ctsh','cent'),
@@ -456,7 +456,7 @@ SEE ALSO
           ('w','ctsh','none'),
           ('double_left','none','menu'),
           ('double_left','none','menu'),
-          ('double_middle','none','none'),                               
+          ('double_middle','none','none'),
           ('double_right','none','cent'),
           ('single_left','none','+/-'),
           ('single_right','none', 'menu'),
@@ -468,10 +468,10 @@ SEE ALSO
           ('r','none','movz'),
           ('l','shft','pkat'),
           ('m','shft','none'),
-          ('r','shft','clip'),                 
+          ('r','shft','clip'),
           ('l','ctrl','torf'),
           ('m','ctrl','none'),
-          ('r','ctrl','pktb'),                 
+          ('r','ctrl','pktb'),
           ('l','ctsh','rotf'),
           ('m','ctsh','none'),
           ('r','ctsh','movf'),
@@ -483,11 +483,11 @@ SEE ALSO
           ('w','ctrl','none'),
           ('w','ctsh','none'),
           ('double_left','none','menu'),
-          ('double_middle','none','none'),                               
+          ('double_middle','none','none'),
           ('double_right','none','cent'),
           ('single_left','none','pkat'),
-          ('single_middle','none','none'),                               
-          ('single_right','none','menu'),                               
+          ('single_middle','none','none'),
+          ('single_right','none','menu'),
           ('single_left','alt', 'cent'),
           ],
          'one_button_viewing' :
@@ -527,7 +527,7 @@ SEE ALSO
           ('single_right','none', 'none'),
           ('single_left','shft','none'),
           ('single_left','ctrl','menu'),
-          ('single_left','ctsh','pkat'), 
+          ('single_left','ctsh','pkat'),
           ('single_left','alt', 'cent'),
           ('single_left','alsh','none'),
           ('single_left','ctal','none'),
@@ -604,7 +604,7 @@ SEE ALSO
             r = _cmd.order(_self._COb,str(names),int(sort),int(location))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException         
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def mouse(action=None, quiet=1, _self=cmd):# INTERNAL
@@ -645,9 +645,9 @@ USAGE
                 sm = sm - 1
                 if sm<0: sm = 6
                 _self.set("mouse_selection_mode",sm,quiet=1)
-            
+
             mode_list = None
-            if action==None:
+            if action is None:
                 bm = _self.get_setting_int("button_mode")
                 if bm>=0:
                     bm = bm % len(mouse_ring)
@@ -658,7 +658,7 @@ USAGE
                     bm = (-1-bm) % len(mode_name_list)
                     mode = mode_name_list[bm]
                     _self.set("button_mode_name",mode_name_dict.get(mode,mode))
-                    mode_list = mode_dict[mode]                    
+                    mode_list = mode_dict[mode]
             elif action in mouse_ring:
                 mode = action
                 _self.set("button_mode_name",mode_name_dict.get(mode,mode))
@@ -671,7 +671,7 @@ USAGE
                 bm = -1 - mode_name_list.index(action)
                 _self.set("button_mode",bm)
                 mode_list = mode_dict[mode]
-            if mode_list!=None:
+            if mode_list is not None:
                 kw_dict = {'_self':_self}
                 for a in mode_list:
                     button(*a, **kw_dict)
@@ -682,10 +682,10 @@ USAGE
             r = DEFAULT_SUCCESS
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException                     
+        if _self._raising(r,_self): raise pymol.CmdException
         _self.refresh_wizard() # refresh mouse config in GUI
         return r
-            
+
 
     def edit_mode(active=1,quiet=1,_self=cmd):
         '''
@@ -711,13 +711,13 @@ DESCRIPTION
                         mouse(action='three_button_editing',quiet=quiet,_self=_self)
             else:
                 if mouse_mode[0:10]=='two_button':
-                    if mouse_mode!='two_button_viewing':               
+                    if mouse_mode!='two_button_viewing':
                         mouse(action='two_button_viewing',quiet=quiet,_self=_self)
                 elif mouse_mode[0:12] == 'three_button':
                     if mouse_mode!='three_button_viewing':
                         mouse(action='three_button_viewing',quiet=quiet,_self=_self)
         return DEFAULT_SUCCESS
-    
+
     def set_key(key,fn=None,arg=(),kw={},_self=cmd):
         '''
 DESCRIPTION
@@ -866,7 +866,7 @@ SEE ALSO
             r = _cmd.button(_self._COb,but_code,act_code)
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException         
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
 
@@ -896,11 +896,11 @@ SEE ALSO
         selection = selector.process(selection)
         #
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.mask(_self._COb,"("+str(selection)+")",1,int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException         
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def unmask(selection="(all)",quiet=1,_self=cmd):
@@ -924,12 +924,11 @@ SEE ALSO
         r = DEFAULT_ERROR
         # preprocess selection
         selection = selector.process(selection)
-        #   
+        #
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.mask(_self._COb,"("+str(selection)+")",0,int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException         
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/creating.py pymol-open-source-2.3.3/modules/pymol/creating.py
--- pymol-open-source-2.3.0/modules/pymol/creating.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/creating.py	2019-08-22 10:24:47.838615233 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
 #-* Filipe Maia (slicing code)
-#-* 
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -54,7 +54,7 @@ if True:
         "grayscale" : 8,
         "object" : [[-1.0,-1.0,-1.0]]
         }
-    
+
     ramp_spectrum_sc = Shortcut(ramp_spectrum_dict.keys())
 
     group_action_dict = {
@@ -78,7 +78,7 @@ if True:
         "mtz" : 2,
         "cif" : 3
         }
-    
+
     def group(name, members="", action='auto', quiet=1,_self=cmd):
         '''
 
@@ -122,8 +122,8 @@ SEE ALSO
     ungroup, order, "group_auto_mode" setting
     
 '''
-        
-        r = DEFAULT_ERROR        
+
+        r = DEFAULT_ERROR
         action = group_action_dict[group_action_sc.auto_err(str(action),'group action')]
         if name=='all': name='*'
         if action==6:
@@ -138,9 +138,9 @@ SEE ALSO
             r = _cmd.group(_self._COb,str(name),str(members),int(action),int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException         
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
-    
+
     def ungroup(name, members="", quiet=1, _self=cmd):
         '''
 
@@ -159,14 +159,14 @@ SEE ALSO
     group
     
     '''
-        
+
         r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             r = _cmd.group(_self._COb,str(name),str(members),7,int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException         
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def map_generate(name, reflection_file, amplitudes, phases, weights="None",
@@ -230,7 +230,7 @@ NOTES
             # TODO: work for CIF, MTZ, and CNS
             from . import headering
             mtzFile = headering.MTZHeader(reflection_file)
-                
+
             # FORMAT: crystal/dataset/column
             _, datasetName, ampColName = ('//' + amplitudes).rsplit('/', 2)
 
@@ -267,7 +267,7 @@ NOTES
                               float(cellX), float(cellY), float(cellZ),
                               float(cellAlpha), float(cellBeta), float(cellGamma),
                               int(quiet),int(zoom))
-            if r!=None:
+            if r is not None:
                 if not quiet:
                     print("Loading map '%s'" % (name))
                 r = _self.load(r, name, format="ccp4", finish=1)
@@ -280,10 +280,10 @@ NOTES
             print(" MapGenerate-Error: Cannot import headering module.  Cannot read MTZ file or make map.")
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException         
+        if _self._raising(r,_self): raise pymol.CmdException
 
         return name
-    
+
     def map_new(name, type='gaussian', grid=None, selection="(all)",
                 buffer=None, box=None, state=0, quiet=1, zoom=0,
                 normalize=-1, clamp=[1.0,-1.0], resolution=0.0, _self=cmd):
@@ -332,7 +332,7 @@ NOTES
         # preprocess selection
         r = DEFAULT_ERROR
         selection = selector.process(selection)
-        if box!=None: # box should be [[x1,y1,z1],[x2,y2,z2]]
+        if box is not None: # box should be [[x1,y1,z1],[x2,y2,z2]]
             if _self.is_string(box):
                 box = safe_list_eval(box)
             box = (float(box[0][0]),
@@ -345,9 +345,9 @@ NOTES
         else:
             box = (0.0,0.0,0.0,1.0,1.0,1.0)
             box_flag = 0
-        if grid==None:
+        if grid is None:
             grid = _self.get_setting_float('gaussian_resolution')/3.0
-        if buffer==None:
+        if buffer is None:
             buffer = -1.0
         grid = float(grid) # for now, uniform xyz; later (x,y,z)
 
@@ -364,7 +364,7 @@ NOTES
                              float(clamp[0]),float(clamp[1]),float(resolution))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException         
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def ramp_new(name, map_name, range=[-1.0,0.0,1.0],
@@ -482,7 +482,7 @@ SEE ALSO
             _self._invalidate_color_sc(_self)
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException         
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def ramp_update(name, range=[], color=[], quiet=1, _self=cmd):
@@ -564,7 +564,7 @@ SEE ALSO
         if selection not in [ 'center', 'origin' ]:
             selection = "("+selection+")"
         #
-        if carve==None:
+        if carve is None:
             carve=0.0
         try:
             _self.lock(_self)
@@ -575,7 +575,7 @@ SEE ALSO
                              float(level))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException         
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def volume(name, map, ramp='', selection='', buffer=0.0,
@@ -621,7 +621,7 @@ SEE ALSO
 
 '''
         r = DEFAULT_ERROR
-        
+
         if selection!='':
             region = 1 # about a selection
         else:
@@ -631,7 +631,7 @@ SEE ALSO
         if selection not in [ 'center', 'origin' ]:
             selection = "("+selection+")"
 
-        if carve==None:
+        if carve is None:
             carve=0.0
 
         try:
@@ -640,7 +640,7 @@ SEE ALSO
             ramp = ''
         except (ValueError, TypeError):
             level = 0.0
-        
+
         try:
             _self.lock(_self)
 
@@ -652,7 +652,7 @@ SEE ALSO
 
         finally:
             _self.unlock(r,_self)
-        
+
         if _self._raising(r,_self): raise pymol.CmdException
 
         if ramp:
@@ -729,7 +729,7 @@ SEE ALSO
             r = _cmd.slice_new(_self._COb,str(name),str(map),int(state)-1,int(source_state)-1)
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException         
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
 
@@ -782,7 +782,7 @@ SEE ALSO
         if selection not in [ 'center', 'origin' ]:
             selection = "("+selection+")"
       #
-        if carve==None:
+        if carve is None:
             carve=0.0
         try:
             _self.lock(_self)
@@ -793,7 +793,7 @@ SEE ALSO
 
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException         
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def isodot(name,map,level=1.0,selection='',buffer=0.0,state=0,
@@ -836,7 +836,7 @@ SEE ALSO
         if selection not in [ 'center', 'origin' ]:
             selection = "("+selection+")"
         #
-        if carve==None:
+        if carve is None:
             carve=0.0
         try:
             _self.lock(_self)
@@ -847,7 +847,7 @@ SEE ALSO
                              float(level))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException                  
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
 
@@ -870,7 +870,7 @@ USAGE
         finally:
             _self.unlock(r,_self)
         if not int(query):
-            if _self._raising(r,_self): raise pymol.CmdException                  
+            if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def gradient(name, map, minimum=1.0, maximum=-1.0,
@@ -909,7 +909,7 @@ SEE ALSO
         if selection not in [ 'center', 'origin' ]:
             selection = "("+selection+")"
         #
-        if carve==None:
+        if carve is None:
             carve=0.0
         try:
             _self.lock(_self)
@@ -920,7 +920,7 @@ SEE ALSO
                              float(maximum))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException                  
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def copy(target,source,zoom=-1,_self=cmd):
@@ -942,13 +942,13 @@ SEE ALSO
 
     create
         '''
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             r = _cmd.copy(_self._COb,str(source),str(target),int(zoom))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException                  
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def symexp(prefix, object, selection, cutoff, segi=0, quiet=1,_self=cmd):
@@ -982,7 +982,7 @@ SEE ALSO
                             int(segi),int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException                           
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def fragment(name, object=None, origin=1, zoom=0, quiet=1, _self=cmd):
@@ -999,7 +999,7 @@ USAGE
     '''
         r = DEFAULT_ERROR
         try:
-            if object==None:
+            if object is None:
                 object=name
             model = fragments.get(str(name))
             la = len(model.atom)
@@ -1013,7 +1013,7 @@ USAGE
             r = _self.load_model(model,str(object),quiet=quiet,zoom=zoom, _self=_self)
         except IOError:
             raise pymol.CmdException("unable to load fragment '%s'." % name)
-        if _self._raising(r,_self): raise pymol.CmdException                                    
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def create(name, selection, source_state=0,
@@ -1111,7 +1111,7 @@ SEE ALSO
     create
     
     '''
-        
+
         kw['extract'] = 1
         return create(*arg, **kw)
 
@@ -1119,13 +1119,13 @@ SEE ALSO
         "unit" : 0, # radius 0.5
         "extent" : 1,
         "rms" : 2,
-#        "ellipse" : 2,  for anisotropic b-factors? 
+#        "ellipse" : 2,  for anisotropic b-factors?
         }
 
     pseudoatom_mode_sc =  Shortcut(pseudoatom_mode_dict.keys())
 
     unquote_re = re.compile(r"r?('.*'|\".*\")$")
-    
+
     def unquote(s):
         if sys.version_info[0] > 2 and isinstance(s, bytes):
             s = s.decode('utf-8', 'replace')
@@ -1137,7 +1137,7 @@ SEE ALSO
             except SyntaxError:
                 print(" Warning: unquote failed for", repr(s))
         return s
-    
+
     def pseudoatom(object='', selection='', name='PS1', resn='PSD', resi='1', chain='P',
                    segi='PSDO', elem='PS', vdw=-1.0, hetatm=1, b=0.0, q=0.0, color='',
                    label='', pos=None, state=0, mode='rms', quiet=1,_self=cmd):
@@ -1160,8 +1160,8 @@ NOTES
     on must place an atom or a label in 3D space.
     
     '''
-        
-        r = DEFAULT_ERROR      
+
+        r = DEFAULT_ERROR
         # preprocess selection
         if len(color):
             color = _self.get_color_index(str(color))
@@ -1169,12 +1169,12 @@ NOTES
             color = -1 # default
         selection = selector.process(selection)
         mode = pseudoatom_mode_dict[pseudoatom_mode_sc.auto_err(str(mode),'pseudoatom mode')]
-        
+
         (name,resn,resi,chain,segi,elem,label) = list(map(unquote,(name,resn,resi,chain,segi,elem,label)))
-        #      
+        #
         try:
             _self.lock(_self)
-            if pos!=None:
+            if pos is not None:
                 if not (is_list(pos) or is_tuple(pos)):
                     pos = safe_list_eval(pos)
                 pos = (float(pos[0]), # tuple-ize
@@ -1189,9 +1189,9 @@ NOTES
                                 int(state)-1, int(mode), int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException                                    
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
-        
+
     def join_states(name, selection='all', mode=2, zoom=0, quiet=1, _self=cmd):
         '''
 DESCRIPTION
@@ -1256,4 +1256,3 @@ EXAMPLE
 
         if int(zoom):
             _self.zoom(name, state=0)
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/diagnosing.py pymol-open-source-2.3.3/modules/pymol/diagnosing.py
--- pymol-open-source-2.3.0/modules/pymol/diagnosing.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/diagnosing.py	2019-08-22 10:24:47.838615233 +0200
@@ -1,4 +1,5 @@
 import sys
+import os
 
 def _unicode(s):
     # Return - if possible - unicode, or if the byte string can't be
@@ -25,12 +26,7 @@ ARGUMENTS
 
     filename = str: If given, write output to text file
     '''
-    import platform
-    import os
-    import re
-    import glob
     import time
-    import textwrap
     from pymol import invocation
     from pymol import cmd, CmdException
 
@@ -46,31 +42,15 @@ ARGUMENTS
             body += 'build date: %s %s\n' % (time.ctime(version[3]), TZ)
         if version[4]:
             body += 'git sha: %s\n' % version[4]
-        if version[5]:
-            body += "svn rev: %s\n" % version[5]
 
-    try:
-        # pymol conda package version
-        condameta = glob.glob(os.path.join(sys.prefix, 'conda-meta',
-            'pymol-' + version[0] + '*.json'))
-        if condameta:
-            import json
-            d = json.load(open(condameta[0]))
-            body += 'conda build: %s %s\n' % (d.get('build'),
-                    d.get('schannel') or d.get('channel'))
-    except BaseException as e:
-        print(e)
+    body += diagnostics_conda(version[0])
 
     if not compact:
         body += '\nLicense Information:\n'
 
     body += 'Open-Source Build\n'
 
-    if not compact:
-        body += '\nOperating System:\n'
-    body += platform.platform() + '\n'
-    if platform.system() == 'Linux':
-        body += platform.version() + '\n'
+    body += diagnostics_platform()
 
     if not compact:
         body += '\nOpenGL Driver:\n'
@@ -79,21 +59,10 @@ ARGUMENTS
     body += str(renderer[1] or '(none)') + '\n'
     body += str(renderer[2] or '(none)') + '\n'
 
-    try:
-        from pymol.Qt import QtCore
-        body += '%s %s (Qt %s)\n' % (
-                QtCore.__name__.split('.')[0],
-                QtCore.PYQT_VERSION_STR,
-                QtCore.QT_VERSION_STR)
-    except Exception as e:
-        body += '(%s)\n' % (e,)
+    body += diagnostics_qt()
 
     if not compact:
-        body += '\nPython:\n'
-        body += '%s\n' % sys.version
-        body += 'prefix=%s\n' % _unicode(sys.prefix)
-        body += 'executable=%s\n' % _unicode(sys.executable)
-        body += u'filesystemencoding={}\n'.format(sys.getfilesystemencoding())
+        body += diagnostics_python()
 
         body += '\nStartup Scripts:\n'
         pymolrc = invocation.get_user_config()
@@ -103,13 +72,7 @@ ARGUMENTS
         else:
             body += '(no pymolrc file found)\n'
 
-        body += '\nQt, Python and PyMOL Environment Variables:\n'
-        for key in sorted(os.environ):
-            if re.search(r'^PY|QT|^LANG', key) and not (key == 'PYMOL_SCRIPTS'):
-                body += u'%s=%s\n' % (key, _unicode(os.environ[key]))
-
-        body += '\nPATH:\n'
-        body += textwrap.fill(_unicode(os.getenv('PATH', '')), 78) + '\n'
+        body += diagnostics_env_vars()
 
         body += '\nDiagnostics collected on %s %s\n' % (time.ctime(), TZ)
 
@@ -125,3 +88,87 @@ ARGUMENTS
         print(body.rstrip())
 
     return body
+
+
+def diagnostics_no_cmd():
+    '''
+    System level diagnostics data which doesn't depend on pymol._cmd
+    '''
+    body = ''
+    body += diagnostics_conda()
+    body += diagnostics_platform()
+    body += diagnostics_qt()
+    body += diagnostics_python()
+    body += diagnostics_env_vars()
+    return body
+
+
+def diagnostics_conda(versionselector=''):
+    import glob
+    body = ''
+    try:
+        # pymol conda package version
+        condameta = glob.glob(os.path.join(sys.prefix, 'conda-meta',
+            'pymol-' + versionselector + '*.json'))
+        for jsonfile in condameta:
+            import json
+            d = json.load(open(jsonfile))
+            if not versionselector:
+                body += os.path.basename(jsonfile) + '\n'
+            body += u'conda build: {} {}\n'.format(d.get('build'),
+                    d.get('schannel') or d.get('channel'))
+    except BaseException as e:
+        print(e)
+    return body
+
+
+def diagnostics_platform(compact=False):
+    import platform
+    body = u''
+
+    if not compact:
+        body += '\nOperating System:\n'
+
+    body += platform.platform() + '\n'
+
+    if platform.system() == 'Linux':
+        body += platform.version() + '\n'
+
+    return body
+
+
+def diagnostics_qt():
+    try:
+        from pymol.Qt import QtCore
+        return u'{} {} (Qt {})\n'.format(
+                QtCore.__name__.split('.')[0],
+                QtCore.PYQT_VERSION_STR,
+                QtCore.QT_VERSION_STR)
+    except Exception as e:
+        return u'({})\n'.format(e)
+
+
+def diagnostics_python():
+    tmpl = (u'\nPython:\n'
+            u'{v}\n'
+            u'prefix={p}\n'
+            u'executable={exe}\n'
+            u'filesystemencoding={enc}\n')
+    return tmpl.format(v=sys.version,
+                       p=_unicode(sys.prefix),
+                       exe=_unicode(sys.executable),
+                       enc=sys.getfilesystemencoding())
+
+
+def diagnostics_env_vars():
+    import re
+    import textwrap
+
+    body = '\nQt, Python and PyMOL Environment Variables:\n'
+    for key in sorted(os.environ):
+        if re.search(r'^PY|QT|^LANG', key) and not (key == 'PYMOL_SCRIPTS'):
+            body += u'%s=%s\n' % (key, _unicode(os.environ[key]))
+
+    body += '\nPATH:\n'
+    body += textwrap.fill(_unicode(os.getenv('PATH', '')), 78) + '\n'
+    return body
diff -upNr pymol-open-source-2.3.0/modules/pymol/editing.py pymol-open-source-2.3.3/modules/pymol/editing.py
--- pymol-open-source-2.3.0/modules/pymol/editing.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/editing.py	2019-08-22 10:24:47.838615233 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -22,9 +22,9 @@ if True:
     cmd = __import__("sys").modules["pymol.cmd"]
     from .cmd import _cmd,lock,unlock,Shortcut,is_string, \
           boolean_sc,boolean_dict,safe_list_eval, is_sequence, \
-          DEFAULT_ERROR, DEFAULT_SUCCESS, _raising, is_ok, is_error              
+          DEFAULT_ERROR, DEFAULT_SUCCESS, _raising, is_ok, is_error
     from chempy import cpv
-    
+
     ref_action_dict = {
         'store'     : 1,
         'recall'    : 2,
@@ -33,7 +33,7 @@ if True:
     }
 
     ref_action_sc = Shortcut(ref_action_dict.keys())
-    
+
     def reference(action='validate', selection='(all)',
                   state=0, quiet=1, _self=cmd):
         r = DEFAULT_ERROR
@@ -42,16 +42,16 @@ if True:
             action = ref_action_dict[action]
         else:
             action = int(action)
-        selection = selector.process(selection)           
+        selection = selector.process(selection)
         try:
             _self.lock(_self)
             r = _cmd.reference( _self._COb, int(action), str(selection),
                                int(state)-1, int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
-    
+
     def sculpt_purge(_self=cmd):
         '''
 DESCRIPTION
@@ -65,7 +65,7 @@ DESCRIPTION
             r = _cmd.sculpt_purge(_self._COb)
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def sculpt_deactivate(object, _self=cmd):
@@ -89,10 +89,10 @@ SEE ALSO
             r = _cmd.sculpt_deactivate(_self._COb,str(object))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
-    def sculpt_activate(object, state=0, match_state=-1, 
+    def sculpt_activate(object, state=0, match_state=-1,
                         match_by_segment=0, _self=cmd):
         '''
 DESCRIPTION
@@ -120,7 +120,7 @@ SEE ALSO
                                      int(match_by_segment))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def split_states(object, first=1, last=0, prefix=None, _self=cmd):
@@ -181,13 +181,13 @@ SEE ALSO
 
                 r = _self.create(name, "?%s & ?%s" % (sele, object), a, 1)
 
-                if is_error(r): 
+                if is_error(r):
                     break
 
         _self.delete(sele)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
-     
+
     def sculpt_iterate(object, state=0, cycles=10, _self=cmd):
         '''
 DESCRIPTION
@@ -218,7 +218,7 @@ SEE ALSO
             r = _cmd.sculpt_iterate(_self._COb,str(object),int(state)-1,int(cycles))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def smooth(selection="all", passes=1, window=5, first=1,
@@ -255,9 +255,9 @@ SEE ALSO
     load_traj
 
     '''
-        
+
         r = DEFAULT_ERROR
-        selection = selector.process(selection)   
+        selection = selector.process(selection)
         try:
             _self.lock(_self)
             r = _cmd.smooth(_self._COb,str(selection),int(passes),int(window),
@@ -265,7 +265,7 @@ SEE ALSO
 
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def set_state_order(name, order, quiet=1, _self=cmd):
@@ -330,7 +330,7 @@ PYMOL API
                                          str(spacegroup))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def symmetry_copy(source_name='', target_name='', source_state=1, target_state=1, target_undo=1, log=0, quiet=1, _self=cmd):
@@ -359,7 +359,7 @@ PYMOL API
 
         r = DEFAULT_ERROR
 
-        if source_name == None:
+        if source_name is None:
             source_name = ''
 
         target_name = str(target_name).strip()
@@ -368,10 +368,10 @@ PYMOL API
         # ignored for now
         source_mode = 1
         target_mode = 1
-        
+
         try:
             _self.lock(_self)
-            
+
             r = _cmd.symmetry_copy(_self._COb,str(source_name),
                                    str(target_name),
                                    int(source_mode),
@@ -384,7 +384,7 @@ PYMOL API
         finally:
             _self.unlock(r,_self)
         if _self._raising(r,_self):
-            raise pymol.CmdException            
+            raise pymol.CmdException
         return r
 
 
@@ -410,7 +410,7 @@ PYMOL API
                                     str(new_name))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
 
@@ -445,7 +445,7 @@ SEE ALSO
             r = _cmd.set_geometry(_self._COb,str(selection),int(geometry),int(valence))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def undo(_self=cmd):
@@ -463,13 +463,13 @@ SEE ALSO
 
     redo, push_undo
     '''
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             r = _cmd.undo(_self._COb,-1)
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def push_undo(selection, just_coordinates=1, finish_undo=0, add_objects=0, delete_objects=0, state=0, _self=cmd):
@@ -498,7 +498,7 @@ SEE ALSO
             r = _cmd.push_undo(_self._COb,"("+str(selection)+")",int(state)-1)
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def redo(_self=cmd):
@@ -516,17 +516,17 @@ SEE ALSO
 
     undo, push_undo
     '''
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             r = _cmd.undo(_self._COb,1)
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException                     
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     order_dict = {
-    # simulation 
+    # simulation
         '0'         : 0,
         '1'         : 1,
         '2'         : 2,
@@ -567,11 +567,11 @@ SEE ALSO
             order = int(order)
         r = DEFAULT_ERROR
         # preprocess selections
-        if selection1 == None:
+        if selection1 is None:
             selection1="(pk1)"
-            if selection2 == None:
+            if selection2 is None:
                 selection2="(pk2)"
-        if selection2 == None:
+        if selection2 is None:
             selection2 = selection1
         selection1 = selector.process(selection1)
         selection2 = selector.process(selection2)
@@ -585,12 +585,12 @@ SEE ALSO
                 r = _cmd.revalence(_self._COb,
                                    "("+selection1+")",
                                    "("+selection2+")",
-                                   str(source), 
+                                   str(source),
                                    int(target_state)-1, int(source_state)-1,
                                    int(reset), int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def bond(atom1="(pk1)", atom2="(pk2)", order=1, edit=1, quiet=1, _self=cmd):
@@ -630,7 +630,7 @@ SEE ALSO
                           int(order),1,int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def invert(quiet=1, _self=cmd):
@@ -692,7 +692,7 @@ SEE ALSO
         r = DEFAULT_ERROR
         # preprocess selections
         atom1 = selector.process(atom1)
-        atom2 = selector.process(atom2)   
+        atom2 = selector.process(atom2)
         try:
             _self.lock(_self)
             r = _cmd.bond(_self._COb,
@@ -700,7 +700,7 @@ SEE ALSO
                           0,0,int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def remove(selection, quiet=1, _self=cmd):
@@ -729,14 +729,14 @@ SEE ALSO
         r = DEFAULT_ERROR
         # preprocess selection
         selection = selector.process(selection)
-        #   
+        #
         r = 1
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.remove(_self._COb,"("+selection+")",int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
 
@@ -769,11 +769,11 @@ SEE ALSO
     '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.remove_picked(_self._COb,int(hydrogens),int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
 
@@ -812,13 +812,13 @@ SEE ALSO
     '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.cycle_valence(_self._COb,quiet)
         finally:
             _self.unlock(r,_self)
         if h_fill:
             globals()['h_fill'](quiet)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
 
@@ -839,15 +839,15 @@ PYMOL API
     '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.attach(_self._COb,str(element),int(geometry),int(valence),str(name))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
 
-    def fuse(selection1="(pk1)", selection2="(pk2)", 
+    def fuse(selection1="(pk1)", selection2="(pk2)",
              mode=0, recolor=1, move=1, _self=cmd):
         '''
 DESCRIPTION
@@ -889,14 +889,14 @@ SEE ALSO
         # preprocess selections
         selection1 = selector.process(selection1)
         selection2 = selector.process(selection2)
-        #   
+        #
         try:
             _self.lock(_self)
             r = _cmd.fuse(_self._COb,str(selection1),str(selection2),
                               int(mode),int(recolor),int(move))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def unpick(_self=cmd):
@@ -918,14 +918,14 @@ SEE ALSO
 
     edit
         '''
-        
-        r = DEFAULT_ERROR      
+
+        r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.unpick(_self._COb)
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def drag(selection=None, wizard=1, edit=1, quiet=1, mode=-1, _self=cmd):
@@ -954,7 +954,7 @@ NOTES
         import pymol.wizard.dragging
 
         quiet = int(quiet)
-        if (selection!=None) and (selection!=""):
+        if (selection is not None) and (selection!=""):
             selection = selector.process(selection)
             if is_string(edit):
                 edit=boolean_dict[boolean_sc.auto_err(edit,'boolean')]
@@ -970,7 +970,7 @@ NOTES
         #
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.drag(_self._COb,str(selection),int(quiet),int(mode))
         finally:
             _self.unlock(r,_self)
@@ -979,7 +979,7 @@ NOTES
                 _self.edit_mode(edit)
             if wizard:
                 wiz = _self.get_wizard()
-                if (wiz == None):
+                if (wiz is None):
                     _self.wizard("dragging",old_button_mode)
                 elif not isinstance(wiz, pymol.wizard.dragging.Dragging):
                     _self.wizard("dragging",old_button_mode)
@@ -987,7 +987,7 @@ NOTES
                     wiz.recount()
         if _self._raising(r,_self): raise pymol.CmdException
         return r
-        
+
     def edit(selection1='', selection2='none', selection3='none',
              selection4='none', pkresi=0, pkbond=1, quiet=1, _self=cmd):
         '''
@@ -1024,7 +1024,7 @@ SEE ALSO
         #
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.edit(_self._COb,str(selection1),str(selection2),
                               str(selection3),str(selection4),
                               int(pkresi),int(pkbond),int(quiet))
@@ -1036,11 +1036,11 @@ SEE ALSO
     def get_editor_scheme(_self=cmd):
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.get_editor_scheme(_self._COb)
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def torsion(angle,_self=cmd):
@@ -1066,11 +1066,11 @@ SEE ALSO
     '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.torsion(_self._COb,float(angle))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def h_fill(quiet=1, _self=cmd):
@@ -1098,11 +1098,11 @@ SEE ALSO
     '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.h_fill(_self._COb,int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def h_fix(selection="",quiet=1,_self=cmd):
@@ -1118,11 +1118,11 @@ DESCRIPTION
 
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.h_fix(_self._COb,str(selection),int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
 
@@ -1154,15 +1154,15 @@ SEE ALSO
     '''
         # preprocess selection
         selection = selector.process(selection)
-        #   
+        #
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.h_add(_self._COb,selection,int(quiet),
                     int(state) - 1, int(legacy))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
 
@@ -1194,11 +1194,11 @@ SEE ALSO
             r = _cmd.sort(_self._COb,str(object))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
 
-    def replace(element, geometry, valence, h_fill=1, name="", 
+    def replace(element, geometry, valence, h_fill=1, name="",
 		quiet=1, _self=cmd):
         '''
 DESCRIPTION
@@ -1222,8 +1222,8 @@ SEE ALSO
 
     remove, attach, fuse, bond, unbond
     '''
-        r = DEFAULT_ERROR      
-        if not "pk1" in _self.get_names("selections"):
+        r = DEFAULT_ERROR
+        if "pk1" not in _self.get_names("selections"):
             print(" Error: you must first pick an atom to replace.")
             raise pymol.CmdException
         try:
@@ -1233,7 +1233,7 @@ SEE ALSO
             r = _cmd.replace(_self._COb,str(element),int(geometry),int(valence),str(name),quiet)
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def rename(selection="all", force=0, quiet=1, _self=cmd):
@@ -1254,14 +1254,14 @@ SEE ALSO
 
     alter
     '''
-        r = DEFAULT_ERROR   
+        r = DEFAULT_ERROR
         selection = "("+selector.process(selection)+")"
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.rename(_self._COb,str(selection),int(force),int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def dss(selection="(all)", state=0, context=None, preserve=0,
@@ -1320,7 +1320,7 @@ PYMOL API
         # preprocess selections
         selection = selector.process(selection)
         r = DEFAULT_ERROR
-        if context==None:
+        if context is None:
             context = ""
         else:
             context = selector.process(context)
@@ -1330,8 +1330,8 @@ PYMOL API
             r = _cmd.dss(_self._COb,str(selection),int(state)-1,str(context),
                             int(preserve),int(quiet))
         finally:
-            _self.unlock(r,_self)   
-        if _self._raising(r,_self): raise pymol.CmdException            
+            _self.unlock(r,_self)
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def alter(selection, expression, quiet=1, space=None, _self=cmd):
@@ -1379,7 +1379,7 @@ SEE ALSO
         if not expression:
             raise pymol.CmdException('missing expression')
 
-        if space == None:
+        if space is None:
             space = _self._pymol.__dict__
         r = DEFAULT_ERROR
         # preprocess selections
@@ -1389,7 +1389,7 @@ SEE ALSO
             _self.lock(_self)
             r = _cmd.alter(_self._COb,"("+str(selection)+")",str(expression),0,int(quiet),dict(space))
         finally:
-            _self.unlock(r,_self)   
+            _self.unlock(r,_self)
         if _self._raising(r,_self): raise pymol.CmdException
         return r
 
@@ -1401,14 +1401,14 @@ DESCRIPTION
     
         '''
         #
-        if space == None:
+        if space is None:
             space = _self._pymol.__dict__
         try:
             _self.lock(_self)
             r = _cmd.alter_list(_self._COb,str(object),list(expr_list),int(quiet),dict(space))
         finally:
-            _self.unlock(r,_self)   
-        if _self._raising(r,_self): raise pymol.CmdException            
+            _self.unlock(r,_self)
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
 
@@ -1447,7 +1447,7 @@ SEE ALSO
         if not expression:
             raise pymol.CmdException('missing expression')
 
-        if space == None:
+        if space is None:
             space = _self._pymol.__dict__
         r = DEFAULT_ERROR
         # preprocess selection
@@ -1457,8 +1457,8 @@ SEE ALSO
             _self.lock(_self)
             r = _cmd.alter(_self._COb,"("+str(selection)+")",str(expression),1,int(quiet),dict(space))
         finally:
-            _self.unlock(r,_self)   
-        if _self._raising(r,_self): raise pymol.CmdException            
+            _self.unlock(r,_self)
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def alter_state(state, selection, expression, quiet=1,
@@ -1495,7 +1495,7 @@ SEE ALSO
         if not expression:
             raise pymol.CmdException('missing expression')
 
-        if space == None:
+        if space is None:
             space = _self._pymol.__dict__
         r = DEFAULT_ERROR
         # preprocess selection
@@ -1509,11 +1509,11 @@ SEE ALSO
                                  str(expression),
                                  0,int(atomic),int(quiet),dict(space))
         finally:
-            _self.unlock(r,_self)   
-        if _self._raising(r,_self): raise pymol.CmdException            
+            _self.unlock(r,_self)
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
-    def iterate_state(state, selection, expression, quiet=1, 
+    def iterate_state(state, selection, expression, quiet=1,
                       space=None, atomic=1, _self=cmd):
 
         '''
@@ -1539,7 +1539,7 @@ SEE ALSO
             raise pymol.CmdException('missing expression')
 
         r = DEFAULT_ERROR
-        if space == None:
+        if space is None:
             space = _self._pymol.__dict__
         # preprocess selection
         selection = selector.process(selection)
@@ -1551,11 +1551,11 @@ SEE ALSO
                                         str(expression),1,int(atomic),
                                         int(quiet),dict(space))
         finally:
-            _self.unlock(r,_self)   
-        if _self._raising(r,_self): raise pymol.CmdException            
+            _self.unlock(r,_self)
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
-    def translate(vector=[0.0,0.0,0.0], selection="all", state=-1, 
+    def translate(vector=[0.0,0.0,0.0], selection="all", state=-1,
                   camera=1, object=None, object_mode=0, _self=cmd):
 
         '''
@@ -1632,7 +1632,7 @@ NOTES
                 shift = cpv.transform(mat,vector)
             else:
                 shift = vector
-            if object==None:
+            if object is None:
                 ttt = [1.0,0.0,0.0,shift[0],
                          0.0,1.0,0.0,shift[1],
                          0.0,0.0,1.0,shift[2],
@@ -1658,12 +1658,12 @@ NOTES
                     _self.unlock(r,_self)
             else:
                 print(" Error: translate: unrecognized object_mode")
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
-    def rotate(axis='x', angle=0.0, selection="all", state=-1, camera=1, 
+    def rotate(axis='x', angle=0.0, selection="all", state=-1, camera=1,
                object=None, origin=None, object_mode=0, _self=cmd):
-        
+
         '''
 DESCRIPTION
 
@@ -1740,7 +1740,7 @@ PYMOL API
             axis = [float(axis[0]),float(axis[1]),float(axis[2])]
             angle = math.pi*float(angle)/180.0
             view = _self.get_view(0)
-            if origin!=None:
+            if origin is not None:
                 have_origin = 1
                 if _self.is_string(origin):
                     if ',' in origin:
@@ -1759,8 +1759,8 @@ PYMOL API
                 vmat = [ view[0:3],view[3:6],view[6:9] ]
                 axis = cpv.transform(vmat,axis)
             mat = cpv.rotation_matrix(angle,axis)
-            if object==None:
-                ttt = [mat[0][0],mat[0][1],mat[0][2],origin[0],                   
+            if object is None:
+                ttt = [mat[0][0],mat[0][1],mat[0][2],origin[0],
                        mat[1][0],mat[1][1],mat[1][2],origin[1],
                        mat[2][0],mat[2][1],mat[2][2],origin[2],
                        -origin[0],-origin[1],-origin[2], 1.0]
@@ -1781,10 +1781,10 @@ PYMOL API
                 if not is_sequence(origin):
                     print(" Error: rotate: unknown object '%s'."%object)
                     if _self._raising(r,_self):
-                        raise pymol.CmdException                                
+                        raise pymol.CmdException
             elif object_mode==1:
-                
-                matrix = [mat[0][0],mat[0][1],mat[0][2], origin[0],     
+
+                matrix = [mat[0][0],mat[0][1],mat[0][2], origin[0],
                           mat[1][0],mat[1][1],mat[1][2], origin[1],
                           mat[2][0],mat[2][1],mat[2][2], origin[2],
                           -origin[0],-origin[1],-origin[2], 1.0]
@@ -1794,10 +1794,10 @@ PYMOL API
                                                       list(matrix),0,'',0)
                 finally:
                     _self.unlock(r,_self)
-                
+
             else:
                 print(" Error: rotate: unrecognized object_mode")
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
 
@@ -1826,7 +1826,7 @@ PYMOL API
         finally:
             _self.unlock(r,_self)
 
-    def set_object_ttt(object, ttt, state=0, quiet=1, homogenous=0, 
+    def set_object_ttt(object, ttt, state=0, quiet=1, homogenous=0,
                        _self=cmd):
         '''
 DESCRIPTION
@@ -1872,15 +1872,15 @@ SEE ALSO
 				    (float(ttt[ 0]),
 				     float(ttt[ 1]),
 				     float(ttt[ 2]),
-				     float(ttt[ 3]),            
+				     float(ttt[ 3]),
 				     float(ttt[ 4]),
 				     float(ttt[ 5]),
 				     float(ttt[ 6]),
-				     float(ttt[ 7]),            
+				     float(ttt[ 7]),
 				     float(ttt[ 8]),
 				     float(ttt[ 9]),
 				     float(ttt[10]),
-				     float(ttt[11]),            
+				     float(ttt[11]),
 				     float(ttt[12]),
 				     float(ttt[13]),
 				     float(ttt[14]),
@@ -1888,10 +1888,10 @@ SEE ALSO
 				    int(state)-1,int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
-    def transform_selection(selection, matrix, state=-1, log=0, 
+    def transform_selection(selection, matrix, state=-1, log=0,
                             homogenous=0, transpose=0, _self=cmd):
         '''
 
@@ -1948,7 +1948,7 @@ NOTES
                                                   list(matrix),int(log),int(homogenous))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def transform_object(name, matrix, state=-1, log=0, selection='',
@@ -2000,7 +2000,7 @@ SEE ALSO
                                               int(homogenous))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def matrix_copy(source_name='', target_name='',
@@ -2028,9 +2028,9 @@ SEE ALSO
 
     matrix_reset, align, fit, pair_fit
 '''
-        
+
         r = DEFAULT_ERROR
-        if source_name == None:
+        if source_name is None:
             source_name = ''
         target_name = str(target_name).strip()
         source_name = str(source_name).strip()
@@ -2039,17 +2039,17 @@ SEE ALSO
             view = _self.get_view()
             new_view = (
                 mat[ 0]*view[ 0] + mat[ 4]*view[ 3] + mat[ 8]*view[ 6],
-                mat[ 0]*view[ 1] + mat[ 4]*view[ 4] + mat[ 8]*view[ 7],  
+                mat[ 0]*view[ 1] + mat[ 4]*view[ 4] + mat[ 8]*view[ 7],
                 mat[ 0]*view[ 2] + mat[ 4]*view[ 5] + mat[ 8]*view[ 8],
                 mat[ 1]*view[ 0] + mat[ 5]*view[ 3] + mat[ 9]*view[ 6],
-                mat[ 1]*view[ 1] + mat[ 5]*view[ 4] + mat[ 9]*view[ 7],  
+                mat[ 1]*view[ 1] + mat[ 5]*view[ 4] + mat[ 9]*view[ 7],
                 mat[ 1]*view[ 2] + mat[ 5]*view[ 5] + mat[ 9]*view[ 8],
                 mat[ 2]*view[ 0] + mat[ 6]*view[ 3] + mat[10]*view[ 6],
-                mat[ 2]*view[ 1] + mat[ 6]*view[ 4] + mat[10]*view[ 7],  
+                mat[ 2]*view[ 1] + mat[ 6]*view[ 4] + mat[10]*view[ 7],
                 mat[ 2]*view[ 2] + mat[ 6]*view[ 5] + mat[10]*view[ 8],
                 view[ 9] ,         view[10] ,         view[11],
                 mat[ 0]*view[12] + mat[ 1]*view[13] + mat[ 2]*view[14] -
-                mat[ 0]* mat[ 3] - mat[ 4]* mat[ 7] - mat[ 8]* mat[11], 
+                mat[ 0]* mat[ 3] - mat[ 4]* mat[ 7] - mat[ 8]* mat[11],
                 mat[ 4]*view[12] + mat[ 5]*view[13] + mat[ 6]*view[14] -
                 mat[ 1]* mat[ 3] - mat[ 5]* mat[ 7] - mat[ 9]* mat[11],
                 mat[ 8]*view[12] + mat[ 9]*view[13] + mat[10]*view[14] -
@@ -2071,7 +2071,7 @@ SEE ALSO
             finally:
                 _self.unlock(r,_self)
             if _self._raising(r,_self):
-                raise pymol.CmdException            
+                raise pymol.CmdException
         return r
 
     def matrix_reset(name, state=1, mode=-1, log=0, quiet=1,_self=cmd):
@@ -2101,7 +2101,7 @@ SEE ALSO
     matrix_copy, align, super, fit, pair_fit
     
 '''
-        
+
         r = DEFAULT_ERROR
         try:
             _self.lock(_self)
@@ -2113,10 +2113,10 @@ SEE ALSO
         finally:
             _self.unlock(r,_self)
         if _self._raising(r,_self):
-            raise pymol.CmdException            
+            raise pymol.CmdException
         return r
 
-        
+
     def translate_atom(sele1, v0, v1, v2, state=0, mode=0,
                        log=0, _self=cmd):
 
@@ -2128,10 +2128,10 @@ SEE ALSO
                                             float(v2),int(state)-1,int(mode),int(log))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
-    def update(target, source, target_state=0, source_state=0, 
+    def update(target, source, target_state=0, source_state=0,
                matchmaker=1, quiet=1, _self=cmd):
 
         '''
@@ -2163,14 +2163,14 @@ SEE ALSO
         b = selector.process(b)
         #
         if a[0]!='(': a="("+str(a)+")"
-        if b[0]!='(': b="("+str(b)+")"   
+        if b[0]!='(': b="("+str(b)+")"
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.update(_self._COb,str(a),str(b),int(target_state)-1,
                                  int(source_state)-1,int(matchmaker),int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
 
@@ -2202,7 +2202,7 @@ PYMOL API
         atom2 = selector.process(atom2)
         atom3 = selector.process(atom3)
         atom4 = selector.process(atom4)
-        #   
+        #
         r = DEFAULT_ERROR
         try:
             _self.lock(_self)
@@ -2210,7 +2210,7 @@ PYMOL API
                                     float(angle),int(state)-1,int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     map_op_dict = {
@@ -2222,10 +2222,10 @@ PYMOL API
         'copy'          : 5,
         'unique'        : 6,
         }
-    
+
     map_op_sc = Shortcut(map_op_dict.keys())
 
-    def map_set(name, operator, operands='', target_state=0, 
+    def map_set(name, operator, operands='', target_state=0,
                 source_state=0, zoom=0, quiet=1, _self=cmd):
 
         '''
@@ -2263,9 +2263,9 @@ SEE ALSO
                          int(target_state)-1, int(source_state)-1, int(zoom), int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
-            
+
     def map_set_border(name, level=0.0, state=0, _self=cmd):
 
         '''
@@ -2292,7 +2292,7 @@ SEE ALSO
             r = _cmd.map_set_border(_self._COb,str(name),float(level),int(state))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def map_double(name, state=0, _self=cmd):
@@ -2316,7 +2316,7 @@ USAGE
             r = _cmd.map_double(_self._COb,str(name),int(state)-1)
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def map_halve(name, state=0, smooth=1, _self=cmd):
@@ -2346,7 +2346,7 @@ SEE ALSO
             r = _cmd.map_halve(_self._COb,str(name),int(state)-1,int(smooth))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def map_trim(name, selection, buffer=0.0, map_state=0, sele_state=0, quiet=1, _self=cmd):
@@ -2357,11 +2357,11 @@ DESCRIPTION
     reducing the extent of a map to cover just a single selection of atoms.
 
     '''
-        
+
         r = DEFAULT_ERROR
         # preprocess selection
         selection = selector.process(selection)
-        #   
+        #
         try:
             _self.lock(_self)
             r = _cmd.map_trim(_self._COb,str(name),str(selection),
@@ -2369,10 +2369,10 @@ DESCRIPTION
                                   int(sele_state)-1,int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
-    
+
     def protect(selection="(all)", quiet=1, _self=cmd):
         '''
 DESCRIPTION
@@ -2397,13 +2397,13 @@ SEE ALSO
         r = DEFAULT_ERROR
         # preprocess selection
         selection = selector.process(selection)
-        #   
+        #
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.protect(_self._COb,"("+str(selection)+")",1,int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def deprotect(selection="(all)", quiet=1, _self=cmd):
@@ -2427,24 +2427,24 @@ SEE ALSO
         r = DEFAULT_ERROR
         # preprocess selection
         selection = selector.process(selection)
-        #   
+        #
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.protect(_self._COb,"("+str(selection)+")",0,int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     flag_dict = {
-    # simulation 
+    # simulation
         'focus'         : 0,
         'free'          : 1,
         'restrain'      : 2,
         'fix'           : 3,
         'exclude'       : 4,
         'study'         : 5,
-        
+
     # rendering
         'exfoliate'     : 24,
         'ignore'        : 25,
@@ -2473,13 +2473,13 @@ DESCRIPTION
         selection1 = selector.process(selection1)
         selection2 = selector.process(selection2)
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.fix_chemistry(_self._COb,"("+str(selection1)+")",
 				   "("+str(selection2)+")",int(invalidate),
 				   int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def set_object_color(name, color, quiet=1, _self=cmd):
@@ -2488,10 +2488,10 @@ DESCRIPTION
             _self.lock(_self)
             r = _cmd.set_object_color(_self._COb,str(name),str(color),int(quiet))
         finally:
-            _self.unlock(r,_self)      
+            _self.unlock(r,_self)
         if _raising(r,_self): raise pymol.CmdException
         return r
-    
+
     def flag(flag, selection, action="reset", quiet=1, _self=cmd):
         '''
 DESCRIPTION
@@ -2568,14 +2568,14 @@ PYMOL API
         # preprocess selection
         selection = selector.process(selection)
         action = flag_action_dict[flag_action_sc.auto_err(action,'action')]
-        #      
+        #
         try:
             _self.lock(_self)
             r = _cmd.flag(_self._COb,int(flag),"("+str(selection)+")",
                               int(action),int(quiet))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException            
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def vdw_fit(selection1, selection2, state1=1,state2=1,buffer=0.24,quiet=1,_self=cmd):
diff -upNr pymol-open-source-2.3.0/modules/pymol/editor.py pymol-open-source-2.3.3/modules/pymol/editor.py
--- pymol-open-source-2.3.0/modules/pymol/editor.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/editor.py	2019-08-22 10:24:47.842615885 +0200
@@ -49,7 +49,7 @@ ARGUMENTS
 
     anchor = int: none-hydrogen atom ID in fragment to fuse
     '''
-    if not selection in _self.get_names("selections"):
+    if selection not in _self.get_names("selections"):
         if fragment in _self.get_names("objects"):
             print(" Error: an object with than name already exists")
             raise QuietException
@@ -62,12 +62,12 @@ ARGUMENTS
         if _self.count_atoms("((%s) and elem H)"%selection,quiet=1):
             _self.fuse("(%s and id %d)"%(tmp_editor,hydrogen),"(pk1)",1)
             if _self.get_setting_boolean("auto_remove_hydrogens"):
-                _self.remove("(hydro and pkmol)")            
+                _self.remove("(hydro and pkmol)")
         else:
             _self.remove("(%s and id %d)"%(tmp_editor,hydrogen))
             _self.fuse("(%s and id %d)"%(tmp_editor,anchor),"(pk1)",1)
             if _self.get_setting_boolean("auto_remove_hydrogens"):
-                _self.remove("(hydro and pkmol)")            
+                _self.remove("(hydro and pkmol)")
             elif _self.count_atoms('hydro and (neighbor pk2)'):
                 _self.h_fill()
         _self.delete(tmp_editor)
@@ -82,14 +82,6 @@ def combine_fragment(selection,fragment,
         finally:
             _self.delete(tmp_editor)
 
-#from time import time as ___time
-#___total = 0.0
-#___seg1 = 0.0
-#___seg2 = 0.0
-#___seg3 = 0.0
-#___pass = 0
-#___last = ___time()
-
 def attach_amino_acid(selection,amino_acid,center=0,animate=-1,object="",hydro=-1,ss=-1,_self=cmd):
     '''
 ARGUMENTS
@@ -108,11 +100,6 @@ ARGUMENTS
 
     ss = int: Secondary structure 1=alpha helix, 2=antiparallel beta, 3=parallel beta, 4=flat
     '''
-#    global ___total, ___seg1, ___seg2, ___seg3, ___pass, ___last
-#    ___mark0 = ___time()
-#    ___mark1 = ___time()
-#    ___mark2 = ___time()
-#    ___entry = ___time()
     r = DEFAULT_SUCCESS
     ss = int(ss)
     center = int(center)
@@ -124,7 +111,7 @@ ARGUMENTS
             else _self.count_atoms(selection) == 0):
         if object == "":
             object = amino_acid
-        # create new object 
+        # create new object
         if amino_acid in _self.get_names("objects"):
             print("Error: an object with than name already exists")
             raise QuietException
@@ -181,7 +168,7 @@ ARGUMENTS
 
                 if ((_self.select(tmp3,"(name CA,CH3 & nbr. ?pk1)",domain=tmp_domain)==1) and
                     (_self.select(tmp4,"(name CA,CH3 & nbr. ?pk2)",domain=tmp_domain)==1)):
-                    _self.set_dihedral(tmp4,tmp2,tmp1,tmp3,180.0) 
+                    _self.set_dihedral(tmp4,tmp2,tmp1,tmp3,180.0)
 
                 if hydro:
                     _self.h_fix(tmp2) # fix hydrogen position
@@ -196,7 +183,7 @@ ARGUMENTS
                                           domain=tmp_domain)==1)):
                             _self.set_dihedral( # PHI
                                 tmp4, # C
-                                tmp3, # CA 
+                                tmp3, # CA
                                 tmp2, # N
                                 tmp1, # C
                                 phi)
@@ -226,15 +213,14 @@ ARGUMENTS
             _self.select(tmp_domain, "byresi (pk1 | pk2)")
 
             if not hydro:
-                _self.remove("(pkmol and hydro)") 
+                _self.remove("(pkmol and hydro)")
 
             if (( _self.select(tmp1,"?pk1",domain=tmp_domain)==1) and
                 ( _self.select(tmp2,"?pk2",domain=tmp_domain)==1)):
 
-#                ___mark1 = ___time()
                 if ((_self.select(tmp3,"(name CA,CH3 & nbr. ?pk1)",domain=tmp_domain)==1) and
                     (_self.select(tmp4,"(name CA,CH3 & nbr. ?pk2)",domain=tmp_domain)==1)):
-                    _self.set_dihedral(tmp4,tmp2,tmp1,tmp3,180.0) 
+                    _self.set_dihedral(tmp4,tmp2,tmp1,tmp3,180.0)
                 if hydro:
                     _self.h_fix("pk1") # fix hydrogen position
                 if ss:
@@ -253,7 +239,7 @@ ARGUMENTS
                             _self.set_dihedral( # PHI
                                 tmp2, # C
                                 tmp1, # N
-                                tmp3, # CA 
+                                tmp3, # CA
                                 tmp4, # C
                                 phi)
                     if ((_self.select(tmp3,"(name CA & nbr. "+tmp2+")",domain=tmp_domain)==1) and
@@ -264,7 +250,6 @@ ARGUMENTS
                             tmp2, # C
                             tmp1, # N
                             psi)
-#            ___mark2 = ___time()
             sele = ("(name C & (byres nbr. %s) & !(byres %s))"% (tmp_connect,tmp_connect))
             if _self.select(tmp1,sele,domain=tmp_domain):
                 _self.edit(tmp1)
@@ -275,24 +260,13 @@ ARGUMENTS
         elif _self.count_atoms("((%s) and elem H)"%selection):
             print("Error: please pick a nitrogen or carbonyl carbon to grow from.")
             _self.delete(tmp_wild)
-            raise QuietException            
+            raise QuietException
         else:
             print("Error: unable to attach fragment.")
             _self.delete(tmp_wild)
             raise QuietException
     _self.delete(tmp_wild)
 
-#    ___exit = ___time()
-#    ___seg1 = ___seg1 + ___mark1 - ___entry
-#    ___seg2 = ___seg2 + ___mark2 - ___mark1
-#    ___seg3 = ___seg3 + ___exit  - ___mark2
-#    ___total = ___total + ___exit - ___entry
-#    ___pass = ___pass + 1
-#    print "%0.3f %0.3f %0.3f / %0.3f + %0.3f + %0.3f = %0.3f vs %0.3f"%(___seg1/___total,___seg2/___total,___seg3/___total,
-#                                                          ___seg1/___pass, ___seg2/___pass, ___seg3/___pass,
-#                                                          ___total/___pass, (___time()-___last) - (___exit - ___entry))
-#    ___last = ___time()
-
     return r
 
 _aa_codes =  {
@@ -337,7 +311,7 @@ def _fab(input,name,mode,resi,chain,segi
 
     if hydro < 0:
         hydro = not _self.get_setting_boolean("auto_remove_hydrogens")
-    
+
     seq_len = 0
     if (mode == 'peptide') and is_string(input):
         # '123/ ADC B/234/ AFCD' to [ '123/','A','D','C','B/234/','F','C','D' ]
@@ -350,21 +324,17 @@ def _fab(input,name,mode,resi,chain,segi
                 seq_len = seq_len + len(frag)
                 input.extend(list(frag))
                 input.append("/") # breaks chain
-    if name == None:
+    if name is None:
         name = _self.get_unused_name("obj")
     elif name in _self.get_names():
         _self.delete(name)
 
-#    if mode in [ 'smiles' ]: # small molecule (FUTURE)
-#        from chempy.champ import Champ
-#        ch = Champ()
-#        ch.insert_pattern_string(input)
     if mode in [ 'peptide' ]:  # polymers
         if (seq_len>99) and not quiet:
             print(" Generating a %d residue peptide from sequence..."%seq_len)
         input.reverse()
         sequence = input
-        if code != None:
+        if code is not None:
             while len(sequence):
                 while len(sequence) and '/' in sequence[-1]:
                     part = sequence.pop().split('/')
@@ -455,4 +425,3 @@ EXAMPLE
 def build_peptide(sequence,_self=cmd): # legacy
     for aa in sequence:
         attach_amino_acid("pk1",_aa_codes[aa])
-        
diff -upNr pymol-open-source-2.3.0/modules/pymol/experimenting.py pymol-open-source-2.3.3/modules/pymol/experimenting.py
--- pymol-open-source-2.3.0/modules/pymol/experimenting.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/experimenting.py	2019-08-22 10:24:47.842615885 +0200
@@ -1,27 +1,27 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
 if True:
-    
+
     from . import selector
     from .cmd import _cmd,lock,unlock,Shortcut,QuietException, \
-          DEFAULT_ERROR, DEFAULT_SUCCESS, _raising, is_ok, is_error        
+          DEFAULT_ERROR, DEFAULT_SUCCESS, _raising, is_ok, is_error
     cmd = __import__("sys").modules["pymol.cmd"]
     import threading
     import pymol
     import string
-    
+
     def get_bond_print(obj,max_bond,max_type,_self=cmd):
         r = DEFAULT_ERROR
         try:
@@ -29,7 +29,7 @@ if True:
             r = _cmd.get_bond_print(_self._COb,str(obj),int(max_bond),int(max_type))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException                  
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def spheroid(object="",average=0,_self=cmd):  # EXPERIMENTAL
@@ -54,7 +54,7 @@ USAGE
             r = _cmd.spheroid(_self._COb,str(object),int(average))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException                  
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def mem(_self=cmd):
@@ -71,7 +71,7 @@ DESCRIPTION
             r = _cmd.mem(_self._COb)
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException                  
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
 
@@ -83,17 +83,17 @@ DESCRIPTION
     to do with assigning forcefield parameters to a selection of
     atoms.
     
-'''        
+'''
         # This function relies on code that is not currently part of PyMOL/ChemPy
         # NOTE: the realtime module relies on code that is not yet part of PyMOL/ChemPy
         from chempy.tinker import realtime
-        if selection==None:
+        if selection is None:
             arg = cmd.get_names("objects")
             arg = arg[0:1]
             if arg:
                 if len(arg):
                     selection = arg
-        if selection!=None:
+        if selection is not None:
             selection = selector.process(selection)
             realtime.assign("("+selection+")",int(preserve))
             realtime.setup("("+selection+")")
@@ -106,7 +106,7 @@ DESCRIPTION
     eventually have something to do with doing a quick clean up of the
     molecular structure.
     
-'''        
+'''
         kwargs['_setup'] = 0
         return minimize(*args, **kwargs)
 
@@ -117,8 +117,8 @@ DESCRIPTION
     "fast_minimize" is an unsupported nonfunctional command that may
     eventually have something to do with minimization.
     
-'''        
-        from chempy.tinker import realtime  
+'''
+        from chempy.tinker import realtime
 
         if not sele:
             names = _self.get_names("objects")
@@ -147,7 +147,7 @@ DESCRIPTION
             r = _cmd.dump(_self._COb,str(fnam),obj)
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException                  
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
 
@@ -163,21 +163,21 @@ DESCRIPTION
     '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r=_cmd.test(_self._COb,int(group),int(index))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException                  
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def import_coords(coords,name,state,_self=cmd): # experimental
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.import_coords(_self._COb,str(name),int(state)-1,coords)
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException                  
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def load_coords(model, oname, state=1): # UNSUPPORTED
diff -upNr pymol-open-source-2.3.0/modules/pymol/exporting.py pymol-open-source-2.3.3/modules/pymol/exporting.py
--- pymol-open-source-2.3.0/modules/pymol/exporting.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/exporting.py	2019-08-22 10:24:47.842615885 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -24,7 +24,7 @@ if True:
     from . import selector
     import re
     import copy
-    
+
     import pymol
     cmd = sys.modules["pymol.cmd"]
     from .cmd import _cmd,lock,unlock,Shortcut,QuietException
@@ -42,7 +42,7 @@ if True:
             r = _self._copy_image(_self,int(quiet))
         else:
             r = _self.do('cmd._copy_image(quiet=%d)'%int(quiet))
-        if _self._raising(r,_self): raise QuietException         
+        if _self._raising(r,_self): raise QuietException
         return r
 
     cache_action_dict = {
@@ -91,7 +91,7 @@ PYMOL API
     cmd.cache(string action, string scenes, int state, int quiet)
 
     '''
-        
+
         r = DEFAULT_ERROR
         action = cache_action_dict[cache_action_sc.auto_err(str(action),'action')]
         quiet = int(quiet)
@@ -110,7 +110,7 @@ PYMOL API
             cache_max = int(_self.get('cache_max'))
             if cache_max>0:
                 # allow double memory for an optimized cache
-                _self.set('cache_max',cache_max*2) 
+                _self.set('cache_max',cache_max*2)
             scenes = str(scenes)
             scene_list = scenes.split()
             cache_mode = int(_self.get('cache_mode'))
@@ -141,13 +141,13 @@ PYMOL API
             else:
                 _self.set('cache_mode',2) # hmm... could use 1 here instead.
             _self.set('cache_max',cache_max) # restore previous limits
-            if not quiet:            
+            if not quiet:
                 print(" cache: optimization complete (~%0.1f MB)."%(usage*4/1000000.0))
         try:
             _self.lock(_self)
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise QuietException         
+        if _self._raising(r,_self): raise QuietException
         return r
 
     _resn_to_aa =  {
@@ -182,7 +182,7 @@ PYMOL API
             'DG'  : 'G',
             'DC'  : 'C',
             }
-    
+
     def get_fastastr(selection="all", state=-1, quiet=1, key='', _self=cmd):
         '''
 DESCRIPTION
@@ -273,7 +273,7 @@ NOTES
         else:
             result = str(obj)
         return result
-    
+
     def _session_convert_legacy(session, version, _self=cmd):
         '''
         Convert session contents to be compatible with previous PyMOL versions
@@ -424,7 +424,7 @@ NOTES
                 if ((cache_mode > 0) and (cache_opt != 0)) or (cache_opt==1):
                     _self.cache('optimize')
         for a in _self._pymol._session_save_tasks:
-            if a==None:
+            if a is None:
                 try:
                     _self.lock(_self)
                     r = _cmd.get_session(_self._COb,session,str(names),
@@ -467,9 +467,9 @@ NOTES
                 session = zlib.compress(cPickle.dumps(session, 1))
             return session
         elif _self._raising(r,_self):
-            raise QuietException                  
+            raise QuietException
         return r
-        
+
     def _unit2px(value, dpi, unit=''):
         '''API only. Returns pixel units given a string representation in other units'''
         if cmd.is_string(value):
@@ -542,10 +542,10 @@ PYMOL API
         if format == 'png':
             format = 0
 
-        if prior: 
+        if prior:
             # fetch the prior image, without doing any work (fast-path / non-GLUT thread-safe)
             r = _self._png(str(filename),0,0,float(dpi),0,int(quiet),1,
-                           int(format),_self)            
+                           int(format),_self)
             if r != 1: # no prior image available -- revert to default behavior
                 if prior < 0: # default is to fall back to actual rendering
                     prior = 0
@@ -569,7 +569,7 @@ PYMOL API
     def export_coords(obj,state,_self=cmd): # experimental
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.export_coords(_self._COb,str(obj),int(state)-1)
         finally:
             _self.unlock(r,_self)
@@ -577,7 +577,7 @@ PYMOL API
         return r
 
     def multisave(filename, pattern="all", state=-1,
-                  append=0, format='', quiet=1, _self=cmd): 
+                  append=0, format='', quiet=1, _self=cmd):
         '''
 DESCRIPTION
 
@@ -651,6 +651,8 @@ DESCRIPTION
         '''
         assert format not in ('mmtf',), 'binary format, use get_bytes'
         b = get_bytes(format, selection, state, ref, ref_state, multi, quiet, _self)
+        if b is None:
+            return None
         return b.decode('utf-8')
 
     def get_bytes(format, selection='(all)', state=-1, ref='',
@@ -807,7 +809,7 @@ SEE ALSO
 
         # preprocess selection
         selection = selector.process(selection)
-        #   
+        #
         r = DEFAULT_ERROR
 
         # analyze filename
@@ -895,7 +897,7 @@ SEE ALSO
             with fopen(filename, 'wb') as handle:
                 handle.write(contents)
             r = DEFAULT_SUCCESS
-            
+
         if _self._raising(r,_self): raise QuietException
 
         if not quiet:
@@ -983,4 +985,5 @@ SEE ALSO
         'idtf': 'pymol.querying:get_idtf',
         'mtl': _get_mtl_obj, # TODO not implemented
         'obj': _get_mtl_obj,
+        'stl': 'pymol.lazyio:get_stlstr',
     }
diff -upNr pymol-open-source-2.3.0/modules/pymol/externing.py pymol-open-source-2.3.3/modules/pymol/externing.py
--- pymol-open-source-2.3.0/modules/pymol/externing.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/externing.py	2019-08-22 10:24:47.842615885 +0200
@@ -1,21 +1,21 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
 from __future__ import print_function
 
 if True:
-    
+
     import os
     import pymol
     import string
@@ -23,11 +23,11 @@ if True:
     import threading
     cmd = __import__("sys").modules["pymol.cmd"]
     import traceback
-    
+
     from glob import glob
     from .cmd import _cmd,lock,unlock,Shortcut,QuietException, \
           _feedback,fb_module,fb_mask, exp_path, \
-          DEFAULT_ERROR, DEFAULT_SUCCESS, _raising, is_ok, is_error        
+          DEFAULT_ERROR, DEFAULT_SUCCESS, _raising, is_ok, is_error
 
     try:
         from os import getcwdu
@@ -95,7 +95,7 @@ SEE ALSO
 
     cd, pwd, system   
         '''
-        if pattern==None:
+        if pattern is None:
             pattern = u"*"
         else:
             pattern = exp_path(pattern)
@@ -176,5 +176,4 @@ SEE ALSO
                         new_lst.append(a)
             r = _cmd.paste(_self._COb,new_lst)
         if _raising(r,_self): raise pymol.CmdException
-        return r 
-
+        return r
diff -upNr pymol-open-source-2.3.0/modules/pymol/feedingback.py pymol-open-source-2.3.3/modules/pymol/feedingback.py
--- pymol-open-source-2.3.0/modules/pymol/feedingback.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/feedingback.py	2019-08-22 10:24:47.842615885 +0200
@@ -74,7 +74,7 @@ EXAMPLES
     feedback enable, main, blather
 
     '''
-    
+
     r = None
 
     # validate action
@@ -85,7 +85,7 @@ EXAMPLES
         act_int = 0
     else:
         act_kee = fb_action_sc.interpret(action)
-        if act_kee == None:
+        if act_kee is None:
             print("Error: invalid feedback action '%s'."%action)
             if _raising(_self=_self):
                 raise QuietException
@@ -126,7 +126,7 @@ EXAMPLES
         mask_lst = mask.split()
         for mask in mask_lst:
             mask_kee = fb_mask_sc.interpret(mask)
-            if mask_kee == None:
+            if mask_kee is None:
                 print("Error: invalid feedback mask '%s'."%mask)
                 if _raising(_self=_self): raise QuietException
                 else: return None
@@ -141,7 +141,7 @@ EXAMPLES
         mod_lst = module.split()
         for module in mod_lst:
             mod_kee = fb_module_sc.interpret(module)
-            if mod_kee == None:
+            if mod_kee is None:
                 print("Error: invalid feedback module '%s'."%module)
                 if _raising(_self=_self): raise QuietException
                 else: return None
diff -upNr pymol-open-source-2.3.0/modules/pymol/fitting.py pymol-open-source-2.3.3/modules/pymol/fitting.py
--- pymol-open-source-2.3.0/modules/pymol/fitting.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/fitting.py	2019-08-22 10:24:47.842615885 +0200
@@ -1,21 +1,21 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
 from __future__ import print_function
 
 if True:
-	
+
         cmd = __import__("sys").modules["pymol.cmd"]
         from .cmd import _cmd,lock,unlock
         from . import selector
@@ -71,7 +71,7 @@ SEE ALSO
                 # handle PyMOL's macro /// notation
                 mobile = selector.process(mobile)
                 target = selector.process(target)
-                                
+
                 # make the lists for holding coordinates and IDs
                 mod1 = _self.get_model(target, state=target_state)
                 mod2 = _self.get_model(mobile, state=mobile_state)
@@ -79,7 +79,7 @@ SEE ALSO
                 sel2 = mod2.get_coord_list()
                 ids1 = [a.id for a in mod1.atom]
                 ids2 = [a.id for a in mod2.atom]
-                
+
                 if len(sel1) < 2 * window:
                         print("CEalign-Error: Your target selection is too short.")
                         raise pymol.CmdException
@@ -94,7 +94,7 @@ SEE ALSO
                         raise pymol.CmdException
 
                 r = DEFAULT_ERROR
-                
+
                 try:
                         _self.lock(_self)
 
@@ -133,7 +133,7 @@ SEE ALSO
                     print(" CEalign-Error: alignment failed")
                 finally:
                         _self.unlock(r,_self)
-                if _self._raising(r,_self): raise pymol.CmdException             
+                if _self._raising(r,_self): raise pymol.CmdException
                 return ( {"alignment_length": aliLen, "RMSD" : RMSD, "rotation_matrix" : rotMat } )
 
         def extra_fit(selection='(all)', reference='', method='align', zoom=1,
@@ -232,17 +232,17 @@ SEE ALSO
                         raise pymol.CmdException('no public objects')
                     selection = '%' + ' %'.join(names)
                 return extra_fit(selection, target, method, 0, quiet, _self, **kwargs)
-                                
+
 
 
         def super(mobile, target, cutoff=2.0, cycles=5,
                           gap=-1.5, extend=-0.7, max_gap=50, object=None,
-                          matrix="BLOSUM62", mobile_state=0, target_state=0, 
+                          matrix="BLOSUM62", mobile_state=0, target_state=0,
                           quiet=1, max_skip=0, transform=1, reset=0,
                           seq=0.0, radius=12.0, scale=17.0, base=0.65,
                           coord=0.0, expect=6.0, window=3, ante=-1.0,
                           _self=cmd):
-                
+
                 '''
 DESCRIPTION
 
@@ -272,7 +272,7 @@ SEE ALSO
                 r = DEFAULT_ERROR
                 mobile = selector.process(mobile)
                 target = selector.process(target)
-                if object==None: object=''
+                if object is None: object=''
                 matrix = str(matrix)
                 if matrix.lower() in ['none', '']:
                         mfile = ''
@@ -283,7 +283,7 @@ SEE ALSO
                 # delete existing alignment object (if asked to reset it)
                 try:
                         _self.lock(_self)
-                        
+
                         r = _cmd.align(_self._COb,mobile,"("+target+")",float(cutoff),
                                                    int(cycles),float(gap),float(extend),int(max_gap),
                                                    str(object),str(mfile),
@@ -293,17 +293,17 @@ SEE ALSO
                                                    float(radius),float(scale),float(base),
                                                    float(coord),float(expect),int(window),
                                                    float(ante))
-                        
+
                 finally:
                         _self.unlock(r,_self)
-                if _self._raising(r,_self): raise pymol.CmdException             
+                if _self._raising(r,_self): raise pymol.CmdException
                 return r
 
         def align(mobile, target, cutoff=2.0, cycles=5, gap=-10.0,
                           extend=-0.5, max_gap=50, object=None,
                           matrix="BLOSUM62", mobile_state=0, target_state=0,
                           quiet=1, max_skip=0, transform=1, reset=0, _self=cmd):
-                
+
                 '''
 DESCRIPTION
 
@@ -374,7 +374,7 @@ SEE ALSO
                         mfile = matrix
                 else:
                         mfile = cmd.exp_path("$PYMOL_DATA/pymol/matrices/"+matrix)
-                if object==None: object=''
+                if object is None: object=''
                 # delete existing alignment object (if asked to reset it)
                 try:
                         _self.lock(_self)
@@ -386,7 +386,7 @@ SEE ALSO
                                                    -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0.0)
                 finally:
                         _self.unlock(r,_self)
-                if _self._raising(r,_self): raise pymol.CmdException             
+                if _self._raising(r,_self): raise pymol.CmdException
                 return r
 
         def intra_fit(selection, state=1, quiet=1, mix=0, _self=cmd):
@@ -426,7 +426,7 @@ SEE ALSO
                 '''
                 # preprocess selection
                 selection = selector.process(selection)
-                #       
+                #
                 r = DEFAULT_ERROR
                 state = int(state)
                 mix = int(mix)
@@ -446,7 +446,7 @@ SEE ALSO
                                         else:
                                                 print(" cmd.intra_fit: %5.3f in state %d vs state %d"%(a,st,state))
                                 st = st + 1
-                if _self._raising(r,_self): raise pymol.CmdException             
+                if _self._raising(r,_self): raise pymol.CmdException
                 return r
 
         def intra_rms(selection, state=0, quiet=1, _self=cmd):
@@ -474,7 +474,7 @@ SEE ALSO
                 '''
                 # preprocess selection
                 selection = selector.process(selection)
-                #       
+                #
                 r = DEFAULT_ERROR
                 state = int(state)
                 try:
@@ -490,7 +490,7 @@ SEE ALSO
                                 if a>=0.0:
                                         print(" cmd.intra_rms: %5.3f in state %d vs state %d"%(a,st,state))
                                 st = st + 1
-                if _self._raising(r,_self): raise pymol.CmdException             
+                if _self._raising(r,_self): raise pymol.CmdException
                 return r
 
         def intra_rms_cur(selection, state=0, quiet=1, _self=cmd):
@@ -517,7 +517,7 @@ SEE ALSO
                 '''
                 # preprocess selection
                 selection = selector.process(selection)
-                #       
+                #
                 r = DEFAULT_ERROR
                 state = int(state)
                 try:
@@ -587,14 +587,14 @@ SEE ALSO
 
 	align, super, pair_fit, rms, rms_cur, intra_fit, intra_rms, intra_rms_cur
             '''
-            r = DEFAULT_ERROR	   
+            r = DEFAULT_ERROR
             a=str(mobile)
             b=str(target)
             # preprocess selections
             a = selector.process(a)
             b = selector.process(b)
             #
-            if object==None: object=''
+            if object is None: object=''
             if int(matchmaker)==0:
                 sele1 = "((%s) in (%s))" % (str(a),str(b))
                 sele2 = "((%s) in (%s))" % (str(b),str(a))
@@ -609,7 +609,8 @@ SEE ALSO
                         int(cycles),str(object))
             finally:
                 _self.unlock(r,_self)
-            if _self._raising(r,_self): raise pymol.CmdException		 
+            if r < -0.5:
+                raise pymol.CmdException
             return r
 
         def rms(mobile, target, mobile_state=0, target_state=0, quiet=1,
@@ -632,14 +633,14 @@ SEE ALSO
 
 	fit, rms_cur, intra_fit, intra_rms, intra_rms_cur, pair_fit	  
             '''
-            r = DEFAULT_ERROR	   
+            r = DEFAULT_ERROR
             a=str(mobile)
             b=str(target)
             # preprocess selections
             a = selector.process(a)
             b = selector.process(b)
             #
-            if object==None: object=''		
+            if object is None: object=''
             if int(matchmaker)==0:
                 sele1 = "((%s) in (%s))" % (str(a),str(b))
                 sele2 = "((%s) in (%s))" % (str(b),str(a))
@@ -647,20 +648,21 @@ SEE ALSO
                 sele1 = str(a)
                 sele2 = str(b)
             try:
-                _self.lock(_self)	
+                _self.lock(_self)
                 r = _cmd.fit(_self._COb,sele1,sele2,1,
                         int(mobile_state)-1,int(target_state)-1,
                         int(quiet),int(matchmaker),float(cutoff),
                         int(cycles),str(object))
             finally:
                 _self.unlock(r,_self)
-            if _self._raising(r,_self): raise pymol.CmdException		 
+            if r < -0.5:
+                raise pymol.CmdException
             return r
 
         def rms_cur(mobile, target, mobile_state=0, target_state=0,
 				quiet=1, matchmaker=0, cutoff=2.0, cycles=0,
 				object=None, _self=cmd):
-		
+
             '''
 DESCRIPTION
 
@@ -675,14 +677,14 @@ SEE ALSO
 
 	fit, rms, intra_fit, intra_rms, intra_rms_cur, pair_fit	  
             '''
-            r = DEFAULT_ERROR	   
+            r = DEFAULT_ERROR
             a=str(mobile)
             b=str(target)
             # preprocess selections
             a = selector.process(a)
             b = selector.process(b)
             #
-            if object==None: object=''			  
+            if object is None: object=''
             if int(matchmaker)==0:
                 sele1 = "((%s) in (%s))" % (str(a),str(b))
                 sele2 = "((%s) in (%s))" % (str(b),str(a))
@@ -697,7 +699,8 @@ SEE ALSO
                         int(cycles),str(object))
             finally:
                 _self.unlock(r,_self)
-            if _self._raising(r,_self): raise pymol.CmdException		 
+            if r < -0.5:
+                raise pymol.CmdException
             return r
 
         def pair_fit(*arg, **kw):
@@ -739,22 +742,17 @@ SEE ALSO
             if kw:
                 raise pymol.CmdException('unexpected keyword arguments: ' + str(list(kw)))
 
-            r = DEFAULT_ERROR	   
+            r = DEFAULT_ERROR
             if len(arg) < 2:
                 raise pymol.CmdException('need at least 2 selection')
             if len(arg) % 2:
                 raise pymol.CmdException('need even number of selections')
             new_arg = list(map(selector.process, arg))
             try:
-                _self.lock(_self)	
+                _self.lock(_self)
                 r = _cmd.fit_pairs(_self._COb,new_arg, quiet)
             finally:
                 _self.unlock(r,_self)
-            if _self._raising(r,_self): raise pymol.CmdException		 
+            if r < -0.5:
+                raise pymol.CmdException
             return r
-
-
-
-
-
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/_gui.py pymol-open-source-2.3.3/modules/pymol/_gui.py
--- pymol-open-source-2.3.0/modules/pymol/_gui.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/_gui.py	2019-08-22 10:24:47.834614582 +0200
@@ -65,7 +65,7 @@ class PyMOLDesktopGUI(object):
         def transparency_menu(setting_name):
             return [
                 ('radio', lab, setting_name, val)
-                for lab, val in [ ('Off', 0.0), ('20%', 0.2), ('40%', 0.4), 
+                for lab, val in [ ('Off', 0.0), ('20%', 0.2), ('40%', 0.4),
                     ('50%', 0.5), ('60%', 0.6), ('80%', 0.8) ]
             ]
 
@@ -674,7 +674,7 @@ class PyMOLDesktopGUI(object):
                 ]),
                 ('menu', 'Transparency', [
                     ('menu', 'Surface', transparency_menu('transparency')),
-                    ('menu', 'Sphere',  transparency_menu('sphere_transparency')),      
+                    ('menu', 'Sphere',  transparency_menu('sphere_transparency')),
                     ('menu', 'Cartoon', transparency_menu('cartoon_transparency')),
                     ('menu', 'Stick',   transparency_menu('stick_transparency')),
                     ('separator',),
@@ -835,7 +835,7 @@ class PyMOLDesktopGUI(object):
                 ('command', 'Measurement', 'wizard measurement'),
                 ('menu', 'Mutagenesis', [
                     ('command', 'Protein', 'wizard mutagenesis'),
-                    ('command', 'Nucleic Acids', 'wizard nucmutagenesis'), 
+                    ('command', 'Nucleic Acids', 'wizard nucmutagenesis'),
                 ]),
                 ('command', 'Pair Fitting', 'wizard pair_fit'),
                 ('separator',),
diff -upNr pymol-open-source-2.3.0/modules/pymol/gui.py pymol-open-source-2.3.3/modules/pymol/gui.py
--- pymol-open-source-2.3.0/modules/pymol/gui.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/gui.py	2019-08-22 10:24:47.842615885 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -39,7 +39,7 @@ def createlegacypmgapp():
     import pymol.plugins.legacysupport as m
     return m.createlegacypmgapp()
 
-# external gui control 
+# external gui control
 
 def ext_hide(_self=cmd):
     qtwindow = get_qtwindow()
@@ -48,11 +48,11 @@ def ext_hide(_self=cmd):
         return
 
     pymol = _self._pymol
-    if pymol._ext_gui != None:
+    if pymol._ext_gui is not None:
         pymol._ext_gui.fifo.put('self.root.withdraw()')
     else:
         pass
-    
+
 def ext_show(_self=cmd):
     qtwindow = get_qtwindow()
     if qtwindow is not None:
@@ -60,7 +60,7 @@ def ext_show(_self=cmd):
         return
 
     pymol = _self._pymol
-    if pymol._ext_gui != None:
+    if pymol._ext_gui is not None:
         pymol._ext_gui.fifo.put('self.root.deiconify()')
     else:
         pass
@@ -74,7 +74,7 @@ def save_as(_self=cmd):
         return
 
     pymol = _self._pymol
-    if pymol._ext_gui != None:
+    if pymol._ext_gui is not None:
         pymol._ext_gui.fifo.put('self.skin.session_save_as()')
     else:
         pass
@@ -86,8 +86,7 @@ def save_image(_self=cmd):
         return
 
     pymol = _self._pymol
-    if pymol._ext_gui != None:
+    if pymol._ext_gui is not None:
         pymol._ext_gui.fifo.put('self.skin.file_save_png()')
     else:
         pass
-    
diff -upNr pymol-open-source-2.3.0/modules/pymol/headering.py pymol-open-source-2.3.3/modules/pymol/headering.py
--- pymol-open-source-2.3.0/modules/pymol/headering.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/headering.py	2019-08-22 10:24:47.842615885 +0200
@@ -64,7 +64,7 @@ class baseHeader:
                 print("Error: Please provide the setting 'default_%s_names' a comma separated string" % (prg))
                 print("       with the values for 2FoFc and FoFc, amplitude and phase names, respectively.")
                 return [None]*3
-                        
+
 
             # defaultF =~ "FWT", "2FOFCFWT", "2FOFCWT_no_fill", "2FOFCWT", "DELFWT", "FOFCWT", ..
             for curFCol in fC:
@@ -75,7 +75,7 @@ class baseHeader:
 
                     ## print "curFCol = %s" % curFCol
                     ## print "curPCol = %s" % curPCol
-                    
+
                     if curPCol in pC:
                         # found perfectly matching columns
                         looksLike = prg
@@ -83,8 +83,8 @@ class baseHeader:
                         PCol = curPCol
                         return (FCol, PCol, looksLike)
         return [None]*3
-                            
-        
+
+
 
 class CNSHeader(baseHeader):
     """
@@ -94,7 +94,7 @@ class CNSHeader(baseHeader):
         ## print "CNSHeader cstr"
         baseHeader.__init__(self,filename)
         self.parseFile()
-    
+
 class CIFHeader(baseHeader):
     """
     mmCIF
@@ -111,9 +111,9 @@ class CIFHeader(baseHeader):
                 inFile.close()
 
                 in_loop = False
-                
+
                 curLine = data.pop(0)
-                while curLine!=None:
+                while curLine is not None:
                     if in_loop:
                         if curLine.startswith("_refln."):
                             self.cols.append(curLine.split(".",1)[1].strip())
@@ -199,7 +199,7 @@ class MTZHeader(baseHeader):
             c=[]
             ## print "KEY = %s" % key
             # user wants all columns
-            if colType==None:
+            if colType is None:
                 c = list(self.datasets[key]["cols"].keys())
             else:
                 # user wants a specfic column
@@ -225,7 +225,7 @@ class MTZHeader(baseHeader):
     def getColumnsOfType(self,colType):
         self.format_cols(colType)
         return baseHeader.getColumns(self)
-        
+
     def get_byteorder(self):
         f = open(self.filename, 'rb')
         f.seek(8)
@@ -260,7 +260,7 @@ class MTZHeader(baseHeader):
         elif i==4:
             self.byteorder_int = "<"
             self.wordsize = 4
-        
+
     def parseFile(self):
         import shlex
 
@@ -275,7 +275,7 @@ class MTZHeader(baseHeader):
             file_len = f.tell()
             # get header offset
             f.seek(4)
-            if self.wordsize!=None:
+            if self.wordsize is not None:
                 (header_start,) = struct.unpack(self.byteorder_int+"i", f.read(4))
             else:
                 print("Warning: Byte order of file unknown.  Guessing header location.")
@@ -291,7 +291,7 @@ class MTZHeader(baseHeader):
                 bAdjust = author_word_size * host_word_size
             else:
                 bAdjust = host_word_size
-                
+
             header_start  = (header_start-1) * (bAdjust)
 
             if file_len<header_start:
@@ -303,11 +303,11 @@ class MTZHeader(baseHeader):
 
             curLine = struct.unpack("80s", f.read(80))[0]
             curLine = str(curLine.decode())
-            
+
             while not (curLine.startswith("END")):
                 # yank field identifier
                 (field, tokens) = curLine.split(" ",1)
-                
+
                 H = MTZHeader.HEADER_KEYWORDS
                 try:
                     if field.startswith(H["VERS"]):
@@ -351,7 +351,7 @@ class MTZHeader(baseHeader):
                         if i not in self.datasets:
                             self.datasets[i] = {}
                             self.datasets[i]["cols"]  = {}
-                            
+
                         self.datasets[i]["cols"][lab] = {}
                         self.datasets[i]["cols"][lab]["type"] = typ
                         self.datasets[i]["cols"][lab]["min"]  = m
@@ -367,7 +367,7 @@ class MTZHeader(baseHeader):
                     elif field.startswith(H["CRYSTAL"]):
                         # can have multiple crystals per dataset?
                         # if, so not supported (overwritten) here.
-                        (i,cryst) = tokens.split(None, 1) 
+                        (i,cryst) = tokens.split(None, 1)
                         if i not in self.datasets:
                             self.datasets[i] = {}
                         self.datasets[i]["crystal"] = cryst.strip()
diff -upNr pymol-open-source-2.3.0/modules/pymol/helping.py pymol-open-source-2.3.3/modules/pymol/helping.py
--- pymol-open-source-2.3.0/modules/pymol/helping.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/helping.py	2019-08-22 10:24:47.842615885 +0200
@@ -1,21 +1,21 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
 from __future__ import print_function
 
 if True:
-    
+
     cmd = __import__("sys").modules["pymol.cmd"]
     import pymol
     from pymol import CmdException
@@ -73,9 +73,7 @@ USAGE
     help command
         '''
         r = DEFAULT_SUCCESS
-#        if cmd.get_setting_legacy("internal_feedback")>0.1:
-#            cmd.set("text","1",quiet=1)
-        cmmd = _self.help_sc.auto_err(command,'topic')   
+        cmmd = _self.help_sc.auto_err(command,'topic')
         if cmmd in _self.keyword:
             doc = _self.keyword[cmmd][0].__doc__
         elif cmmd in _self.help_only:
@@ -720,7 +718,7 @@ SEE ALSO
     embed, skip, python
     '''
         return None
-    
+
     def skip(_self=cmd):
         '''
 DESCRIPTION
@@ -779,7 +777,7 @@ SEE ALSO
     '''
         pymol_names = _self._pymol.__dict__
         exec(string, pymol_names, pymol_names)
-    
+
     def embed(_self=cmd):
         '''
 DESCRIPTION
diff -upNr pymol-open-source-2.3.0/modules/pymol/importing.py pymol-open-source-2.3.3/modules/pymol/importing.py
--- pymol-open-source-2.3.0/modules/pymol/importing.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/importing.py	2019-08-22 12:55:03.267031098 +0200
@@ -1,21 +1,21 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
 from __future__ import print_function, absolute_import
 
 if True:
-    
+
     import re
     import os
     import sys
@@ -30,13 +30,13 @@ if True:
           _load, is_list, space_sc, safe_list_eval, is_string, loadable
     from .constants import _loadable
     from pymol.creating import unquote
-    
+
     def incentive_format_not_available_func(format=''):
         raise pymol.IncentiveOnlyException(
                 "'%s' format not supported by this PyMOL build" % format)
 
     from chempy import io
-    
+
     def filename_to_objectname(fname, _self=cmd):
         oname, _, _, _ = filename_to_format(fname)
         return _self.get_legal_name(oname)
@@ -124,7 +124,7 @@ if True:
 
     def set_session(session,partial=0,quiet=1,cache=1,steal=-1,_self=cmd):
         r = DEFAULT_SUCCESS
-        if is_string(session): # string implies compressed session data 
+        if is_string(session): # string implies compressed session data
             import zlib
             session = io.pkl.fromString(zlib.decompress(session))
             if steal<0:
@@ -134,7 +134,7 @@ if True:
         # use the pymol instance to store state, not the code module
         _pymol = _self._pymol
         for a in _pymol._session_restore_tasks:
-            if a==None:
+            if a is None:
                 try:
                     _self.lock(_self)
                     r = _cmd.set_session(_self._COb,session,int(partial),int(quiet))
@@ -189,7 +189,7 @@ PYMOL API
         '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.load_object(_self._COb,str(name),object,int(state)-1,
                                         int(type),int(finish),int(discrete),
                                         int(quiet),int(zoom))
@@ -271,24 +271,24 @@ SEE ALSO
     
     '''
         r = DEFAULT_ERROR
-        
+
         tables = { 'cmyk' : "$PYMOL_DATA/pymol/cmyk.png",
                    'pymol' : 'pymol',
                    'rgb' : 'rgb',
                    'greyscale': 'greyscale' }
-        
+
         space_auto = space_sc.interpret(space)
-        if (space_auto != None) and not is_list(space_auto):
+        if (space_auto is not None) and not is_list(space_auto):
             space = space_auto
 
-        if space=="": 
+        if space=="":
             filename = ""
-        else:         
+        else:
             filename = tables.get(space.lower(),"")
             if filename == "":
                 print("Error: unknown color space '%s'."%space)
                 filename = None
-        if filename!=None:
+        if filename is not None:
             try:
                 if filename!="":
                     filename = _self.exp_path(filename)
@@ -333,8 +333,8 @@ PYMOL API
         _self = kw.get('_self',cmd)
         lst = [loadable.cgo]
         lst.extend(list(arg))
-        if not is_list(lst[1]): 
-           lst[1] = list(lst[1]) 
+        if not is_list(lst[1]):
+           lst[1] = list(lst[1])
         return _self.load_object(*lst, **kw)
 
     def load_model(*arg,**kw):
@@ -409,7 +409,7 @@ SEE ALSO
 
             # preprocess selection
             selection = selector.process(selection)
-            #   
+            #
 
             filename = unquote(filename)
 
@@ -454,7 +454,7 @@ SEE ALSO
             _self.unlock(r,_self)
         if _self._raising(r,_self): raise pymol.CmdException
         return r
-    
+
     def _processALN(fname,quiet=1,_self=cmd):
         legal_dict = {}
         seq_dict = {}
@@ -506,7 +506,7 @@ SEE ALSO
         for key in seq_order:
             raw_seq = seq_dict[key].replace('-','')
             _self.fab(raw_seq, key, quiet=quiet)
-        
+
     def _processPWG(fname,_self=cmd):
         r = DEFAULT_ERROR
 
@@ -538,7 +538,7 @@ SEE ALSO
                             if len(input)>1:
                                 port = int(input[1].strip())
                                 launch_flag = 1
-                        elif keyword == 'logging': 
+                        elif keyword == 'logging':
                             if len(input)>1:
                                 logging = int(input[1].strip())
                         elif keyword == 'root': # must encode a valid filesystem path to local content
@@ -589,7 +589,7 @@ SEE ALSO
                     r = DEFAULT_SUCCESS
                 else:
                     r = DEFAULT_SUCCESS
-                if report_url != None: # report port back to server url (is this secure?)
+                if report_url is not None: # report port back to server url (is this secure?)
                     try:
                         report_url = report_url + str(port)
                         print(" Reporting back pymol port via: '%s'"%report_url)
@@ -602,7 +602,7 @@ SEE ALSO
         if is_error(r):
             print("Error: unable to handle PWG file")
         return r
-    
+
     def _magic_check_cor_charmm(filename):
         # http://www.ks.uiuc.edu/Research/vmd/plugins/molfile/corplugin.html
         # assume at least 2 title/comment lines, starting with *
@@ -705,14 +705,9 @@ SEE ALSO
             finish = int(finish)
             zoom = int(zoom)
             discrete = int(discrete)
-            if multiplex==None:
+            if multiplex is None:
                 multiplex=-2
 
-            filename = unquote(filename)
-
-            # analyze filename
-            noext, ext, format_guessed, zipped = filename_to_format(filename)
-
             # file format
             try:
                 # user specified the type as an int
@@ -720,6 +715,22 @@ SEE ALSO
                 format = loadable._reverse_lookup(format)
             except ValueError:
                 format = str(format)
+                ftype = getattr(_loadable, format, -1)
+
+            if ftype in _self._load2str.values():
+                assert format.endswith('str')
+                colorprinting.warning(
+                    ' cmd.load(format="{}") is deprecated, use cmd.load_raw(format="{}")'
+                    .format(format, format[:-3]))
+                return _self.load_raw(filename, format[:-3], object, state,
+                        finish, discrete, quiet, multiplex, zoom)
+
+            filename = unquote(filename)
+
+            # analyze filename
+            noext, ext, format_guessed, zipped = filename_to_format(filename)
+
+            if ftype == -1:
                 if not format:
                     format = format_guessed
                 elif format.startswith('plugin'):
@@ -730,8 +741,7 @@ SEE ALSO
                     format = 'model' # legacy
                 ftype = getattr(_loadable, format, -1)
 
-            if ftype not in _self._load2str.values():
-                filename = _self.exp_path(filename)
+            filename = _self.exp_path(filename)
 
             # object name
             object = str(object).strip()
@@ -865,7 +875,7 @@ NOTES
         if object_props or atom_props:
             print(' Warning: properties are not supported in Open-Source PyMOL')
         list = _self._parser.get_embedded(key)
-        if list == None:
+        if list is None:
             print("Error: embedded data '%s' not found."%key)
             return DEFAULT_ERROR
 
@@ -875,27 +885,39 @@ NOTES
         return _self.load_raw(''.join(list[1]), list[0], name, state,
                 finish, discrete, quiet, multiplex, zoom)
 
-    def load_raw(content,  format='', object='', state=0, finish=1,
+    def load_raw(content, format, object='', state=0, finish=1,
                  discrete=-1, quiet=1, multiplex=None, zoom=-1,_self=cmd):
+        '''
+DESCRIPTION
+
+    API-only function for loading data from memory.
+
+EXAMPLE
+
+    contents = open('example.mmtf', 'rb').read()
+    cmd.load_raw(contents, 'mmtf')
+        '''
         r = DEFAULT_ERROR
-        if multiplex==None:
+        if multiplex is None:
             multiplex=-2
         ftype = getattr(loadable, format, None)
+        if not isinstance(content, bytes):
+            content = content.encode('utf-8')
         if True:
             _raw_dict = cmd._load2str
             if ftype in _raw_dict:
                 try:
                     _self.lock(_self)
-                    r = _cmd.load(_self._COb,str(object),str(content),int(state)-1,
+                    r = _cmd.load(_self._COb,str(object),content,int(state)-1,
                                   _raw_dict[ftype],int(finish),int(discrete),
                                   int(quiet),int(multiplex),int(zoom))
                 finally:
                     _self.unlock(r,_self)
             else:
-                raise pymol.CmdException("unknown raw format '%s'", format)
+                raise pymol.CmdException("unknown raw format '{}'".format(format))
         if _self._raising(r,_self): raise pymol.CmdException
         return r
-        
+
     def read_sdfstr(sdfstr,name,state=0,finish=1,discrete=1,quiet=1,
                     zoom=-1,multiplex=-2,object_props=None,_self=cmd):
         '''
@@ -978,7 +1000,7 @@ DESCRIPTION
     '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.load(_self._COb, str(name).strip(), str(content),
                     int(state)-1, loadable.mmodstr, 1, 1, int(quiet), 0,
                     int(zoom))
@@ -1015,7 +1037,7 @@ NOTES
     '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             ftype = loadable.pdbstr
             pdb = contents
             r = _cmd.load(_self._COb,str(oname),pdb,int(state)-1,int(ftype),
@@ -1054,7 +1076,7 @@ NOTES
     '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             ftype = loadable.mol2str
             oname = str(name).strip()
             r = _cmd.load(_self._COb,str(oname),mol2,int(state)-1,int(ftype),
@@ -1086,7 +1108,7 @@ NOTES
     '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             ftype = loadable.xplorstr
             oname = str(name).strip()
             r = _cmd.load(_self._COb,str(oname),xplor,int(state)-1,int(ftype),
@@ -1114,7 +1136,7 @@ PYMOL API
         '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.finish_object(_self._COb,name)
         finally:
             _self.unlock(r,_self)
@@ -1260,10 +1282,10 @@ PYMOL API
             r = _self.read_pdbstr(contents, name, state,
                     finish, discrete, quiet, zoom, multiplex)
         elif contents and bioType in ('cif', 'cc'):
-            r = _self.load(contents, name, state, loadable.cifstr,
+            r = _self.load_raw(contents, 'cif', name, state,
                     finish, discrete, quiet, multiplex, zoom)
         elif contents and bioType in ('mmtf',):
-            r = _self.load(contents, name, state, loadable.mmtfstr,
+            r = _self.load_raw(contents, 'mmtf', name, state,
                     finish, discrete, quiet, multiplex, zoom)
 
         if not _self.is_error(r):
@@ -1323,11 +1345,11 @@ PYMOL API
                 _self.remove(r'?%s & ! c. \%s' % (r, chain))
 
         return r
-    
+
     def fetch(code, name='', state=0, finish=1, discrete=-1,
               multiplex=-2, zoom=-1, type='', async_=0, path='',
               file=None, quiet=1, _self=cmd, **kwargs):
-        
+
         '''
 DESCRIPTION
 
@@ -1396,7 +1418,7 @@ NOTES
             finally:
                 _self.unblock_flush(_self)
         return r
-        
+
     def load_coordset(coords, object, state=0, quiet=1, _self=cmd):
         '''
 DESCRIPTION
@@ -1633,6 +1655,7 @@ DESCRIPTION
         'r3d': load_r3d,
         'cc1': load_cc1,
         'pdb': read_pdbstr,
+        'stl': 'pymol.lazyio:read_stlstr',
 
         # Incentive
         'vis': incentive_format_not_available_func,
diff -upNr pymol-open-source-2.3.0/modules/pymol/__init__.py pymol-open-source-2.3.3/modules/pymol/__init__.py
--- pymol-open-source-2.3.0/modules/pymol/__init__.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/__init__.py	2019-08-22 10:24:47.834614582 +0200
@@ -74,16 +74,6 @@ IS_MACOS = sys.platform.startswith('darw
 IS_LINUX = sys.platform.startswith('linux')
 
 if IS_PY3:
-    # legacy string API, still used by Pmw for example
-    import string
-    for attr in ['capitalize', 'count', 'find', 'index', 'lower',
-            'replace', 'rstrip', 'split', 'strip', 'upper', 'zfill']:
-        setattr(string, attr, getattr(str, attr))
-    string.letters      = string.ascii_letters
-    string.lowercase    = string.ascii_lowercase
-    string.join = lambda words, sep=' ': sep.join(words)
-    string.atoi = int
-
     import _thread as thread
 else:
     import thread
@@ -177,9 +167,6 @@ def get_version_message(v=None):
     p += "Incentive Product" if invocation.options.incentive_product else \
          "Open-Source"
 
-    if v[5]:
-        p += ", svn rev %s" % v[5]
-
     return p
 
 def guess_pymol_path():
@@ -568,9 +555,6 @@ setup_environ()
 # initialize instance-specific module/object internals
 _init_internals(sys.modules[__name__])
 
-# maximize responsiveness
-sys.setcheckinterval(1)
-
 # get X-window support (machine_get_clipboard)
 if 'DISPLAY' in os.environ:
     from .xwin import *
diff -upNr pymol-open-source-2.3.0/modules/pymol/internal.py pymol-open-source-2.3.3/modules/pymol/internal.py
--- pymol-open-source-2.3.0/modules/pymol/internal.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/internal.py	2019-08-22 10:24:47.846616537 +0200
@@ -37,7 +37,7 @@ def _cache_validate(_self=cmd):
             _pymol._cache_memory = 0
     finally:
         _self.unlock_data(_self)
-        
+
 def _cache_clear(_self=cmd):
     r = DEFAULT_SUCCESS
     try:
@@ -48,14 +48,14 @@ def _cache_clear(_self=cmd):
     finally:
         _self.unlock_data(_self)
     return r
-    
+
 def _cache_mark(_self=cmd):
     r = DEFAULT_SUCCESS
     try:
         _self.lock_data(_self)
         _pymol = _self._pymol
         _cache_validate(_self)
-        for entry in _self._pymol._cache: 
+        for entry in _self._pymol._cache:
             entry[5] = 0.0
     finally:
         _self.unlock_data(_self)
@@ -77,7 +77,7 @@ def _cache_purge(max_size, _self=cmd):
                 new_cache = [x[1] for x in new_cache]
                 # remove oldest entries one by one until size requirement is met
                 while (cur_size>max_size) and (len(new_cache)>1):
-                    entry = new_cache.pop() 
+                    entry = new_cache.pop()
                     cur_size = cur_size - entry[0]
                 _pymol._cache = new_cache
                 _pymol._cache_memory = cur_size
@@ -94,13 +94,13 @@ def _cache_purge(max_size, _self=cmd):
     finally:
         _self.unlock_data(_self)
     return result
-        
+
 def _cache_get(target, hash_size = None, _self=cmd):
     result = None
     try:
         _self.lock_data(_self)
         try:
-            if hash_size == None:
+            if hash_size is None:
                 hash_size = len(target[1])
             key = target[1][0:hash_size]
             # should optimize this with a dictionary lookup, key -> index in _cache
@@ -132,10 +132,10 @@ def _cache_set(new_entry, max_size, _sel
             found = 0
             new_entry[4] = new_entry[4] + 1 # incr access count
             new_entry[5] = time.time() # timestamp
-            for entry in _pymol._cache: 
+            for entry in _pymol._cache:
                 if entry[1][0:hash_size] == key:
                     if entry[2] == new_entry[2]: # dupe (shouldn't happen)
-                        entry[3] = new_entry[3] 
+                        entry[3] = new_entry[3]
                         found = 1
                         break
                 count = count + 1
@@ -150,11 +150,11 @@ def _cache_set(new_entry, max_size, _sel
     finally:
         _self.unlock_data(_self)
     return r
-        
+
 # ray tracing threads
 
 def _ray_anti_spawn(thread_info,_self=cmd):
-    # WARNING: internal routine, subject to change      
+    # WARNING: internal routine, subject to change
     # internal routine to support multithreaded raytracing
     thread_list = []
     for a in thread_info[1:]:
@@ -169,24 +169,24 @@ def _ray_anti_spawn(thread_info,_self=cm
         t.join()
 
 def _ray_hash_spawn(thread_info,_self=cmd):
-    # WARNING: internal routine, subject to change      
+    # WARNING: internal routine, subject to change
     # internal routine to support multithreaded raytracing
     thread_list = []
     for a in thread_info[1:]:
-        if a != None:
+        if a is not None:
             t = threading.Thread(target=_cmd.ray_hash_thread,
                                  args=(_self._COb,a))
             t.setDaemon(1)
             thread_list.append(t)
     for t in thread_list:
         t.start()
-    if thread_info[0] != None:
+    if thread_info[0] is not None:
         _cmd.ray_hash_thread(_self._COb,thread_info[0])
     for t in thread_list:
         t.join()
 
 def _ray_spawn(thread_info,_self=cmd):
-    # WARNING: internal routine, subject to change      
+    # WARNING: internal routine, subject to change
     # internal routine to support multithreaded raytracing
     thread_list = []
     for a in thread_info[1:]:
@@ -272,7 +272,7 @@ def _mpng(prefix, first=-1, last=-1, pre
     format = int(format)
     # WARNING: internal routine, subject to change
     try:
-        _self.lock(_self)   
+        _self.lock(_self)
         fname = prefix
         if re.search("[0-9]*\.png$",fname): # remove numbering, etc.
             fname = re.sub("[0-9]*\.png$","",fname)
@@ -296,7 +296,7 @@ def _mpng(prefix, first=-1, last=-1, pre
 def _copy_image(_self=cmd,quiet=1):
     r = DEFAULT_ERROR
     try:
-        _self.lock(_self)   
+        _self.lock(_self)
         r = _cmd.copy_image(_self._COb,int(quiet))
     finally:
         _self.unlock(r,_self)
@@ -530,14 +530,14 @@ def _cmmd(k,_self=cmd):
     # command-key on macs
     if k in _self.cmmd:
         ak = _self.cmmd[k]
-        if ak[0]!=None:
+        if ak[0] is not None:
             ak[0](*ak[1], **ak[2])
     return None
 
 def _ctsh(k,_self=cmd):
     # WARNING: internal routine, subject to change
     _invoke_key('CTSH-' + k, 0, _self)
-    
+
 
 # writing PNG files (thread-unsafe)
 
@@ -545,7 +545,7 @@ def _png(a,width=0,height=0,dpi=-1.0,ray
     # INTERNAL - can only be safely called by GLUT thread (unless prior == 1)
     # WARNING: internal routine, subject to change
     try:
-        _self.lock(_self)   
+        _self.lock(_self)
         fname = a
         if re.search("\.ppm$",fname):
             if format<0:
@@ -570,7 +570,7 @@ def _quit(code=0, _self=cmd):
     try:
         _self.lock(_self)
         try: # flush and close log if possible to avoid threading exception
-            if pymol._log_file!=None:
+            if pymol._log_file is not None:
                 try:
                     pymol._log_file.flush()
                 except:
@@ -579,7 +579,7 @@ def _quit(code=0, _self=cmd):
                 del pymol._log_file
         except:
             pass
-        if _self.reaper!=None:
+        if _self.reaper is not None:
             try:
                 _self.reaper.join()
             except:
@@ -603,7 +603,7 @@ def _refresh(swap_buffers=1,_self=cmd):
                 else:
                     r = _cmd.refresh(_self._COb)
             else:
-                r = _cmd.refresh_later(_self._COb)                
+                r = _cmd.refresh_later(_self._COb)
         else:
             r = _cmd.refresh_later(_self._COb)
     finally:
@@ -626,7 +626,7 @@ def _interpret_color(_self,color):
 
 def _validate_color_sc(_self=cmd):
     # WARNING: internal routine, subject to change
-    if _self.color_sc == None: # update color shortcuts if needed
+    if _self.color_sc is None: # update color shortcuts if needed
         lst = _self.get_color_indices()
         names = [x[0] for x in lst]
         names.extend(['default', 'auto', 'current', 'atomic'])
@@ -657,8 +657,6 @@ def _get_feedback(_self=cmd): # INTERNAL
         l = None
     return l
 
-get_feedback = _get_feedback # for legacy compatibility
-
 def _fake_drag(_self=cmd): # internal
     _self.lock(_self)
     try:
@@ -669,7 +667,7 @@ def _fake_drag(_self=cmd): # internal
 
 def _sdof(tx,ty,tz,rx,ry,rz,_self=cmd):
     _cmd._sdof(_self._COb,tx,ty,tz,rx,ry,rz)
-    
+
 # testing tools
 
 # for comparing floating point numbers calculated using
diff -upNr pymol-open-source-2.3.0/modules/pymol/invocation.py pymol-open-source-2.3.3/modules/pymol/invocation.py
--- pymol-open-source-2.3.0/modules/pymol/invocation.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/invocation.py	2019-08-22 10:24:47.846616537 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -27,7 +27,6 @@ Options
 
   --help    display this help and exit
   --version display PyMOL version and exit
-  --retina  use retina resolution (MacPyMOL) and set display_scale_factor=2
   --gldebug use glDebugMessageCallback for GL debugging
   --testing run pymol testing
 
@@ -119,19 +118,19 @@ if True:
     import glob
     import sys
     import traceback
-    
+
     pymolrc_pat1 = '.pymolrc*'
     pymolrc_pat2 = 'pymolrc*'
-    
+
     ros_pat = 'run_on_startup*'
-    
+
     class generic:
         pass
 
     global_options = generic();
 
     options = global_options
-    
+
     options.deferred = []
     options.no_gui = 0
     options.internal_gui = 1
@@ -146,7 +145,7 @@ if True:
     options.win_x = 640
     options.win_y = 480
     options.win_xy_set = False
-    options.win_px = 4 
+    options.win_px = 4
     options.sigint_handler = 1 # terminate on Ctrl-C?
     options.reuse_helper = 0
     options.auto_reinitialize = 0
@@ -167,7 +166,6 @@ if True:
     options.plugins = 2
     options.exit_on_error = 0
     options.pymolrc = None
-    options.retina = 0
     options.no_spacenav = 0
     options.launch_status = 0
     options.gldebug = 0
@@ -186,7 +184,7 @@ if True:
     options.rpcServer = 0
     # end
     options.security = 1
-    
+
     script_re = re.compile(r"pymolrc$|\.pml$|\.PML$|\.p1m$|\.P1M$")
     py_re = re.compile(r"\.py$|\.pym$|\.PY$|\.PYM$")
 
@@ -232,7 +230,7 @@ if True:
             if py_re.search(a):
                 first.append(a) # preceeding "_ " cloaks
             elif script_re.search(a):
-                second.append(a) # preceeding "_ " cloaks 
+                second.append(a) # preceeding "_ " cloaks
 
         first.sort()
         second.sort()
@@ -243,8 +241,8 @@ if True:
             global _argv
             _argv = copy.deepcopy(argv) # pymol.invocation._argv
             global global_options
-            if options == None:
-                if _pymol==None:
+            if options is None:
+                if _pymol is None:
                     options = global_options
                 else:
                     options = _pymol.invocation.options
@@ -278,7 +276,7 @@ if True:
                             print(helptext2)
                         sys.exit()
                     elif a == "--retina":
-                        options.retina = 1
+                        print("Warning: --retina option has been removed")
                     elif a == "--nospnav":
                         print(' Warning: --nospnav not available in Open-Source PyMOL')
                     elif a == "--gldebug":
@@ -287,7 +285,7 @@ if True:
                         options.testing = 1
                     else:
                         # double hypen signals end of PyMOL arguments
-                        if python_script == None:
+                        if python_script is None:
                             python_script = argv[0]
                         rev_av = copy.deepcopy(av)
                         rev_av.reverse()
@@ -300,7 +298,7 @@ if True:
                 if ("A" in a) or ("a" in a): # application configuration
                     new_args = []
                     # ====== mode 1 - simple viewer window ======
-                    if a[2:3] == "1": 
+                    if a[2:3] == "1":
                         if 'A1' not in once_dict:
                             once_dict['A1'] = 1
                             new_args = ["-qxiF",
@@ -309,7 +307,7 @@ if True:
                                 ]
                     # ====== mode 2 - not available -- clashes with -2 =======
                     # ====== mode 3 - internal GUI only no splash ======
-                    if a[2:3] == "3": 
+                    if a[2:3] == "3":
                         if 'A3' not in once_dict:
                             once_dict['A3'] = 1
                             new_args = ["-qx",
@@ -325,7 +323,7 @@ if True:
                                 "-Y","100",
                                 ]
                     # ====== mode 5 - mode 5 helper application ======
-                    if a[2:3] == "5": 
+                    if a[2:3] == "5":
                         if 'A5' not in once_dict:
                             once_dict['A5'] = 1
                             new_args = ["-QxiICUF",
@@ -333,7 +331,7 @@ if True:
                                 "-Y","100",
                                 ]
                     # ====== mode 6 - mode 6 presentation (no GUI) ======
-                    if a[2:3] == "6": 
+                    if a[2:3] == "6":
                         if 'A6' not in once_dict:
                             once_dict['A6'] = 1
                             new_args = ["-qxieICUPF",
@@ -358,7 +356,7 @@ if True:
                 if "E" in a:
                     options.multisample = int(av.pop())
                 if "P" in a:
-                    options.presentation = 1 
+                    options.presentation = 1
                 if "W" in a:
                     options.win_x = int(av.pop())
                     options.win_xy_set = True
@@ -383,7 +381,7 @@ if True:
                     options.incentive_product = 1
                 if "t" in a: # type of stereo to use
                     options.stereo_mode = int(av.pop())
-                if "T" in a: # what skin to use? 
+                if "T" in a: # what skin to use?
                     options.skin = str(av.pop())
                 if "w" in a: # what gui to use
                     options.gui = str(av.pop())
@@ -406,8 +404,8 @@ if True:
                                 options.win_py = 216
                         else:
                             options.external_gui = 2
-                            options.win_py = 184 
-                    
+                            options.win_py = 184
+
                     if "e" in a:
                         options.full_screen = 1
                     if "G" in a: # Game mode (reqd for Mac stereo)
@@ -418,7 +416,7 @@ if True:
                         options.force_stereo = 1
                         if options.stereo_mode == 0:
                             options.stereo_mode = 1  # quadbuffer
-                        if sys.platform=='darwin': 
+                        if sys.platform=='darwin':
                             options.deferred.append(
                               "_do__ set stereo_double_pump_mono,1,quiet=1")
                     if "M" in a: # Force mono on stereo hardware (all)
@@ -472,7 +470,7 @@ if True:
                             options.deferred.append("_do__ cmd.get_wizard().ray_trace1()")
                         if a[2:]=='2':
                             options.deferred.append("_do__ cmd.get_wizard().ray_trace2()")
-                        
+
                     if "p" in a:
                         options.read_stdin = 1
                     if "K" in a:
@@ -497,7 +495,7 @@ if True:
             elif not restricted:
                 suffix = a[-4:].lower().split('.')[-1]
                 if suffix == "p5m":
-                    # mode 5 helper application 
+                    # mode 5 helper application
                     av.append("-A5")
                 elif suffix == "psw":
                     # presentation mode
@@ -513,7 +511,7 @@ if True:
                         traceback.print_exc()
                 options.deferred.append(a)
                 loaded_something = 1
-        if pymolrc != None:
+        if pymolrc is not None:
             options.deferred = [('_do__ @' + a) if script_re.search(a) else a
                     for a in pymolrc] + options.deferred
             options.pymolrc = pymolrc
diff -upNr pymol-open-source-2.3.0/modules/pymol/keyboard.py pymol-open-source-2.3.3/modules/pymol/keyboard.py
--- pymol-open-source-2.3.0/modules/pymol/keyboard.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/keyboard.py	2019-08-22 10:24:47.846616537 +0200
@@ -33,7 +33,7 @@ class _PersistentEditing:
         if self._init == 0:
             self._obj = self._cmd.get_unused_name("_persistent_obj")
             self._init = 1
-        
+
     def set_sel(self,sel):
         self._sel = sel
 
@@ -43,7 +43,7 @@ class _PersistentEditing:
 
     def create_tmp(self,sel,extract):
 
-        if sel==None: return
+        if sel is None: return
 
         # creates an invisible temporary persistent
         # object for pasting; it is created via CTRL-C
@@ -117,7 +117,7 @@ def editing_ring(action, space=_persiste
 
             # copying or pasting; enable that object
             # and create the duplicate
-            
+
             self_cmd.enable(space._obj)
 
             self_cmd.copy(self_cmd.get_unused_name("obj"),space._obj,zoom=0)
@@ -128,7 +128,7 @@ def editing_ring(action, space=_persiste
 
         finally:
             self_cmd.set("suspend_updates", 0)
-            
+
 
 #
 # collapse down to one function in a switch
@@ -150,7 +150,7 @@ def invert_active_selection(self_cmd=cmd
     sel = get_active_selection_name(self_cmd)
     if sel:
         self_cmd.select(sel, 'not %s' % sel)
-    
+
 def get_active_selection_name(self_cmd=cmd):
     # find the name of the active selection
 
diff -upNr pymol-open-source-2.3.0/modules/pymol/keywords.py pymol-open-source-2.3.3/modules/pymol/keywords.py
--- pymol-open-source-2.3.0/modules/pymol/keywords.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/keywords.py	2019-08-22 10:24:47.846616537 +0200
@@ -17,13 +17,13 @@ def get_command_keywords(self_cmd=cmd):
         'align'         : [ self_cmd.align             , 0 , 0 , ''  , parsing.STRICT ],
         'alignto'       : [ self_cmd.alignto           , 0 , 0 , ''  , parsing.STRICT ],
         'alter'         : [ self_cmd.alter             , 0 , 0 , ''  , parsing.LITERAL1 ], # insecure
-        '_alt'          : [ self_cmd._alt              , 0 , 0 , ''  , parsing.STRICT ],                
+        '_alt'          : [ self_cmd._alt              , 0 , 0 , ''  , parsing.STRICT ],
         'alter_state'   : [ self_cmd.alter_state       , 0 , 0 , ''  , parsing.LITERAL2 ], # insecure
         'alphatoall'    : [ self_cmd.alphatoall        , 0 , 0 , ''  , parsing.STRICT ],
-        'angle'         : [ self_cmd.angle             , 0 , 0 , ''  , parsing.STRICT ],          
+        'angle'         : [ self_cmd.angle             , 0 , 0 , ''  , parsing.STRICT ],
         'api'           : [ self_cmd.helping.api       , 0 , 0 , ''  , parsing.STRICT ],
-        'as'            : [ self_cmd.show_as           , 0 , 0 , ''  , parsing.STRICT ],          
-        'assert'        : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ], 
+        'as'            : [ self_cmd.show_as           , 0 , 0 , ''  , parsing.STRICT ],
+        'assert'        : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ],
         'assign_stereo' : [ self_cmd.assign_stereo     , 0 , 0 , ''  , parsing.STRICT ],
         'attach'        : [ self_cmd.attach            , 0 , 0 , ''  , parsing.STRICT ],
         'backward'      : [ self_cmd.backward          , 0 , 0 , ''  , parsing.STRICT ],
@@ -37,27 +37,27 @@ def get_command_keywords(self_cmd=cmd):
         'cealign'       : [ self_cmd.cealign	       , 0 , 0 , ''  , parsing.STRICT ],
         'centerofmass'  : [ self_cmd.centerofmass      , 0 , 0 , ''  , parsing.STRICT ],
         'cd'            : [ self_cmd.cd                , 0 , 0 , ''  , parsing.STRICT ],
-        'center'        : [ self_cmd.center            , 0 , 0 , ''  , parsing.STRICT ],     
+        'center'        : [ self_cmd.center            , 0 , 0 , ''  , parsing.STRICT ],
         'check'         : [ self_cmd.check             , 0 , 0 , ''  , parsing.STRICT ],
         'clean'         : [ self_cmd.clean             , 0 , 0 , ''  , parsing.STRICT ],
-        'class'         : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ], 
+        'class'         : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ],
         'clip'          : [ self_cmd.clip              , 0 , 0 , ''  , parsing.STRICT ],
         'cls'           : [ self_cmd.cls               , 0 , 0 , ''  , parsing.STRICT ],
-        '_ctrl'         : [ self_cmd._ctrl             , 0 , 0 , ''  , parsing.STRICT ],        
-        '_ctsh'         : [ self_cmd._ctsh             , 0 , 0 , ''  , parsing.STRICT ],        
+        '_ctrl'         : [ self_cmd._ctrl             , 0 , 0 , ''  , parsing.STRICT ],
+        '_ctsh'         : [ self_cmd._ctsh             , 0 , 0 , ''  , parsing.STRICT ],
         'color'         : [ self_cmd.color             , 0 , 0 , ''  , parsing.STRICT ],
         'config_mouse'  : [ self_cmd.config_mouse      , 0 , 0 , ''  , parsing.STRICT ],
         'copy'          : [ self_cmd.copy              , 0 , 0 , ''  , parsing.LEGACY ],
         'copy_to'       : [ self_cmd.copy_to           , 0 , 0 , ''  , parsing.STRICT ],
         'count_atoms'   : [ self_cmd.count_atoms       , 0 , 0 , ''  , parsing.STRICT ],
-        'count_frames'  : [ self_cmd.count_frames      , 0 , 0 , ''  , parsing.STRICT ],   
+        'count_frames'  : [ self_cmd.count_frames      , 0 , 0 , ''  , parsing.STRICT ],
         'count_states'  : [ self_cmd.count_states      , 0 , 0 , ''  , parsing.STRICT ],
         'count_discrete': [ self_cmd.count_discrete    , 0 , 0 , ''  , parsing.STRICT ],
         'cycle_valence' : [ self_cmd.cycle_valence     , 0 , 0 , ''  , parsing.STRICT ],
         'create'        : [ self_cmd.create            , 0 , 0 , ''  , parsing.LEGACY ],
-        'decline'       : [ self_cmd.decline           , 0 , 0 , ''  , parsing.STRICT ],      
+        'decline'       : [ self_cmd.decline           , 0 , 0 , ''  , parsing.STRICT ],
         'delete'        : [ self_cmd.delete            , 0 , 0 , ''  , parsing.STRICT ],
-        'def'           : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ],   
+        'def'           : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ],
         'del'           : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ],
         'deprotect'     : [ self_cmd.deprotect         , 0 , 0 , ''  , parsing.STRICT ],
         'desaturate'    : [ self_cmd.desaturate        , 0 , 0 , ''  , parsing.STRICT ],
@@ -67,7 +67,7 @@ def get_command_keywords(self_cmd=cmd):
         'dir'           : [ self_cmd.ls                , 0 , 0 , ''  , parsing.STRICT ],
         'disable'       : [ self_cmd.disable           , 0 , 0 , ''  , parsing.STRICT ],
         'distance'      : [ self_cmd.distance          , 0 , 0 , ''  , parsing.LEGACY ],
-        'drag'          : [ self_cmd.drag              , 0 , 0 , ''  , parsing.STRICT ],            
+        'drag'          : [ self_cmd.drag              , 0 , 0 , ''  , parsing.STRICT ],
         'draw'          : [ self_cmd.draw              , 0 , 0 , ''  , parsing.STRICT ],
         'dss'           : [ self_cmd.dss               , 0 , 0 , ''  , parsing.STRICT ],
         'dump'          : [ self_cmd.dump              , 0 , 0 , ''  , parsing.STRICT ],
@@ -77,8 +77,8 @@ def get_command_keywords(self_cmd=cmd):
         'enable'        : [ self_cmd.enable            , 0 , 0 , ''  , parsing.STRICT ],
         'ending'        : [ self_cmd.ending            , 0 , 0 , ''  , parsing.STRICT ],
         'extra_fit'     : [ self_cmd.extra_fit         , 0 , 0 , ''  , parsing.STRICT ],
-        'extract'       : [ self_cmd.extract           , 0 , 0 , ''  , parsing.STRICT ],            
-        'exec'          : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ],   
+        'extract'       : [ self_cmd.extract           , 0 , 0 , ''  , parsing.STRICT ],
+        'exec'          : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ],
         'export_dots'   : [ self_cmd.export_dots       , 0 , 0 , ''  , parsing.STRICT ],
         'fab'           : [ self_cmd.fab               , 0 , 0 , ''  , parsing.STRICT ],
         'feedback'      : [ self_cmd.feedback          , 0,  0 , ''  , parsing.STRICT ],
@@ -95,7 +95,7 @@ def get_command_keywords(self_cmd=cmd):
         'fuse'          : [ self_cmd.fuse              , 0 , 0 , ''  , parsing.STRICT ],
         'frame'         : [ self_cmd.frame             , 0 , 0 , ''  , parsing.STRICT ],
         'get'           : [ self_cmd.get               , 0 , 0 , ''  , parsing.STRICT ],
-        'get_angle'     : [ self_cmd.get_angle         , 0 , 0 , ''  , parsing.STRICT ],      
+        'get_angle'     : [ self_cmd.get_angle         , 0 , 0 , ''  , parsing.STRICT ],
         'get_area'      : [ self_cmd.get_area          , 0 , 0 , ''  , parsing.STRICT ],
         'get_bond'      : [ self_cmd.get_bond          , 0 , 0 , ''  , parsing.STRICT ],
         'get_chains'    : [ self_cmd.get_chains        , 0 , 0 , ''  , parsing.STRICT ],
@@ -106,32 +106,32 @@ def get_command_keywords(self_cmd=cmd):
         'get_sasa_relative' : [ self_cmd.get_sasa_relative , 0 , 0 , ''  , parsing.STRICT ],
         'get_symmetry'  : [ self_cmd.get_symmetry      , 0 , 0 , ''  , parsing.STRICT ],
         'get_renderer'  : [ self_cmd.get_renderer      , 0 , 0 , ''  , parsing.STRICT ],
-        'get_title'     : [ self_cmd.get_title         , 0 , 0 , ''  , parsing.STRICT ],   
+        'get_title'     : [ self_cmd.get_title         , 0 , 0 , ''  , parsing.STRICT ],
         'get_type'      : [ self_cmd.get_type          , 0 , 0 , ''  , parsing.STRICT ],
-        'get_version'   : [ self_cmd.get_version       , 0 , 0 , ''  , parsing.STRICT ],            
+        'get_version'   : [ self_cmd.get_version       , 0 , 0 , ''  , parsing.STRICT ],
         'get_view'      : [ self_cmd.get_view          , 0 , 0 , ''  , parsing.STRICT ],
         'get_viewport'  : [ self_cmd.get_viewport      , 0 , 0 , ''  , parsing.STRICT ],
         'global'        : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ],
-        'gradient'      : [ self_cmd.gradient          , 0 , 0 , ''  , parsing.STRICT ],            
+        'gradient'      : [ self_cmd.gradient          , 0 , 0 , ''  , parsing.STRICT ],
         'group'         : [ self_cmd.group             , 0 , 0 , ''  , parsing.STRICT ],
         'h_add'         : [ self_cmd.h_add             , 0 , 0 , ''  , parsing.STRICT ],
         'h_fill'        : [ self_cmd.h_fill            , 0 , 0 , ''  , parsing.STRICT ],
-        'h_fix'         : [ self_cmd.h_fix             , 0 , 0 , ''  , parsing.STRICT ],            
+        'h_fix'         : [ self_cmd.h_fix             , 0 , 0 , ''  , parsing.STRICT ],
         'help'          : [ self_cmd.help              , 0 , 0 , ''  , parsing.STRICT ],
         'help_setting'  : [ self_cmd.help_setting      , 0 , 0 , ''  , parsing.STRICT ],
         'hide'          : [ self_cmd.hide              , 0 , 0 , ''  , parsing.STRICT ],
         'id_atom'       : [ self_cmd.id_atom           , 0 , 0 , ''  , parsing.STRICT ],
         'identify'      : [ self_cmd.identify          , 0 , 0 , ''  , parsing.STRICT ],
         'if'            : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ],
-        'import'        : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ],   
+        'import'        : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ],
         'index'         : [ self_cmd.index             , 0 , 0 , ''  , parsing.STRICT ],
-        'indicate'      : [ self_cmd.indicate          , 0 , 0 , ''  , parsing.STRICT ],   
+        'indicate'      : [ self_cmd.indicate          , 0 , 0 , ''  , parsing.STRICT ],
         'intra_fit'     : [ self_cmd.intra_fit         , 0 , 0 , ''  , parsing.STRICT ],
         'intra_rms'     : [ self_cmd.intra_rms         , 0 , 0 , ''  , parsing.STRICT ],
         'intra_rms_cur' : [ self_cmd.intra_rms_cur     , 0 , 0 , ''  , parsing.STRICT ],
         'invert'        : [ self_cmd.invert            , 0 , 0 , ''  , parsing.STRICT ],
         'isodot'        : [ self_cmd.isodot            , 0 , 0 , ''  , parsing.LEGACY ],
-        'isolevel'      : [ self_cmd.isolevel          , 0 , 0 , ''  , parsing.STRICT ],      
+        'isolevel'      : [ self_cmd.isolevel          , 0 , 0 , ''  , parsing.STRICT ],
         'isomesh'       : [ self_cmd.isomesh           , 0 , 0 , ''  , parsing.LEGACY ],
         'isosurface'    : [ self_cmd.isosurface        , 0 , 0 , ''  , parsing.LEGACY ],
         'iterate'       : [ self_cmd.iterate           , 0 , 0 , ''  , parsing.LITERAL1 ], # insecure
@@ -154,26 +154,26 @@ def get_command_keywords(self_cmd=cmd):
         'map_set'       : [ self_cmd.map_set           , 0 , 0 , ''  , parsing.STRICT ],
         'map_set_border': [ self_cmd.map_set_border    , 0 , 0 , ''  , parsing.STRICT ],
         'map_double'    : [ self_cmd.map_double        , 0 , 0 , ''  , parsing.STRICT ],
-        'map_halve'     : [ self_cmd.map_halve         , 0 , 0 , ''  , parsing.STRICT ],            
-        'map_new'       : [ self_cmd.map_new           , 0 , 0 , ''  , parsing.STRICT ],    
-        'map_trim'      : [ self_cmd.map_trim          , 0 , 0 , ''  , parsing.STRICT ],                  
+        'map_halve'     : [ self_cmd.map_halve         , 0 , 0 , ''  , parsing.STRICT ],
+        'map_new'       : [ self_cmd.map_new           , 0 , 0 , ''  , parsing.STRICT ],
+        'map_trim'      : [ self_cmd.map_trim          , 0 , 0 , ''  , parsing.STRICT ],
         'mappend'       : [ self_cmd.mappend           , 2 , 2 , ':' , parsing.MOVIE  ],
-        'matrix_reset'  : [ self_cmd.matrix_reset      , 0 , 0 , ''  , parsing.STRICT ],         
+        'matrix_reset'  : [ self_cmd.matrix_reset      , 0 , 0 , ''  , parsing.STRICT ],
         'matrix_copy'   : [ self_cmd.matrix_copy       , 0 , 0 , ''  , parsing.STRICT ],
-        'mcopy'         : [ self_cmd.mcopy             , 0 , 0 , ''  , parsing.STRICT ],                
+        'mcopy'         : [ self_cmd.mcopy             , 0 , 0 , ''  , parsing.STRICT ],
         'mdelete'       : [ self_cmd.mdelete           , 0 , 0 , ''  , parsing.STRICT ],
         'mem'           : [ self_cmd.mem               , 0 , 0 , ''  , parsing.STRICT ],
         'meter_reset'   : [ self_cmd.meter_reset       , 0 , 0 , ''  , parsing.STRICT ],
         'minsert'       : [ self_cmd.minsert           , 0 , 0 , ''  , parsing.STRICT ],
-        'mmove'         : [ self_cmd.mmove             , 0 , 0 , ''  , parsing.STRICT ],        
+        'mmove'         : [ self_cmd.mmove             , 0 , 0 , ''  , parsing.STRICT ],
         'move'          : [ self_cmd.move              , 0 , 0 , ''  , parsing.STRICT ],
         'mse2met'       : [ self_cmd.mse2met           , 0 , 0 , ''  , parsing.STRICT ],
         'mset'          : [ self_cmd.mset              , 0 , 0 , ''  , parsing.STRICT ],
         'mdo'           : [ self_cmd.mdo               , 2 , 2 , ':' , parsing.MOVIE  ],
-        'mdump'         : [ self_cmd.mdump             , 0 , 0 , ''  , parsing.STRICT ],      
+        'mdump'         : [ self_cmd.mdump             , 0 , 0 , ''  , parsing.STRICT ],
         'mpng'          : [ self_cmd.mpng              , 0 , 0 , ''  , parsing.SECURE ],
         'mplay'         : [ self_cmd.mplay             , 0 , 0 , ''  , parsing.STRICT ],
-        'mtoggle'       : [ self_cmd.mtoggle           , 0 , 0 , ''  , parsing.STRICT ],         
+        'mtoggle'       : [ self_cmd.mtoggle           , 0 , 0 , ''  , parsing.STRICT ],
         'mstop'         : [ self_cmd.mstop             , 0 , 0 , ''  , parsing.STRICT ],
         'mclear'        : [ self_cmd.mclear            , 0 , 0 , ''  , parsing.STRICT ],
         'middle'        : [ self_cmd.middle            , 0 , 0 , ''  , parsing.STRICT ],
@@ -197,15 +197,15 @@ def get_command_keywords(self_cmd=cmd):
         'python'        : [ self_cmd.helping.python    , 0 , 2 , ',' , parsing.PYTHON_BLOCK ],
         'skip'          : [ self_cmd.helping.skip      , 0 , 1 , ',' , parsing.SKIP ],
         'raise'         : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ],
-        'ramp_new'      : [ self_cmd.ramp_new          , 0 , 0 , ''  , parsing.STRICT ],      
+        'ramp_new'      : [ self_cmd.ramp_new          , 0 , 0 , ''  , parsing.STRICT ],
         'ramp_update'   : [ self_cmd.ramp_update       , 0 , 0 , ''  , parsing.STRICT ],
         'ray'           : [ self_cmd.ray               , 0 , 0 , ''  , parsing.STRICT ],
         'rebuild'       : [ self_cmd.rebuild           , 0 , 0 , ''  , parsing.STRICT ],
-        'recolor'       : [ self_cmd.recolor           , 0 , 0 , ''  , parsing.STRICT ],   
+        'recolor'       : [ self_cmd.recolor           , 0 , 0 , ''  , parsing.STRICT ],
         'redo'          : [ self_cmd.redo              , 0 , 0 , ''  , parsing.STRICT ],
         'reference'     : [ self_cmd.reference         , 0 , 0 , ''  , parsing.STRICT ],
         'volume_ramp_new': [ self_cmd.volume_ramp_new, 0 , 0 , ''  , parsing.STRICT ],
-        'reinitialize'  : [ self_cmd.reinitialize      , 0 , 0 , ''  , parsing.STRICT ],      
+        'reinitialize'  : [ self_cmd.reinitialize      , 0 , 0 , ''  , parsing.STRICT ],
         'refresh'       : [ self_cmd.refresh           , 0 , 0 , ''  , parsing.STRICT ],
         'refresh_wizard': [ self_cmd.refresh_wizard    , 0 , 0 , ''  , parsing.STRICT ],
         'remove'        : [ self_cmd.remove            , 0 , 0 , ''  , parsing.STRICT ],
@@ -216,7 +216,7 @@ def get_command_keywords(self_cmd=cmd):
         'reset'         : [ self_cmd.reset             , 0 , 0 , ''  , parsing.STRICT ],
         'resume'        : [ self_cmd.resume            , 0 , 0 , ''  , parsing.STRICT ],
         'rewind'        : [ self_cmd.rewind            , 0 , 0 , ''  , parsing.STRICT ],
-        #      'rgbfunction'   : [ self_cmd.rgbfunction       , 0 , 0 , ''  , parsing.LEGACY ],         
+        #      'rgbfunction'   : [ self_cmd.rgbfunction       , 0 , 0 , ''  , parsing.LEGACY ],
         'rock'          : [ self_cmd.rock              , 0 , 0 , ''  , parsing.STRICT ],
         'rotate'        : [ self_cmd.rotate            , 0 , 0 , ''  , parsing.STRICT ],
         'run'           : [ self_cmd.run               , 0 , 0 , ',' , parsing.SECURE ], # insecure
@@ -225,7 +225,7 @@ def get_command_keywords(self_cmd=cmd):
         'save'          : [ self_cmd.save              , 0 , 0 , ''  , parsing.SECURE ],
         'scene'         : [ self_cmd.scene             , 0 , 0 , ''  , parsing.STRICT ],
         'scene_order'   : [ self_cmd.scene_order       , 0 , 0 , ''  , parsing.STRICT ],
-        'sculpt_purge'  : [ self_cmd.sculpt_purge      , 0 , 0 , ''  , parsing.STRICT ],   
+        'sculpt_purge'  : [ self_cmd.sculpt_purge      , 0 , 0 , ''  , parsing.STRICT ],
         'sculpt_deactivate': [ self_cmd.sculpt_deactivate,0, 0 , ''  , parsing.STRICT ],
         'sculpt_activate': [ self_cmd.sculpt_activate  , 0 , 0 , ''  , parsing.STRICT ],
         'sculpt_iterate': [ self_cmd.sculpt_iterate    , 0 , 0 , ''  , parsing.STRICT ],
@@ -237,10 +237,10 @@ def get_command_keywords(self_cmd=cmd):
         'set_dihedral'  : [ self_cmd.set_dihedral      , 0 , 0 , ''  , parsing.STRICT ],
         'set_name'      : [ self_cmd.set_name          , 0 , 0 , ''  , parsing.STRICT ],
         'set_geometry'  : [ self_cmd.set_geometry      , 0 , 0 , ''  , parsing.STRICT ],
-        'set_symmetry'  : [ self_cmd.set_symmetry      , 0 , 0 , ''  , parsing.STRICT ],         
-        'set_title'     : [ self_cmd.set_title         , 0 , 0 , ''  , parsing.STRICT ],   
+        'set_symmetry'  : [ self_cmd.set_symmetry      , 0 , 0 , ''  , parsing.STRICT ],
+        'set_title'     : [ self_cmd.set_title         , 0 , 0 , ''  , parsing.STRICT ],
         'set_key'       : [ self_cmd.set_key           , 0 , 0 , ''  , parsing.LITERAL1 ], # insecure
-        'set_view'      : [ self_cmd.set_view          , 0 , 0 , ''  , parsing.STRICT ],   
+        'set_view'      : [ self_cmd.set_view          , 0 , 0 , ''  , parsing.STRICT ],
         'show'          : [ self_cmd.show              , 0 , 0 , ''  , parsing.STRICT ],
         'slice_new'     : [ self_cmd.slice_new         , 0 , 0 , ''  , parsing.STRICT ],
         #      'slice_lock'    : [ self_cmd.slice_lock        , 0 , 0 , ''  , parsing.LEGACY ],
@@ -258,7 +258,7 @@ def get_command_keywords(self_cmd=cmd):
         'symexp'        : [ self_cmd.symexp            , 0 , 0 , ''  , parsing.LEGACY ],
         'symmetry_copy' : [ self_cmd.symmetry_copy     , 0 , 0 , ''  , parsing.STRICT ],
         'system'        : [ self_cmd.system            , 0 , 0 , ''  , parsing.LITERAL ],
-        'toggle'        : [ self_cmd.toggle            , 0 , 0 , ''  , parsing.STRICT ],      
+        'toggle'        : [ self_cmd.toggle            , 0 , 0 , ''  , parsing.STRICT ],
         'torsion'       : [ self_cmd.torsion           , 0 , 0 , ''  , parsing.STRICT ], # vs toggle_object
         'translate'     : [ self_cmd.translate         , 0 , 0 , ''  , parsing.STRICT ],
         'try'           : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ],
@@ -273,18 +273,18 @@ def get_command_keywords(self_cmd=cmd):
         'uniquify'      : [ self_cmd.uniquify          , 0 , 0 , ''  , parsing.STRICT ],
         'unmask'        : [ self_cmd.unmask            , 0 , 0 , ''  , parsing.STRICT ],
         'unset'         : [ self_cmd.unset             , 0 , 0 , ''  , parsing.STRICT ],
-        'unset_bond'    : [ self_cmd.unset_bond        , 0 , 0 , ''  , parsing.STRICT ],               
+        'unset_bond'    : [ self_cmd.unset_bond        , 0 , 0 , ''  , parsing.STRICT ],
         'unset_deep'    : [ self_cmd.unset_deep        , 0 , 0 , ''  , parsing.STRICT ],
         'update'        : [ self_cmd.update            , 0 , 0 , ''  , parsing.STRICT ],
-        'valence'       : [ self_cmd.valence           , 0 , 0 , ''  , parsing.STRICT ],           
-        'vdw_fit'       : [ self_cmd.vdw_fit           , 0 , 0 , ''  , parsing.STRICT ],   
-        'view'          : [ self_cmd.view              , 0 , 0 , ''  , parsing.STRICT ],   
+        'valence'       : [ self_cmd.valence           , 0 , 0 , ''  , parsing.STRICT ],
+        'vdw_fit'       : [ self_cmd.vdw_fit           , 0 , 0 , ''  , parsing.STRICT ],
+        'view'          : [ self_cmd.view              , 0 , 0 , ''  , parsing.STRICT ],
         'viewport'      : [ self_cmd.viewport          , 0 , 0 , ''  , parsing.STRICT ],
         'volume'        : [ self_cmd.volume            , 0 , 0 , ''  , parsing.STRICT ],
         'volume_color'  : [ self_cmd.volume_color      , 0 , 0 , ''  , parsing.STRICT ],
         'volume_panel'  : [ self_cmd.volume_panel      , 0 , 0 , ''  , parsing.STRICT ],
-        'window'        : [ self_cmd.window            , 0 , 0 , ''  , parsing.STRICT ],         
-        'while'         : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ],   
+        'window'        : [ self_cmd.window            , 0 , 0 , ''  , parsing.STRICT ],
+        'while'         : [ self_cmd.python_help       , 0 , 0 , ''  , parsing.PYTHON ],
         'wizard'        : [ self_cmd.wizard            , 0 , 0 , ''  , parsing.STRICT ],
         'zoom'          : [ self_cmd.zoom              , 0 , 0 , ''  , parsing.STRICT ],
         # utility programs
@@ -300,7 +300,7 @@ def get_command_keywords(self_cmd=cmd):
         'util.cbam'     : [ self_cmd.util.cbam         , 0 , 0 , ''  , parsing.STRICT ],
         'util.cbc'      : [ self_cmd.util.cbc          , 0 , 0 , ''  , parsing.STRICT ],
         'util.chainbow' : [ self_cmd.util.chainbow     , 0 , 0 , ''  , parsing.STRICT ],
-        'util.cnc'      : [ self_cmd.util.cnc          , 0 , 0 , ''  , parsing.STRICT ],        
+        'util.cnc'      : [ self_cmd.util.cnc          , 0 , 0 , ''  , parsing.STRICT ],
         'util.ss'       : [ self_cmd.util.ss           , 0 , 0 , ''  , parsing.STRICT ],# secondary structure
         'util.rainbow'  : [ self_cmd.util.rainbow      , 0 , 0 , ''  , parsing.STRICT ],
         # movie programs
@@ -325,25 +325,25 @@ def fix_list(kw_list):
 def fix_dict(keyword):
 
     # Prepare for Python 2.6 (not hashed)
-    
+
     keyword['show_as'] = keyword['as']
-    
+
     # Aliases for Mother England (not hashed)
-    
+
     keyword['colour'] = keyword['color']
     keyword['set_colour'] = keyword['set_color']
     keyword['recolour'] = keyword['recolor']
     keyword['bg_colour'] = keyword['bg_color']
-    
+
     # legacy
     keyword['matrix_transfer'] = keyword['matrix_copy']
     keyword['util.mrock'] = [ cmd.util.mrock, 0, 0, '', parsing.STRICT ]
     keyword['util.mroll'] = [ cmd.util.mroll, 0, 0, '', parsing.STRICT ]
 
 def get_help_only_keywords(self_cmd=cmd):
-    return {  
+    return {
         'commands'              : [ self_cmd.helping.commands ],
-        'editing'               : [ self_cmd.helping.editing ],  
+        'editing'               : [ self_cmd.helping.editing ],
         'edit_keys'             : [ self_cmd.helping.edit_keys ],
         'examples'              : [ self_cmd.helping.examples ],
         'extend'                : [ self_cmd.extend ],
@@ -361,16 +361,16 @@ def get_help_only_keywords(self_cmd=cmd)
         'launching'             : [ self_cmd.helping.launching  ],
         'load_model'            : [ self_cmd.load_model  ],
         'movies'                : [ self_cmd.helping.movies  ],
-        'python_help'           : [ self_cmd.python_help   ],        
+        'python_help'           : [ self_cmd.python_help   ],
         'povray'                : [ self_cmd.helping.povray  ],
         'read_molstr'           : [ self_cmd.read_molstr ],
         'read_pdbstr'           : [ self_cmd.read_pdbstr ],
-        'read_sdfstr'           : [ self_cmd.read_sdfstr ],              
-        'release'               : [ self_cmd.helping.release ],   
+        'read_sdfstr'           : [ self_cmd.read_sdfstr ],
+        'release'               : [ self_cmd.helping.release ],
         'selections'            : [ self_cmd.helping.selections ],
         'sync'                  : [ self_cmd.sync ],
         'stereochemistry'       : [ self_cmd.helping.stereochemistry ],
         'text_type'             : [ self_cmd.helping.text_type ],
         'transparency'          : [ self_cmd.helping.transparency ],
-        '@'                     : [ self_cmd.helping.at_sign ],  
+        '@'                     : [ self_cmd.helping.at_sign ],
         }
diff -upNr pymol-open-source-2.3.0/modules/pymol/lazyio.py pymol-open-source-2.3.3/modules/pymol/lazyio.py
--- pymol-open-source-2.3.0/modules/pymol/lazyio.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/lazyio.py	2019-08-22 10:24:47.846616537 +0200
@@ -9,6 +9,7 @@ from __future__ import absolute_import a
 
 import os
 
+import pymol
 from pymol import cmd, CmdException
 
 try:
@@ -223,6 +224,26 @@ DESCRIPTION
                 state=model_num, zoom=zoom, discrete=discrete)
 
 
+def get_stlstr(binary=1, quiet=0, _self=cmd):
+    '''
+DESCRIPTION
+
+    STL geometry export
+    '''
+    raise pymol.IncentiveOnlyException(
+            "STL export not supported by this PyMOL build")
+
+
+def read_stlstr(contents, object, state=0, zoom=-1, _self=cmd):
+    '''
+DESCRIPTION
+
+    Load STL ASCII or binary content as a CGO object
+    '''
+    raise pymol.IncentiveOnlyException(
+            "STL import not supported by this PyMOL build")
+
+
 def get_mmtfstr(selection='all', state=1, _self=cmd):
     '''
 DESCRIPTION
diff -upNr pymol-open-source-2.3.0/modules/pymol/locking.py pymol-open-source-2.3.3/modules/pymol/locking.py
--- pymol-open-source-2.3.0/modules/pymol/locking.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/locking.py	2019-08-22 10:24:47.846616537 +0200
@@ -13,8 +13,8 @@ from .cmd import fb_module, fb_mask, fb_
 
 from pymol import _cmd
 
-# WARNING: internal routines, subject to change      
-def lock_c(_self=cmd): 
+# WARNING: internal routines, subject to change
+def lock_c(_self=cmd):
     _self.lock_api_c.acquire(1)
 
 def unlock_c(_self=cmd):
@@ -25,17 +25,17 @@ def lock_data(_self=cmd):
 
 def unlock_data(_self=cmd):
     _self.lock_api_data.release()
-    
+
 def lock_status_attempt(_self=cmd):
     return _self.lock_api_status.acquire(0)
 
-def lock_status(_self=cmd): 
+def lock_status(_self=cmd):
     _self.lock_api_status.acquire(1)
 
 def unlock_status(_self=cmd):
     _self.lock_api_status.release()
 
-def lock_glut(_self=cmd): 
+def lock_glut(_self=cmd):
     _self.lock_api_glut.acquire(1)
 
 def unlock_glut(_self=cmd):
@@ -60,13 +60,11 @@ class LockCM(object):
         unlock(None, self.cmd)
 
 def lock(_self=cmd): # INTERNAL -- API lock
-#      print " lock: acquiring as 0x%x"%thread.get_ident(),(thread.get_ident() == pymol.glutThread)
     if not _self.lock_api.acquire(0):
         w = 0.0001
         while 1:
-#            print " lock: ... as 0x%x"%thread.get_ident(),(thread.get_ident() == pymol.glutThread)
-            e = threading.Event() 
-            e.wait(w)  
+            e = threading.Event()
+            e.wait(w)
             del e
             if _self.lock_api.acquire(0):
                 break
@@ -75,7 +73,6 @@ def lock(_self=cmd): # INTERNAL -- API l
             else: # we're not getting lucky, so block for real
                 _self.lock_api.acquire(1)
                 break
-#      print "lock: acquired by 0x%x"%thread.get_ident()
 
 def lock_attempt(_self=cmd): # INTERNAL
     return _self.lock_api.acquire(blocking=0)
@@ -89,7 +86,7 @@ def unblock_flush(_self=cmd):
     lock(_self)
     _self.lock_api_allow_flush = 1
     unlock(None,_self)
-    
+
 def unlock(result=None,_self=cmd): # INTERNAL
     if (thread.get_ident() == pymol.glutThread):
         if _self.reaper:
@@ -102,15 +99,13 @@ def unlock(result=None,_self=cmd): # INT
             except:
                 pass
         _self.lock_api.release()
-    #         print "lock: released by 0x%x (glut)"%thread.get_ident()
         if _self.lock_api_allow_flush:
             if result is None: # don't flush if we have an incipient error (negative input)
                 _cmd.flush_now(_self._COb)
             elif _self.is_ok(result):
-                
+
                 _cmd.flush_now(_self._COb)
     else:
-    #         print "lock: released by 0x%x (not glut), waiting queue"%thread.get_ident()
         _self.lock_api.release()
         if _cmd.wait_queue(_self._COb): # commands waiting to be executed?
             e = threading.Event() # abdicate control for a 100 usec for quick tasks
@@ -125,10 +120,9 @@ def unlock(result=None,_self=cmd): # INT
                 if w > 0.1: # wait up 0.2 sec max for PyMOL to flush queue
                     if _self._feedback(fb_module.cmd,fb_mask.debugging,_self):
                         fb_debug.write("Debug: avoiding possible dead-lock?\n")
-   #                      print "dead locked as 0x%x"%thread.get_ident()
                     break
                 w = w * 2 # wait twice as long each time until flushed
-            
+
 def is_glut_thread(): # internal
     if thread.get_ident() == pymol.glutThread:
         return 1
diff -upNr pymol-open-source-2.3.0/modules/pymol/m4x.py pymol-open-source-2.3.3/modules/pymol/m4x.py
--- pymol-open-source-2.3.0/modules/pymol/m4x.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/m4x.py	2019-08-22 10:24:47.850617188 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
 #-* Scott Dixon, Metaphorics LLC
-#-* 
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -30,7 +30,6 @@ from chempy.models import Indexed
 from pymol import util
 
 import re
-import string
 
 from chempy import cex
 CEX=cex
@@ -58,12 +57,12 @@ class CEXpyParser(CEX.CEXsmilesParser):
     def SetAtomicMass(self, atom, mass):
         pass
 
-   
+
 #---------------------------------------------------------------------------------
 def readcex(filename, object=''):  # Author: Scott Dixon
     import os.path
 
-      
+
     standardResidues = ("ALA", "ARG", "ASP", "ASN", "ASX", "CYS", "GLY", "GLU",
                         "GLN", "HIS", "ILE", "LEU", "LYS", "MET", "PHE", "PRO",
                         "SER", "THR", "TYR", "TRP", "VAL", "HID", "HIE")
@@ -75,7 +74,7 @@ def readcex(filename, object=''):  # Aut
             return list
         except IndexError:
             return None
-        
+
     f = open(filename,"r")
     cs = CEX.CEXstream(f)
     modelname = object if object else \
@@ -133,7 +132,7 @@ def readcex(filename, object=''):  # Aut
             for conf in confs:
                 if conf.value[0] == '"':
                     conf.value = conf.value[1:-1]
-                    xyz = [string.split(x,",") for x in string.split(conf.value,";")]
+                    xyz = [x.split(",") for x in conf.value.split(";")]
                     for at in parser.model.atom:
                         i = at.index
                         at.coord = [ float(xyz[i][0]), float(xyz[i][1]), float(xyz[i][2]) ]
@@ -142,7 +141,7 @@ def readcex(filename, object=''):  # Aut
             pass
     _cmd.finish_object(_self._COb,modelname)
     f.close()
- 
+
 def colorbyB(selection="spheres",first=7,last=3): # Author: Scott Dixon
     cols = [(0.,0.,1.),(.5,.5,1.),(.8,.8,1.),(1.,1.,1.),
             (1.,.9,.9),(1.,.6,.6),(1.,0.,0.)]
@@ -154,7 +153,7 @@ def colorbyB(selection="spheres",first=7
         b = first - i*incr
         cmd.color(cname,"((%s) and not(b > %f) and b > %f)"%(selection,b,b-incr))
 
-def metaphorics(): 
+def metaphorics():
     cmd.extend("readcex",readcex)
     cmd.extend("colorbyB",colorbyB)
 
@@ -162,16 +161,16 @@ def get_context_info():  # Author: Warre
     context_dict= {}
     context_list= []
     for a in cmd.get_names("all"):
-       context = None   
-       if a[-6:]=='_water': 
-          context = a[:-6] 
-       if a[-7:]=='_ligand':  
-          context = a[:-7] 
-       if a[-5:]=='_site':  
-          context = a[:-5] 
-       if a[-6:]=='_hbond':  
+       context = None
+       if a[-6:]=='_water':
+          context = a[:-6]
+       if a[-7:]=='_ligand':
+          context = a[:-7]
+       if a[-5:]=='_site':
+          context = a[:-5]
+       if a[-6:]=='_hbond':
           context = a[:-6]
-       if context!=None:
+       if context is not None:
            if context not in context_dict:
                context_list.append(context)
                context_dict[context] = [a]
@@ -269,12 +268,12 @@ def setup_contexts(context_info):   # Au
     if len(key_list):
         key = key_list.pop(0)
         cmd.set_key(key,toggle_labels)
-        doc_list.append(key+": Toggle Dist")        
+        doc_list.append(key+": Toggle Dist")
     if len(key_list):
         key = key_list.pop(0)
         cmd.set_key(key,lambda :(cmd.zoom(),toggle_labels(0)))
         doc_list.append(key+": Zoom All")
-    
+
     for a in list:
         water = a+"_water"
         ligand = a+"_ligand"
@@ -314,12 +313,12 @@ def setup_contexts(context_info):   # Au
                 else:
                     cont_name = a
                 doc_list.append(key+": Zoom "+cont_name)
-                
+
         if hbond in name_list:
             cmd.show("dashes",hbond)
             cmd.show("labels",hbond)
 
-        
+
     cmd.wizard("fedora",doc_list)
     if zoom_context not in (0,1):
         cmd.zoom(zoom_context)
@@ -330,14 +329,14 @@ def setup_contexts(context_info):   # Au
     cmd.feedback("disable","scene","actions")
     cmd.set("internal_feedback",1)
     cmd.set("internal_prompt",0)
-    
-        
+
+
 def setup_alignment_contexts(context_info):   # Author: Warren DeLano
     (list,dict) = context_info[0:2]
     doc_list = ['\888Legend:']
     obj_name_dict = {}
     for a in list:
-        sf = string.find(a,"_")
+        sf = a.find("_")
         if sf>=0:
             object_name = a[0:sf]
             if object_name not in obj_name_dict:
@@ -349,7 +348,7 @@ def setup_alignment_contexts(context_inf
                         col_int = [int(x*9+0.49999) for x in col_tup]
                         col_str = ''.join([chr(ord('0')+x) for x in col_int])
                         doc_list.append("\\"+col_str+object_name+"\\---")
-                    
+
     key_list = [
         'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10', #,'F11','F12',
         'SHFT-F1','SHFT-F2','SHFT-F3','SHFT-F4','SHFT-F5','SHFT-F6','SHFT-F7',
@@ -357,7 +356,7 @@ def setup_alignment_contexts(context_inf
     doc_list.append("")
     doc_list.append("\\888Toggles:")
     zoom_context = 1
-                                  
+
     global labels,ligands,waters,sites,cgos,zooms,dashes
     labels = 1
     ligands = 1
@@ -373,7 +372,7 @@ def setup_alignment_contexts(context_inf
 
     cmd.select(m4x_sites,"none")
     cmd.select(m4x_ligands,"none")
-    cmd.select(m4x_waters,"none")   
+    cmd.select(m4x_waters,"none")
     if len(key_list):
         key = key_list.pop(0)
         cmd.set_key(key,toggle_zooms)
@@ -381,28 +380,28 @@ def setup_alignment_contexts(context_inf
     if len(key_list):
         key = key_list.pop(0)
         cmd.set_key(key,toggle_sites)
-        doc_list.append(key+": Sites")        
+        doc_list.append(key+": Sites")
     if len(key_list):
         key = key_list.pop(0)
         cmd.set_key(key,toggle_waters)
-        doc_list.append(key+": Waters")        
+        doc_list.append(key+": Waters")
     if len(key_list):
         key = key_list.pop(0)
         cmd.set_key(key,toggle_dashes)
-        doc_list.append(key+": H-Bonds")        
+        doc_list.append(key+": H-Bonds")
     if len(key_list):
         key = key_list.pop(0)
         cmd.set_key(key,toggle_cgos)
-        doc_list.append(key+": Fits")        
+        doc_list.append(key+": Fits")
     if len(key_list):
         key = key_list.pop(0)
         cmd.set_key(key,toggle_ligands)
-        doc_list.append(key+": Ligands")        
+        doc_list.append(key+": Ligands")
     if len(key_list):
         key = key_list.pop(0)
         cmd.set_key(key,toggle_labels)
-        doc_list.append(key+": HB-Dists")        
-    
+        doc_list.append(key+": HB-Dists")
+
     for a in list:
         include_flag = 0
         water = a+"_water"
diff -upNr pymol-open-source-2.3.0/modules/pymol/menu.py pymol-open-source-2.3.3/modules/pymol/menu.py
--- pymol-open-source-2.3.0/modules/pymol/menu.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/menu.py	2019-08-22 10:24:47.850617188 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -48,7 +48,7 @@ def extract(self_cmd, sele):
     return [[ 2, 'Extract', '' ],
             [ 1, 'object', 'cmd.create(None,"'+sele+'",extract="'+sele+'",zoom=0)' ],
             [ 1, 'extend 1', 'cmd.create(None,"('+sele+') extend 1",extract="'+sele+'",zoom=0)' ],
-            [ 1, 'byres extend 1', 'cmd.create(None,"byres (('+sele+') extend 1)",extract="'+sele+'",zoom=0)' ],            
+            [ 1, 'byres extend 1', 'cmd.create(None,"byres (('+sele+') extend 1)",extract="'+sele+'",zoom=0)' ],
             ]
 
 def camera_store_with_scene(self_cmd,frame):
@@ -104,9 +104,9 @@ def smooth(self_cmd,extra=''):
     return [[ 1, 'a little'  ,   'cmd.mview("smooth"%s)'%extra            ],
             [ 1, 'more'     ,   'cmd.mview("smooth",window=15%s)'%extra ],
             [ 1, 'a lot'   ,   'cmd.mview("smooth",window=30%s)'%extra ]]
-              
+
 def camera_motion(self_cmd, frame="0"):
-    return [[ 2, 'Camera Motion:'     , ''                       ],     
+    return [[ 2, 'Camera Motion:'     , ''                       ],
             [ 1, 'store'         , 'cmd.mview("store",first='+frame+')'      ],
             [ 1, 'store with scene' , camera_store_with_scene(self_cmd,frame) ],
             [ 1, 'store with state' , store_with_state(self_cmd,'',frame) ],
@@ -114,21 +114,21 @@ def camera_motion(self_cmd, frame="0"):
             [ 0, ''               ,''                             ],
             [ 1, 'reset camera motions'   , 'cmd.mview("reset")'   ],
             [ 0, ''               ,''                             ],
-            [ 1, 'purge entire movie'   , 'cmd.mset()'   ],            
+            [ 1, 'purge entire movie'   , 'cmd.mset()'   ],
             [ 0, ''               ,''                             ],
             [ 1, 'smooth key frames'  ,   smooth(self_cmd)     ],
             [ 0, ''               ,''                             ],
             [ 1, 'interpolate'   , 'cmd.mview("interpolate")'   ],
-            [ 1, 'reinterpolate'   , 'cmd.mview("reinterpolate")'   ],            
-            [ 1, 'uninterpolate'   , 'cmd.mview("uninterpolate")'   ],            
+            [ 1, 'reinterpolate'   , 'cmd.mview("reinterpolate")'   ],
+            [ 1, 'uninterpolate'   , 'cmd.mview("uninterpolate")'   ],
             ]
 
 def obj_motion(self_cmd, obj, frame="0"):
-    return [[ 2, 'Object "'+obj+'" Motion:'     , ''                       ],     
+    return [[ 2, 'Object "'+obj+'" Motion:'     , ''                       ],
             [ 1, 'drag'       ,   'cmd.drag("'+obj+'")'    ],
             [ 0, ''               ,''                             ],
             [ 1, 'store'         , 'cmd.mview("store",object="'+obj+'",first='+frame+')'      ],
-            [ 1, 'store with state' , store_with_state(self_cmd,obj,frame) ],            
+            [ 1, 'store with state' , store_with_state(self_cmd,obj,frame) ],
             [ 1, 'reset'       ,   ';cmd.reset(object="'+obj+'");'    ],
             [ 1, 'clear'       ,   'cmd.mview("clear",object="'+obj+'",first='+frame+')'    ],
             [ 0, ''               ,''                             ],
@@ -219,24 +219,24 @@ def mol_hide(self_cmd, sele):
         [[ 0, ''          , ''                                ],
          [ 1, 'main chain', 'cmd.hide("((byres ('+sele+'))&(bb.&!'+sele_ms_shared+'))")' ],
          [ 1, 'side chain', 'cmd.hide("((byres ('+sele+'))&(sc.&!'+sele_ms_shared+'))")' ],
-         [ 1, 'waters'    , 'cmd.hide("(solvent and ('+sele+'))")'     ],                      
+         [ 1, 'waters'    , 'cmd.hide("(solvent and ('+sele+'))")'     ],
          [ 0, ''          , ''                                ],
          [ 1, 'hydrogens' , hide_hydro(self_cmd, sele) ],
-         [ 0, ''          , ''                                ],           
+         [ 0, ''          , ''                                ],
          [ 1, 'unselected', 'cmd.hide("(not '+sele+')")'         ],
          ]
          + [[ 0, '', ''],
            [ 1, 'valence', 'cmd.set_bond("valence", "0", "'+sele+'",quiet=1)'],
          ] )
 
-        
+
 def measurement_show(self_cmd, sele):
     return [[ 2, 'Show:'     , ''                               ],
               [ 1, 'dashes'    , 'cmd.show("dashes"    ,"'+sele+'")' ],
               [ 1, 'angles'    , 'cmd.show("angles"    ,"'+sele+'")' ],
               [ 1, 'dihedrals' , 'cmd.show("dihedrals" ,"'+sele+'")' ],
               [ 1, 'labels'    , 'cmd.show("labels"    ,"'+sele+'")' ]
-             ]   
+             ]
 
 def measurement_hide(self_cmd, sele):
     return [[ 2, 'Hide:'     , ''                                ],
@@ -249,7 +249,7 @@ def measurement_hide(self_cmd, sele):
 def cgo_show(self_cmd, sele):
     return [[ 2, 'Show:'     , ''                               ],
               [ 1, 'cgo'    , 'cmd.show("cgo"    ,"'+sele+'")' ],
-             ]   
+             ]
 
 def cgo_hide(self_cmd, sele):
     return [[ 2, 'Hide:'     , ''                                ],
@@ -266,38 +266,38 @@ def simple_hide(self_cmd, sele):
 
 def map_show(self_cmd, sele):
     return [[ 2, 'Show:'       , ''                             ],
-              [ 1, 'dots'        , 'cmd.show("dots","'+sele+'")'     ],           
+              [ 1, 'dots'        , 'cmd.show("dots","'+sele+'")'     ],
               [ 1, 'extent'        , 'cmd.show("extent","'+sele+'")'     ],
               [ 1, 'everything'  , 'cmd.show("everything","'+sele+'")'          ]]
 
 def map_hide(self_cmd, sele):
     return [[ 2, 'Hide:'     ,''                                ],
-              [ 1, 'dots'        , 'cmd.hide("dots","'+sele+'")'     ],           
+              [ 1, 'dots'        , 'cmd.hide("dots","'+sele+'")'     ],
               [ 1, 'extent'      , 'cmd.hide("extent","'+sele+'")'     ],
               [ 1, 'everything'    ,'cmd.hide("everything","'+sele+'")'        ]]
 
 def mesh_show(self_cmd, sele):
     return [[ 2, 'Show:'       , ''                             ],
-              [ 1, 'mesh'        , 'cmd.show("mesh","'+sele+'")'     ],           
+              [ 1, 'mesh'        , 'cmd.show("mesh","'+sele+'")'     ],
               [ 1, 'cell'        , 'cmd.show("cell","'+sele+'")'     ],
               [ 1, 'everything'  , 'cmd.show("everything","'+sele+'")'          ]]
 
 def mesh_hide(self_cmd, sele):
     return [[ 2, 'Hide:'       , ''                             ],
-              [ 1, 'mesh'        , 'cmd.hide("mesh","'+sele+'")'     ],                      
-              [ 1, 'cell'        , 'cmd.hide("cell","'+sele+'")'      ],           
+              [ 1, 'mesh'        , 'cmd.hide("mesh","'+sele+'")'     ],
+              [ 1, 'cell'        , 'cmd.hide("cell","'+sele+'")'      ],
               [ 1, 'everything'  , 'cmd.hide("everything","'+sele+'")'          ]]
 
 def surface_show(self_cmd, sele):
     return [[ 2, 'Show:'       , ''                             ],
-              [ 1, 'surface'        , 'cmd.show("surface","'+sele+'")'     ],           
+              [ 1, 'surface'        , 'cmd.show("surface","'+sele+'")'     ],
               [ 1, 'cell'        , 'cmd.show("cell","'+sele+'")'     ],
               [ 1, 'everything'  , 'cmd.show("everything","'+sele+'")'          ]]
 
 def surface_hide(self_cmd, sele):
     return [[ 2, 'Hide:'       , ''                             ],
-              [ 1, 'surface'        , 'cmd.hide("surface","'+sele+'")'     ],                      
-              [ 1, 'cell'        , 'cmd.hide("cell","'+sele+'")'      ],           
+              [ 1, 'surface'        , 'cmd.hide("surface","'+sele+'")'     ],
+              [ 1, 'cell'        , 'cmd.hide("cell","'+sele+'")'      ],
               [ 1, 'everything'  , 'cmd.hide("everything","'+sele+'")'          ]]
 
 def slice_show(self_cmd, sele):
@@ -334,7 +334,7 @@ def by_elem2(self_cmd, sele):
         [1,'\\049C\\777H\\229N\\922O\\950S...','util.cba(17,"'+sele+'",_self=cmd)'],# marine
         [1,'\\760C\\777H\\229N\\922O\\950S...','util.cba(18,"'+sele+'",_self=cmd)'],# olive
         ]
-        
+
 def by_elem3(self_cmd, sele):
     return [
         [ 2, 'Atoms'     ,''                               ],
@@ -347,7 +347,7 @@ def by_elem3(self_cmd, sele):
         [1,'\\499C\\777H\\229N\\922O\\950S...','util.cba(5257,"'+sele+'",_self=cmd)'],# aquamarine
         [1,'\\994C\\777H\\229N\\922O\\950S...','util.cba(5256,"'+sele+'",_self=cmd)'],# paleyellow
         ]
-    
+
 def by_elem4(self_cmd, sele):
     return [
         [ 2, 'Atoms'     ,''                               ],
@@ -386,7 +386,7 @@ def by_elem6(self_cmd, sele):
 [1,'\\191C\\521H\\229N\\922O\\950S...','util.cbh("chocolate","'+sele+'",_self=cmd)'],# chocolate
 [1,'\\191C\\000H\\229N\\922O\\950S...','util.cbh("black","'+sele+'",_self=cmd)'],# black
               ]
-    
+
 def by_elem(self_cmd, sele):
     return [
         [ 2, 'Atoms'     ,''                               ],
@@ -403,8 +403,8 @@ def by_elem(self_cmd, sele):
         [ 1, 'set 2'     ,by_elem2(self_cmd, sele)                    ],
         [ 1, 'set 3'     ,by_elem3(self_cmd, sele)                    ],
         [ 1, 'set 4'     ,by_elem4(self_cmd, sele)                    ],
-        [ 1, 'set 5'     ,by_elem5(self_cmd, sele)                    ],      
-        [ 1, 'set 6/H'   ,by_elem6(self_cmd, sele)                    ],      
+        [ 1, 'set 5'     ,by_elem5(self_cmd, sele)                    ],
+        [ 1, 'set 6/H'   ,by_elem6(self_cmd, sele)                    ],
               ]
 
 def by_ss(self_cmd, sele):
@@ -463,7 +463,7 @@ def by_chain(self_cmd, sele):
                  'util.color_chains("('+sele+')",_self=cmd)'],
                       [ 0, ''                                , ''                 ],
               [ 1, '\\900c\\950h\\990a\\090i\\099n\\059b\\009o\\705w\\888s',
-                 'util.chainbow("('+sele+')",_self=cmd)'],                                 
+                 'util.chainbow("('+sele+')",_self=cmd)'],
               [ 0, '', '' ],
               [ 1, by_segi + '(elem C)', 'cmd.spectrum("segi","rainbow","('+sele+') & elem C")'],
               [ 1, by_segi, 'cmd.spectrum("segi","rainbow","' + sele + '")' ],
@@ -629,7 +629,7 @@ def all_colors(self_cmd, sele):
     expr = 'util.color_deep("{0}", ' + repr(sele) + ', 0)'
     with menucontext(self_cmd, sele):
         return all_colors_generic(self_cmd, expr)
- 
+
 def vol_color(self_cmd, sele):
     from pymol.colorramping import namedramps
     rsele = repr(sele)
@@ -651,14 +651,14 @@ def color_auto(self_cmd, sele):
         [ 2, 'Auto'     ,''                               ],
         [ 1, 'elem C', 'cmd.color("auto","('+sele+') and elem C")' ],
         [ 0, ''                                , ''                 ],
-        [ 1, 'all','cmd.color("auto","'+sele+'")' ],                  
+        [ 1, 'all','cmd.color("auto","'+sele+'")' ],
         [ 0, ''                                , ''                 ],
         [ 1, '\\900b\\950y \\090o\\099b\\059j\\999(elem C)',
           'util.color_objs("('+sele+' and elem C)",_self=cmd)'],
         [ 1, '\\900b\\950y \\090o\\099b\\059j',
           'util.color_objs("('+sele+')",_self=cmd)'],
         ]
-   
+
 def mol_color(self_cmd, sele):
     with menucontext(self_cmd, sele):
       return (
@@ -670,7 +670,7 @@ def mol_color(self_cmd, sele):
          [ 1, '\\900s\\950p\\990e\\090c\\099t\\059r\\009u\\555m', spectrum(self_cmd, sele) ],
          [ 0, ''                                , ''                 ],
          [ 1, 'auto', color_auto(self_cmd, sele) ],
-         [ 0, ''                                , ''                 ],         
+         [ 0, ''                                , ''                 ],
          ] +
         all_colors(self_cmd, sele))
 
@@ -716,11 +716,11 @@ def preset_ligand_sites(self_cmd, sele):
               [ 1, 'mesh surface'   , 'preset.ligand_sites_mesh("'+sele+'",_self=cmd)'          ]]
 
 def presets(self_cmd, sele):
-    return [[ 2, 'Preset:'       ,''                        ],     
+    return [[ 2, 'Preset:'       ,''                        ],
               [ 1, 'classified', 'preset.classified("'+sele+'",_self=cmd)' ],
               [ 0, '', '' ],
               [ 1, 'simple'   ,'preset.simple("'+sele+'",_self=cmd)'          ],
-              [ 1, 'simple (no solvent)'   ,'preset.simple_no_solv("'+sele+'",_self=cmd)'          ],           
+              [ 1, 'simple (no solvent)'   ,'preset.simple_no_solv("'+sele+'",_self=cmd)'          ],
               [ 1, 'ball and stick' , 'preset.ball_and_stick("'+sele+'",_self=cmd)' ],
               [ 1, 'b factor putty' , 'preset.b_factor_putty("'+sele+'",_self=cmd)' ],
               [ 1, 'technical'   , 'preset.technical("'+sele+'",_self=cmd)'          ],
@@ -730,14 +730,14 @@ def presets(self_cmd, sele):
               [ 1, 'pretty (with solvent)'     , 'preset.pretty_solv("'+sele+'",_self=cmd)'          ],
               [ 1, 'publication '   , 'preset.publication("'+sele+'",_self=cmd)'          ],
               [ 1, 'publication (with solvent)'   , 'preset.pub_solv("'+sele+'",_self=cmd)'          ],
-              [ 0, ''               ,''                             ],                      
+              [ 0, ''               ,''                             ],
               [ 1, 'protein interface', 'preset.interface("'+sele+'",_self=cmd)' ],
               [ 0, '', '' ],
-              [ 1, 'default'   ,'preset.default("'+sele+'",_self=cmd)'          ],           
+              [ 1, 'default'   ,'preset.default("'+sele+'",_self=cmd)'          ],
               ]
 
 def hydrogens(self_cmd, sele):
-   return [[ 2, 'Hydrogens:'       ,''                        ],     
+   return [[ 2, 'Hydrogens:'       ,''                        ],
            [ 1, 'add'   ,'cmd.h_add("'+sele+'");cmd.sort("'+sele+' extend 1")' ],
            [ 1, 'add polar' , 'cmd.h_add("'+sele+' & (don.|acc.)");cmd.sort("'+sele+' extend 1")' ],
            [ 1, 'remove'   ,'cmd.remove("('+sele+') and hydro")'          ],
@@ -754,29 +754,29 @@ def state(self_cmd, sele):
               [ 0, '', '' ],
               [ 1, 'split'   ,'cmd.split_states("'+sele+'")' ],
               ]
-    
+
 def movement(self_cmd, sele):
-    return [[ 2, 'Movement:'       ,''                        ],     
+    return [[ 2, 'Movement:'       ,''                        ],
               [ 1, 'protect'   ,'cmd.protect("'+sele+'")'          ],
-              [ 1, 'deprotect'   ,'cmd.deprotect("'+sele+'")'          ],           
+              [ 1, 'deprotect'   ,'cmd.deprotect("'+sele+'")'          ],
               ]
 
 def sequence(self_cmd, sele):
-    return [[ 2, 'Sequence:'       ,''                        ],     
+    return [[ 2, 'Sequence:'       ,''                        ],
               [ 1, 'include'   ,'cmd.set("seq_view","on","'+sele+'")'          ],
               [ 1, 'exclude'   ,'cmd.set("seq_view","off","'+sele+'")'          ],
-              [ 0, ''               ,''                             ],                      
-              [ 1, 'default'   ,'cmd.unset("seq_view","'+sele+'")'          ],                      
+              [ 0, ''               ,''                             ],
+              [ 1, 'default'   ,'cmd.unset("seq_view","'+sele+'")'          ],
               ]
 
 def masking(self_cmd, sele):
-    return [[ 2, 'Masking:'       ,''                        ],     
+    return [[ 2, 'Masking:'       ,''                        ],
               [ 1, 'mask'   ,'cmd.mask("'+sele+'")'          ],
-              [ 1, 'unmask'   ,'cmd.unmask("'+sele+'")'          ],           
+              [ 1, 'unmask'   ,'cmd.unmask("'+sele+'")'          ],
               ]
 
 def compute(self_cmd, sele):
-    return [[ 2, 'Compute:', '' ],     
+    return [[ 2, 'Compute:', '' ],
             [ 1, 'atom count'   ,'cmd.count_atoms("'+sele+'",quiet=0)'          ],
             [ 1, 'charges',
               [[ 2, 'Charge:', ''],
@@ -823,7 +823,7 @@ def symmetry(self_cmd, sele):
               [ 1, 'within 1000 A', 'cmd.symexp("'+sele+'_","'+sele+'","'+sele+'",cutoff=1000,segi=1)'          ]]
 
 def mol_assign(self_cmd, sele):
-    return [[ 2, 'Assign:'       ,''                        ],     
+    return [[ 2, 'Assign:'       ,''                        ],
               [ 1, 'Amber 99 atomic properties',  'util.assign_amber99("'+sele+'",_self=cmd)' ],
               ]
 
@@ -836,7 +836,7 @@ def selection(self_cmd, sele):
               [ 1, 'polar hydrogens', 'cmd.select("'+sele+'_polar_h","('+sele+') and (e. H and bound_to e. S+O+N)")'],
               [ 1, 'non-polar hydrogens', 'cmd.select("'+sele+'_npolar_h","('+sele+') and (e. H and (not bound_to e. S+O+N))")'],
               [ 1, 'donors', 'cmd.select("'+sele+'_donors","('+sele+') and hbd")'],
-              [ 1, 'acceptors', 'cmd.select("'+sele+'_acceptors","('+sele+') and hba")'],           
+              [ 1, 'acceptors', 'cmd.select("'+sele+'_acceptors","('+sele+') and hba")'],
               [ 1, 'surface atoms', 'util.find_surface_atoms(sele="'+sele+'", _self=cmd)' ],
               [ 1, 'C-alphas', 'cmd.select("'+sele+'_calpha","bycalpha ('+sele+')")'],
               ]
@@ -848,13 +848,13 @@ def mol_generate(self_cmd, sele):
               [ 1, 'vacuum electrostatics', vacuum(self_cmd, sele) ],
 #           [ 1, 'assign', mol_assign(self_cmd, sele) ],
               ]
-    
+
 def invert(self_cmd, sele):
-    return [[ 2, 'Invert:'       ,''                        ],     
+    return [[ 2, 'Invert:'       ,''                        ],
               [ 1, 'within object(s)'     ,'cmd.select("'+sele+'","((byobj '+sele+') and not '+sele+')",enable=1)'    ],
-              [ 1, 'within segment(s)'     ,'cmd.select("'+sele+'","((byseg '+sele+') and not '+sele+')",enable=1)'    ],           
+              [ 1, 'within segment(s)'     ,'cmd.select("'+sele+'","((byseg '+sele+') and not '+sele+')",enable=1)'    ],
               [ 1, 'within chain(s)'     ,'cmd.select("'+sele+'","((bychain '+sele+') and not '+sele+')",enable=1)'    ],
-              [ 1, 'within residue(s)'   ,'cmd.select("'+sele+'","((byres '+sele+') and not '+sele+')",enable=1)'    ],                      
+              [ 1, 'within residue(s)'   ,'cmd.select("'+sele+'","((byres '+sele+') and not '+sele+')",enable=1)'    ],
               [ 0, ''               ,''                             ],
               [ 1, 'within molecule(s)'     ,'cmd.select("'+sele+'","((bymol '+sele+') and not '+sele+')",enable=1)'    ],
               [ 0, ''               ,''                             ],
@@ -862,16 +862,16 @@ def invert(self_cmd, sele):
               ]
 
 def complete(self_cmd, sele):
-    return [[ 2, 'Complete:'       ,''                        ],     
+    return [[ 2, 'Complete:'       ,''                        ],
 
               [ 1, 'residues'  ,'cmd.select("'+sele+'","(byres '+sele+')",enable=1)'      ],
               [ 1, 'chains'  ,'cmd.select("'+sele+'","(bychain '+sele+')",enable=1)'      ],
               [ 1, 'segments'  ,'cmd.select("'+sele+'","(byseg '+sele+')",enable=1)'      ],
               [ 1, 'objects'  ,'cmd.select("'+sele+'","(byobj '+sele+')",enable=1)'      ],
-              [ 0, ''               ,''                             ],           
+              [ 0, ''               ,''                             ],
               [ 1, 'molecules'  ,'cmd.select("'+sele+'","(bymol '+sele+')",enable=1)'      ],
               [ 0, ''               ,''                             ],
-              [ 1, 'C-alphas'  ,'cmd.select("'+sele+'","(bycalpha '+sele+')",enable=1)'      ],           
+              [ 1, 'C-alphas'  ,'cmd.select("'+sele+'","(bycalpha '+sele+')",enable=1)'      ],
               ]
 
 def modify_by_object(self_cmd, sele, op):
@@ -893,10 +893,10 @@ def modify_by_sele(self_cmd, sele, op):
     return result
 
 def restrict(self_cmd, sele):
-    return [[ 2, 'Restrict:'       ,''                        ],     
+    return [[ 2, 'Restrict:'       ,''                        ],
             [ 1, 'to object'   , modify_by_object(self_cmd, sele,'and') ],
             [ 1, 'to selection' , modify_by_sele(self_cmd, sele,'and') ],
-            [ 0, ''               ,''                             ],           
+            [ 0, ''               ,''                             ],
             [ 1, 'to visible'   , 'cmd.select("'+sele+'","('+sele+') and vis",enable=1)'],
             [ 0, ''               ,''                             ],
             [ 1, 'to polymer'   , 'cmd.select("'+sele+'","('+sele+') and polymer",enable=1)'],
@@ -906,18 +906,18 @@ def restrict(self_cmd, sele):
             ]
 
 def include(self_cmd, sele):
-    return [[ 2, 'Include:'       ,''                        ],     
+    return [[ 2, 'Include:'       ,''                        ],
               [ 1, 'object'   , modify_by_object(self_cmd, sele,'or') ],
               [ 1, 'selection' , modify_by_sele(self_cmd, sele,'or') ],
-              [ 0, ''               ,''                             ],           
+              [ 0, ''               ,''                             ],
               [ 1, 'visible'   , 'cmd.select("'+sele+'","('+sele+') or vis",enable=1)'],
               ]
 
 def exclude(self_cmd, sele):
-    return [[ 2, 'Exclude:'       ,''                        ],     
+    return [[ 2, 'Exclude:'       ,''                        ],
             [ 1, 'object'   , modify_by_object(self_cmd, sele,'and not') ],
             [ 1, 'selection' , modify_by_sele(self_cmd, sele,'and not') ],
-            [ 0, ''               ,''                             ],           
+            [ 0, ''               ,''                             ],
             [ 1, 'polymer'   , 'cmd.select("'+sele+'","('+sele+') and not organic",enable=1)'],
             [ 1, 'solvent'   , 'cmd.select("'+sele+'","('+sele+') and not solvent",enable=1)'],
             [ 1, 'organic'   , 'cmd.select("'+sele+'","('+sele+') and not organic",enable=1)'],
@@ -925,13 +925,13 @@ def exclude(self_cmd, sele):
             ]
 
 def expand(self_cmd, sele):
-    return [[ 2, 'Expand:'       ,''                        ],     
+    return [[ 2, 'Expand:'       ,''                        ],
               [ 1, 'by 4 A'  ,'cmd.select("'+sele+'","('+sele+' expand 4)",enable=1)' ],
               [ 1, 'by 5 A'  ,'cmd.select("'+sele+'","('+sele+' expand 5)",enable=1)' ],
-              [ 1, 'by 6 A'  ,'cmd.select("'+sele+'","('+sele+' expand 6)",enable=1)' ],           
+              [ 1, 'by 6 A'  ,'cmd.select("'+sele+'","('+sele+' expand 6)",enable=1)' ],
               [ 1, 'by 8 A'  ,'cmd.select("'+sele+'","('+sele+' expand 8)",enable=1)' ],
               [ 1, 'by 12 A'  ,'cmd.select("'+sele+'","('+sele+' expand 12)",enable=1)' ],
-              [ 1, 'by 20 A'  ,'cmd.select("'+sele+'","('+sele+' expand 20)",enable=1)' ],           
+              [ 1, 'by 20 A'  ,'cmd.select("'+sele+'","('+sele+' expand 20)",enable=1)' ],
               [ 0, ''               ,''                             ],
               [ 1, 'by 4 A, residues'  ,'cmd.select("'+sele+'","(byres ('+sele+' expand 4))",enable=1)' ],
               [ 1, 'by 5 A, residues'  ,'cmd.select("'+sele+'","(byres ('+sele+' expand 5))",enable=1)' ],
@@ -942,30 +942,30 @@ def expand(self_cmd, sele):
               ]
 
 def around(self_cmd, sele):
-    return [[ 2, 'Around:'       ,''                        ],     
+    return [[ 2, 'Around:'       ,''                        ],
               [ 1, 'atoms within 4 A'  ,'cmd.select("'+sele+'","('+sele+' around 4)",enable=1)' ],
-              [ 1, 'atoms within 5 A'  ,'cmd.select("'+sele+'","('+sele+' around 5)",enable=1)' ],           
-              [ 1, 'atoms within 6 A'  ,'cmd.select("'+sele+'","('+sele+' around 6)",enable=1)' ],           
+              [ 1, 'atoms within 5 A'  ,'cmd.select("'+sele+'","('+sele+' around 5)",enable=1)' ],
+              [ 1, 'atoms within 6 A'  ,'cmd.select("'+sele+'","('+sele+' around 6)",enable=1)' ],
               [ 1, 'atoms within 8 A'  ,'cmd.select("'+sele+'","('+sele+' around 8)",enable=1)' ],
               [ 1, 'atoms within 12 A'  ,'cmd.select("'+sele+'","('+sele+' around 12)",enable=1)' ],
               [ 1, 'atoms within 20 A'  ,'cmd.select("'+sele+'","('+sele+' around 20)",enable=1)' ],
-              [ 0, ''               ,''                             ],           
+              [ 0, ''               ,''                             ],
               [ 1, 'residues within 4 A'  ,'cmd.select("'+sele+'","(byres ('+sele+' around 4))",enable=1)' ],
-              [ 1, 'residues within 5 A'  ,'cmd.select("'+sele+'","(byres ('+sele+' around 5))",enable=1)' ],           
+              [ 1, 'residues within 5 A'  ,'cmd.select("'+sele+'","(byres ('+sele+' around 5))",enable=1)' ],
               [ 1, 'residues within 6 A'  ,'cmd.select("'+sele+'","(byres ('+sele+' around 6))",enable=1)' ],
               [ 1, 'residues within 8 A'  ,'cmd.select("'+sele+'","(byres ('+sele+' around 8))",enable=1)' ],
               [ 1, 'residues within 12 A'  ,'cmd.select("'+sele+'","(byres ('+sele+' around 12))",enable=1)' ],
-              [ 1, 'residues within 20 A'  ,'cmd.select("'+sele+'","(byres ('+sele+' around 20))",enable=1)' ],                                 
+              [ 1, 'residues within 20 A'  ,'cmd.select("'+sele+'","(byres ('+sele+' around 20))",enable=1)' ],
               ]
-    
+
 def extend(self_cmd, sele):
-    return [[ 2, 'Extend:'       ,''                        ],     
+    return [[ 2, 'Extend:'       ,''                        ],
               [ 1, 'by 1 bond'  ,'cmd.select("'+sele+'","('+sele+' extend 1)",enable=1)' ],
-              [ 1, 'by 2 bonds'  ,'cmd.select("'+sele+'","('+sele+' extend 2)",enable=1)' ],           
+              [ 1, 'by 2 bonds'  ,'cmd.select("'+sele+'","('+sele+' extend 2)",enable=1)' ],
               [ 1, 'by 3 bonds'  ,'cmd.select("'+sele+'","('+sele+' extend 3)",enable=1)' ],
               [ 1, 'by 4 bonds'  ,'cmd.select("'+sele+'","('+sele+' extend 4)",enable=1)' ],
               [ 1, 'by 5 bonds'  ,'cmd.select("'+sele+'","('+sele+' extend 5)",enable=1)' ],
-              [ 1, 'by 6 bonds'  ,'cmd.select("'+sele+'","('+sele+' extend 6)",enable=1)' ],           
+              [ 1, 'by 6 bonds'  ,'cmd.select("'+sele+'","('+sele+' extend 6)",enable=1)' ],
               [ 0, ''               ,''                             ],
               [ 1, 'by 1 bond, residues'  ,'cmd.select("'+sele+'","(byres ('+sele+' extend 1))",enable=1)' ],
               [ 1, 'by 2 bonds, residues'  ,'cmd.select("'+sele+'","(byres ('+sele+' extend 2))",enable=1)' ],
@@ -1090,7 +1090,7 @@ def mol_align(self_cmd, sele):
 
 def modify_sele(self_cmd, sele):
     return [[ 2, 'Modify:', ''],
-              [ 1, 'around'         , around(self_cmd, sele)         ],           
+              [ 1, 'around'         , around(self_cmd, sele)         ],
               [ 1, 'expand'         , expand(self_cmd, sele)         ],
               [ 1, 'extend'         , extend(self_cmd, sele)         ],
               [ 1, 'invert'         , invert(self_cmd, sele)         ],
@@ -1123,19 +1123,19 @@ def move_to_group(self_cmd, sele):
         [ 1, gname, 'cmd.group("' + gname + '","' + sele + '",quiet=0)' ]
         for gname in gnames if gname != sele
     ]
-              
+
 def sele_action(self_cmd, sele):
-    return [[ 2, 'Action:'       ,''                        ],     
+    return [[ 2, 'Action:'       ,''                        ],
               [ 1, del_col + 'delete selection', 'cmd.delete("'+sele+'")'          ],
               [ 1, 'rename selection', 'cmd.wizard("renaming","'+sele+'")'          ],
               [ 0, ''               ,''                             ],
               [ 1, 'zoom'           ,'cmd.zoom("'+sele+'",animate=-1)'            ],
               [ 1, 'orient'         ,'cmd.orient("'+sele+'",animate=-1)'          ],
-              [ 1, 'center'         ,'cmd.center("'+sele+'",animate=-1)'            ],           
+              [ 1, 'center'         ,'cmd.center("'+sele+'",animate=-1)'            ],
               [ 1, 'origin'         ,'cmd.origin("'+sele+'")'          ],
               [ 0, ''               ,''                             ],
               [ 1, 'drag coordinates'     , 'cmd.drag("'+sele+'")'    ],
-              [ 1, 'clean'       , 'cmd.clean("'+sele+'")'    ],                                    
+              [ 1, 'clean'       , 'cmd.clean("'+sele+'")'    ],
               [ 0, ''               ,''                             ],
               [ 1, 'modify', modify_sele(self_cmd, sele) ],
               [ 1, 'preset'         ,presets(self_cmd, sele)         ],
@@ -1156,7 +1156,7 @@ def sele_action(self_cmd, sele):
 
 
 def sele_action2(self_cmd, sele):
-    return [[ 2, 'Action:'       ,''                        ],     
+    return [[ 2, 'Action:'       ,''                        ],
               [ 1, del_col + 'delete selection', 'cmd.delete("'+sele+'")'          ],
               [ 1, 'rename selection', 'cmd.wizard("renaming","'+sele+'")'          ],
               [ 0, ''               ,''                             ],
@@ -1165,7 +1165,7 @@ def sele_action2(self_cmd, sele):
               [ 0, ''               ,''                             ],
               [ 1, rem_col + 'remove atoms'   ,'cmd.remove("'+sele+'");cmd.delete("'+sele+'")'          ],
               [ 0, ''               ,''                             ],
-              [ 1, 'around'         , around(self_cmd, sele)         ],           
+              [ 1, 'around'         , around(self_cmd, sele)         ],
               [ 1, 'expand'         , expand(self_cmd, sele)         ],
               [ 1, 'extend'         , extend(self_cmd, sele)         ],
               [ 1, 'invert'         , invert(self_cmd, sele)         ],
@@ -1177,12 +1177,12 @@ def sele_action2(self_cmd, sele):
             [ 0, ''          ,''                                  ],
               [ 1, 'masking'      , masking(self_cmd, sele)         ],
               [ 1, 'movement'       , movement(self_cmd, sele)         ],
-              [ 1, 'compute'        , compute(self_cmd, sele)         ],           
+              [ 1, 'compute'        , compute(self_cmd, sele)         ],
               ]
 
 
 def group_action(self_cmd, sele):
-    return [[ 2, 'Action:'     , ''                       ],     
+    return [[ 2, 'Action:'     , ''                       ],
             [ 1, 'zoom'         , 'cmd.zoom("'+sele+'",animate=-1)'      ],
             [ 1, 'orient'       , 'cmd.orient("'+sele+'",animate=-1)'    ],
             [ 1, 'center'         ,'cmd.center("'+sele+'",animate=-1)'            ],
@@ -1190,11 +1190,11 @@ def group_action(self_cmd, sele):
             [ 0, ''               ,''                             ],
             [ 1, 'drag' , 'cmd.drag("'+sele+'")' ],
             [ 1, 'reset' , 'cmd.reset(object="'+sele+'")' ],
-            [ 0, ''               ,''                             ],            
+            [ 0, ''               ,''                             ],
             [ 1, 'preset'  ,   presets(self_cmd, sele)       ],
             [ 1, 'find',     find(self_cmd, sele) ],
-            [ 1, 'align',     mol_align(self_cmd, sele) ],                      
-            [ 1, 'generate'  ,   mol_generate(self_cmd, sele)       ],           
+            [ 1, 'align',     mol_align(self_cmd, sele) ],
+            [ 1, 'generate'  ,   mol_generate(self_cmd, sele)       ],
             [ 0, ''               ,''                             ],
             [ 1, 'assign sec. struc.'  ,'cmd.dss("'+sele+'")'        ],
             [ 0, ''             , ''                       ],
@@ -1202,18 +1202,18 @@ def group_action(self_cmd, sele):
             [ 1, 'group' , lambda: move_to_group(self_cmd, sele) ],
             [ 1, del_col + 'delete group', 'cmd.delete("'+sele+'")'    ],
             [ 0, ''          ,''                                              ],
-            [ 1, 'hydrogens' , hydrogens(self_cmd, sele)    ],           
+            [ 1, 'hydrogens' , hydrogens(self_cmd, sele)    ],
             [ 1, rem_col + 'remove waters', 'cmd.remove("(solvent and ('+sele+'))")'     ],
             [ 0, ''          ,''                                              ],
-            [ 1, 'state'          , state(self_cmd, sele)         ],                      
+            [ 1, 'state'          , state(self_cmd, sele)         ],
             [ 1, 'masking'        , masking(self_cmd, sele)         ],
-            [ 1, 'sequence'       , sequence(self_cmd, sele)         ],                      
-            [ 1, 'movement'       , movement(self_cmd, sele)         ],           
+            [ 1, 'sequence'       , sequence(self_cmd, sele)         ],
+            [ 1, 'movement'       , movement(self_cmd, sele)         ],
             [ 1, 'compute'        , compute(self_cmd, sele)         ],
             ]
-    
+
 def mol_action(self_cmd, sele):
-    return [[ 2, 'Action:'     , ''                       ],     
+    return [[ 2, 'Action:'     , ''                       ],
             [ 1, 'zoom'         , 'cmd.zoom("'+sele+'",animate=-1)'      ],
             [ 1, 'orient'       , 'cmd.orient("'+sele+'",animate=-1)'    ],
             [ 1, 'center'         ,'cmd.center("'+sele+'",animate=-1)'            ],
@@ -1221,14 +1221,14 @@ def mol_action(self_cmd, sele):
             [ 0, ''               ,''                             ],
             [ 1, 'drag matrix' , 'cmd.drag("'+sele+'")' ],
             [ 1, 'reset matrix' , 'cmd.reset(object="'+sele+'")' ],
-            [ 0, ''               ,''                             ],            
+            [ 0, ''               ,''                             ],
             [ 1, 'drag coordinates' , 'cmd.drag("('+sele+')")' ],
             [ 1, 'clean'       , 'cmd.clean("'+sele+'")'    ],
             [ 0, ''          ,''                                              ],
             [ 1, 'preset'  ,   presets(self_cmd, sele)       ],
             [ 1, 'find',     find(self_cmd, sele) ],
-            [ 1, 'align',     mol_align(self_cmd, sele) ],                      
-            [ 1, 'generate'  ,   mol_generate(self_cmd, sele)       ],           
+            [ 1, 'align',     mol_align(self_cmd, sele) ],
+            [ 1, 'generate'  ,   mol_generate(self_cmd, sele)       ],
             [ 0, ''               ,''                             ],
             [ 1, 'assign sec. struc.'  ,'cmd.dss("'+sele+'")'        ],
             [ 0, ''             , ''                       ],
@@ -1237,32 +1237,32 @@ def mol_action(self_cmd, sele):
             [ 1, 'group' , lambda: move_to_group(self_cmd, sele) ],
             [ 1, del_col + 'delete object', 'cmd.delete("'+sele+'")'    ],
             [ 0, ''          ,''                                              ],
-            [ 1, 'hydrogens' , hydrogens(self_cmd, sele)    ],           
+            [ 1, 'hydrogens' , hydrogens(self_cmd, sele)    ],
             [ 1, rem_col + 'remove waters', 'cmd.remove("(solvent and ('+sele+'))")'     ],
             [ 0, ''          ,''                                              ],
-              [ 1, 'state'          , state(self_cmd, sele)         ],                      
+              [ 1, 'state'          , state(self_cmd, sele)         ],
               [ 1, 'masking'        , masking(self_cmd, sele)         ],
-              [ 1, 'sequence'       , sequence(self_cmd, sele)         ],                      
-              [ 1, 'movement'       , movement(self_cmd, sele)         ],           
+              [ 1, 'sequence'       , sequence(self_cmd, sele)         ],
+              [ 1, 'movement'       , movement(self_cmd, sele)         ],
               [ 1, 'compute'        , compute(self_cmd, sele)         ],
               ]
 
 def slice_action(self_cmd, sele):
     return [[ 2, 'Action:'     , ''                       ],
               [ 1, 'zoom'         , 'cmd.zoom("'+sele+'",animate=-1)'      ],
-              [ 1, 'center'       , 'cmd.center("'+sele+'",animate=-1)'    ],           
-              [ 1, 'origin'       , 'cmd.origin("'+sele+'")'    ],         
+              [ 1, 'center'       , 'cmd.center("'+sele+'",animate=-1)'    ],
+              [ 1, 'origin'       , 'cmd.origin("'+sele+'")'    ],
               [ 0, ''             , ''                       ],
               [ 1, 'tracking on' , 'cmd.set("slice_track_camera",1,"'+sele+'")'      ],
-              [ 1, 'tracking off' , 'cmd.set("slice_track_camera",0,"'+sele+'")'      ],           
+              [ 1, 'tracking off' , 'cmd.set("slice_track_camera",0,"'+sele+'")'      ],
               [ 0, ''             , ''                       ],
               [ 1, 'height map on' , 'cmd.set("slice_height_map",1,"'+sele+'")'    ],
-              [ 1, 'height map off', 'cmd.set("slice_height_map",0,"'+sele+'")'    ],                    
+              [ 1, 'height map off', 'cmd.set("slice_height_map",0,"'+sele+'")'    ],
               [ 0, ''             , ''                       ],
               [ 1, 'dynamic grid on' , 'cmd.set("slice_dynamic_grid",1,"'+sele+'")'    ],
-              [ 1, 'dynamic grid off', 'cmd.set("slice_dynamic_grid",0,"'+sele+'")'    ],                    
+              [ 1, 'dynamic grid off', 'cmd.set("slice_dynamic_grid",0,"'+sele+'")'    ],
               [ 0, ''             , ''                       ],
-              [ 1, 'rename'       , 'cmd.wizard("renaming","'+sele+'")'          ],           
+              [ 1, 'rename'       , 'cmd.wizard("renaming","'+sele+'")'          ],
               [ 1, 'group' , lambda: move_to_group(self_cmd, sele) ],
               [ 0, ''             , ''                       ],
               [ 1, del_col + 'delete', 'cmd.delete("'+sele+'")'    ],
@@ -1271,14 +1271,14 @@ def slice_action(self_cmd, sele):
 def simple_action(self_cmd, sele):
     return [[ 2, 'Action:'     , ''                       ],
             [ 1, 'zoom'         , 'cmd.zoom("'+sele+'",animate=-1)'      ],
-            [ 1, 'center'       , 'cmd.center("'+sele+'",animate=-1)'    ],           
+            [ 1, 'center'       , 'cmd.center("'+sele+'",animate=-1)'    ],
             [ 1, 'origin'       , 'cmd.origin("'+sele+'")'    ],
-            
+
             [ 0, ''             , ''                       ],
             [ 1, 'drag'       , 'cmd.drag("'+sele+'")'          ],
-            [ 1, 'reset'       , 'cmd.reset(object="'+sele+'")'          ],           
+            [ 1, 'reset'       , 'cmd.reset(object="'+sele+'")'          ],
             [ 0, ''             , ''                       ],
-            [ 1, 'rename'       , 'cmd.wizard("renaming","'+sele+'")'          ],           
+            [ 1, 'rename'       , 'cmd.wizard("renaming","'+sele+'")'          ],
             [ 1, 'group' , lambda: move_to_group(self_cmd, sele) ],
             [ 0, ''             , ''                       ],
             [ 1, del_col + 'delete', 'cmd.delete("'+sele+'")'    ],
@@ -1293,10 +1293,10 @@ def iso_with_negative(mapname, suffix, r
 def map_mesh(self_cmd, sele):
     return [[ 2, 'Mesh:',  '' ],
             [ 1, '@ level 1.0'         , 'cmd.isomesh("'+sele+'_mesh","'+sele+'",1.0)'      ],
-            [ 0, ''             , ''                       ],            
+            [ 0, ''             , ''                       ],
             [ 1, '@ level 2.0'         , 'cmd.isomesh("'+sele+'_mesh","'+sele+'",2.0)'      ],
-            [ 1, '@ level 3.0'         , 'cmd.isomesh("'+sele+'_mesh","'+sele+'",3.0)'      ],            
-            [ 0, ''             , ''                       ],            
+            [ 1, '@ level 3.0'         , 'cmd.isomesh("'+sele+'_mesh","'+sele+'",3.0)'      ],
+            [ 0, ''             , ''                       ],
             [ 1, '@ level +/-1.0'      , iso_with_negative(sele, '_mesh', 'mesh')],
             [ 1, '@ level +/-3.0'      , iso_with_negative(sele, '_mesh', 'mesh', 3, 'green')],
             [ 0, ''             , ''                       ],
@@ -1319,14 +1319,14 @@ def map_volume(self_cmd, sele):
 def map_surface(self_cmd, sele):
     return [[ 2, 'Surface:',  '' ],
             [ 1, '@ level 1.0'         , 'cmd.isosurface("'+sele+'_surf","'+sele+'",1.0)'      ],
-            [ 0, ''             , ''                       ],            
+            [ 0, ''             , ''                       ],
             [ 1, '@ level 2.0'         , 'cmd.isosurface("'+sele+'_surf","'+sele+'",2.0)'      ],
-            [ 1, '@ level 3.0'         , 'cmd.isosurface("'+sele+'_surf","'+sele+'",3.0)'      ],            
+            [ 1, '@ level 3.0'         , 'cmd.isosurface("'+sele+'_surf","'+sele+'",3.0)'      ],
             [ 0, ''             , ''                       ],
             [ 1, '@ level +/-1.0'      , iso_with_negative(sele, '_surf', 'surface')],
             [ 1, '@ level +/-3.0'      , iso_with_negative(sele, '_surf', 'surface', 3, 'green')],
             [ 0, ''             , ''                       ],
-            [ 1, '@ level 0.0'         , 'cmd.isosurface("'+sele+'_surf","'+sele+'",0.0)'      ],            
+            [ 1, '@ level 0.0'         , 'cmd.isosurface("'+sele+'_surf","'+sele+'",0.0)'      ],
             [ 1, '@ level -1.0'         , 'cmd.isosurface("'+sele+'_surf","'+sele+'",-1.0)'      ],
             [ 1, '@ level -2.0'         , 'cmd.isosurface("'+sele+'_surf","'+sele+'",-2.0)'      ],
             [ 1, '@ level -3.0'         , 'cmd.isosurface("'+sele+'_surf","'+sele+'",-3.0)'      ],
@@ -1337,7 +1337,7 @@ def map_gradient(self_cmd, sele):
             [ 1, 'default'         , 'cmd.gradient("'+sele+'_grad","'+sele+'");cmd.ramp_new("'+sele+
               '_grad_ramp","'+sele+'");cmd.color("'+sele+'_grad_ramp","'+sele+'_grad");' ]
             ]
-    
+
 def map_slice(self_cmd, sele):
     return [[ 2, 'Slice:',  '' ],
             [ 1, 'default'         , 'cmd.slice_new("'+sele+'_slice","'+sele+'");cmd.ramp_new("'+sele+
@@ -1353,19 +1353,19 @@ def map_action(self_cmd, sele):
             [ 1, 'mesh'         , map_mesh(self_cmd, sele)  ],
             [ 1, 'surface'      , map_surface(self_cmd, sele)  ],
             [ 1, 'slice'        , map_slice(self_cmd, sele)  ],
-            [ 1, 'gradient'     , map_gradient(self_cmd, sele)  ],                                    
+            [ 1, 'gradient'     , map_gradient(self_cmd, sele)  ],
             [ 1, 'volume'       , map_volume(self_cmd, sele)  ],
             [ 0, ''             , ''                       ],
             [ 1, 'zoom'         , 'cmd.zoom("'+sele+'",animate=-1)'      ],
-            [ 1, 'center'       , 'cmd.center("'+sele+'",animate=-1)'    ],           
+            [ 1, 'center'       , 'cmd.center("'+sele+'",animate=-1)'    ],
             [ 1, 'origin'       , 'cmd.origin("'+sele+'")'    ],
             [ 0, ''             , ''                       ],
             [ 1, 'drag' , 'cmd.drag("'+sele+'")' ],
-            [ 1, 'reset'       , 'cmd.reset(object="'+sele+'")'          ],                       
+            [ 1, 'reset'       , 'cmd.reset(object="'+sele+'")'          ],
             [ 0, ''             , ''                       ],
             [ 1, 'matrix_copy'  , mat_tran(self_cmd, sele, 1) ],
             [ 0, ''             , '' ],
-            [ 1, 'rename'       , 'cmd.wizard("renaming","'+sele+'")'          ],           
+            [ 1, 'rename'       , 'cmd.wizard("renaming","'+sele+'")'          ],
             [ 1, 'group' , lambda: move_to_group(self_cmd, sele) ],
             [ 0, ''             , ''                       ],
             [ 1, del_col + 'delete', 'cmd.delete("'+sele+'")'    ],
@@ -1373,11 +1373,11 @@ def map_action(self_cmd, sele):
 
 def level(self_cmd, sele):
     return [[ 2, 'Level',  '' ],
-            [ 1, 'level 5.0'         , 'cmd.isolevel("'+sele+'",5.0)'      ],            
-            [ 1, 'level 4.0'         , 'cmd.isolevel("'+sele+'",4.0)'      ],                        
+            [ 1, 'level 5.0'         , 'cmd.isolevel("'+sele+'",5.0)'      ],
+            [ 1, 'level 4.0'         , 'cmd.isolevel("'+sele+'",4.0)'      ],
             [ 1, 'level 3.0'         , 'cmd.isolevel("'+sele+'",3.0)'      ],
             [ 1, 'level 2.0'         , 'cmd.isolevel("'+sele+'",2.0)'      ],
-            [ 1, 'level 1.5'         , 'cmd.isolevel("'+sele+'",1.5)'      ],            
+            [ 1, 'level 1.5'         , 'cmd.isolevel("'+sele+'",1.5)'      ],
             [ 1, 'level 1.0'         , 'cmd.isolevel("'+sele+'",1.0)'      ],
             [ 1, 'level 0.5'         , 'cmd.isolevel("'+sele+'",0.5)'      ],
             [ 1, 'level 0.0'         , 'cmd.isolevel("'+sele+'",0.0)'      ],
@@ -1387,7 +1387,7 @@ def level(self_cmd, sele):
             [ 1, 'level -2.0'         , 'cmd.isolevel("'+sele+'",-2.0)'      ],
             [ 1, 'level -3.0'         , 'cmd.isolevel("'+sele+'",-3.0)'      ],
             [ 1, 'level -4.0'         , 'cmd.isolevel("'+sele+'",-4.0)'      ],
-            [ 1, 'level -5.0'         , 'cmd.isolevel("'+sele+'",-5.0)'      ],            
+            [ 1, 'level -5.0'         , 'cmd.isolevel("'+sele+'",-5.0)'      ],
             ]
 
 def surface_action(self_cmd, sele):
@@ -1395,13 +1395,13 @@ def surface_action(self_cmd, sele):
             [ 1, 'level'         , level(self_cmd, sele)  ],
             [ 0, ''             , ''                       ],
             [ 1, 'zoom'         , 'cmd.zoom("'+sele+'",animate=-1)'      ],
-            [ 1, 'center'       , 'cmd.center("'+sele+'",animate=-1)'    ],           
+            [ 1, 'center'       , 'cmd.center("'+sele+'",animate=-1)'    ],
             [ 1, 'origin'       , 'cmd.origin("'+sele+'")'    ],
             [ 0, ''             , ''                       ],
             [ 1, 'drag' , 'cmd.drag("'+sele+'")' ],
-            [ 1, 'reset'       , 'cmd.reset(object="'+sele+'")'          ],                       
+            [ 1, 'reset'       , 'cmd.reset(object="'+sele+'")'          ],
             [ 0, ''             , ''                       ],
-            [ 1, 'rename'       , 'cmd.wizard("renaming","'+sele+'")'          ],           
+            [ 1, 'rename'       , 'cmd.wizard("renaming","'+sele+'")'          ],
             [ 1, 'group' , lambda: move_to_group(self_cmd, sele) ],
             [ 0, ''             , ''                       ],
             [ 1, del_col + 'delete', 'cmd.delete("'+sele+'")'    ],
@@ -1412,13 +1412,13 @@ def mesh_action(self_cmd, sele):
             [ 1, 'level'         , level(self_cmd, sele)  ],
             [ 0, ''             , ''                       ],
             [ 1, 'zoom'         , 'cmd.zoom("'+sele+'",animate=-1)'      ],
-            [ 1, 'center'       , 'cmd.center("'+sele+'",animate=-1)'    ],           
+            [ 1, 'center'       , 'cmd.center("'+sele+'",animate=-1)'    ],
             [ 1, 'origin'       , 'cmd.origin("'+sele+'")'    ],
             [ 0, ''             , ''                       ],
             [ 1, 'drag' , 'cmd.drag("'+sele+'")' ],
-            [ 1, 'reset'       , 'cmd.reset(object="'+sele+'")'          ],                       
+            [ 1, 'reset'       , 'cmd.reset(object="'+sele+'")'          ],
             [ 0, ''             , ''                       ],
-            [ 1, 'rename'       , 'cmd.wizard("renaming","'+sele+'")'          ],           
+            [ 1, 'rename'       , 'cmd.wizard("renaming","'+sele+'")'          ],
             [ 1, 'group' , lambda: move_to_group(self_cmd, sele) ],
             [ 0, ''             , ''                       ],
             [ 1, del_col + 'delete', 'cmd.delete("'+sele+'")'    ],
@@ -1426,13 +1426,15 @@ def mesh_action(self_cmd, sele):
 
 def ramp_action(self_cmd, sele):
     return [[ 2, 'Action:'     , ''                       ],
-              [ 1, del_col + 'delete', 'cmd.delete("'+sele+'")'    ],
-              [ 0, '', '' ],
               [ 1, 'levels', [
                   [ 1, 'Range +/- %.1f' % (L),
                       'cmd.ramp_update("%s", range=[%f, %f])' % (sele, -L, L) ]
                   for L in [0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100]
                   ]],
+              [ 0, '', '' ],
+              [ 1, 'group' , lambda: move_to_group(self_cmd, sele) ],
+              [ 0, '', '' ],
+              [ 1, del_col + 'delete', 'cmd.delete("'+sele+'")'    ],
               ]
 
 def ramp_color(self_cmd, sele):
@@ -1446,30 +1448,30 @@ def ramp_color(self_cmd, sele):
             ]
 
 def test1(self_cmd, sele):
-        return [[ 2, 'Test1:'     , ''                      ],     
+        return [[ 2, 'Test1:'     , ''                      ],
               [ 1, 'zoom'         , 'cmd.zoom("all",animate=-1)'     ],
-              [ 1, 'center'   , 'cmd.center("all",animate=-1)'   ],           
+              [ 1, 'center'   , 'cmd.center("all",animate=-1)'   ],
               [ 1, 'origin'   , 'cmd.origin("all")'   ],
               ]
 
 def test2(self_cmd, sele):
-        return [[ 2, 'Test2:'     , ''                      ],     
+        return [[ 2, 'Test2:'     , ''                      ],
               [ 1, 'zoom'         , 'cmd.zoom("all",animate=-1)'     ],
-              [ 1, 'center'   , 'cmd.center("all",animate=-1)'   ],           
+              [ 1, 'center'   , 'cmd.center("all",animate=-1)'   ],
               [ 1, 'origin'   , 'cmd.origin("all")'   ],
               ]
 
 def all_action(self_cmd, sele):
-    return [[ 2, 'Action:'     , ''                      ],     
+    return [[ 2, 'Action:'     , ''                      ],
               [ 1, 'zoom'         , 'cmd.zoom("all",animate=-1)'     ],
-              [ 1, 'center'   , 'cmd.center("all",animate=-1)'   ],           
+              [ 1, 'center'   , 'cmd.center("all",animate=-1)'   ],
               [ 1, 'origin'   , 'cmd.origin("all")'   ],
-              [ 0, ''             , ''                      ],           
+              [ 0, ''             , ''                      ],
               [ 1, 'preset'  , presets(self_cmd, "all")     ],
-              [ 1, 'find', find(self_cmd, "all") ],           
+              [ 1, 'find', find(self_cmd, "all") ],
               [ 0, ''          ,''                                              ],
               [ 1, 'hydrogens' ,hydrogens(self_cmd, sele)     ],
-#              [ 1, 'add hydrogens' ,'cmd.h_add("'+sele+'")'     ],           
+#              [ 1, 'add hydrogens' ,'cmd.h_add("'+sele+'")'     ],
 #              [ 1, 'remove hydrogens'  ,'cmd.remove("(hydro and ('+sele+'))")'     ],
               [ 1, rem_col + 'remove waters', 'cmd.remove("(solvent and ('+sele+'))")'     ],
               [ 0, ''             , ''                      ],
@@ -1477,23 +1479,23 @@ def all_action(self_cmd, sele):
               [ 0, ''          ,''                                              ],
               [ 1, del_col + 'delete everything', 'cmd.delete("all")'     ],
               [ 0, ''          ,''                                              ],
-              [ 1, 'masking'      , masking(self_cmd, sele)         ],                      
+              [ 1, 'masking'      , masking(self_cmd, sele)         ],
               [ 1, 'movement'       , movement(self_cmd, sele)         ],
-              [ 1, 'compute'        , compute(self_cmd, sele)         ],                      
+              [ 1, 'compute'        , compute(self_cmd, sele)         ],
               ]
 
 def label_props(self_cmd, sele):
-    return [[ 2, 'Other Properties:'       ,''                        ],     
-                             
-              [ 1, 'formal charge' , 
+    return [[ 2, 'Other Properties:'       ,''                        ],
+
+              [ 1, 'formal charge' ,
   'cmd.label("'+sele+'","(\'%+d\'%formal_charge) if formal_charge else \'\'")' ],
               [ 0, ''               , ''                                  ],
-              [ 1, 'partial charge (0.00)' ,            
+              [ 1, 'partial charge (0.00)' ,
   'cmd.label("'+sele+'","\'%.2f\'%partial_charge")'                      ],
-              [ 1, 'partial charge (0.0000)' , 
+              [ 1, 'partial charge (0.0000)' ,
   'cmd.label("'+sele+'","\'%.4f\'%partial_charge")'                      ],
               [ 0, ''               , ''                                  ],
-              [ 1, 'elec. radius'       , 'cmd.label("'+sele+'","\'%1.2f\'%elec_radius")'  ],                                 
+              [ 1, 'elec. radius'       , 'cmd.label("'+sele+'","\'%1.2f\'%elec_radius")'  ],
               [ 0, ''               , ''                                  ],
               [ 1, 'text type'      , 'cmd.label("'+sele+'","text_type")'    ],
               [ 1, 'numeric type'   , 'cmd.label("'+sele+'","numeric_type")' ],
@@ -1502,12 +1504,12 @@ def label_props(self_cmd, sele):
               ]
 
 def label_ids(self_cmd, sele):
-    return [[ 2, 'Atom Identifiers:'       ,''                        ],     
+    return [[ 2, 'Atom Identifiers:'       ,''                        ],
               [ 1, 'rank'           , 'cmd.label("'+sele+'","rank")' ],
               [ 1, 'ID'             , 'cmd.label("'+sele+'","ID")' ],
-              [ 1, 'index'          , 'cmd.label("'+sele+'","index")' ],           
+              [ 1, 'index'          , 'cmd.label("'+sele+'","index")' ],
               ]
-              
+
 def mol_labels(self_cmd, sele):
     with menucontext(self_cmd, sele) as mc:
         return [[ 2, 'Label:'        , ''                                  ],
@@ -1516,15 +1518,15 @@ def mol_labels(self_cmd, sele):
               [ 1, 'residues'       , """cmd.label('''(name """+self_cmd.get("label_anchor")+"""+C1*+C1' and (byres("""+sele+""")))''','''"%s-%s"%(resn,resi)''')"""  ],
               [ 1, 'residues (oneletter)', "cmd.label('''byca(" + sele + ")''', 'oneletter+resi')"],
               [ 1, 'chains'       ,   'util.label_chains("'+sele+'",_self=cmd)'  ],
-              [ 1, 'segments'       ,   'util.label_segments("'+sele+'",_self=cmd)'  ],           
-              [ 0, ''               , ''                                  ],           
+              [ 1, 'segments'       ,   'util.label_segments("'+sele+'",_self=cmd)'  ],
+              [ 0, ''               , ''                                  ],
               [ 1, 'atom name'      , 'cmd.label("'+sele+'","name")'         ],
-              [ 1, 'element symbol' , 'cmd.label("'+sele+'","elem")'         ],           
+              [ 1, 'element symbol' , 'cmd.label("'+sele+'","elem")'         ],
               [ 1, 'residue name'  , 'cmd.label("'+sele+'","resn")'         ],
               [ 1, 'one letter code', 'cmd.label("'+sele+'","oneletter")' ],
               [ 1, 'residue identifier'    , 'cmd.label("'+sele+'","resi")'         ],
               [ 1, 'chain identifier' , 'cmd.label("'+sele+'","chain")'         ],
-              [ 1, 'segment identifier'       , 'cmd.label("'+sele+'","segi")'         ],           
+              [ 1, 'segment identifier'       , 'cmd.label("'+sele+'","segi")'         ],
               [ 0, ''               , ''                                  ],
               [ 1, 'b-factor'       , 'cmd.label("'+sele+'","\'%1.2f\'%b")'  ],
               [ 1, 'occupancy'       , 'cmd.label("'+sele+'","\'%1.2f\'%q")'  ],
@@ -1567,14 +1569,14 @@ def all_option(self_cmd, sele):
         [ 1, 'orient'           ,'cmd.orient("'+sele+'",animate=-1)'            ],
         [ 1, 'center'           ,'cmd.center("'+sele+'",animate=-1)'            ],
         [ 1, 'origin'           ,'cmd.origin("'+sele+'")'            ],
-        [ 1, 'select'        ,'cmd.select("'+sele+'",enable=1,merge=2)'            ],        
+        [ 1, 'select'        ,'cmd.select("'+sele+'",enable=1,merge=2)'            ],
         [ 0, ''             , ''                      ],
         [ 1, 'label'      , mol_labels(self_cmd, sele) ],
         [ 0, '', '' ],
         [ 1, 'enable'         ,'cmd.enable("'+sele+'")'            ],
         [ 1, 'disable'        ,'cmd.disable("'+sele+'")'            ],
         ]
-    
+
 def enable_disable(self_cmd, enable):
     names_enabled = self_cmd.get_names('objects', enabled_only=1)
     if enable:
@@ -1607,11 +1609,11 @@ def scene_main(self_cmd):
         [ 2, 'Scene', '' ],
         [ 1, 'next' , 'cmd.scene()' ],
         [ 0, ''             , ''                      ],
-        [ 1, 'append' , 'cmd.scene("new","append",quiet=0)' ],                
+        [ 1, 'append' , 'cmd.scene("new","append",quiet=0)' ],
         [ 1, 'update' , 'cmd.scene("auto","update",quiet=0)' ],
         [ 0, ''             , ''                      ],
         [ 1, 'recall' , recall_list ],
-        [ 0, ''             , ''                      ],        
+        [ 0, ''             , ''                      ],
         [ 1, 'buttons', scene_buttons(self_cmd)] ]
 
 def main_pseudoatom_sub(self_cmd,pos, screenpos):
@@ -1651,15 +1653,15 @@ def main_menu(self_cmd,pos, screenpos):
         [ 0, ''             , ''                      ],
         [ 1, 'zoom (vis)'           ,'cmd.zoom("visible",animate=-1)'            ],
         [ 1, 'orient (vis)'           ,'cmd.orient("visible",animate=-1)'            ],
-        [ 1, 'center (vis)'           ,'cmd.center("visible",animate=-1)'            ],      
+        [ 1, 'center (vis)'           ,'cmd.center("visible",animate=-1)'            ],
         [ 1, 'reset'           ,'cmd.reset()'            ],
         [ 0, ''             , ''                      ],
         [ 1, 'movie'           , movie_main(self_cmd) ],
         [ 1, 'scene'           , scene_main(self_cmd) ],
         [ 0, ''             , ''                      ],
         [ 1, 'enable', enable_disable(self_cmd, 1) ],
-        [ 1, 'disable', enable_disable(self_cmd,0) ],   
-        [ 0, ''             , ''                      ],           
+        [ 1, 'disable', enable_disable(self_cmd,0) ],
+        [ 0, ''             , ''                      ],
         [ 1, '(all)'      , all_option(self_cmd,"all") ],
         [ 1, '(visible)'      , all_option(self_cmd,"visible") ],
         [ 0, ''             , ''                      ],
@@ -1676,12 +1678,12 @@ def pick_sele(self_cmd, sele, title):
         [ 2, title, '' ],
         [ 1, 'disable'    , 'cmd.disable("'+sele+'")' ],
         [ 0, ''             , ''                      ],
-        [ 1, 'actions', sele_action2(self_cmd, sele) ],  
-        [ 0, ''             , ''                      ],      
+        [ 1, 'actions', sele_action2(self_cmd, sele) ],
+        [ 0, ''             , ''                      ],
         [ 1, 'color'      , mol_color(self_cmd, sele) ],
         [ 1, 'show'      , mol_show(self_cmd, sele) ],
         [ 1, 'hide'      , mol_hide(self_cmd, sele) ],
-        [ 1, 'preset'  , presets(self_cmd, sele)       ],      
+        [ 1, 'preset'  , presets(self_cmd, sele)       ],
         [ 1, 'label'       , mol_labels(self_cmd, sele) ],
         [ 1, 'ss'        , mol_ss(self_cmd, sele) ],
         [ 0, ''             , ''                      ],
@@ -1689,14 +1691,14 @@ def pick_sele(self_cmd, sele, title):
         [ 1, 'orient'           ,'cmd.orient("'+sele+'",animate=-1)'            ],
         [ 1, 'center'           ,'cmd.center("'+sele+'",animate=-1)'            ],
         [ 1, 'origin'           ,'cmd.origin("'+sele+'")'            ],
-        [ 0, ''               ,''                             ],        
+        [ 0, ''               ,''                             ],
         [ 1, 'drag'             ,'cmd.drag("'+sele+'")'            ],
-        [ 1, 'clean'             ,'cmd.clean("'+sele+'")'            ],        
-        [ 0, ''               ,''                             ],        
+        [ 1, 'clean'             ,'cmd.clean("'+sele+'")'            ],
+        [ 0, ''               ,''                             ],
         [ 1, rem_col + 'remove', 'cmd.remove("'+sele+'")'            ],
         ]
     return result
-    
+
 def pick_option(self_cmd, sele, title, object=0):
     if object:
         sele = self_cmd.identify(sele, 1)[0][0]
@@ -1705,7 +1707,7 @@ def pick_option(self_cmd, sele, title, o
         [ 1, 'color'      , lambda: mol_color(self_cmd, sele) ],
         [ 1, 'show'      , mol_show(self_cmd, sele) ],
         [ 1, 'hide'      , mol_hide(self_cmd, sele) ],
-        [ 1, 'preset'  , presets(self_cmd, sele)       ],      
+        [ 1, 'preset'  , presets(self_cmd, sele)       ],
         [ 1, 'label'          , mol_labels(self_cmd, sele) ],
         [ 0, ''             , ''                      ],
         [ 1, 'zoom'           ,'cmd.zoom("'+sele+'",animate=-1)'            ],
@@ -1720,24 +1722,24 @@ def pick_option(self_cmd, sele, title, o
                                      [ 1, 'matrix', 'cmd.drag("'+sele+'",mode=1)']]])
     else:
         result.append([ 1, 'drag'   ,  'cmd.drag("'+sele+'")'])
-        
+
     result.extend([
-        [ 1, 'clean'             ,'cmd.clean("'+sele+'")'            ],        
+        [ 1, 'clean'             ,'cmd.clean("'+sele+'")'            ],
         [ 1, 'masking'        , masking(self_cmd, sele)         ],
         [ 1, 'movement'       , movement(self_cmd, sele)         ],
         ])
-  
+
     if object:
         result.extend([
             [ 1, del_col + 'delete', 'cmd.delete("'+sele+'")'            ],
-            [ 0, ''             , ''                      ],         
+            [ 0, ''             , ''                      ],
             [ 1, 'disable'        ,'cmd.disable("'+sele+'")'            ],
             [ 1, 'disable others' ,'cmd.disable("*");cmd.enable("'+sele+'", 1)' ],
             ])
     else:
         result.extend([
             [ 1, rem_col + 'remove atoms', 'cmd.remove("'+sele+'")' ],
-            [ 0, ''             , ''                      ],      
+            [ 0, ''             , ''                      ],
             [ 1, 'copy to object' , lambda: copy_to(self_cmd, sele) ],
             [ 1, 'extract object' ,'cmd.extract(None,"'+sele+'",zoom=0)' ],
             ])
@@ -1767,13 +1769,13 @@ def seq_option(self_cmd, sele, title, ob
     while title[c]!='/':
         c = c-1
     title = title[0:c+1]
-    
+
     result = [
         [ 2, title, '' ],
         [ 1, 'color'     , mol_color(self_cmd, sele) ],
         [ 1, 'show'      , mol_show(self_cmd, sele) ],
         [ 1, 'hide'      , mol_hide(self_cmd, sele) ],
-        [ 1, 'preset'    , presets(self_cmd, sele)       ],      
+        [ 1, 'preset'    , presets(self_cmd, sele)       ],
         [ 1, 'label'     , mol_labels(self_cmd, sele) ],
         [ 1, 'ss'        , mol_ss(self_cmd, sele) ],
         [ 0, ''          , ''                      ],
@@ -1782,28 +1784,28 @@ def seq_option(self_cmd, sele, title, ob
         [ 1, 'center'    ,'cmd.center("'+sele+'",animate=-1)'            ],
         [ 1, 'origin'    ,'cmd.origin("'+sele+'")'            ],
         [ 1, 'select'    ,'cmd.select("'+sele+'",enable=1,merge=2)'            ],
-        [ 0, ''               ,''                             ],        
+        [ 0, ''               ,''                             ],
         [ 1, 'drag'      ,'cmd.drag("'+sele+'")'            ],
-        [ 1, 'clean'      ,'cmd.clean("'+sele+'")'            ],        
+        [ 1, 'clean'      ,'cmd.clean("'+sele+'")'            ],
         ]
-    
+
     if object:
         result.extend([
-            [ 0, ''             , ''                      ],         
+            [ 0, ''             , ''                      ],
             [ 1, 'disable'        ,'cmd.disable("'+sele+'")'            ],
             [ 0, ''             , ''                      ],
             [ 1, del_col + 'delete', 'cmd.delete("'+sele+'")'            ]
             ])
     else:
         result.extend([
-            [ 0, ''             , ''                      ],      
+            [ 0, ''             , ''                      ],
             [ 1, 'create object','cmd.create(None,"'+sele+'",zoom=0)'            ],
             [ 1, 'extract object' ,'cmd.extract(None,"'+sele+'",zoom=0)' ],
             [ 0, ''             , ''                      ],
             [ 1, rem_col + 'remove atoms', 'cmd.remove("'+sele+'")' ],
             ])
     return result
-    
+
 def scene_menu(self_cmd, name):
     safe_name = name.replace('"','\\"') # just in case
     return [[ 2, 'Scene '+name    , '' ],
@@ -1813,4 +1815,3 @@ def scene_menu(self_cmd, name):
             [ 0, ''             , ''                      ],
             [ 1, del_col + 'delete', 'cmd.scene("'+safe_name+'","delete")'],
             ]
-   
diff -upNr pymol-open-source-2.3.0/modules/pymol/monitoring.py pymol-open-source-2.3.3/modules/pymol/monitoring.py
--- pymol-open-source-2.3.0/modules/pymol/monitoring.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/monitoring.py	2019-08-22 10:24:47.850617188 +0200
@@ -18,7 +18,7 @@ def check_redundant_open(file,_self=cmd)
         if a == file:
             found = 1
             break
-    for a in _self._pymol.invocation._argv: 
+    for a in _self._pymol.invocation._argv:
         if a == file:
             found = 1
             break;
diff -upNr pymol-open-source-2.3.0/modules/pymol/movie.py pymol-open-source-2.3.3/modules/pymol/movie.py
--- pymol-open-source-2.3.0/modules/pymol/movie.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/movie.py	2019-08-22 10:24:47.850617188 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
 #-* Peter Haebel, Byron DeLaBarre
-#-* 
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -51,7 +51,7 @@ def pause(pause=15,cycles=1,_self=cmd):
     movie_list = [ pass_string ] * cycles
     movie_string = " ".join(movie_list)
     _self.mset(movie_string)
-                
+
 def load(*args,**kw):
     _self = kw.get('_self',cmd)
     nam = "mov"
@@ -92,7 +92,7 @@ def rock(first=1,last=-1,angle=30,phase=
         diff = disp-last
         # com = "mdo %d:turn %s,%8.3f" % (first+a,axis,diff)
         # _self.do(com)
-        _self.mdo("%d"%(first+a),"turn %s,%8.3f"% (axis,diff))      
+        _self.mdo("%d"%(first+a),"turn %s,%8.3f"% (axis,diff))
         a = a + 1
 
 def roll(first=1,last=-1,loop=1,axis='y',_self=cmd):
@@ -106,7 +106,7 @@ def roll(first=1,last=-1,loop=1,axis='y'
     if loop:
         step = 2*math.pi/(n+1)
     else:
-        step = 2*math.pi/n   
+        step = 2*math.pi/n
     a = 0
     invert = 1
     if axis[0:1]=='-':
@@ -209,7 +209,7 @@ def nutate(first,last,angle=30,phase=0,l
         lasty = angle*math.sin(ang_cur+shift)/2
         ang_cur = ang_cur + ang_inc
         nextx = angle*math.sin(ang_cur)/2
-        nexty = angle*math.sin(ang_cur+shift)/2      
+        nexty = angle*math.sin(ang_cur+shift)/2
         # com = "mdo %d:turn %s,%8.3f" % (first+a,axis,diff)
         # _self.do(com)
         _self.mdo("%d"%(first+a),"turn x,%8.3f;turn y,%8.3f;turn y,%8.3f;turn x,%8.3f"%
@@ -255,7 +255,7 @@ def timed_roll(period=12.0,cycles=1,axis
         frames_per_sec=30.0
     frames_per_cycle = int(period*frames_per_sec)
     total = frames_per_cycle * cycles
-    
+
     _self.mset("1 x%d"%total)
     step = 2*math.pi/(frames_per_cycle)
     deg = (180*step/math.pi)
@@ -330,7 +330,7 @@ ARGUMENTS
         if loop:
             if (start == 1):
                 cmd.mview("interpolate",wrap=1)
-                cmd.turn(axis,120)                
+                cmd.turn(axis,120)
                 cmd.mview("store",start+n_frame-1,power=1,freeze=1)
                 cmd.turn(axis,120)
             else:
@@ -338,7 +338,7 @@ ARGUMENTS
                 cmd.turn(axis,120 - adjustment)
                 cmd.mview("store",start+n_frame-1,power=1,freeze=1)
                 cmd.mview("interpolate")
-                cmd.turn(axis,adjustment) 
+                cmd.turn(axis,adjustment)
         else:
             cmd.turn(axis,120)
             cmd.mview("store",start+n_frame-1,power=1,freeze=1)
@@ -347,7 +347,7 @@ ARGUMENTS
         # PYMOL-2881
         if cmd.get_setting_int('movie_auto_interpolate'):
             cmd.mview("reinterpolate")
-        
+
 def add_rock(duration=8.0,angle=30.0,loop=1,axis='y',start=0,_self=cmd):
     '''
 DESCRIPTION
@@ -435,7 +435,7 @@ def add_state_loop(factor=1,pause=2.0,fi
         if cmd.get_setting_int('movie_auto_interpolate'):
             cmd.mview("reinterpolate")
 
-def add_nutate(duration=8.0, angle=30.0, spiral=0, loop=1, 
+def add_nutate(duration=8.0, angle=30.0, spiral=0, loop=1,
                offset=0, phase=0, shift=math.pi/2.0, start=0,
                _self=cmd):
     '''
@@ -482,7 +482,7 @@ ARGUMENTS
                 sp_angle = angle
             ang_cur = math.pi*phase/180.0 + (2*math.pi*index)/n_frame
             x_rot = sp_angle * math.sin(ang_cur)/2
-            y_rot = sp_angle * math.sin(ang_cur+shift)/2      
+            y_rot = sp_angle * math.sin(ang_cur+shift)/2
             cmd.turn('x',x_rot)
             cmd.turn('y',y_rot)
             cmd.mview('store',start+index,freeze=1)
@@ -491,7 +491,7 @@ ARGUMENTS
     # PYMOL-2881
     if cmd.get_setting_int('movie_auto_interpolate'):
         cmd.mview("reinterpolate")
-    
+
 def _rock(mode,axis,first,last,period,pause,_self=cmd):
     cmd = _self
     n_frame = last - first + 1
@@ -519,7 +519,7 @@ def _rock(mode,axis,first,last,period,pa
         cmd.mview("store",last,power=-1,freeze=1)
         cmd.mview("interpolate",first,last)
 
-def _nutate_sub(start_frame, stop_frame, angle=15.0, spiral=0, loop=1, 
+def _nutate_sub(start_frame, stop_frame, angle=15.0, spiral=0, loop=1,
                 offset=0, phase=0, shift=math.pi/2.0, _self=cmd):
     cmd = _self
     angle = float(angle)
@@ -538,13 +538,13 @@ def _nutate_sub(start_frame, stop_frame,
                 sp_angle = angle
             ang_cur = math.pi*phase/180.0 + (2*math.pi*index)/n_frame
             x_rot = sp_angle * math.sin(ang_cur)/2
-            y_rot = sp_angle * math.sin(ang_cur+shift)/2      
+            y_rot = sp_angle * math.sin(ang_cur+shift)/2
             cmd.turn('x',x_rot)
             cmd.turn('y',y_rot)
             cmd.mview('store',start_frame+index,freeze=1)
             cmd.turn('y',-y_rot)
             cmd.turn('x',-x_rot)
-    
+
 def _nutate(mode,first,last,period,pause,_self=cmd):
     cmd = _self
     n_frame = last - first + 1
@@ -563,7 +563,7 @@ def _nutate(mode,first,last,period,pause
     for frame in frame_list:
         _nutate_sub(frame[0], frame[1], angle, spiral, _self=_self)
         spiral = 0
-        
+
 def add_scenes(names=None, pause=8.0, cut=0.0, loop=1,
                rock=-1, period=8.0, animate=-1, start=0,
                _self=cmd):
@@ -575,7 +575,7 @@ DESCRIPTION
 
 ARGUMENTS
 
-    names = str: list of scenes names {default: all scenes}
+    names = list: list of scenes names {default: all scenes}
 
     pause = float: display time per scene in seconds {default: 8}
 
@@ -606,9 +606,9 @@ ARGUMENTS
     rock = int(rock)
     if animate<0:
         animate = float(cmd.get("scene_animation_duration"))
-    if names == None:
+    if names is None:
         names = cmd.get_scene_list()
-    elif cmd.is_str(names):
+    elif cmd.is_string(names):
         names = cmd.safe_alpha_list_eval(names)
     n_scene = len(names)
     duration = n_scene*(pause+animate)
@@ -642,7 +642,7 @@ ARGUMENTS
                     if sweep_mode==1: # x-axis rock
                         _rock(sweep_mode, 'x', sweep_first, sweep_last,
                                 period, pause, _self=_self)
-                    elif sweep_mode<3: # y-axis rock                        
+                    elif sweep_mode<3: # y-axis rock
                         _rock(sweep_mode, 'y', sweep_first, sweep_last,
                                 period, pause, _self=_self)
                     elif sweep_mode == 3:
@@ -670,7 +670,7 @@ def _watch(filename,done_event):
         tries = tries - 1
         if tries < 0:
             break
-        time.sleep(1) 
+        time.sleep(1)
     if os.path.exists(filename):
         tries = 5
     while os.path.exists(filename):
@@ -688,7 +688,7 @@ def _watch(filename,done_event):
         time.sleep(2)
         if done_event.isSet():
             break
-            
+
 def _encode(filename,first,last,preserve,
             encoder,tmp_path,prefix,img_ext,quality,quiet,_self=cmd):
     import os
@@ -705,7 +705,7 @@ def _encode(filename,first,last,preserve
             break
         elif _self.get_modal_draw(): # keep looping so long as we're rendering...
             tries = 10
-        else: 
+        else:
             tries = tries - 1
             if tries < 0:
                 done = 0
@@ -731,7 +731,7 @@ def _encode(filename,first,last,preserve
                 ok = 0
                 print("produce-error: Unable to validate freemol.mpeg_encode.")
         if not ok:
-            print("produce-error: Unable to create mpeg file.")            
+            print("produce-error: Unable to create mpeg file.")
         else:
             mpeg_quality = 1+int(((100-quality)*29)/100) # 1 to 30
             input = mpeg_encode.input(fn_rel, '.',
@@ -750,7 +750,7 @@ def _encode(filename,first,last,preserve
                 result = mpeg_encode.run(input)
             finally:
                 os.chdir(old_cwd)
-                if done_event != None:
+                if done_event is not None:
                     done_event.set()
     elif encoder == 'ffmpeg':
         fps = get_movie_fps(_self)
@@ -781,7 +781,7 @@ def _encode(filename,first,last,preserve
             pass
     if not quiet:
                 if not os.path.exists(filename):
-                    if result != None:
+                    if result is not None:
                         print(input, result[0], result[1])
                     print(" produce: compression failed")
                 else:
@@ -792,7 +792,7 @@ def _encode(filename,first,last,preserve
             for fil in glob.glob(os.path.join(tmp_path,prefix+"*")):
                 os.unlink(fil)
             os.rmdir(tmp_path)
-    
+
 produce_mode_dict = {
     'normal'  : 0,
     'draw'    : 1,
@@ -815,7 +815,7 @@ def find_exe(exe):
         # filter out C:\Windows\System32
         path = os.pathsep.join(p
                 for p in path.split(os.pathsep)
-                if not r'\windows\system32' in p.lower())
+                if r'\windows\system32' not in p.lower())
 
     e = find_executable(exe, path)
 
@@ -964,4 +964,3 @@ ARGUMENTS
         return _self.DEFAULT_SUCCESS
     else:
         return _self.DEFAULT_ERROR
-    
diff -upNr pymol-open-source-2.3.0/modules/pymol/moving.py pymol-open-source-2.3.3/modules/pymol/moving.py
--- pymol-open-source-2.3.0/modules/pymol/moving.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/moving.py	2019-08-22 10:24:47.854617839 +0200
@@ -1,19 +1,19 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
 if True:
-    
+
     import sys
     if sys.version_info[0] == 2:
         import thread
@@ -26,7 +26,7 @@ if True:
     cmd = sys.modules["pymol.cmd"]
     from .cmd import _cmd,Shortcut, \
           toggle_dict,toggle_sc, \
-          DEFAULT_ERROR, DEFAULT_SUCCESS, _raising, is_ok, is_error        
+          DEFAULT_ERROR, DEFAULT_SUCCESS, _raising, is_ok, is_error
 
     def accept(_self=cmd):
         '''
@@ -37,7 +37,7 @@ DESCRIPTION
     security.
 
         '''
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             r = _cmd.accept(_self._COb)
@@ -55,7 +55,7 @@ DESCRIPTION
     security.
 
         '''
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             r = _cmd.decline(_self._COb)
@@ -71,7 +71,7 @@ DECRIPTION
     as to whether or not the movie is currently playing.
     
         '''
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             r = _cmd.get_movie_playing(_self._COb)
@@ -79,7 +79,7 @@ DECRIPTION
             _self.unlock(r,_self)
         if _self._raising(r,_self): raise pymol.CmdException
         return r
-    
+
     def mdump(_self=cmd):
         '''
 DESCRIPTION
@@ -96,7 +96,7 @@ SEE ALSO
         '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.mdump(_self._COb)
         finally:
             _self.unlock(r,_self)
@@ -109,10 +109,10 @@ DESCRIPTION
 
     "mtoggle" toggles playing of the movie.
     
-    '''        
-        r = DEFAULT_ERROR      
+    '''
+        r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.mplay(_self._COb,-1)
         finally:
             _self.unlock(r,_self)
@@ -136,7 +136,7 @@ SEE ALSO
         '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.mplay(_self._COb,0)
         finally:
             _self.unlock(r,_self)
@@ -153,7 +153,7 @@ SEE ALSO
         'reset'    : 5,
         'uninterpolate' : 6,
         'toggle'    : 7,
-        'toggle_interp' : 8, 
+        'toggle_interp' : 8,
         'purge'      : 9
         }
 
@@ -207,7 +207,7 @@ SEE ALSO
 
     mplay, mset, mdo, mclear, mmatrix
         '''
-        
+
         r = DEFAULT_ERROR
         first = int(first)
         last = int(last)
@@ -220,7 +220,7 @@ SEE ALSO
         if last<0:
             last = _self.count_frames() + last + 1
         action = mview_action_dict[mview_action_sc.auto_err(action,'action')]
-        if (scene==None) or (scene=='auto'):
+        if (scene is None) or (scene=='auto'):
             scene = _self.get("scene_current_name")
         scene = str(scene)
         if (scene!=''):
@@ -232,20 +232,20 @@ SEE ALSO
                            int(simple), float(linear),str(object),
                            int(wrap),int(hand),int(window),int(cycles),
                            str(scene),float(cut),int(quiet),int(state)-1,0)
-            if (not freeze and 
-                ((auto>0) or ((auto<0) and 
+            if (not freeze and
+                ((auto>0) or ((auto<0) and
                               (_self.get_setting_int("movie_auto_interpolate")>0)))):
                 if action in [0,1,7]: # reinterpolate after store, clear, or toggle
                     _cmd.mview(_self._COb,3,-1,-1,
                                float(power),float(bias),
                                int(simple), float(linear),str(object),
                                int(wrap),int(hand),int(window),int(cycles),
-                               str(scene),float(cut),int(quiet),-1,1)                    
+                               str(scene),float(cut),int(quiet),-1,1)
         finally:
             _self.unlock(r,_self)
         if _self._raising(r,_self): raise pymol.CmdException
         return r
-    
+
     def mplay(_self=cmd):
         '''
 DESCRIPTION
@@ -266,7 +266,7 @@ SEE ALSO
         '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.mplay(_self._COb,1)
         finally:
             _self.unlock(r,_self)
@@ -315,7 +315,7 @@ SEE ALSO
         '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.mdo(_self._COb,int(frame)-1,str(command),0)
         finally:
             _self.unlock(r,_self)
@@ -358,7 +358,7 @@ SEE ALSO
         '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.mdo(_self._COb,int(frame)-1,str(";"+command),1)
         finally:
             _self.unlock(r,_self)
@@ -451,7 +451,7 @@ PYMOL API
         '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.mclear(_self._COb)
         finally:
             _self.unlock(r,_self)
@@ -491,7 +491,7 @@ SEE ALSO
         '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.frame(_self._COb, int(frame) - 1, int(trigger))
         finally:
             _self.unlock(r,_self)
@@ -668,7 +668,7 @@ SEE ALSO
         count = int(count)
         freeze = int(freeze)
         object = str(object)
-        quiet = int(quiet)        
+        quiet = int(quiet)
         if not frame: # 0 means use current frame
             frame = _self.get_frame() - 1
         else:
@@ -695,7 +695,7 @@ SEE ALSO
 
     '''
         mset(specification,frame,freeze,_self=_self)
-        
+
     def mset(specification="",frame=1,freeze=0,_self=cmd):
         '''
 DESCRIPTION
@@ -751,7 +751,7 @@ SEE ALSO
                     if x[0]=="x":
                         if last<0:
                             last = cur_state
-                            cnt = int(x[1:])                     
+                            cnt = int(x[1:])
                         else:
                             cnt = int(x[1:])-1
                         while cnt>0:
@@ -809,7 +809,7 @@ EXAMPLES
         '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             if action=="clear":
                 r = _cmd.mmatrix(_self._COb,0)
             elif action=="store":
@@ -844,7 +844,7 @@ SEE ALSO
         '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.set_frame(_self._COb,5,1)
         finally:
             _self.unlock(r,_self)
@@ -871,7 +871,7 @@ SEE ALSO
         '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.set_frame(_self._COb,5,-1)
         finally:
             _self.unlock(r,_self)
@@ -895,7 +895,7 @@ PYMOL API
         '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.set_frame(_self._COb,4,0)
         finally:
             _self.unlock(r,_self)
@@ -907,9 +907,9 @@ PYMOL API
         '''
 internal
         '''
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r=_cmd.set_frame(_self._COb, int(mode), int(frame)-1)
         finally:
             _self.unlock(r,_self)
@@ -930,9 +930,9 @@ PYMOL API
 
     cmd.ending()
         '''
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r=_cmd.set_frame(_self._COb,6,0)
         finally:
             _self.unlock(r,_self)
@@ -955,7 +955,7 @@ PYMOL API
         '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.set_frame(_self._COb,3,0)
         finally:
             _self.unlock(r,_self)
diff -upNr pymol-open-source-2.3.0/modules/pymol/parser.py pymol-open-source-2.3.3/modules/pymol/parser.py
--- pymol-open-source-2.3.0/modules/pymol/parser.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/parser.py	2019-08-22 10:24:47.854617839 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -29,7 +29,7 @@ SCRIPT_TOPLEVEL = 'toplevel'
 
 
 if True:
-    
+
     import pymol
     import traceback
     import collections
@@ -44,7 +44,7 @@ if True:
 
     QuietException = parsing.QuietException
     CmdException = pymol.CmdException
-    
+
     py_delims = { '=' : 1, '+='  : 1, '-='  : 1, '*=' : 1,
                       '/=' :1, '//=' : 1, '%='  : 1, '&=' : 1,
                       '|=' :1, '^='  : 1, '>>=' : 1,'<<=' : 1,
@@ -60,7 +60,7 @@ if True:
         except:
             traceback.print_exc()
         amb = sc.interpret(st, mode)
-        if amb==None:
+        if amb is None:
             colorprinting.warning(" parser: no matching %s."%type_name)
         elif isinstance(amb, str):
             result = amb+postfix
@@ -89,7 +89,7 @@ if True:
             if len(css)>len(st):
                 result = css
         return result
-    
+
     class NestLayer:
 
         def __init__(self):
@@ -112,7 +112,7 @@ if True:
             self.nest = 0
             self.layer = collections.defaultdict(NestLayer)
             self.pymol_names = self.cmd._pymol.__dict__
-            
+
             # parsing state implemented with dictionaries to enable safe recursion
             # to arbitrary depths
 
@@ -222,11 +222,11 @@ if True:
                         if layer.cont != '':
                             layer.com1 = layer.cont + "\n" + layer.com1
                             layer.cont = ''
-        # this routine splits up the line first based on semicolon 
-                        
+        # this routine splits up the line first based on semicolon
+
                         layer.next = parsing.split(layer.com1,';',1) + layer.next[1:]
-                        
-        # layer.com2 now a full non-compound command            
+
+        # layer.com2 now a full non-compound command
                         layer.com2 = layer.next[0]
                         layer.input = layer.com2.split(' ',1)
                         lin = len(layer.input)
@@ -234,7 +234,7 @@ if True:
                             layer.input[0] = layer.input[0].strip()
                             com = layer.input[0]
                             if (com[0:1]=='/'):
-                                # explicit literal python 
+                                # explicit literal python
                                 layer.com2 = layer.com2[1:].strip()
                                 if len(layer.com2)>0:
                                     self.exec_python(layer.com2, secure)
@@ -244,7 +244,7 @@ if True:
                                 # try to find a keyword which matches
                                 if com in self.cmd.kwhash:
                                     amb = self.cmd.kwhash.interpret(com)
-                                    if amb == None:
+                                    if amb is None:
                                         com = self.cmd.kwhash[com]
                                     elif not isinstance(amb, str):
                                         colorprinting.warning('Error: ambiguous command: ')
@@ -319,11 +319,11 @@ if True:
                                         if layer.kw[1]<= len(layer.args) <= layer.kw[2]:
                                             layer.args = [a.strip() for a in layer.args]
                                             if layer.kw[4]<parsing.RUN:
-                                                #                           
+                                                #
                                                 # this is where old-style commands are invoked
                                                 #
                                                 self.result=layer.kw[0](*layer.args)
-                                                #                           
+                                                #
                                             elif (layer.kw[4]==parsing.EMBED):
                                                 layer.next = []
                                                 if secure or self.nest==0: # only legal on top level and p1m files
@@ -394,7 +394,7 @@ if True:
                                             nest_securely = 1
                                         else:
                                             nest_securely = secure
-                                        if re.search("\.py$|\.pym$",path) != None:
+                                        if re.search("\.py$|\.pym$",path) is not None:
                                             if self.cmd._feedback(fb_module.parser,fb_mask.warnings):
                                                 print("Warning: use 'run' instead of '@' with Python files?")
                                         layer.script = open(path,'rU')
@@ -413,13 +413,13 @@ if True:
                                             tmp_cmd = inp_cmd.strip()
                                             if len(tmp_cmd):
                                                 if tmp_cmd[0] not in ['#','_','/']: # suppress comments, internals, python
-                                                    if layer.embed_sentinel==None:
+                                                    if layer.embed_sentinel is None:
                                                         colorprinting.parrot("PyMOL>"+tmp_cmd)
                                                 elif tmp_cmd[0]=='_' and \
                                                       tmp_cmd[1:2] in [' ','']: # "_ " remove echo suppression signal
                                                     inp_cmd=inp_cmd[2:]
                                             pp_result = self.parse(inp_cmd,nest_securely)
-                                            if pp_result==None: # RECURSION
+                                            if pp_result is None: # RECURSION
                                                 break # abort command gets us out
                                             elif pp_result==0: # QuietException
                                                 if self.cmd.get_setting_boolean("stop_on_exceptions"):
@@ -428,7 +428,7 @@ if True:
                                                     break;
                                         self.nest=self.nest-1
                                         layer=self.layer[self.nest]
-                                        
+
                                         layer.script.close()
                                         self.cmd._pymol.__script__ = layer.sc_path
                                     else: # nothing found, try literal python
@@ -453,7 +453,7 @@ if True:
             except (QuietException, CmdException) as e:
                 if e.args:
                     colorprinting.error(e)
-                if self.cmd._feedback(fb_module.parser,fb_mask.blather):         
+                if self.cmd._feedback(fb_module.parser,fb_mask.blather):
                     print("Parser: caught " + type(e).__name__)
                 p_result = 0
             except SecurityException as e:
@@ -471,7 +471,7 @@ if True:
         def get_embedded(self,key=None):
             layer = self.layer[self.nest]
             dict = layer.embed_dict
-            if key==None:
+            if key is None:
                 key = self.get_default_key()
             return dict.get(key,None)
 
@@ -490,7 +490,7 @@ if True:
                     if self.nest==0:
                         # if we're reading embedded input on stdin
                         # then bypass PyMOL C code altogether
-                        if self.layer[0].embed_sentinel!=None:
+                        if self.layer[0].embed_sentinel is not None:
                             self.parse(l)
                         else:
                             self.cmd.do(l, flush=True)
@@ -527,11 +527,11 @@ if True:
                             if full in self.cmd.auto_arg[count]: # autocomplete arguments
                                 flag = 1
                                 pre = re.sub(r"^[^ ]* ",' ',st,count=1) # trim command
-                                if re.search(r",",pre)!=None:
-                                    pre = re.sub(r"[^\, ]*$","",pre,count=1) 
+                                if re.search(r",",pre) is not None:
+                                    pre = re.sub(r"[^\, ]*$","",pre,count=1)
                                     pre = re.sub(r",\s*[^\, ]*$",", ",pre,count=1) # trim 1 arg
                                 else:
-                                    pre = re.sub("[^ ]*$","",pre,count=1) # trim 1 arg               
+                                    pre = re.sub("[^ ]*$","",pre,count=1) # trim 1 arg
                                 pre = re.sub(r"^ *",'',pre)
                                 pre = full+' '+pre
                                 pat = re.sub(r".*[\, ]",'',st)
@@ -571,7 +571,7 @@ if True:
                         css = os.path.commonprefix(flist)
                         if len(css)>len(st3):
                             result = css
-            if result!=None:
+            if result is not None:
                 result = pre+result
             return result
 
@@ -593,7 +593,3 @@ if True:
 #            return a
 #        else:
 #            return None
-
-    
-
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/parsing.py pymol-open-source-2.3.3/modules/pymol/parsing.py
--- pymol-open-source-2.3.0/modules/pymol/parsing.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/parsing.py	2019-08-22 10:24:47.854617839 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -27,7 +27,7 @@
 # command
 
 # * commands with arguments
-#            
+#
 # command value1
 # command value1,value2
 # command value1,value2,value3
@@ -36,7 +36,7 @@
 #
 # command argument1=value1
 # command argument1=value1,argument2=value2,argument3=value3
-# command argument3=value1,argument2=value2,argument1=value1   
+# command argument3=value1,argument2=value2,argument1=value1
 
 # * mixed...
 #
@@ -44,7 +44,7 @@
 
 # * commands with legacy '=' support for first argument
 #
-# command string1=value1    
+# command string1=value1
 # * which should map to
 # command string1,value1
 
@@ -57,7 +57,7 @@
 # === Burdens placed on API functions...
 #
 # None. However, function must have real arguments for error checking.
-# 
+#
 
 from __future__ import absolute_import
 
@@ -71,7 +71,7 @@ if True:
     import types
     import inspect
     from . import colorprinting
-    
+
     class QuietException(BaseException):
         pass
 
@@ -79,21 +79,21 @@ if True:
 
     SIMPLE      = 0  # original pymol parsing (deprecated)
     MOVIE       = 1  # ignore ";", treat entire line as a single command
-    RUN         = 2  # run command 
+    RUN         = 2  # run command
     SPAWN       = 3  # for spawn and fork commands
     ABORT       = 4  # terminates command script
     PYTHON      = 5  # pass entire line to python
     EMBED       = 6  # embedded data
     PYTHON_BLOCK = 7 # embedded python block
     SKIP        = 8  # skipping commands
-    NO_CHECK    = 10 # no error checking 
+    NO_CHECK    = 10 # no error checking
     STRICT      = 11 # strict name->argument checking
     SECURE      = 12 # command not available in "secure" mode
     LEGACY      = 13 # support legacy construct str1=val1,... -> str1,val1,...
-    LITERAL     = 20 # argument is to be treated as a literal string 
+    LITERAL     = 20 # argument is to be treated as a literal string
     LITERAL1    = 21 # one regular argument, followed by literal string
     LITERAL2    = 22 # two regular argument, followed by literal string
-    
+
     # key regular expressions
 
     arg_name_re = re.compile(r"[A-Za-z0-9_]+\s*\=")
@@ -107,7 +107,7 @@ if True:
     arg_value_re = re.compile(r"'''[^']*'''|'[^']*'|"+r'"[^"]*"|[^,;]+')
     def trim_nester(st):
         # utility routine, returns single instance of a nested string
-        # should be modified to handle quotes too                  
+        # should be modified to handle quotes too
         pc = 1
         l = len(st)
         c = 1
@@ -129,13 +129,13 @@ if True:
         result = []
         inp_dict = {}
         for a in inp_arg:
-            if a[0] != None:
+            if a[0] is not None:
                 inp_dict[a[0]] = a[1];
         c = 0
         for p in par:
             if c<n_inp:
                 a = inp_arg[c]
-                if a[0] == None:
+                if a[0] is None:
                     result.append(a[1])
                     c = c + 1
                     continue
@@ -150,7 +150,7 @@ if True:
         if len(inp_dict):
             raise QuietException("Error: invalid argument(s).")
         return result
-    
+
     def parse_arg(st,mode=STRICT,_self=None):
         '''
     parse_arg(st)
@@ -159,7 +159,7 @@ if True:
 
     returns list of tuples of strings: [(None,value),(name,value)...]
     '''
-        result = [] 
+        result = []
         # current character
         cc = 0
         a = st.split(None, 1)
@@ -174,7 +174,7 @@ if True:
                 st = st.lstrip()
                 if st == '':
                     break
-                # read argument name, if any         
+                # read argument name, if any
                 mo = arg_name_re.match(st)
                 if mo:
                     nam = mo.group(0)[:-1].strip()
@@ -197,7 +197,7 @@ if True:
                         # special handling for nesters (selections, lists, tuples, etc.)
                         mo = arg_easy_nester_re.match(st[cc:]) # no internal commas
                         if mo:
-                            cnt = len(nester_char_re.findall(mo.group(0))) 
+                            cnt = len(nester_char_re.findall(mo.group(0)))
                             if cnt % 2 == 1: # make sure nesters are matched in count
                                 mo = None
                         if mo:
@@ -214,7 +214,7 @@ if True:
                             mo = arg_hard_nester_re.match(st[cc:])
                             if mo:
                                 se = trim_nester(mo.group(0))
-                                if se==None:
+                                if se is None:
                                     colorprinting.error("Error: "+st)
                                     colorprinting.error("Error: "+" "*cc+"^ syntax error (type 1).")
                                     raise QuietException
@@ -252,7 +252,7 @@ if True:
                                 break
                             argval = argval + mo.group(0)
                             cc=cc+mo.end(0)
-                        if argval!=None:
+                        if argval is not None:
                             result.append((nam, argval.strip()))
                 # clean whitespace
                 st = st[cc:].lstrip()
@@ -331,7 +331,7 @@ if True:
         print(st + " " + "]"*pc)
 
     def prepare_call(fn,lst,mode=STRICT,name=None,_self=None): # returns tuple of arg,kw or excepts if error
-        if name==None:
+        if name is None:
             name=fn.__name__
         result = (None,None)
         arg = []
@@ -349,13 +349,13 @@ if True:
         nreq = narg-ndef
         if len(lst)==1:
             if lst[0]==(None,'?'):
-                dump_arg(name,arg_nam,nreq)         
+                dump_arg(name,arg_nam,nreq)
                 raise QuietException
 
         if mode==NO_CHECK:
             # no error checking
             for a in lst:
-                if a[0]==None:
+                if a[0] is None:
                     arg.append(a[1])
                 else:
                     kw[a[0]]=a[1]
@@ -380,7 +380,7 @@ if True:
                 # handle legacy string=value transformation
                 tmp_lst = []
                 for a in lst:
-                    if(a[0]!=None):
+                    if(a[0] is not None):
                         if a[0] not in arg_dct:
                             tmp_lst.extend([(None,a[0]),(None,a[1])])
                         else:
@@ -399,13 +399,13 @@ if True:
                 else:
                     colorprinting.error("Error: too many arguments for %s; %d to %d expected, %d found."%(
                         name,nreq,narg,len(lst)))
-                    dump_arg(name,arg_nam,nreq)            
+                    dump_arg(name,arg_nam,nreq)
                 raise QuietException
             # match names to unnamed arguments to create argument dictionary
             ac = 0
             val_dct = {}
             for a in lst:
-                if a[0]==None:
+                if a[0] is None:
                     if ac>=narg:
                         raise QuietException("Parsing-Error: ambiguous argument: '"+str(a[1])+"'")
                     else:
@@ -536,7 +536,7 @@ SEE ALSO
             # without any further output
             _print_exc()
             raise QuietException
-    
+
     def run_file_as_module(file,spawn=0):
         name = re.sub('[^A-Za-z0-9]','_',file)
         if not isinstance(name, str):
diff -upNr pymol-open-source-2.3.0/modules/pymol/plugins/__init__.py pymol-open-source-2.3.3/modules/pymol/plugins/__init__.py
--- pymol-open-source-2.3.0/modules/pymol/plugins/__init__.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/plugins/__init__.py	2019-08-22 12:54:48.870649022 +0200
@@ -198,8 +198,9 @@ class PluginInfo(object):
         Parse plugin file for metadata (hash-commented block at beginning of file).
         '''
         metadata = dict()
-        f = open(self.filename, 'rU')
+        f = open(self.filename, 'rb')
         for line in f:
+            line = line.decode('utf-8', errors='replace')
             if line.strip() == '':
                 continue
             if not line.startswith('#'):
@@ -238,7 +239,7 @@ class PluginInfo(object):
             return self.module.__doc__
 
         try:
-            c = compile(''.join(open(self.filename)), 'x', 'exec', dont_inherit=True)
+            c = compile(b''.join(open(self.filename, 'rb')), 'x', 'exec', dont_inherit=True)
             s = c.co_consts[0]
             if cmd.is_string(s):
                 return s
@@ -428,7 +429,10 @@ def initialize(pmgapp=-1):
 
     if os.path.exists(PYMOLPLUGINSRC):
         from pymol import parsing
-        parsing.run_file(PYMOLPLUGINSRC, {'__script__': PYMOLPLUGINSRC}, {})
+        try:
+            parsing.run_file(PYMOLPLUGINSRC, {'__script__': PYMOLPLUGINSRC}, {})
+        except SyntaxError as e:
+            colorprinting.warning(str(e))
 
     autoload = (pmgapp != -2)
     for parent in [startup]:
diff -upNr pymol-open-source-2.3.0/modules/pymol/plugins/installation.py pymol-open-source-2.3.3/modules/pymol/plugins/installation.py
--- pymol-open-source-2.3.0/modules/pymol/plugins/installation.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/plugins/installation.py	2019-08-22 10:24:47.854617839 +0200
@@ -131,6 +131,9 @@ def extract_zipfile(ofile, ext):
     if len(names) == 0:
         raise BadInstallationFile('Missing __init__.py')
     if len(names) > 1:
+        # filter out "tests" directory
+        names = [n for n in names if n[-1] != 'tests']
+    if len(names) > 1:
         raise BadInstallationFile('Archive must contain a single package.')
     check_valid_name(names[0][-1])
 
@@ -320,11 +323,12 @@ def installPluginFromFile(ofile, parent=
         showinfo('Info', 'Installation cancelled', parent=parent)
         return
 
-    except:
+    except Exception as e:
         if pref_get('verbose', False):
             import traceback
             traceback.print_exc()
-        showinfo('Error', 'unable to install plugin "%s"' % name, parent=parent)
+        msg = 'Unable to install plugin "{}".\n{}'.format(name, e)
+        showinfo('Error', msg, parent=parent)
         return
 
     finally:
diff -upNr pymol-open-source-2.3.0/modules/pymol/plugins/legacysupport.py pymol-open-source-2.3.3/modules/pymol/plugins/legacysupport.py
--- pymol-open-source-2.3.0/modules/pymol/plugins/legacysupport.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/plugins/legacysupport.py	2019-08-22 10:24:47.854617839 +0200
@@ -153,9 +153,10 @@ def createlegacypmgapp():
 
 class _tkMessageBox(object):
     def __getattr__(self, name):
-        if sys.version_info[0] == 2:
+        try:
+            # pmg_qt.mimic_tk provides this for all Python versions
             import tkMessageBox as module
-        else:
+        except ImportError:
             import tkinter.messagebox as module
         from . import pref_get
         wrapped = getattr(module, name)
@@ -170,9 +171,10 @@ class _tkMessageBox(object):
 
 class _tkFileDialog(object):
     def __getattr__(self, name):
-        if sys.version_info[0] == 2:
+        try:
+            # pmg_qt.mimic_tk provides this for all Python versions
             import tkFileDialog as module
-        else:
+        except ImportError:
             import tkinter.filedialog as module
         wrapped = getattr(module, name)
         def dialog(parent=None, *args, **kwargs):
diff -upNr pymol-open-source-2.3.0/modules/pymol/povray.py pymol-open-source-2.3.3/modules/pymol/povray.py
--- pymol-open-source-2.3.0/modules/pymol/povray.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/povray.py	2019-08-22 10:24:47.854617839 +0200
@@ -1,19 +1,19 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
 #-* Peter Haebel
-#-* 
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
 if True:
-    
+
     import os
     import traceback
 
@@ -41,4 +41,3 @@ if True:
         except:
             traceback.print_exc()
         return r
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/preset.py pymol-open-source-2.3.3/modules/pymol/preset.py
--- pymol-open-source-2.3.0/modules/pymol/preset.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/preset.py	2019-08-22 10:24:47.854617839 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -52,9 +52,9 @@ def _prepare(selection,polar_contacts=No
 
     s, selection, dname = get_sname_oname_dname(selection, _self=cmd)
 
-    cmd.cartoon("auto",s)   
+    cmd.cartoon("auto",s)
     cmd.hide("everything",s)
-    
+
     cmd.set("two_sided_lighting",0) # global
     cmd.unset("transparency",s)
     cmd.unset("surface_quality", selection)
@@ -66,8 +66,8 @@ def _prepare(selection,polar_contacts=No
     cmd.unset("cartoon_fancy_helices",selection)
     cmd.unset("cartoon_smooth_loops",selection)
     cmd.unset("cartoon_flat_sheets",selection)
-    cmd.unset("cartoon_side_chain_helper",selection)   
-    if polar_contacts == None:
+    cmd.unset("cartoon_side_chain_helper",selection)
+    if polar_contacts is None:
         polar_contacts = dname
         if polar_contacts in cmd.get_names('objects'):
             cmd.delete(polar_contacts)
@@ -160,7 +160,7 @@ def ball_and_stick(selection="(all)",mod
         cmd.set("stick_ball_color","atomic")
         cmd.show("sticks",s)
     cmd.delete(s)
-    
+
 def b_factor_putty(selection="(name CA+P)",_self=cmd):
     cmd=_self
     s, selection = _prepare(selection, _self=cmd)[:2]
@@ -179,7 +179,7 @@ def ligand_cartoon(selection="(all)",_se
     cmd.hide("ribbon")
     cmd.hide("surface")
     cmd.delete(s)
-    
+
 def ligand_sites(selection="(all)",_self=cmd):
     cmd=_self
     try:
@@ -218,7 +218,7 @@ def ligand_sites(selection="(all)",_self
                 cmd.show("dashes",polar_contacts)
         else:
             cmd.delete(polar_contacts)
-                
+
         cmd.show("nb_spheres",lig+"|"+host+"|"+near_solvent)
         if cmd.count_atoms(lig):
             cmd.zoom(lig,3, animate=1)
@@ -257,7 +257,7 @@ def ligand_sites_trans_hq(selection="(al
     cmd.set("surface_type",0,selection)
     cmd.set("surface_quality",1,selection)
     cmd.delete(s)
-    
+
 def ligand_sites_mesh(selection="(all)",_self=cmd):
     cmd=_self
     s, selection = ligand_sites(selection, _self)[:2]
@@ -266,7 +266,7 @@ def ligand_sites_mesh(selection="(all)",
     cmd.set("surface_type","2",selection)
     cmd.set("surface_quality","0",selection)
     cmd.delete(s)
-    
+
 def ligand_sites_dots(selection="(all)",_self=cmd):
     cmd=_self
     s, selection = ligand_sites(selection, _self)[:2]
@@ -280,7 +280,7 @@ def technical(selection="(all)",_self=cm
     cmd=_self
     s, selection, polar_contacts = _prepare(selection, _self=cmd)
     util.chainbow(s,_self=cmd)
-    util.cbc("("+lig_sele+" and ("+s+"))",_self=cmd)   
+    util.cbc("("+lig_sele+" and ("+s+"))",_self=cmd)
     util.cbac("(("+s+") and not elem C)",_self=cmd)
     cmd.show("nonbonded",s)
     cmd.show("lines","((("+s+") and not "+lig_sele+") extend 1)")
@@ -310,9 +310,9 @@ def pretty_solv(selection="(all)",_self=
     cmd.set("cartoon_fancy_helices",0,selection)
     cmd.set("cartoon_smooth_loops",0,selection)
     cmd.set("cartoon_flat_sheets",1,selection)
-    cmd.set("cartoon_side_chain_helper",0,selection)   
+    cmd.set("cartoon_side_chain_helper",0,selection)
     cmd.delete(s)
-        
+
 def pretty(selection,_self=cmd):
     cmd=_self
     pretty_solv(selection,_self)
@@ -330,7 +330,7 @@ def pub_solv(selection="(all)",_self=cmd
     cmd.set("cartoon_highlight_color","grey50",selection)
     cmd.set("cartoon_fancy_helices",1,selection)
     cmd.set("cartoon_flat_sheets",1,selection)
-    cmd.set("cartoon_side_chain_helper",0,selection)   
+    cmd.set("cartoon_side_chain_helper",0,selection)
     cmd.delete(s)
 
 def publication(selection="(all)",_self=cmd):
@@ -354,7 +354,7 @@ def default(selection="(all)",_self=cmd)
         util.cnc(selection,_self=cmd)
         cmd.color(str(color),"("+s+") and elem C")
     cmd.delete(s)
-        
+
 
 def interface(selection='*', _self=cmd):
     '''
diff -upNr pymol-open-source-2.3.0/modules/pymol/pymolhttpd.py pymol-open-source-2.3.3/modules/pymol/pymolhttpd.py
--- pymol-open-source-2.3.0/modules/pymol/pymolhttpd.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/pymolhttpd.py	2019-08-22 10:24:47.854617839 +0200
@@ -30,7 +30,7 @@ else:
 import cgi
 import socket
 
-# we also rely upon Python's json infrastructure 
+# we also rely upon Python's json infrastructure
 
 try:
     import simplejson as json
@@ -87,14 +87,14 @@ class _PymolHTTPRequestHandler(BaseHTTPS
                                 % host)
             else:
                 self.session = self.server.pymol_session # local session
-                self.callback = None 
+                self.callback = None
                 self.parse_args()
                 self.process_urlpath()
         except socket.error:
             traceback.print_exc()
             print("broken pipe")
             pass
-        
+
     def parse_args(self):
         """
         parses URL arguments into a urlpath (before the ?)
@@ -124,14 +124,14 @@ class _PymolHTTPRequestHandler(BaseHTTPS
         self.urlpath can be a request for a document, or a
         special request, such as apply or getattr
         """
-        parts = self.urlpath.split('/') 
+        parts = self.urlpath.split('/')
 
         # for example:
         # if http://localhost:8080/apply/pymol.cmd.color?...
         # then parts is ['', 'apply', 'pymol.cmd.color...']
         # or if http://localhost:8080/apply?_json=...
         # then parts is ['', 'apply?_json=...']
-        
+
         if len(parts) < 2: # then it cannot be a PyMOL request
             self.send_doc() # simple file retrieval
         else: # might be a PyMOL request
@@ -154,7 +154,7 @@ class _PymolHTTPRequestHandler(BaseHTTPS
         """
         key = '/getattr/' + attr;
         if key in self.session:
-            try:   
+            try:
                 result = repr(self.session[key])
                 self.send_json_result(result)
             except:
@@ -171,7 +171,7 @@ class _PymolHTTPRequestHandler(BaseHTTPS
             return json.dumps(r, indent=indent)
         else:
             return json.dumps(result, indent=indent)
-        
+
     def send_json_result(self, result):
         """
         send the mime header and result body.  requests that came from
@@ -179,7 +179,7 @@ class _PymolHTTPRequestHandler(BaseHTTPS
         formatted results.  other requests will have come from
         ordinary GET or POST requests via links or forms
         """
-        if self.callback != None:
+        if self.callback is not None:
             self.send_resp_header(200,'text/javascript')
             self.wfile_write("%s(%s)"%(self.callback,self.wrap_return(result)))
 
@@ -188,15 +188,15 @@ class _PymolHTTPRequestHandler(BaseHTTPS
             if accept_mime in _json_mime_types:
                 self.send_resp_header(200,accept_mime)
                 self.wfile_write(self.wrap_return(result))
-                
+
             else:
                 self.send_resp_header(200,'text/html')
                 self.wfile_write("PyMOL's JSON response: <pre>")
                 self.wfile_write(self.wrap_return(result,indent=4))
                 self.wfile_write("</pre>")
-            
+
     def send_json_error(self, code, message):
-        if self.callback != None:
+        if self.callback is not None:
             self.send_resp_header(code,'text/javascript')
             self.wfile_write("%s(%s)"%(self.callback,self.wrap_return(message,"ERROR")))
         else:
@@ -216,7 +216,7 @@ class _PymolHTTPRequestHandler(BaseHTTPS
         tb = fp.getvalue()
         message = message + tb.split('\n')
         response = json.dumps(message)
-        if self.callback != None:
+        if self.callback is not None:
             self.send_resp_header(code, 'text/javascript')
             self.wfile_write("%s(%s)"%(self.callback,response))
         else:
@@ -234,7 +234,7 @@ class _PymolHTTPRequestHandler(BaseHTTPS
         """
         apply the appropriate method held in the session dictionary.
         supply the method arguements in the form of key/value
-        """        
+        """
         args = None
         kwds = None
         query_kwds = {}
@@ -247,8 +247,8 @@ class _PymolHTTPRequestHandler(BaseHTTPS
                 elif k == '_json': # main path for Javascript API
                     method = json.loads(self.fs.getfirst(k))
                     # [ "my_method", [ arg1, ... ] , { 'key1' : 'val1, ... } ]
-                    # or 
-                    # [ [ "my_met1", [ arg1, ... ], { 'key1' : 'val1, ... } ], 
+                    # or
+                    # [ [ "my_met1", [ arg1, ... ], { 'key1' : 'val1, ... } ],
                     #   [ "my_met2", [ arg1, ... ], { 'key1' : 'val1, ... } ] ]
                 elif k == '_method': # tentative, not in spec -- may disappear
                     # a method name "my_method"
@@ -260,13 +260,13 @@ class _PymolHTTPRequestHandler(BaseHTTPS
                 # other underscore arguments are ignored (not passed on)
             elif k[0:1] != '_':
                 query_kwds[k] = self.fs.getfirst(k)
-                
-        blocks = []            
+
+        blocks = []
         if isinstance(method, str):
-            # method is merely a string 
-            if kwds == None:
+            # method is merely a string
+            if kwds is None:
                 kwds = query_kwds
-            if args == None:
+            if args is None:
                 args = ()
             if len(method):
                 blocks = [ [ method, args, kwds ] ]
@@ -290,7 +290,7 @@ class _PymolHTTPRequestHandler(BaseHTTPS
                 fn = self.session.get(block[0],None)
                 if fn is None and block[0].startswith('pymol.cmd.'):
                     fn = getattr(self.server.pymol_cmd, block[0][10:], None)
-                if fn != None:
+                if fn is not None:
                     len_block = len(block)
                     if len_block>1:
                         args = tuple(block[1])
@@ -311,7 +311,7 @@ class _PymolHTTPRequestHandler(BaseHTTPS
                         return
                 else:
                     self.send_json_error(500,[ "Method not found:",
-                                               str(block) ])                
+                                               str(block) ])
                     return
 
                 if block[0] == '_quit': # special quit behavior
@@ -322,9 +322,9 @@ class _PymolHTTPRequestHandler(BaseHTTPS
                         href = str(kwds['href'])
                     elif len(args):
                         href = str(args[1])
-                    if href == None:
+                    if href is None:
                         self.wfile_write("<body>")
-                    elif not len(href): # simply 
+                    elif not len(href): # simply
                         self.wfile_write("<body onload=\"window.close()\">")
                     else:
                         self.wfile_write(
@@ -353,7 +353,7 @@ class _PymolHTTPRequestHandler(BaseHTTPS
         if '..' in path_list: # prevent access to parent directories
             self.send_error(404,"Illegal path.")
             self.wfile_write(": %s" % self.path)
-        elif self.server.pymol_root == None:
+        elif self.server.pymol_root is None:
             self.send_error(404,"No content root specified.")
         else:
             try:
@@ -394,7 +394,7 @@ class _PymolHTTPRequestHandler(BaseHTTPS
             return 'application/x-pymol'
         else:
             return 'text/plain'
-            
+
     def send_error(self,errcode,errmsg):
         self.send_response(errcode)
         self.send_header('Content-type', 'text/plain')
@@ -403,7 +403,7 @@ class _PymolHTTPRequestHandler(BaseHTTPS
         self.send_header('Expires','Sat, 10 Jan 2008 01:00:00 GMT')
         self.end_headers()
         self.wfile_write("PyMOL-HTTPd-Error: "+errmsg+"\n")
-        
+
     def send_resp_header(self, code=200, mime='text/html'):
         self.send_response(code)
         self.send_header('Content-type', mime)
@@ -411,7 +411,7 @@ class _PymolHTTPRequestHandler(BaseHTTPS
         self.send_header('Cache-Control','no-cache, must-revalidate')
         self.send_header('Expires','Sat, 10 Jan 2008 01:00:00 GMT')
         self.end_headers()
-        
+
     def echo_args(self):
         """
         for debugging requests
@@ -448,7 +448,7 @@ class _PymolHTTPRequestHandler(BaseHTTPS
 class PymolHttpd:
 
     def __init__(self, port=8080, root=None, logging=1, wrap_natives=0, self_cmd=None):
-        if self_cmd == None:
+        if self_cmd is None:
             # fallback on the global singleton PyMOL API
             try:
                 from pymol import cmd
@@ -468,14 +468,14 @@ class PymolHttpd:
         session['_quit'] = lambda href=None,s=self:s.quit()
 
         # JavaScript workarounds for keyword clashes
-        
-        session['pymol.cmd.delete_'] = self_cmd.delete 
-        session['pymol.cmd.super_'] = self_cmd.super 
+
+        session['pymol.cmd.delete_'] = self_cmd.delete
+        session['pymol.cmd.super_'] = self_cmd.super
 
         ## Unsafe methods to workaround (uses eval)
 
         session['pymol.cmd.label'] = self_cmd.label2 # no-eval version
-        
+
         self.server = BaseHTTPServer.HTTPServer(('', self.port),
                                                 _PymolHTTPRequestHandler)
         self.server.wrap_natives = wrap_natives
@@ -484,15 +484,15 @@ class PymolHttpd:
             self.port = self.server.socket.getsockname()[1]
         self.server.pymol_session = self.session
         self.server.pymol_root = self.root
-        if self.root != None:
+        if self.root is not None:
             os.environ['PYMOL_HTTP_ROOT'] = self.root
-        self.server.pymol_cmd = self.cmd 
+        self.server.pymol_cmd = self.cmd
         self.server.pymol_logging = logging
 
     def _server_thread(self):
         while not self.stop_event.isSet():
             self.server.handle_request()
-        
+
     def start(self):
         print ( " PyMOL-HTTPd: serving requests on http://localhost:%d" %
                 self.port )
@@ -518,17 +518,15 @@ class PymolHttpd:
         exposes a Python method or symbol to the web services interface
         '''
         self.session[name] = value
-        
+
 # default behavior if run explicitly from PyMOL
 
-if __name__ == 'pymol': # launched inside PyMOL 
+if __name__ == 'pymol': # launched inside PyMOL
+
+    # initialize the server
 
-    # initialize the server 
-    
     server = PymolHttpd()
-    
+
     # handle_requests (fires off a separate thread)
 
     server.start()
-
-  
diff -upNr pymol-open-source-2.3.0/modules/pymol/querying.py pymol-open-source-2.3.3/modules/pymol/querying.py
--- pymol-open-source-2.3.0/modules/pymol/querying.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/querying.py	2019-08-22 10:24:47.858618491 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -35,7 +35,7 @@ if True:
                         _self.angle()
                 else:
                     _self.distance()
-        _self.unpick()   
+        _self.unpick()
 
     def get_volume_field(objName, state=1, copy=1, _self=cmd):
         '''
@@ -91,7 +91,7 @@ DESCRIPTION
     def get_modal_draw(_self=cmd,quiet=1):
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.get_modal_draw(_self._COb)
         finally:
             _self.unlock(r,_self)
@@ -100,7 +100,7 @@ DESCRIPTION
     def get_drag_object_name(_self=cmd):
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.get_drag_object_name(_self._COb)
         finally:
             _self.unlock(r,_self)
@@ -117,7 +117,7 @@ DESCRIPTION
         r = DEFAULT_ERROR
         object = str(object)
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.get_object_matrix(_self._COb,str(object), int(state)-1, int(incl_ttt))
         finally:
             _self.unlock(r,_self)
@@ -161,7 +161,7 @@ DESCRIPTION
     "get_object_list" is an unsupported command that may have
     something to do with querying the objects covered by a selection.
     '''
-        
+
         r = DEFAULT_ERROR
         selection = selector.process(selection)
         try:
@@ -231,16 +231,16 @@ PYMOL API
             _self.lock(_self)
             r = _cmd.get_title(_self._COb,str(object),int(state)-1)
             if not quiet:
-                if r!=None:
-                    print(" get_title: %s"%r)      
+                if r is not None:
+                    print(" get_title: %s"%r)
         finally:
             _self.unlock(r,_self)
         if _raising(r,_self): raise pymol.CmdException
         return r
 
 
-    def angle(name=None, selection1="(pk1)", selection2="(pk2)", 
-	      selection3="(pk3)", mode=None, label=1, reset=0, 
+    def angle(name=None, selection1="(pk1)", selection2="(pk2)",
+	      selection3="(pk3)", mode=None, label=1, reset=0,
 	      zoom=0, state=0, quiet=1, _self=cmd,
               state1=-3, state2=-3, state3=-3):
 
@@ -268,7 +268,7 @@ SEE ALSO
 
     distance, dihedral
     '''
-        
+
         r = DEFAULT_SUCCESS
         if selection1=="(pk1)":
             if "pk1" not in _self.get_names('selections'):
@@ -277,20 +277,20 @@ SEE ALSO
                 r = DEFAULT_ERROR
         if selection2=="(pk2)":
             if "pk2" not in _self.get_names('selections'):
-                if _feedback(fb_module.cmd,fb_mask.errors,_self):         
+                if _feedback(fb_module.cmd,fb_mask.errors,_self):
                     print("cmd-Error: The 'pk2' selection is undefined.")
                 r = DEFAULT_ERROR
         if selection3=="(pk3)":
             if "pk3" not in _self.get_names('selections'):
-                if _feedback(fb_module.cmd,fb_mask.errors,_self):         
+                if _feedback(fb_module.cmd,fb_mask.errors,_self):
                     print("cmd-Error: The 'pk3' selection is undefined.")
                 r = DEFAULT_ERROR
         if is_ok(r):
             r = DEFAULT_ERROR
-            
+
             # if unlabeled, then get next name in series
 
-            if name!=None:
+            if name is not None:
                 nam=name
             else:
                 try:
@@ -302,7 +302,7 @@ SEE ALSO
                     _self.unlock(r,_self)
 
             # defaults
-            if mode == None:
+            if mode is None:
                 mode = 0
             # preprocess selections
             selection1 = selector.process(selection1)
@@ -354,7 +354,7 @@ SEE ALSO
 
     distance, angle
     '''
-        r = DEFAULT_SUCCESS      
+        r = DEFAULT_SUCCESS
         if selection1=="(pk1)":
             if "pk1" not in _self.get_names('selections'):
                 if _feedback(fb_module.cmd,fb_mask.errors,_self):
@@ -362,24 +362,24 @@ SEE ALSO
                 r = DEFAULT_ERROR
         if selection2=="(pk2)":
             if "pk2" not in _self.get_names('selections'):
-                if _feedback(fb_module.cmd,fb_mask.errors,_self):         
+                if _feedback(fb_module.cmd,fb_mask.errors,_self):
                     print("cmd-Error: The 'pk2' selection is undefined.")
                 r = DEFAULT_ERROR
         if selection3=="(pk3)":
             if "pk3" not in _self.get_names('selections'):
-                if _feedback(fb_module.cmd,fb_mask.errors,_self):         
+                if _feedback(fb_module.cmd,fb_mask.errors,_self):
                     print("cmd-Error: The 'pk3' selection is undefined.")
                 r = DEFAULT_ERROR
         if selection3=="(pk4)":
             if "pk4" not in _self.get_names('selections'):
-                if _feedback(fb_module.cmd,fb_mask.errors,_self):         
+                if _feedback(fb_module.cmd,fb_mask.errors,_self):
                     print("cmd-Error: The 'pk4' selection is undefined.")
                 r = DEFAULT_ERROR
         if is_ok(r):
             r = DEFAULT_ERROR
             # if unlabeled, then get next name in series
 
-            if name!=None:
+            if name is not None:
                 nam=name
             else:
                 try:
@@ -391,7 +391,7 @@ SEE ALSO
                     _self.unlock(r,_self)
 
             # defaults
-            if mode == None:
+            if mode is None:
                 mode = 0
             # preprocess selections
             selection1 = selector.process(selection1)
@@ -418,12 +418,12 @@ SEE ALSO
                 _self.unlock(r,_self)
         if _raising(r,_self): raise pymol.CmdException
         return r
-        
-    def distance(name=None, selection1="(pk1)", selection2="(pk2)", 
+
+    def distance(name=None, selection1="(pk1)", selection2="(pk2)",
 		 cutoff=None, mode=None, zoom=0, width=None, length=None,
                  gap=None, label=1, quiet=1, reset=0, state=0,
                  state1=-3, state2=-3, _self=cmd):
-	
+
         '''
 DESCRIPTION
 
@@ -482,10 +482,10 @@ PYMOL API
     '''
         # handle unnamed distance
         r = DEFAULT_SUCCESS
-        if name!=None:
+        if name is not None:
             if len(name):
                 if name[0]=='(' or ' ' in name or '/' in name: # we're one argument off...
-                    if cutoff!=None:
+                    if cutoff is not None:
                         mode = cutoff
                     if selection2!="(pk2)":
                         cutoff = selection2
@@ -501,7 +501,7 @@ PYMOL API
                 r = DEFAULT_ERROR
         if selection2=="(pk2)":
             if "pk2" not in _self.get_names('selections'):
-                if _feedback(fb_module.cmd,fb_mask.errors,_self):         
+                if _feedback(fb_module.cmd,fb_mask.errors,_self):
                     print("cmd-Error: The 'pk2' selection is undefined.")
                 r = DEFAULT_ERROR
         if is_ok(r):
@@ -509,7 +509,7 @@ PYMOL API
 
             # if unlabeled, then get next name in series
 
-            if name!=None:
+            if name is not None:
                 nam=name
             else:
                 try:
@@ -521,9 +521,9 @@ PYMOL API
                     _self.unlock(r,_self)
 
             # defaults
-            if mode == None:
+            if mode is None:
                 mode = 0
-            if cutoff == None:
+            if cutoff is None:
                 cutoff = -1.0
             # preprocess selections
             selection1 = selector.process(selection1)
@@ -538,11 +538,11 @@ PYMOL API
                               int(label),int(quiet),int(reset),
                               int(state)-1,int(zoom),
                               int(state1)-1, int(state2)-1)
-                if width!=None:
+                if width is not None:
                     _self.set("dash_width",width,nam)
-                if length!=None:
+                if length is not None:
                     _self.set("dash_length",length,nam)
-                if gap!=None:
+                if gap is not None:
                     _self.set("dash_gap",gap,nam)
             finally:
                 _self.unlock(r,_self)
@@ -569,7 +569,7 @@ PYMOL API
         '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.get_povray(_self._COb)
         finally:
             _self.unlock(r,_self)
@@ -590,7 +590,7 @@ PYMOL API
         '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.get_idtf(_self._COb)
         finally:
             _self.unlock(r,_self)
@@ -619,13 +619,13 @@ PYMOL API
         '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.get_mtl_obj(_self._COb)
         finally:
             _self.unlock(r,_self)
         if _raising(r,_self): raise pymol.CmdException
         return r
-    
+
     def get_version(quiet=1,_self=cmd):
         '''
 DESCRIPTION
@@ -657,7 +657,7 @@ PYMOL API
                         print(' git sha:', r[4])
         return r
 
-    def get_vrml(version=2,_self=cmd): 
+    def get_vrml(version=2,_self=cmd):
         '''
 DESCRIPTION
 
@@ -671,7 +671,7 @@ PYMOL API
         '''
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.get_vrml(_self._COb,int(version))
         finally:
             _self.unlock(r,_self)
@@ -726,10 +726,10 @@ SEE ALSO
             _self.unlock(r,_self)
         if is_ok(r):
             if not quiet:
-                print(" cmd.count_states: %d states."%r)            
+                print(" cmd.count_states: %d states."%r)
         if _raising(r,_self): raise pymol.CmdException
         return r
-    
+
     def get_movie_length(quiet=1, images=-1, _self=cmd):
         '''
 DESCRIPTION
@@ -758,7 +758,7 @@ SEE ALSO
                 if r>0:
                     r = 0
             if r>=0 and not quiet:
-                print(" cmd.get_movie_length: %d frames"%r)      
+                print(" cmd.get_movie_length: %d frames"%r)
         finally:
             _self.unlock(r,_self)
         if _raising(r,_self): raise pymol.CmdException
@@ -787,13 +787,13 @@ SEE ALSO
         try:
             _self.lock(_self)
             r = _cmd.count_frames(_self._COb)
-            if not quiet: print(" cmd.count_frames: %d frames"%r)      
+            if not quiet: print(" cmd.count_frames: %d frames"%r)
         finally:
             _self.unlock(r,_self)
         if _raising(r,_self): raise pymol.CmdException
         return r
 
-    def export_dots(object,state,_self=cmd):  
+    def export_dots(object,state,_self=cmd):
         '''
 DESCRIPTION
 
@@ -830,7 +830,7 @@ NOTES
     sum.
 
     '''
-        
+
         # preprocess selections
         selection1 = selector.process(selection1)
         selection2 = selector.process(selection2)
@@ -864,18 +864,18 @@ NOTES
             _self.lock(_self)
             r = _cmd.get_object_color_index(_self._COb,name)
         finally:
-            _self.unlock(r,_self)      
+            _self.unlock(r,_self)
 #        if _raising(r,_self): raise pymol.CmdException
         return r
-    
+
     def get_color_tuple(name,mode=0,_self=cmd):
         name=str(name)
         r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             r = _cmd.get_color(_self._COb,name,mode)
-            if r==None:
-                if _feedback(fb_module.cmd,fb_mask.errors,_self):         
+            if r is None:
+                if _feedback(fb_module.cmd,fb_mask.errors,_self):
                     print("cmd-Error: Unknown color '%s'."%name)
         finally:
             _self.unlock(r,_self)
@@ -889,7 +889,7 @@ NOTES
             if all:
                 r = _cmd.get_color(_self._COb,'',2)
             else:
-                r = _cmd.get_color(_self._COb,'',1)            
+                r = _cmd.get_color(_self._COb,'',1)
         finally:
             _self.unlock(r,_self)
         if _raising(r,_self): raise pymol.CmdException
@@ -903,7 +903,7 @@ NOTES
         finally:
             _self.unlock(r,_self)
         return r
-            
+
     def get_renderer(quiet=1, _self=cmd):
         '''
 DESCRIPTION
@@ -929,7 +929,7 @@ DESCRIPTION
     def get_phipsi(selection="(name CA)",state=-1,_self=cmd):
         # preprocess selections
         selection = selector.process(selection)
-        #   
+        #
         r = DEFAULT_ERROR
         try:
             _self.lock(_self)
@@ -954,7 +954,7 @@ DESCRIPTION
             r = _cmd.get_atom_coords(_self._COb,str(selection),int(state)-1,int(quiet))
         finally:
             _self.unlock(r,_self)
-        if r==None:
+        if r is None:
             if _self._raising(_self=_self): raise pymol.CmdException
         elif not quiet:
             for a in r:
@@ -1000,7 +1000,7 @@ ARGUMENTS
             r = _cmd.get_coordset(_self._COb, name, int(state) - 1, int(copy))
             return r
 
-    
+
     def get_position(quiet=1, _self=cmd):
         '''
 DESCRIPTION
@@ -1009,7 +1009,7 @@ DESCRIPTION
     viewer window.
 
     '''
-        
+
         try:
             _self.lock(_self)
             r = _cmd.get_position(_self._COb)
@@ -1047,7 +1047,7 @@ PYMOL API
         # preprocess selections
         atom1 = selector.process(atom1)
         atom2 = selector.process(atom2)
-        #   
+        #
         r = None
         try:
             _self.lock(_self)
@@ -1086,7 +1086,7 @@ PYMOL API
         atom1 = selector.process(atom1)
         atom2 = selector.process(atom2)
         atom3 = selector.process(atom3)
-        #   
+        #
         r = DEFAULT_ERROR
         try:
             _self.lock(_self)
@@ -1098,7 +1098,7 @@ PYMOL API
         elif not quiet:
             print(" cmd.get_angle: %5.3f degrees."%r)
         return r
-        
+
     def get_dihedral(atom1="pk1",atom2="pk2",atom3="pk3",atom4="pk4",state=-1,quiet=1,_self=cmd):
         '''
 DESCRIPTION
@@ -1129,7 +1129,7 @@ PYMOL API
         atom2 = selector.process(atom2)
         atom3 = selector.process(atom3)
         atom4 = selector.process(atom4)
-        #   
+        #
         r = DEFAULT_ERROR
         try:
             _self.lock(_self)
@@ -1155,12 +1155,12 @@ PYMOL API
         '''
         # preprocess selection
         selection = selector.process(selection)
-        #   
+        #
         r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             r = _cmd.get_model(_self._COb,"("+str(selection)+")",int(state)-1,str(ref),int(ref_state)-1)
-            if r==None:
+            if r is None:
                 r = DEFAULT_ERROR
         finally:
             _self.unlock(r,_self)
@@ -1241,7 +1241,7 @@ ARGUMENTS
             r = _cmd.get_chains(_self._COb,"("+str(selection)+")",int(state)-1)
         finally:
             _self.unlock(r,_self)
-        if r==None:
+        if r is None:
             return []
         if _raising(r,_self):
             raise pymol.CmdException
@@ -1294,7 +1294,7 @@ SEE ALSO
             mode = 9
         else:
             print("Error: unknown type: '%s'"%str(type))
-            if _raising(-1,_self): raise pymol.CmdException            
+            if _raising(-1,_self): raise pymol.CmdException
         try:
             _self.lock(_self)
             r = _cmd.get_names(_self._COb,int(mode),int(enabled_only),str(selection))
@@ -1350,7 +1350,7 @@ SEE ALSO
         finally:
             _self.unlock(r,_self)
         if is_error(r):
-            if not quiet and _feedback(fb_module.cmd,fb_mask.errors,_self):      
+            if not quiet and _feedback(fb_module.cmd,fb_mask.errors,_self):
                 print("Cmd-Error: unrecognized name.")
         elif not quiet:
             print(r)
@@ -1449,7 +1449,7 @@ NOTE
         '''
         # preprocess selection
         selection = selector.process(selection)
-        #      
+        #
         r = DEFAULT_ERROR
         try:
             _self.lock(_self)
@@ -1495,7 +1495,7 @@ NOTE
         # preprocess selection
         selection1 = selector.process(selection1)
         selection2 = selector.process(selection2)
-        #      
+        #
         r = DEFAULT_ERROR
         try:
             _self.lock(_self)
@@ -1524,7 +1524,7 @@ PYMOL API
         '''
         # preprocess selection
         selection = selector.process(selection)
-        #      
+        #
         r = DEFAULT_ERROR
         try:
             _self.lock(_self)
@@ -1535,7 +1535,7 @@ PYMOL API
             if _self._raising(_self=_self): raise pymol.CmdException
         elif not quiet:
             print(" cmd.extent: min: [%8.3f,%8.3f,%8.3f]"%(r[0][0],r[0][1],r[0][2]))
-            print(" cmd.extent: max: [%8.3f,%8.3f,%8.3f]"%(r[1][0],r[1][1],r[1][2]))      
+            print(" cmd.extent: max: [%8.3f,%8.3f,%8.3f]"%(r[1][0],r[1][1],r[1][2]))
         if _raising(r,_self): raise pymol.CmdException
         return r
 
@@ -1548,9 +1548,9 @@ DESCRIPTION
     
 USAGE
         '''
-        
+
         r = cmd.get_phipsi(selection)
-        if r!=None:
+        if r is not None:
             kees = list(r.keys())
             kees.sort()
             if not quiet:
@@ -1561,7 +1561,7 @@ USAGE
                                 ("( %6.1f, %6.1f )"%r[a])+
                                 "'%(resn+'-'+resi+':'))")
                 _self.feedback('pop')
-        elif _feedback(fb_module.cmd,fb_mask.errors,_self):      
+        elif _feedback(fb_module.cmd,fb_mask.errors,_self):
             print("cmd-Error: can't compute phi_psi")
         if _raising(r,_self): raise pymol.CmdException
         return r
@@ -1582,7 +1582,7 @@ USAGE
         selection = selector.process(selection)
         #
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.select(_self._COb,"_count_tmp","("+str(selection)+")",1,int(state)-1,str(domain))
             _cmd.delete(_self._COb,"_count_tmp")
         finally:
@@ -1622,7 +1622,7 @@ DESCRIPTION
             obj = _self.get_names(obj_type)
         except:
             pass
-    
+
         if obj:
             try:
                 types = list(map(_self.get_type,obj))
diff -upNr pymol-open-source-2.3.0/modules/pymol/rpc.py pymol-open-source-2.3.3/modules/pymol/rpc.py
--- pymol-open-source-2.3.0/modules/pymol/rpc.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/rpc.py	2019-08-22 10:24:47.858618491 +0200
@@ -23,12 +23,12 @@ else:
   import xmlrpc.server as SimpleXMLRPCServer
 import threading,os,tempfile
 from pymol import cmd,cgo
- 
+
 # initial port to try for the server
 _xmlPort=9123
 # number of alternate ports to try if the first fails
 _nPortsToTry=5
- 
+
 def rpcPing():
   """ Used to establish whether or not the server is alive.
  
@@ -39,7 +39,7 @@ def rpcPing():
  
   """
   return 1
- 
+
 def rpcLabel(pos,labelText,id='lab1',color=(1,1,1)):
   """ create a text label
  
@@ -57,7 +57,7 @@ def rpcLabel(pos,labelText,id='lab1',col
   cmd.set_color("%s-color"%id,color)
   cmd.color("%s-color"%id,id)
   return 1
- 
+
 def rpcResetCGO(id):
   """ removes a CGO from the local dictionary
  
@@ -72,7 +72,7 @@ def rpcResetCGO(id):
   else:
     res = 0
   return res
- 
+
 def rpcSphere(pos,rad,color,id='cgo',extend=1,
               transparent=0,transparency=0.5):
   """ create a sphere
@@ -123,7 +123,7 @@ def rpcRenderCGO(cgoV,id='cgo',extend=1)
   cmd.load_cgo(obj,id,1)
   return 1
 
- 
+
 def rpcSpheres(sphereD,id='cgo',extend=1):
   """ create a sphere
  
@@ -150,7 +150,7 @@ def rpcSpheres(sphereD,id='cgo',extend=1
   cgoDict[id] = obj
   cmd.load_cgo(obj,id,1)
   return 1
- 
+
 def rpcCylinder(end1,end2,rad,color1,id='cgo',color2=None,extend=1,
                 transparent=0,transparency=0.5):
   """ create a cylinder
@@ -175,7 +175,7 @@ is white
  
   """
   global cgoDict
- 
+
   if color2 is None: color2 = color1
   r1,g1,b1 = color1
   r2,g2,b2 = color2
@@ -194,7 +194,7 @@ is white
   cgoDict[id] = obj
   cmd.load_cgo(obj,id,1)
   return 1
- 
+
 def rpcDeleteObject(objName):
   """ deletes an object """
   try:
@@ -203,8 +203,8 @@ def rpcDeleteObject(objName):
     res = 0
   else:
     res = 1
-  return res  
- 
+  return res
+
 def rpcDeleteAll():
   """ deletes all objects """
   res = cmd.delete('all')
@@ -212,7 +212,7 @@ def rpcDeleteAll():
     return res
   else:
     return ''
- 
+
 def colorObj(objName,colorScheme):
   """ sets an molecule's color scheme
     Arguments:
@@ -238,7 +238,7 @@ def colorObj(objName,colorScheme):
   else:
     res = 0
   return res
- 
+
 def rpcLoadPDB(data,objName,colorScheme='',replace=1):
   """ loads a molecule from a pdb string
  
@@ -263,7 +263,7 @@ def rpcLoadPDB(data,objName,colorScheme=
   else:
     return ''
 
- 
+
 def rpcLoadMolBlock(data,objName,colorScheme='',replace=1):
   """ loads a molecule from a mol block
  
@@ -287,7 +287,7 @@ def rpcLoadMolBlock(data,objName,colorSc
   else:
     return ''
 
- 
+
 def rpcLoadFile(fileName,objName='',format='',colorScheme='',replace=1):
   """ loads an object from a file
  
@@ -312,7 +312,7 @@ def rpcLoadFile(fileName,objName='',form
   else:
     return ''
 
- 
+
 def rpcLoadSurface(fileName,objName,format='',surfaceLevel=1.0):
   """ loads surface data from a file and adds an isosurface
  
@@ -322,7 +322,7 @@ def rpcLoadSurface(fileName,objName,form
       format: (OPTIONAL) the format of the input file
       surfaceLevel: (OPTIONAL) the isosurface level
  
-   """   
+   """
   if not objName:
     objName = fileName.split('.')[0]
   gridName = 'grid-%s'%objName
@@ -332,7 +332,7 @@ def rpcLoadSurface(fileName,objName,form
     return res
   else:
     return ''
- 
+
 def rpcLoadSurfaceData(data,objName='surface',format='',surfaceLevel=1.0):
   """ loads surface data from a string and adds an isosurface
  
@@ -342,7 +342,7 @@ def rpcLoadSurfaceData(data,objName='sur
       format: (OPTIONAL) the format of the input file
       surfaceLevel: (OPTIONAL) the isosurface level
  
-   """   
+   """
   gridName = 'grid-%s'%objName
   # it would be nice if we didn't have to go by way of the temporary file,
   # but at the moment pymol will only read shapes from files
@@ -355,7 +355,7 @@ def rpcLoadSurfaceData(data,objName='sur
   else:
     return ''
 
- 
+
 def rpcRotate(vect,objName='',state=-1):
   """ rotates objects
  
@@ -374,16 +374,16 @@ def rpcRotate(vect,objName='',state=-1):
 def rpcGetNames(what='selections',enabledOnly=1):
   """ returns the results of cmd.get_names(what) """
   return cmd.get_names(what,enabled_only=enabledOnly)
- 
+
 def rpcIdAtom(what='all',mode=0):
   """ returns the results of cmd.id_atom(what) """
   return cmd.id_atom(what,mode=mode)
- 
+
 def rpcGetAtomCoords(what='all',state=0):
   """ returns the results of cmd.get_atom_coords(what,state) """
   return cmd.get_atom_coords(what,state=state)
- 
- 
+
+
 def rpcHelp(what=''):
   """ returns general help text or help on a particular command """
   global serv
@@ -410,9 +410,9 @@ def rpcHelp(what=''):
       res += ')\n'
       if fn.__doc__:
         res += fn.__doc__
-  return res  
- 
- 
+  return res
+
+
 def launch_XMLRPC(hostname='',port=_xmlPort,nToTry=_nPortsToTry):
   """ launches the xmlrpc server into a separate thread
  
@@ -427,7 +427,7 @@ def launch_XMLRPC(hostname='',port=_xmlP
   if not hostname:
     import os
     hostname = os.environ.get('PYMOL_RPCHOST', 'localhost')
- 
+
   global cgoDict,serv
   cgoDict = {}
   for i in range(nToTry):
@@ -467,7 +467,7 @@ def launch_XMLRPC(hostname='',port=_xmlP
 
     # legacy stuff, should be removed because overwrites API names!
     serv.register_function(rpcLabel,'label')   # pseudoatom
-    serv.register_function(rpcRotate,'rotate') 
+    serv.register_function(rpcRotate,'rotate')
 
     serv.register_introspection_functions()
     t = threading.Thread(target=serv.serve_forever)
@@ -475,5 +475,5 @@ def launch_XMLRPC(hostname='',port=_xmlP
     t.start()
   else:
     print('xml-rpc server could not be started')
-    
+
 # vi:expandtab:smarttab:sw=2
diff -upNr pymol-open-source-2.3.0/modules/pymol/selecting.py pymol-open-source-2.3.3/modules/pymol/selecting.py
--- pymol-open-source-2.3.0/modules/pymol/selecting.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/selecting.py	2019-08-22 10:24:47.858618491 +0200
@@ -1,26 +1,26 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
 if True:
-    
+
     from . import selector
 
     cmd = __import__("sys").modules["pymol.cmd"]
 
     from .cmd import _cmd,Shortcut, \
           DEFAULT_ERROR, DEFAULT_SUCCESS, _raising, is_ok, is_error
-    
+
     import pymol
 
     def deselect(_self=cmd):
@@ -41,11 +41,11 @@ PYMOL API
         arg = _self.get_names("selections",enabled_only=1)
         for a in arg:
             _self.disable(a)
-        if _self._raising(r,_self): raise pymol.CmdException                  
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
-    
 
-    def select(name, selection="", enable=-1, quiet=1, merge=0, state=0, domain='',_self=cmd): 
+
+    def select(name, selection="", enable=-1, quiet=1, merge=0, state=0, domain='',_self=cmd):
         '''
 DESCRIPTION
 
@@ -86,18 +86,18 @@ SEE ALSO
         try:
             _self.lock(_self)
             if selection=="":
-                selection = name                    
+                selection = name
                 if _self.get_setting_boolean("auto_number_selections"):
                     sel_cnt = _self.get_setting_int("sel_counter") + 1
                     _self.set("sel_counter", sel_cnt)
                     name = "sel%02.0f" % sel_cnt
                 else:
                     name = "sele"
-            if name == None:
+            if name is None:
                 sel_cnt = _self.get_setting_int("sel_counter") + 1
                 _self.set("sel_counter", sel_cnt)
                 name = "sel%02.0f" % sel_cnt
-                
+
             # preprocess selection (note: inside TRY)
             selection = selector.process(selection)
             merge = int(merge)
@@ -114,7 +114,7 @@ SEE ALSO
                 _cmd.onoff(_self._COb,str(name),0,0)
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException                  
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
 
@@ -158,7 +158,7 @@ PYMOL API
                     r = _cmd.onoff(_self._COb,str(name),0,0)
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException                  
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     id_type_dict = {
@@ -166,14 +166,29 @@ PYMOL API
         'id'    : 1,
         'rank'  : 2,
         }
-    
+
     id_type_sc = Shortcut(id_type_dict.keys())
-    
+
     def select_list(name,object,id_list,state=0,mode='id',quiet=1,_self=cmd):
         '''
 DESCRIPTION
-    "select_list" is currently in development
-    
+
+    API only. Select by atom indices within a single object.
+
+    Returns the number of selected atoms.
+
+ARGUMENTS
+
+    name = str: a unique name for the selection
+
+    object = str: object name
+
+    id_list = list of integers: ID, index, or rank list.
+
+    state = int: object state, to limit selection to atoms which have
+    coordinates in that state (-1 = current, 0 = ignore) {default: 0}
+
+    mode = id|index|rank: {default: id}
         '''
         #
         r = DEFAULT_ERROR
@@ -204,9 +219,9 @@ PYMOL API
         r = DEFAULT_ERROR
         # preprocess selection
         selection = selector.process(selection)
-        #      
+        #
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.select(_self._COb,"indicate","("+str(selection)+")",1,-1,'')
             if is_error(r):
                 _self.delete("indicate")
@@ -214,7 +229,7 @@ PYMOL API
                 _self.enable("indicate")
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise pymol.CmdException                  
+        if _self._raising(r,_self): raise pymol.CmdException
         return r
 
     def objsele_state_iter(selection, state=0, _self=cmd):
@@ -235,8 +250,3 @@ DESCRIPTION
                 last = _self.count_states('%' + oname)
             for ostate in range(first, last + 1):
                 yield osele, ostate
-
-
-
-
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/setting.py pymol-open-source-2.3.3/modules/pymol/setting.py
--- pymol-open-source-2.3.0/modules/pymol/setting.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/setting.py	2019-08-22 10:24:47.858618491 +0200
@@ -1,21 +1,21 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
 from __future__ import print_function
 
 if True:
-    
+
     import traceback
     from . import selector
     from .shortcut import Shortcut
@@ -23,7 +23,7 @@ if True:
     from .cmd import _cmd,lock,lock_attempt,unlock,QuietException, \
           is_string, \
           _feedback,fb_module,fb_mask, \
-          DEFAULT_ERROR, DEFAULT_SUCCESS, _raising, is_ok, is_error        
+          DEFAULT_ERROR, DEFAULT_SUCCESS, _raising, is_ok, is_error
 
     # name -> index mapping
     index_dict = _cmd.get_setting_indices()
@@ -37,11 +37,6 @@ if True:
     # legacy
     index_dict['ray_shadows'] =     index_dict['ray_shadow']
 
-    # legacy, in case someone used that in a script
-    class SettingIndex:
-        def __getattr__(self, name):
-            return index_dict[name]
-
     boolean_dict = {
         "true" : 1,
         "false": 0,
@@ -189,13 +184,13 @@ PYMOL API
                     raise _self.pymol.CmdException("invalid value: %s" % repr(value))
             finally:
                 _self.unlock(r,_self)
-        if _self._raising(r,_self): raise QuietException            
+        if _self._raising(r,_self): raise QuietException
         return r
 
-        
+
     def set(name, value=1, selection='', state=0, updates=1, log=0,
             quiet=1,_self=cmd):
-        
+
         '''
 DESCRIPTION
 
@@ -295,7 +290,7 @@ SEE ALSO
                     raise _self.pymol.CmdException("invalid value: %s" % repr(value))
             finally:
                 _self.unlock(r,_self)
-        if _self._raising(r,_self): raise QuietException            
+        if _self._raising(r,_self): raise QuietException
         return r
 
     def unset(name, selection='', state=0, updates=1, log=0, quiet=1, _self=cmd):
@@ -355,7 +350,7 @@ SEE ALSO
                 finally:
                     _self.unlock(r,_self)
         return r
-    
+
     def unset_bond(name,selection1,selection2=None,state=0,updates=1,log=0,quiet=1,_self=cmd):
         '''
 DESCRIPTION
@@ -389,7 +384,7 @@ USAGE
                     print("Error: unable to unset setting value.")
             finally:
                 _self.unlock(r,_self)
-        if _self._raising(r,_self): raise QuietException            
+        if _self._raising(r,_self): raise QuietException
         return r
 
     def get_setting(name,object='',state=0,_self=cmd): # INTERNAL
@@ -412,7 +407,7 @@ USAGE
         if is_ok(r):
             return value
         elif _self._raising(r,_self):
-            raise QuietException                     
+            raise QuietException
         return r
 
     def get(name, selection='', state=0, quiet=1, _self=cmd):
@@ -452,7 +447,7 @@ SEE ALSO
     set, set_bond, get_bond
 
     '''
-        
+
         r = DEFAULT_ERROR
         state = int(state)
         i = _get_index(name)
@@ -461,7 +456,7 @@ SEE ALSO
             r = _cmd.get_setting_text(_self._COb,i,str(selection),state-1)
         finally:
             _self.unlock(r,_self)
-        if is_ok(r) and (r!=None):
+        if is_ok(r) and (r is not None):
             if not int(quiet):
                 name = name_dict.get(i, name)
                 r_str = str(r)
@@ -475,7 +470,7 @@ SEE ALSO
                     print(" get: %s = %s in object %s state %d"%(name,r_str,selection,state))
         if _self._raising(r,_self): raise QuietException
         return r
-    
+
     def get_setting_tuple_new(name,object='',state=0,_self=cmd): # INTERNAL
         r = DEFAULT_ERROR
         i = _get_index(name)
@@ -493,7 +488,7 @@ SEE ALSO
             # legacy API
             r = (r[0], (r[1],))
         return r
-    
+
     def get_setting_boolean(name,object='',state=0,_self=cmd): # INTERNAL
         r = DEFAULT_ERROR
         i = _get_index(name)
@@ -504,7 +499,7 @@ SEE ALSO
             _self.unlock(r,_self)
         if _self._raising(r,_self): raise QuietException
         return r
-    
+
     def get_setting_int(name,object='',state=0,_self=cmd): # INTERNAL
         r = DEFAULT_ERROR
         i = _get_index(name)
@@ -514,7 +509,7 @@ SEE ALSO
         finally:
             _self.unlock(r,_self)
         return r
-    
+
     def get_setting_float(name,object='',state=0,_self=cmd): # INTERNAL
         r = DEFAULT_ERROR
         i = _get_index(name)
@@ -614,7 +609,7 @@ PYMOL API
                     raise QuietException
             finally:
                 _self.unlock(r,_self)
-        if _self._raising(r,_self): raise QuietException            
+        if _self._raising(r,_self): raise QuietException
         if not quiet:
             name = name_dict.get(index, name)
             suffix = ' state %d' % state if state > 0 else ''
diff -upNr pymol-open-source-2.3.0/modules/pymol/shortcut.py pymol-open-source-2.3.3/modules/pymol/shortcut.py
--- pymol-open-source-2.3.0/modules/pymol/shortcut.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/shortcut.py	2019-08-22 10:24:47.858618491 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -152,7 +152,7 @@ if True:
         def auto_err(self,kee,descrip=None):
             result = None
             if kee not in self.shortcut:
-                if descrip!=None:
+                if descrip is not None:
                     print("Error: unknown %s: '%s'." % (descrip, kee), end=' ')
                     lst = self.interpret('')
                     if is_list(lst):
@@ -170,7 +170,7 @@ if True:
             else:
                 result = self.interpret(kee)
                 if not is_string(result):
-                    if descrip!=None:
+                    if descrip is not None:
                         print("Error: ambiguous %s:"%descrip)
                         lst = parsing.list_to_str_list(result)
                         for a in lst:
diff -upNr pymol-open-source-2.3.0/modules/pymol/util.py pymol-open-source-2.3.3/modules/pymol/util.py
--- pymol-open-source-2.3.0/modules/pymol/util.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/util.py	2019-08-22 10:24:47.858618491 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -271,7 +271,7 @@ def mass_align(target,enabled_only=0,max
                 cmd.align('polymer and name CA and (%s)'%name,
                 'polymer and name CA and (%s)'%target,max_gap=max_gap,quiet=0,
                           object=aln_object)
-    
+
 def sum_formal_charges(selection="(all)",quiet=1,_self=cmd):
     _util_sum_fc = [0]
     _self.iterate(selection, "_util_sum_fc[0] += formal_charge", space=locals())
@@ -337,14 +337,14 @@ NOTES
     if not quiet:
         print(" util.compute_mass: mass = %0.4f u"%result)
     return result
-    
+
 def protein_assign_charges_and_radii(obj_name,_self=cmd):
     cmd=_self
 
     from chempy.champ import assign
 
     # apply a few kludges
-    
+
     # convent Seleno-methionine to methionine
 
     cmd.alter(obj_name+"///MSE/SE","elem='S';name='SD'",quiet=1)
@@ -357,12 +357,12 @@ def protein_assign_charges_and_radii(obj
     cmd.alter(obj_name,"alt=''")
     cmd.sort(obj_name)
     cmd.fix_chemistry(obj_name,obj_name,1)
-    
+
     # make sure all atoms are included...
     cmd.alter(obj_name,"q=1.0",quiet=1)
-    
+
     print(" Util: Fixing termini and assigning formal charges...")
-    
+
     assign.missing_c_termini(obj_name,quiet=1,_self=_self)
 
     while not assign.formal_charges(obj_name,quiet=1,_self=_self):
@@ -371,23 +371,23 @@ def protein_assign_charges_and_radii(obj
                         'print("  "+model+"/"+segi+"/"+chain+"/"+resn+"`"+resi+"/")',quiet=1)
         cmd.remove("byres ("+obj_name+" and flag 23)") # get rid of residues that weren't assigned
         assign.missing_c_termini(obj_name,quiet=1,_self=_self)
-        
+
     print(" Util: Assigning Amber 99 charges and radii...")
-    
+
     cmd.h_add(obj_name)
     if not assign.amber99(obj_name,quiet=1,_self=_self):
         print(" WARNING: some unassigned atoms are being deleted:")
         cmd.iterate("byres ("+obj_name+" and flag 23)",
                         'print("  "+model+"/"+segi+"/"+chain+"/"+resn+"`"+resi+"/"+name+"? ["+elem+"]")',quiet=1)
         cmd.remove(obj_name+" and flag 23") # get rid of any atoms that weren't assigned
-        
+
     # show the user what the net charges are...
-        
+
     formal = sum_formal_charges(obj_name,quiet=0,_self=_self)
     partial = sum_partial_charges(obj_name,quiet=0,_self=_self)
     if round(formal)!=round(partial):
         print(" WARNING: formal and partial charge sums don't match -- there is a problem!")
-    
+
 def protein_vacuum_esp(selection, mode=2, border=10.0, quiet = 1, _self=cmd):
     cmd=_self
 
@@ -408,7 +408,7 @@ def protein_vacuum_esp(selection, mode=2
          # try to just get protein...
 
     protein_assign_charges_and_radii(obj_name,_self=_self)
-        
+
     ext = cmd.get_extent(obj_name)
     max_length = max(abs(ext[0][0] - ext[1][0]),abs(ext[0][1] - ext[1][1]),abs(ext[0][2]-ext[1][2])) + 2*border
 
@@ -422,19 +422,19 @@ def protein_vacuum_esp(selection, mode=2
     elif mode==1: # neutral, no cutoff
         cmd.map_new(map_name,"coulomb_neutral",sep,obj_name,border)
     else: # local, with cutoff
-        cmd.map_new(map_name,"coulomb_local",sep,obj_name,border)      
-        
+        cmd.map_new(map_name,"coulomb_local",sep,obj_name,border)
+
     cmd.ramp_new(pot_name, map_name, selection=obj_name,zero=1)
     cmd.hide("everything",obj_name)
     cmd.show("surface",obj_name)
     cmd.set("surface_color",pot_name,obj_name)
     cmd.set("surface_ramp_above_mode",1,obj_name)
-    
+
 def color_carbon(color,selection="(all)",_self=cmd):
     cmd=_self
     selection = str(selection)
     cmd.color(color,"(%s) and elem C"%selection)
-    
+
 def cbss(selection="(all)",helix_color="red",sheet_color="yellow",loop_color="green",quiet=1,_self=cmd):
     cmd=_self
     sel = str(selection)
@@ -451,67 +451,67 @@ def cbag(selection="(all)",quiet=1,_self
     s = str(selection)
     cmd.color("atomic","(("+s+") and not elem C)",quiet=quiet)
     cmd.color("carbon","(elem C and ("+s+"))",quiet=quiet)
-    
+
 def cbac(selection="(all)",quiet=1,_self=cmd):
     '''Wrapper around "color atomic"'''
     cmd=_self
     s = str(selection)
     cmd.color("atomic","(("+s+") and not elem C)",quiet=quiet)
     cmd.color("cyan","(elem C and ("+s+"))",quiet=quiet)
-    
+
 def cbam(selection="(all)",quiet=1,_self=cmd):
     '''Wrapper around "color atomic"'''
     cmd=_self
-    s = str(selection)   
+    s = str(selection)
     cmd.color("atomic","(("+s+") and not elem C)",quiet=quiet)
     cmd.color("lightmagenta","(elem C and ("+s+"))",quiet=quiet)
 
 def cbay(selection="(all)",quiet=1,_self=cmd):
     '''Wrapper around "color atomic"'''
     cmd=_self
-    s = str(selection)   
+    s = str(selection)
     cmd.color("atomic","(("+s+") and not elem C)",quiet=quiet)
     cmd.color("yellow","(elem C and ("+s+"))",quiet=quiet)
 
 def cbas(selection="(all)",quiet=1,_self=cmd):
     '''Wrapper around "color atomic"'''
     cmd=_self
-    s = str(selection)   
+    s = str(selection)
     cmd.color("atomic","(("+s+") and not elem C)",quiet=quiet)
     cmd.color("salmon","(elem C and ("+s+"))",quiet=quiet)
 
 def cbaw(selection="(all)",quiet=1,_self=cmd):
     '''Wrapper around "color atomic"'''
     cmd=_self
-    s = str(selection)   
+    s = str(selection)
     cmd.color("atomic","(("+s+") and not elem C)",quiet=quiet)
     cmd.color("hydrogen","(elem C and ("+s+"))",quiet=quiet)
 
 def cbab(selection="(all)",quiet=1,_self=cmd):
     '''Wrapper around "color atomic"'''
     cmd=_self
-    s = str(selection)   
+    s = str(selection)
     cmd.color("atomic","(("+s+") and not elem C)",quiet=quiet)
     cmd.color("slate","(elem C and ("+s+"))",quiet=quiet)
 
 def cbao(selection="(all)",quiet=1,_self=cmd):
     '''Wrapper around "color atomic"'''
     cmd=_self
-    s = str(selection)   
+    s = str(selection)
     cmd.color("atomic","(("+s+") and not elem C)",quiet=quiet)
     cmd.color("brightorange","(elem C and ("+s+"))",quiet=quiet)
 
 def cbap(selection="(all)",quiet=1,_self=cmd):
     '''Wrapper around "color atomic"'''
     cmd=_self
-    s = str(selection)   
+    s = str(selection)
     cmd.color("atomic","(("+s+") and not elem C)",quiet=quiet)
     cmd.color("purple","(elem C and ("+s+"))",quiet=quiet)
 
 def cbak(selection="(all)",quiet=1,_self=cmd):
     '''Wrapper around "color atomic"'''
     cmd=_self
-    s = str(selection)   
+    s = str(selection)
     cmd.color("atomic","(("+s+") and not elem C)",quiet=quiet)
     cmd.color("pink","(elem C and ("+s+"))",quiet=quiet)
 
@@ -563,7 +563,7 @@ def modernize_rendering(mode,_self=cmd):
     and quality.
     """
     cmd = _verbose_cmd_proxy(_self)
-    
+
     cmd.set("max_ups",0)
 
     enable_all_shaders(cmd)
@@ -579,7 +579,7 @@ def performance(mode,_self=cmd):
     mode = int(mode)
     if mode==0: # maximum quality
         cmd.set('line_smooth',1)
-        cmd.set('depth_cue',1)         
+        cmd.set('depth_cue',1)
         cmd.set('specular',1)
         cmd.set('surface_quality',1)
         cmd.set('cartoon_sampling',14)
@@ -615,8 +615,8 @@ def performance(mode,_self=cmd):
             cmd.set('sphere_quality',2)
             cmd.set('stick_ball',1)
     elif mode==33:
-        cmd.set('line_smooth',1)         
-        cmd.set('depth_cue',1)         
+        cmd.set('line_smooth',1)
+        cmd.set('depth_cue',1)
         cmd.set('specular',1)
         cmd.set('surface_quality',0)
         cmd.set('cartoon_sampling',7)
@@ -654,7 +654,7 @@ def performance(mode,_self=cmd):
 
     elif mode==66: # good perfomance
         cmd.set('line_smooth',0)
-        cmd.set('depth_cue',0)         
+        cmd.set('depth_cue',0)
         cmd.set('specular',1)
         cmd.set('surface_quality',0)
         cmd.set('cartoon_sampling',6)
@@ -723,7 +723,7 @@ def performance(mode,_self=cmd):
 
     cmd.do("rebuild")
 
-    
+
 def label_chains(sele="all",_self=cmd):
     pymol=_self._pymol
     cmd=_self
@@ -743,9 +743,9 @@ def label_chains(sele="all",_self=cmd):
     list = [_f for _f in list if _f]
     for a in list:
         if(a[1]==''):
-            cmd.label("%s`%d"%(a[0],a[2]),'''"chain ''"''',quiet=1)         
+            cmd.label("%s`%d"%(a[0],a[2]),'''"chain ''"''',quiet=1)
         elif(a[1]==' '):
-            cmd.label("%s`%d"%(a[0],a[2]),'''"chain ' '"''',quiet=1)         
+            cmd.label("%s`%d"%(a[0],a[2]),'''"chain ' '"''',quiet=1)
         else:
             cmd.label("%s`%d"%(a[0],a[2]),"'chain '+chain",quiet=1)
 
@@ -768,22 +768,12 @@ def label_segments(sele="all",_self=cmd)
     list = [_f for _f in list if _f]
     for a in list:
         if(a[1]==''):
-            cmd.label("%s`%d"%(a[0],a[2]),'''"segi ''"''',quiet=1)         
+            cmd.label("%s`%d"%(a[0],a[2]),'''"segi ''"''',quiet=1)
         elif(a[1]==' '):
-            cmd.label("%s`%d"%(a[0],a[2]),'''"segi ' '"''',quiet=1)         
+            cmd.label("%s`%d"%(a[0],a[2]),'''"segi ' '"''',quiet=1)
         else:
             cmd.label("%s`%d"%(a[0],a[2]),"'segi '+segi",quiet=1)
 
-    
-# legacy
-from pymol.selecting import deselect as hide_sele # noqa
-
-# FUBAR
-#def hbond(a,b,cutoff=3.3,name='hbond'):
-#   cmd.dist(name,"((%s) and ((%s) around %4.2f) and elem N,O)"%(a,b,cutoff),
-#            "((%s) and ((%s) around %4.2f) and elem N,O)"%(b,a,cutoff),
-#            cutoff)
-
 def cbc(selection='(all)',first_color=7,quiet=1,legacy=0,_self=cmd):
     '''
     Color all chains a different color
@@ -799,9 +789,9 @@ def cbc(selection='(all)',first_color=7,
         if not quiet:
             print(" util.cbc: color %s, (chain %s)" % (color, a))
         _self.color(color, "(chain %s and (%s))" % (a, selection), quiet=quiet)
-        
+
 def color_objs(selection='(all)',quiet=1,_self=cmd):
-    cmd=_self 
+    cmd=_self
     '''
     Color all chains a different color
     '''
@@ -832,11 +822,8 @@ def chainbow(selection='(all)', palette=
             _self.spectrum('count', palette,
                     "(chain '%s' & model %s & (%s))" % (a, model, selection),
                     byres=1, quiet=quiet)
-            
-color_chains = cbc
 
-# legacy
-sum_charge = sum_partial_charges
+color_chains = cbc
 
 def ray_shadows(mode,_self=cmd):
     cmd = _verbose_cmd_proxy(_self)
@@ -845,7 +832,7 @@ def ray_shadows(mode,_self=cmd):
         cmd.set('ray_shadow',0)
     else:
         cmd.set('ray_shadow',1)
-    if mode=='light': 
+    if mode=='light':
         cmd.set('light_count',2)
         cmd.set("light","[-0.4,-0.4,-1.0]")
         cmd.set('ambient',0.14)
@@ -868,7 +855,7 @@ def ray_shadows(mode,_self=cmd):
         cmd.set('reflect',0.45)
         cmd.set('shininess',25)
         cmd.set('power',1.25)
-        cmd.set('spec_count',-1)                
+        cmd.set('spec_count',-1)
         cmd.set('specular_intensity',0.2)
         cmd.set('spec_direct',0)
         cmd.set('ray_shadow_decay_factor',0)
@@ -890,7 +877,7 @@ def ray_shadows(mode,_self=cmd):
         cmd.set('spec_count',1)
         cmd.set('shininess',55)
         cmd.set('power',1.0)
-        cmd.set('spec_direct',0)        
+        cmd.set('spec_direct',0)
         cmd.set('ray_shadow_decay_factor',0.1)
         cmd.set('ray_shadow_decay_range',1.8)
     elif mode=='occlusion':
@@ -907,7 +894,7 @@ def ray_shadows(mode,_self=cmd):
         cmd.set('direct',0.10)
         cmd.set('reflect',0.80)
         cmd.set('shininess',10)
-        cmd.set('spec_count',-1)        
+        cmd.set('spec_count',-1)
         cmd.set('power',1.0)
         cmd.set('specular_intensity',0)
         cmd.set('spec_direct',0.25)
@@ -939,14 +926,14 @@ def ray_shadows(mode,_self=cmd):
         cmd.set('spec_direct',0)
         cmd.set('ray_shadow_decay_factor',0)
     elif mode=='heavy':
-        cmd.set('light_count',2)        
+        cmd.set('light_count',2)
         cmd.set("light","[-0.4,-0.4,-1.0]")
         cmd.set('ambient',0.05)
         cmd.set('direct',0.20)
         cmd.set('reflect',0.85)
         cmd.set('spec_count',-1)
-        cmd.set('shininess',90) 
-        cmd.set('power',1.0) 
+        cmd.set('shininess',90)
+        cmd.set('power',1.0)
         cmd.set('specular_intensity',0.5)
         cmd.set('spec_direct',0)
         cmd.set('ray_shadow_decay_factor',0)
@@ -962,7 +949,7 @@ def ray_shadows(mode,_self=cmd):
         cmd.set('specular_intensity',0.5)
         cmd.set('spec_direct',0)
         cmd.set('ray_shadow_decay_factor',0)
-        
+
 def ff_copy(src,dst,_self=cmd):
     pymol=_self._pymol
     cmd=_self # NOT THREAD SAFE
@@ -974,12 +961,12 @@ def ff_copy(src,dst,_self=cmd):
     cmd.iterate("(%s)"%src,"_rcopy.tt[name]=text_type")
     cmd.alter("(%s)"%dst,"text_type=_rcopy.tt[name]")
     del pymol._rcopy
-    
+
 def b2vdw(selection='all', _self=cmd):
     # use B values to create RMS VDW spheres
     # rms = sqrt(b/(8*(PI^2)))
     _self.alter(selection, "vdw=(b/78.9568352087)**0.5")
-    
+
 def phipsi(selection="(pk1)",_self=cmd):
     cmd=_self # NOT THREAD SAFE
     n_sele =   "((byres (%s)) & name N)"%selection
@@ -1016,540 +1003,35 @@ def rainbow(selection="(name CA and alt
 
     Use instead: spectrum
     '''
-    cmd=_self # NOT THREAD SAFE
-
-    cmd.feedback("push")
-    cmd.feedback("disable","executive","actions")
-
-    # your basic rainbow...
-    
+    print(' util.rainbow: Deprecated, use cmd.spectrum() instead')
     list = [
-        (0,0,255),      
+        (0,0,255),
         (0,0,255),
         (0,128,255),
         (0,255,255),
-        (0,255,128),           
+        (0,255,128),
         (0,255,0),
         (128,255,0),
         (255,255,0),
         (255,128,0),
         (255,0,0),
-        (255,0,0)      
+        (255,0,0)
         ]
     if reverse:
         list.reverse()
-    #
-    last = list.pop(0)
-    cmd.set_color("_000",[last[0]/255.0,last[1]/255.0,last[2]/255.0])
-    c = 1
-    for a in list:
-        for b in range(1,21):
-            b0 = b/20.0
-            b1 = 1.0-b0
-            cname = "_%03d"%c
-            r = last[0]*b1+a[0]*b0
-            g = last[1]*b1+a[1]*b0
-            b = last[2]*b1+a[2]*b0
-            cmd.set_color(cname,[r/255.0,g/255.0,b/255.0])
-            c = c + 1
-        last = a
+    list = ['0x%02x%02x%02x' % rgb for rgb in list]
+    _self.spectrum('count', ' '.join(list), selection)
 
-    cas = cmd.index("((byres ("+selection+")) and name CA and not het)")
-    l = len(cas)
-    if not len(cas):
-        return
-    c = 0
-    for a in cas:
-        col = int((200*c)/l)
-        cmd.color("_%03d"%col,"((%s) and (byres %s`%d))"%(selection,a[0],a[1]))
-        c = c + 1
 
-    cmd.feedback("pop")
-    
 def ss(selection="(name CA and alt '',A)",state=1,_self=cmd):
     '''
     Legacy secondary structure assignment routine. Don't use.
 
     Use instead: dss
     '''
-    pymol=_self._pymol
-    cmd=_self # NOT THREAD SAFE
-
-    print(' util.ss: WARNING: This is not a "correct" secondary structure')
-    print(' util.ss: assignment algorithm!  Please use only as a last resort.')
-    
-    cmd.feedback("push")
-    cmd.feedback("disable","executive","actions")
-    
-    ss_pref = "_sss"
-    sss1 = ss_pref+"1"
-    cnt = cmd.select(sss1,"((byres ("+selection+")) and name CA and not het)")
-    print(" util.ss: initiating secondary structure assignment on %d residues."%cnt)
-    cas = cmd.index(sss1)
-    if not len(cas):
-        return
-    # set cartoon mode to auto over the selection
-    
-    cmd.cartoon("auto",sss1)
-
-    print(" util.ss: extracting sequence and relationships...")
-
-    # get CA list
-    
-    res_list = []
-    pymol._ss = pymol.Scratch_Storage()
-    pymol._ss.res_list = res_list
-    cmd.iterate(sss1,'_ss.res_list.append((model,index))')
-
-    # generate atom-to-residue conversion dictionaries
-
-    ca_dict = {}
-    n_dict = {}
-    o_dict = {}
-    scr_dict = {} # scr = segment,chain,resi 
-    pymol._ss.n_dict = n_dict
-    pymol._ss.o_dict = o_dict
-    pymol._ss.scr_dict = scr_dict
-    pymol._ss.ca_dict = ca_dict
-    cmd.iterate(sss1,
-                    '_ss.scr_dict[(model,index)]=(segi,chain,resi)') # CA's
-    cmd.iterate("((byres "+sss1+") and n;N)"
-                    ,'_ss.scr_dict[(model,index)]=(segi,chain,resi)') # N's
-    cmd.iterate("((byres "+sss1+") and n;O)",
-                    '_ss.scr_dict[(model,index)]=(segi,chain,resi)') # O's
-    cmd.iterate(sss1,
-                    '_ss.ca_dict[(segi,chain,resi)] = (model,index)')
-    cmd.iterate("((byres "+sss1+") and n;N)",
-                    '_ss.n_dict[(segi,chain,resi)] = (model,index)')
-    cmd.iterate("((byres "+sss1+") and n;O)",
-                    '_ss.o_dict[(segi,chain,resi)] = (model,index)')
-
-    scr_dict[None]=None
-    o_dict[None]=None
-    n_dict[None]=None
-    ca_dict[None]=None
-    
-    # create special version of cas with gaps
-
-    gap = [None,None,None,None]  
-    # gap large enough to distinguish i+4 interations from gaps
-    last = None
-    for a in res_list:
-        if last!=None:
-            if(cmd.count_atoms(
-                "((neighbor(neighbor(neighbor (%s`%d)))) and (%s`%d))"%
-                (last[0],last[1],a[0],a[1]),quiet=1)==0):
-                gap.extend([None,None,None,None])
-        gap.append(a)
-        last = a
-    gap.extend([None,None,None,None])
-
-    print(" util.ss: analyzing phi/psi angles (slow)...")
-
-    # generate reverse-lookup for gap indices
-
-    ss = {}
-
-    c = 0
-    gap_idx = {}
-    for a in gap:
-        gap_idx[a] = c
-        c = c + 1
-
-    # secondary structure database...
-    
-    ss = {}
-    ss[None]=None
-    
-    # make decisions based on phi/psi
-
-    for a in cas:
-        ss[a] = 'L' # default
-    phipsi = cmd.get_phipsi(sss1,state)
-    for a in phipsi.keys():
-        (phi,psi) = phipsi[a]
-#      print scr_dict[a],(phi,psi)
-        if (phi!=None) and (psi!=None):
-            if ((phi<-45) and (phi>-160) and
-                 (psi<-170) or (psi>10)): # beta?
-                ss[a] = 's'
-            elif ((phi<-45) and (phi>-160) and
-                    (psi>-80) and (psi<-25)): # helix?
-                ss[a] = 'H'
-                
-    print(" util.ss: finding hydrogen bonds...")
-    
-    # find all pairwise hydrogen bonds and make note of them in dict
-
-    hb = cmd.find_pairs("((byres "+sss1+") and n;N)",
-                              "((byres "+sss1+") and n;O)",mode=1,
-                              cutoff=3.7,angle=55,
-                              state1=state,state2=state)
-    
-    hb_dict = {}  # [((N-atom) (O-atom))] = 1
-    n_hb_dict = {} # [(N-atom)] = [(O-atom),...]
-    o_hb_dict = {} # [(O-atom)] = [(N-atom),...]
-    for a in hb:
-#      cmd.dist("(%s`%d)"%a[0],"(%s`%d)"%a[1])
-        hb_dict[a] = 1
-        n = a[0]
-        o = a[1]
-        if n not in n_hb_dict: n_hb_dict[n]=[]
-        if o not in o_hb_dict: o_hb_dict[o]=[]
-        n_hb_dict[n].append(o)
-        o_hb_dict[o].append(n)
-
-    # check to insure that all helical residues have at least an i +/- 4
-    # hydrogen bond
-
-    for c in range(4,len(gap)-4):
-        a = gap[c]
-        if ss[a]=='H':
-            aN = n_dict[scr_dict[a]]
-            aO = o_dict[scr_dict[a]]
-            am4O = o_dict[scr_dict[gap[c-4]]]
-            ap4N = n_dict[scr_dict[gap[c+4]]]
-            if (aN,am4O) not in hb_dict:
-                if (ap4N,aO) not in hb_dict:
-                    ss[a]='L'
-
-    print(" util.ss: verifying beta sheets...")
-    
-    # check to insure that all beta residues have proper interactions
-
-    rep_dict = {}
-    repeat = 1
-    while repeat:
-        repeat = 0
-        c = 4
-        cc = len(gap)-4
-        while c<cc:
-            a1 = gap[c]
-            if (ss[a1] in ['s','S']) and a1 not in rep_dict:
-                rep_dict[a1] = 1
-                valid = 0
-                scr_a1 = scr_dict[a1]
-                # look for antiparallel 2:2 H-bonds (NH-O=C + C=O-HN) 
-                n_a1_atom = n_dict[scr_a1]
-                o_a1_atom = o_dict[scr_a1]
-                if (n_a1_atom in n_hb_dict and 
-                     o_a1_atom in o_hb_dict):
-                    for n_hb_atom in n_hb_dict[n_a1_atom]:
-                        for o_hb_atom in o_hb_dict[o_a1_atom]:
-                            n_hb_scr = scr_dict[n_hb_atom]
-                            o_hb_scr = scr_dict[o_hb_atom]
-                            if o_hb_scr == n_hb_scr:
-                                b1 = ca_dict[o_hb_scr]
-                                if abs(c-gap_idx[b1])>2:
-                                    ss[b1] = 'S' 
-                                    ss[a1] = 'S' 
-                                    valid = 1
-                # look for antiparallel offset HB (i,i+2,j,j-2)
-                a3 = gap[c+2]
-                if (a3!=None):
-                    scr_a3 = scr_dict[a3]
-                    o_a1_atom = o_dict[scr_a1]
-                    n_a3_atom = n_dict[scr_a3]
-                    if (n_a3_atom in n_hb_dict and
-                         o_a1_atom in o_hb_dict):               
-                        for n_hb_atom in n_hb_dict[n_a3_atom]:
-                            for o_hb_atom in o_hb_dict[o_a1_atom]:
-                                n_hb_scr = scr_dict[n_hb_atom]
-                                o_hb_scr = scr_dict[o_hb_atom]
-                                b1 = ca_dict[o_hb_scr]
-                                if b1!=None:
-                                    b1_i = gap_idx[b1]
-                                    if abs(c-b1_i)>2: # no turns!
-                                        b3 = gap[b1_i-2]
-                                        if b3!=None:
-                                            b3_scr = scr_dict[b3]
-                                            if b3_scr == n_hb_scr:
-                                                a2 = gap[c+1]
-                                                b2 = gap[gap_idx[b1]-1]
-                                                ss[b1] = 'S'
-                                                ss[b3] = 'S'
-                                                ss[a1] = 'S'
-                                                ss[a3] = 'S'
-                                                if ss[a2]=='L': ss[a2] = 's'
-                                                if ss[b2]=='L': ss[b2] = 's'
-                                                valid = 1
-                # look for antiparallel offset HB (i,i-2,j,j+2)
-                a3 = gap[c-2]
-                if (a3!=None):
-                    scr_a3 = scr_dict[a3]
-                    n_a1_atom = n_dict[scr_a1]
-                    o_a3_atom = o_dict[scr_a3]
-                    if (n_a1_atom in n_hb_dict and
-                         o_a3_atom in o_hb_dict):               
-                        for n_hb_atom in n_hb_dict[n_a1_atom]:
-                            for o_hb_atom in o_hb_dict[o_a3_atom]:
-                                n_hb_scr = scr_dict[n_hb_atom]
-                                o_hb_scr = scr_dict[o_hb_atom]
-                                b1 = ca_dict[o_hb_scr]
-                                if b1!=None:
-                                    b1_i = gap_idx[b1]
-                                    if abs(c-b1_i)>2: # no turns!
-                                        b3 = gap[b1_i-2]
-                                        if b3!=None:
-                                            b3_scr = scr_dict[b3]
-                                            if b3_scr == n_hb_scr:
-                                                a2 = gap[c-1]
-                                                b2 = gap[gap_idx[b1]-1]
-                                                ss[b1] = 'S'
-                                                ss[b3] = 'S'
-                                                ss[a1] = 'S'
-                                                ss[a3] = 'S'
-                                                if ss[a2]=='L': ss[a2] = 's'
-                                                if ss[b2]=='L': ss[b2] = 's'
-                                                valid = 1
-                # look for parallel 1:3 HB (i,j-1,j+1)
-                n_a1_atom = n_dict[scr_a1]
-                o_a1_atom = o_dict[scr_a1]
-                if (n_a1_atom in n_hb_dict and
-                     o_a1_atom in o_hb_dict):
-                    for n_hb_atom in n_hb_dict[n_a1_atom]:
-                        for o_hb_atom in o_hb_dict[o_a1_atom]:
-                            n_hb_scr = scr_dict[n_hb_atom]
-                            o_hb_scr = scr_dict[o_hb_atom]
-                            b0 = ca_dict[n_hb_scr]
-                            if b0!=None:
-                                b2 = gap[gap_idx[b0]+2]
-                                if b2!=None:
-                                    b2_scr = scr_dict[b2]
-                                    if b2_scr == o_hb_scr:
-                                        b1 = gap[gap_idx[b0]+1]
-                                        ss[a1] = 'S' 
-                                        ss[b0] = 'S'
-                                        if ss[b1]=='L': ss[b1]='s'
-                                        ss[b2] = 'S'
-                                        valid = 1
-                                        repeat = 1
-                if not valid:
-                    ss[a1] = 'L'
-            c = c + 1
-
-    # automatically fill 1 residue gaps in helices and well-defined sheets
-    c = 4
-    cc = len(gap)-6
-    while c<cc:
-        a1 = gap[c]
-        a3 = gap[c+2]
-        ss_a1 = ss[a1]
-        ss_a3 = ss[a3]
-        if (ss_a1==ss_a3) and (ss_a1 in ['S','H']):
-            a2 = gap[c+1]
-            ss[a2] = ss_a1
-        c = c + 1
-
-    # remove singleton sheet residues
-    c = 4
-    cc = len(gap)-4
-    while c<cc:
-        a0 = gap[c-1]
-        a1 = gap[c]
-        a2 = gap[c+1]
-        if ss[a1] in ['s','S']:
-            if ((not ss[a0] in ['s','S']) and
-                 (not ss[a2] in ['s','S'])):
-                 ss[a1] = 'L'
-        c = c + 1
-
-    # remove sheet residues which aren't next to another sheet 
-    c = 4
-    cc = len(gap)-4
-    while c<cc:
-        a1 = gap[c]
-        if ss[a1]=='S':
-            a1 = gap[c]
-            scr_a1 = scr_dict[a1]
-            # look for hydrogen bonds to another sheet
-            n_a1_atom = n_dict[scr_a1]
-            o_a1_atom = o_dict[scr_a1]
-            certain = 0
-            if n_a1_atom in n_hb_dict:
-                for n_hb_atom in n_hb_dict[n_a1_atom]:
-                    n_hb_ca_atom=ca_dict[scr_dict[n_hb_atom]]
-                    if ss[n_hb_ca_atom]=='S':
-                        certain = 1
-                        break
-            if o_a1_atom in o_hb_dict:
-                for o_hb_atom in o_hb_dict[o_a1_atom]:
-                    o_hb_ca_atom=ca_dict[scr_dict[o_hb_atom]]
-                    if ss[o_hb_ca_atom]=='S':
-                        certain = 1
-                        break
-            if not certain:
-                ss[a1] = 's'
-        c = c + 1
-
-    # remove questionable sheet residues
-    c = 4
-    cc = len(gap)-4
-    while c<cc:
-        a0 = gap[c-1]
-        a1 = gap[c]
-        a2 = gap[c+1]
-        if ss[a1]=='s':
-            if (not ((ss[a0]=='S') and (ss[a2]=='S'))):
-                ss[a1] = 'L'
-        c = c + 1
-
-    # extend helices if hydrogen bonding requirements are met
-    rep_dict = {}
-    repeat = 1
-    while repeat:
-        repeat = 0
-        c = 4
-        cc = len(gap)-4
-        while c<cc:
-            a = gap[c]
-            if a not in rep_dict:
-                if ss[gap[c+1]]=='H':
-                    rep_dict[a] = 1
-                    if ss[a]!='H': # N-terminal end
-                        aO = o_dict[scr_dict[a]]
-                        ap4N = n_dict[scr_dict[gap[c+4]]]
-                        ap3N = n_dict[scr_dict[gap[c+3]]]
-                        if (ap4N,aO) in hb_dict or (ap3N,aO) in hb_dict:
-                            ss[a]='H'
-                            repeat = 1
-                            c = c - 5
-                            if c<4: c=4
-                if ss[gap[c-1]]=='H':
-                    a = gap[c]
-                    if ss[a]!='H': # C-terminal end
-                        rep_dict[a] = 1
-                        aN = n_dict[scr_dict[a]]
-                        am4O = o_dict[scr_dict[gap[c-4]]]
-                        am3O = o_dict[scr_dict[gap[c-3]]]
-                        if (aN,am4O) in hb_dict or (aN,am3O) in hb_dict:
-                            ss[a]='H'
-                            repeat = 1
-                            c = c - 5
-                            if c<4: c=4
-            c = c + 1
-
-    # remove doubleton helices
-
-    c = 4
-    cc = len(gap)-5
-    while c<cc:
-        a0 = gap[c-1]
-        a1 = gap[c]
-        a2 = gap[c+1]
-        a3 = gap[c+2]
-        ss_a0 = ss[gap[c-1]]
-        ss_a1 = ss[gap[c]]
-        ss_a2 = ss[gap[c+1]]
-        ss_a3 = ss[gap[c+2]]
-        if ss_a1=='H':
-            if (ss_a2==ss_a1) and (ss_a0!=ss_a2) and (ss_a2!=ss_a3):
-                ss[a1] = 'L'
-                ss[a2] = 'L'
-        c = c + 1
-
-    # remove totally unreasonable helix and sheet residues
-
-    c = 4
-    cc = len(gap)-5
-    while c<cc:
-        a1 = gap[c]
-        ss_a1 = ss[gap[c]]
-        if ss_a1=='H':
-            if a1 in phipsi:
-                (phi,psi) = phipsi[a1]
-                if (phi>0) and (phi<150):
-                    ss[a1] = 'L'
-                elif((psi<-120) or (psi>140)):
-                    ss[a1] = 'L'
-        elif ss_a1 in ['S','s']:
-            if a1 in phipsi:
-                (phi,psi) = phipsi[a1]
-                if (phi>45) and (phi<160):
-                    ss[a1] = 'L'
-#            if (psi<-30) and (psi>-150):
-                if (psi<-65) and (psi>-150):
-                    ss[a1] = 'L'
-            
-        c = c + 1
-
-
-    for x in range(1,3):
-        # remove singleton sheet residues
-        c = 4
-        cc = len(gap)-4
-        while c<cc:
-            a0 = gap[c-1]
-            a1 = gap[c]
-            a2 = gap[c+1]
-            if ss[a1] in ['s','S']:
-                if ((not ss[a0] in ['s','S']) and
-                     (not ss[a2] in ['s','S'])):
-                     ss[a1] = 'L'
-            c = c + 1
-
-        # remove sheet residues which aren't next to another sheet 
-        c = 4
-        cc = len(gap)-4
-        while c<cc:
-            a1 = gap[c]
-            if ss[a1]=='S':
-                a1 = gap[c]
-                scr_a1 = scr_dict[a1]
-                # look for hydrogen bonds to another sheet
-                n_a1_atom = n_dict[scr_a1]
-                o_a1_atom = o_dict[scr_a1]
-                certain = 0
-                if n_a1_atom in n_hb_dict:
-                    for n_hb_atom in n_hb_dict[n_a1_atom]:
-                        n_hb_ca_atom=ca_dict[scr_dict[n_hb_atom]]
-                        if ss[n_hb_ca_atom]=='S':
-                            certain = 1
-                            break
-                if o_a1_atom in o_hb_dict:
-                    for o_hb_atom in o_hb_dict[o_a1_atom]:
-                        o_hb_ca_atom=ca_dict[scr_dict[o_hb_atom]]
-                        if ss[o_hb_ca_atom]=='S':
-                            certain = 1
-                            break
-                if not certain:
-                    ss[a1] = 's'
-            c = c + 1
-
-        # remove questionable sheet residues
-        c = 4
-        cc = len(gap)-4
-        while c<cc:
-            a0 = gap[c-1]
-            a1 = gap[c]
-            a2 = gap[c+1]
-            if ss[a1]=='s':
-                if (not ((ss[a0]=='S') and (ss[a2]=='S'))):
-                    ss[a1] = 'L'
-            c = c + 1
-
-#      lst = ss.keys()
-#      lst.sort()
-#      for a in lst: print scr_dict[a],ss[a]
-        
-    # assign protein
-    for a in cas:
-        if ss[a]=='s':
-            ss[a]='S'
-        
-    cmd.alter(sss1,"ss ='L'")
-    for a in cas:
-        if ss[a]!='L':
-            cmd.alter("(%s`%d)"%a,"ss='%s'"%ss[a])
-
-    cmd.feedback("pop")
+    print(' util.ss: Deprecated, use cmd.dss() instead')
+    _self.dss(selection, state)
 
-    del pymol._ss # IMPORTANT
-    cmd.delete(sss1)
-    cmd.rebuild(selection,'cartoon')
-    #
-#   print conn_hash.keys()
-    print(" util.ss: assignment complete.")
 
 def colors(scheme="",_self=cmd):
     cmd=_self
diff -upNr pymol-open-source-2.3.0/modules/pymol/vfont.py pymol-open-source-2.3.3/modules/pymol/vfont.py
--- pymol-open-source-2.3.0/modules/pymol/vfont.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/vfont.py	2019-08-22 10:24:47.862619142 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -73,14 +73,14 @@ isp = iw + sp
 
 # 0 = newpath, x,y
 # 1 = continue, x,y
-     
+
 plain = {
-    ' ': [ Nsp, []],   
+    ' ': [ Nsp, []],
     'A': [ Nsp,
              [ 0, 0.0, 0.0,
                 1, 0.0, Ht_Bvl,
                 1, Bvl, Ht,
-                1, Nw_Bvl, Ht,            
+                1, Nw_Bvl, Ht,
                 1, Nw, Ht_Bvl,
                 1, Nw, 0.0,
                 0, 0.0, Ht_2,
@@ -91,7 +91,7 @@ plain = {
              [ 0, 0.0, 0.0,
                 1, 0.0, Ht,
                 1, Nw_BBvl, Ht,
-                1, Nw_Btop, Ht_Bvl,            
+                1, Nw_Btop, Ht_Bvl,
                 1, Nw_Btop, Ht_2pBvl,
                 1, Nw_BBvl, Ht_2,
                 0, 0.0, Ht_2,
@@ -110,7 +110,7 @@ plain = {
                 1, 0.0, Bvl,
                 1, 0.0, Ht_Bvl,
                 1, Bvl, Ht,
-                1, Nw_Bvl, Ht,            
+                1, Nw_Bvl, Ht,
                 1, Nw, Ht_Bvl,
                 ],
              ],
@@ -118,7 +118,7 @@ plain = {
              [ 0, 0.0, 0.0,
                 1, 0.0, Ht,
                 1, Nw_2, Ht,
-                1, Nw, Ht-Bvl*2,            
+                1, Nw, Ht-Bvl*2,
                 1, Nw, Bvl*2,
                 1, Nw_2, 0.0,
                 1, 0.0, 0.0,
@@ -134,7 +134,7 @@ plain = {
                 ],
              ],
     'F': [ Nsp,
-             [ 
+             [
                 0, 0.0, 0.0,
                 1, 0.0, Ht,
                 1, Nw, Ht,
@@ -144,20 +144,20 @@ plain = {
              ],
     'G': [ Nsp,
              [
-                0, Nw_2, Ht_2,   
-                1, Nw, Ht_2,   
+                0, Nw_2, Ht_2,
+                1, Nw, Ht_2,
                 1, Nw, Bvl,
                 1, Nw_Bvl, 0.0,
                 1, Bvl, 0.0,
                 1, 0.0, Bvl,
                 1, 0.0, Ht_Bvl,
                 1, Bvl, Ht,
-                1, Nw_Bvl, Ht,            
+                1, Nw_Bvl, Ht,
                 1, Nw, Ht_Bvl,
                 ],
              ],
     'H': [ Nsp,
-             [ 
+             [
                 0, 0.0, 0.0,
                 1, 0.0, Ht,
                 0, Nw, 0.0,
@@ -167,7 +167,7 @@ plain = {
                 ],
              ],
     'I': [ Isp,
-             [ 
+             [
                 0, 0.0, 0.0,
                 1, Iw, 0.0,
                 0, Iw_2, 0.0,
@@ -181,14 +181,14 @@ plain = {
                 0, 0.0, Bvl,
                 1, Bvl, 0.0,
                 1, Nw_Iw_2_Bvl, 0.0,
-                1, Nw_Iw_2, Bvl,            
+                1, Nw_Iw_2, Bvl,
                 1, Nw_Iw_2, Ht,
                 0, Nw_Iw, Ht,
                 1, Nw, Ht,
                 ],
              ],
     'K': [ Nsp,
-             [ 
+             [
                 0, 0.0, 0.0,
                 1, 0.0, Ht,
                 0, Nw, Ht,
@@ -212,40 +212,40 @@ plain = {
                 ],
              ],
     'N': [ Nsp,
-             [ 
+             [
                 0, 0.0, 0.0,
                 1, 0.0, Ht,
                 1, Nw, 0.0,
-                1, Nw, Ht,                        
+                1, Nw, Ht,
                 ],
              ],
     'O': [ Nsp,
-             [ 
-                0, Nw_Bvl, Ht,   
-                1, Nw, Ht_Bvl,   
+             [
+                0, Nw_Bvl, Ht,
+                1, Nw, Ht_Bvl,
                 1, Nw, Bvl,
                 1, Nw_Bvl, 0.0,
                 1, Bvl, 0.0,
                 1, 0.0, Bvl,
                 1, 0.0, Ht_Bvl,
                 1, Bvl, Ht,
-                1, Nw_Bvl, Ht,            
+                1, Nw_Bvl, Ht,
                 ],
              ],
     'P': [ Nsp,
              [ 0, 0.0, 0.0,
                 1, 0.0, Ht,
                 1, Nw_Bvl, Ht,
-                1, Nw, Ht_Bvl,            
+                1, Nw, Ht_Bvl,
                 1, Nw, Ht_2pBvl,
                 1, Nw_Bvl, Ht_2,
                 1, 0.0, Ht_2,
                 ],
              ],
     'Q': [ Nsp,
-             [ 
-                0, Nw_Bvl, Ht,   
-                1, Nw, Ht_Bvl,   
+             [
+                0, Nw_Bvl, Ht,
+                1, Nw, Ht_Bvl,
                 1, Nw, Bvl,
                 1, Nw_Bvl, 0.0,
                 1, Bvl, 0.0,
@@ -261,7 +261,7 @@ plain = {
              [ 0, 0.0, 0.0,
                 1, 0.0, Ht,
                 1, Nw_Bvl, Ht,
-                1, Nw, Ht_Bvl,            
+                1, Nw, Ht_Bvl,
                 1, Nw, Ht_2pBvl,
                 1, Nw_Bvl, Ht_2,
                 1, 0.0, Ht_2,
@@ -278,10 +278,10 @@ plain = {
                 1, Nw, Ht_2mBvl,
                 1, Nw_Bvl, Ht_2,
                 1, Bvl, Ht_2,
-                1, 0.0, Ht_2pBvl,                                    
+                1, 0.0, Ht_2pBvl,
                 1, 0.0, Ht_Bvl,
                 1, Bvl, Ht,
-                1, Nw_Bvl, Ht,            
+                1, Nw_Bvl, Ht,
                 1, Nw, Ht_Bvl,
                 ],
              ],
@@ -294,7 +294,7 @@ plain = {
              ],
     'U': [ Nsp,
              [
-                0, Nw, Ht,   
+                0, Nw, Ht,
                 1, Nw, Bvl,
                 1, Nw_Bvl, 0.0,
                 1, Bvl, 0.0,
@@ -305,7 +305,7 @@ plain = {
              ],
     'V': [ Nsp,
              [
-                0, 0.0, Ht,   
+                0, 0.0, Ht,
                 1, Nw_2, 0.0,
                 1, Nw, Ht,
                 ],
@@ -334,15 +334,15 @@ plain = {
                 ],
              ],
     'Z': [ Nsp,
-             [ 
+             [
                 0, 0.0, Ht,
                 1, Nw, Ht,
                 1, 0.0, 0.0,
-                1, Nw, 0.0,                        
+                1, Nw, 0.0,
                 ],
              ],
     '1': [ Isp,
-             [ 
+             [
                 0, 0.0, Ht_Bvl,
                 1, Iw_2, Ht,
                 1, Iw_2, 0.0,
@@ -355,9 +355,9 @@ plain = {
                 0, Nw, 0.0,
                 1, 0.0, 0.0,
                 1, 0.0, Bvl,
-                1, Nw, Ht_Bvl - Bvl,            
+                1, Nw, Ht_Bvl - Bvl,
                 1, Nw, Ht_Bvl,
-                1, Nw_Bvl, Ht,            
+                1, Nw_Bvl, Ht,
                 1, Bvl, Ht,
                 1, 0.0, Ht_Bvl,
                 ],
@@ -372,9 +372,9 @@ plain = {
                 1, Nw_Bvl, Ht_2,
                 1, Bvl, Ht_2,
                 0, Nw_Bvl, Ht_2,
-                1, Nw, Ht_2pBvl,            
+                1, Nw, Ht_2pBvl,
                 1, Nw, Ht_Bvl,
-                1, Nw_Bvl, Ht,            
+                1, Nw_Bvl, Ht,
                 1, Bvl, Ht,
                 1, 0.0, Ht_Bvl,
                 ],
@@ -385,7 +385,7 @@ plain = {
                 1, 0.0, Ht_2,
                 1, Nw, Ht_2,
                 0, Nw_Bvl,Ht,
-                1, Nw_Bvl,0.0            
+                1, Nw_Bvl,0.0
                 ],
              ],
     '5': [ Nsp,
@@ -397,7 +397,7 @@ plain = {
                 1, Nw, Ht_2,
                 1, Nw_Bvl, Ht_2pBvl,
                 1, Bvl, Ht_2pBvl,
-                1, 0.0, Ht_2,                                    
+                1, 0.0, Ht_2,
                 1, 0.0, Ht,
                 1, Nw, Ht,
                 ],
@@ -405,9 +405,9 @@ plain = {
     '6': [ Nsp,
              [
                 0, Nw, Ht_Bvl,
-                1, Nw_Bvl, Ht,         
-                1, Bvl, Ht,      
-                1, 0.0, Ht_Bvl,   
+                1, Nw_Bvl, Ht,
+                1, Bvl, Ht,
+                1, 0.0, Ht_Bvl,
                 1, 0.0, Bvl,
                 1, Bvl, 0.0,
                 1, Nw_Bvl, 0.0,
@@ -415,7 +415,7 @@ plain = {
                 1, Nw, Ht_2mBvl,
                 1, Nw_Bvl, Ht_2,
                 1, Bvl, Ht_2,
-                1, 0.0, Ht_2mBvl,                                    
+                1, 0.0, Ht_2mBvl,
                 ],
              ],
     '7': [ Nsp,
@@ -429,7 +429,7 @@ plain = {
     '8': [ Nsp,
              [
                 0, Bvl, Ht_2,
-                1, 0.0, Ht_2mBvl,            
+                1, 0.0, Ht_2mBvl,
                 1, 0.0, Bvl,
                 1, Bvl, 0.0,
                 1, Nw_Bvl, 0.0,
@@ -437,13 +437,13 @@ plain = {
                 1, Nw, Ht_2mBvl,
                 1, Nw_Bvl, Ht_2,
                 1, Bvl, Ht_2,
-                1, 0.0, Ht_2pBvl,                                    
+                1, 0.0, Ht_2pBvl,
                 1, 0.0, Ht_Bvl,
                 1, Bvl, Ht,
-                1, Nw_Bvl, Ht,            
+                1, Nw_Bvl, Ht,
                 1, Nw, Ht_Bvl,
                 1, Nw, Ht_2pBvl,
-                1, Nw_Bvl, Ht_2,                        
+                1, Nw_Bvl, Ht_2,
                 ],
              ],
     '9': [ Nsp,
@@ -451,10 +451,10 @@ plain = {
                 0, Nw, Ht_2pBvl,
                 1, Nw_Bvl, Ht_2,
                 1, Bvl, Ht_2,
-                1, 0.0, Ht_2pBvl,                                    
+                1, 0.0, Ht_2pBvl,
                 1, 0.0, Ht_Bvl,
                 1, Bvl, Ht,
-                1, Nw_Bvl, Ht,            
+                1, Nw_Bvl, Ht,
                 1, Nw, Ht_Bvl,
                 1, Nw, Bvl,
                 1, Nw_Bvl, 0.0,
@@ -463,9 +463,9 @@ plain = {
                 ],
              ],
     '0': [ Nsp,
-             [ 
-                0, Nw_Bvl, Ht,   
-                1, Nw, Ht_Bvl,   
+             [
+                0, Nw_Bvl, Ht,
+                1, Nw, Ht_Bvl,
                 1, Nw, Bvl,
                 1, Nw_Bvl, 0.0,
                 1, Bvl, 0.0,
@@ -482,7 +482,7 @@ plain = {
                 0, 0.0, ht_bvl,
                 1, bvl, ht,
                 1, nw_bvl, ht,
-                1, nw, ht_bvl,            
+                1, nw, ht_bvl,
                 0, nw, ht_2,
                 1, nw_bvl, ht_2pbvl,
                 1, bvl, ht_2pbvl,
@@ -492,7 +492,7 @@ plain = {
                 1, nw_bvl, 0.0,
                 1, nw, bvl,
                 0, nw, 0.0,
-                1, nw, ht,            
+                1, nw, ht,
                 ],
              ],
     'b': [ nsp,
@@ -505,9 +505,9 @@ plain = {
                 1, nw_bvl, 0.0,
                 1, bvl, 0.0,
                 1, 0.0, bvl,
-                
+
                 0, 0.0,0.0,
-                1, 0.0, Ht,            
+                1, 0.0, Ht,
                 ],
              ],
     'c': [ nsp,
@@ -533,14 +533,14 @@ plain = {
                 1, nw_bvl, 0.0,
                 1, nw, bvl,
                 0, nw, 0.0,
-                1, nw, Ht,            
+                1, nw, Ht,
                 ],
              ],
     'e': [ nsp,
              [
                 0, 0.0, ht_2,
                 1, nw_bvl, ht_2,
-                1, nw, ht_2pbvl,            
+                1, nw, ht_2pbvl,
                 1, nw, ht_bvl,
                 1, nw_bvl, ht,
                 1, bvl, ht,
@@ -565,9 +565,9 @@ plain = {
     'g': [ nsp,
              [
                 0, 0.0, ds_bvl,
-                1, bvl, ds,                  
-                1, nw_bvl, ds,      
-                1, nw, ds_bvl,   
+                1, bvl, ds,
+                1, nw_bvl, ds,
+                1, nw, ds_bvl,
                 1, nw, ht_bvl,
                 1, nw_bvl, ht,
                 1, bvl, ht,
@@ -587,7 +587,7 @@ plain = {
                 1, nw, bvl,
                 1, nw, 0.0,
                 0, 0.0,0.0,
-                1, 0.0, Ht,            
+                1, 0.0, Ht,
                 ],
              ],
     'i': [ isp,
@@ -601,9 +601,9 @@ plain = {
     'j': [ nsp,
              [
                 0, 0.0, ds_bvl,
-                1, bvl, ds,                  
-                1, nw_bvl, ds,      
-                1, nw, ds_bvl,   
+                1, bvl, ds,
+                1, nw_bvl, ds,
+                1, nw, ds_bvl,
                 1, nw, ht_bvl,
                 0, nw, ht+bvl,
                 1, nw, ht+2*bvl,
@@ -619,7 +619,7 @@ plain = {
                 ],
              ],
     'l': [ isp,
-             [ 
+             [
                 0, 0.0, Ht,
                 1, 0.0, 0.0,
                 ],
@@ -637,7 +637,7 @@ plain = {
                 1, mw, ht_bvl,
                 1, mw, 0.0,
                 0, 0.0,0.0,
-                1, 0.0, ht,            
+                1, 0.0, ht,
                 ],
              ],
     'n': [ nsp,
@@ -649,7 +649,7 @@ plain = {
                 1, nw, bvl,
                 1, nw, 0.0,
                 0, 0.0,0.0,
-                1, 0.0, ht,            
+                1, 0.0, ht,
                 ],
              ],
     'o': [ nsp,
@@ -662,7 +662,7 @@ plain = {
                 1, nw_bvl, 0.0,
                 1, bvl, 0.0,
                 1, 0.0, bvl,
-                1, 0.0, ht_bvl,            
+                1, 0.0, ht_bvl,
                 ],
              ],
     'p': [ nsp,
@@ -675,9 +675,9 @@ plain = {
                 1, nw_bvl, 0.0,
                 1, bvl, 0.0,
                 1, 0.0, bvl,
-                
+
                 0, 0.0,ds,
-                1, 0.0, ht,            
+                1, 0.0, ht,
                 ],
              ],
     'q': [ nsp,
@@ -691,7 +691,7 @@ plain = {
                 1, nw_bvl, 0.0,
                 1, nw, bvl,
                 0, nw, ds,
-                1, nw, ht,            
+                1, nw, ht,
                 ],
              ],
     'r': [ nsp,
@@ -701,7 +701,7 @@ plain = {
                 1, nw_bvl, ht,
                 1, nw, ht_bvl,
                 0, 0.0,0.0,
-                1, 0.0, ht,            
+                1, 0.0, ht,
                 ],
              ],
     's': [ nsp,
@@ -713,7 +713,7 @@ plain = {
                 1, 0.0, ht_2pbvl,
                 1, bvl, ht_2,
                 1, nw_bvl, ht_2,
-                1, nw, ht_2mbvl,                                                
+                1, nw, ht_2mbvl,
                 1, nw, bvl,
                 1, nw_bvl, 0.0,
                 1, bvl, 0.0,
@@ -739,7 +739,7 @@ plain = {
                 1, nw_bvl, 0.0,
                 1, nw, bvl,
                 0, nw, 0.0,
-                1, nw, ht,            
+                1, nw, ht,
                 ],
              ],
     'v': [ nsp,
@@ -768,9 +768,9 @@ plain = {
     'y': [ nsp,
              [
                 0, 0.0, ds_bvl,
-                1, bvl, ds,                  
-                1, nw_bvl, ds,      
-                1, nw, ds_bvl,   
+                1, bvl, ds,
+                1, nw_bvl, ds,
+                1, nw, ds_bvl,
                 1, nw, ht,
                 0, 0.0, ht,
                 1, 0.0, bvl,
@@ -842,7 +842,7 @@ plain = {
                 1, 0.0, Ht-Bvl*2,
                 1, 0.0, Bvl*2,
                 1, Nw_2, 0.0,
-                1, Nw, 0.0,            
+                1, Nw, 0.0,
                 ],
              ],
     ')': [ Nsp,
@@ -852,7 +852,7 @@ plain = {
                 1, Nw, Ht-Bvl*2,
                 1, Nw, Bvl*2,
                 1, Nw_2, 0.0,
-                1, 0.0, 0.0,            
+                1, 0.0, 0.0,
                 ],
              ],
     '[': [ Isp,
@@ -891,13 +891,13 @@ plain = {
                 1, Bvl, Ht,
                 1, Bvl, Ht-Bvl,
                 1, 0.0, Ht-Bvl,
-                1, 0.0, Ht,            
+                1, 0.0, Ht,
 
                 0, Nw, 0.0,
                 1, Nw, Bvl,
                 1, Nw-Bvl, Bvl,
                 1, Nw-Bvl, 0.0,
-                1, Nw, 0.0,            
+                1, Nw, 0.0,
                 ],
              ],
     '<': [ Nsp,
@@ -914,11 +914,8 @@ plain = {
                 1, 0.0, Bvl,
                 ],
              ],
-    
+
     }
 
 def get_font(size,face,style):
     return plain
-
-
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/viewing.py pymol-open-source-2.3.3/modules/pymol/viewing.py
--- pymol-open-source-2.3.0/modules/pymol/viewing.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/viewing.py	2019-08-22 10:24:47.862619142 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
 #-* Filipe Maia (slicing code)
-#-* 
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -30,7 +30,7 @@ if True:
     from . import parsing
     import re
     cmd = sys.modules["pymol.cmd"]
-    
+
     from .cmd import _cmd,lock,unlock,Shortcut,QuietException,_raising, \
           _feedback,fb_module,fb_mask, \
           repres,repres_sc, is_string, is_list, is_ok, is_error, \
@@ -40,7 +40,7 @@ if True:
           safe_list_eval, safe_alpha_list_eval, \
           location_code, location_sc, boolean_dict, boolean_sc, \
           DEFAULT_ERROR, DEFAULT_SUCCESS
-        
+
     palette_colors_dict = {
         'rainbow_cycle'     : 'magenta blue cyan green yellow orange red magenta',
         'rainbow_cycle_rev' : 'magenta red orange yellow green cyan blue magenta',
@@ -53,7 +53,7 @@ if True:
         'cbmr'              : 'cyan blue magenta red',
         'rmbc'              : 'red magenta blue cyan',
     }
-    
+
     rep_list = [ "lines", "sticks", "spheres", "dots", "surface",
                  "mesh", "nonbonded", "nb_spheres", "cartoon",
                  "ribbon", "labels", "slice", "ellipsoids", "volume" ]
@@ -133,7 +133,7 @@ SEE ALSO
         #
         r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.zoom(_self._COb,str(selection),float(buffer),
                               int(state)-1,int(complete),float(animate))
         finally:
@@ -184,7 +184,7 @@ SEE ALSO
         selection = selector.process(selection)
         #
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.center(_self._COb,str(selection),int(state)-1,int(origin),float(animate))
         finally:
             _self.unlock(r,_self)
@@ -230,19 +230,19 @@ SEE ALSO
 
     zoom, orient, reset
         '''
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         mode = clip_action_sc.auto_err(str(mode),'mode')
-        if selection!=None:
+        if selection is not None:
             selection = selector.process(selection)
         else:
             selection = ''
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.clip(_self._COb,str(mode),float(distance),
                           str(selection),int(state)-1)
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise QuietException         
+        if _self._raising(r,_self): raise QuietException
         return r
 
     def origin(selection="(all)", object=None, position=None, state=0, _self=cmd):
@@ -282,14 +282,14 @@ SEE ALSO
     zoom, orient, reset
         '''
         #'
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         # preprocess selection
         selection = selector.process(selection)
-        #   
+        #
         try:
             _self.lock(_self)
-            if object==None: object=''
-            if position==None: position=(0.0,0.0,0.0)
+            if object is None: object=''
+            if position is None: position=(0.0,0.0,0.0)
             else:
                 if _self.is_string(position):
                     position = safe_list_eval(position)
@@ -301,7 +301,7 @@ SEE ALSO
                                   ),int(state)-1)
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise QuietException         
+        if _self._raising(r,_self): raise QuietException
         return r
 
     def orient(selection="(all)", state=0, animate=0, _self=cmd):
@@ -341,16 +341,16 @@ SEE ALSO
 
     zoom, origin, reset
         '''
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         # preprocess selection
         selection = selector.process(selection)
-        #   
+        #
         try:
             _self.lock(_self)
             r = _cmd.orient(_self._COb,"("+selection+")",int(state)-1,float(animate))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise QuietException         
+        if _self._raising(r,_self): raise QuietException
         return r
 
     def move(axis, distance, _self=cmd):
@@ -376,13 +376,13 @@ SEE ALSO
 
     turn, rotate, translate, zoom, center, clip
         '''
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.move(_self._COb,str(axis),float(distance))
         finally:
             _self.unlock(r,_self)
-        if _self._raising(r,_self): raise QuietException         
+        if _self._raising(r,_self): raise QuietException
         return r
 
     def enable(name='all', parents=0, _self=cmd):
@@ -426,7 +426,7 @@ SEE ALSO
 
     show, hide, disable
         '''
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         if name[0]=='(':
             selection = selector.process(name)
             try:
@@ -436,11 +436,11 @@ SEE ALSO
                 _self.unlock(r,_self)
         else:
             try:
-                _self.lock(_self)   
+                _self.lock(_self)
                 r = _cmd.onoff(_self._COb,str(name),1,int(parents));
             finally:
                 _self.unlock(r,_self)
-        if _self._raising(r,_self): raise QuietException            
+        if _self._raising(r,_self): raise QuietException
         return r
 
     def disable(name='all',_self=cmd):
@@ -465,7 +465,7 @@ SEE ALSO
 
     show, hide, enable   
         '''
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         if name[0]=='(':
             selection = selector.process(name)
             try:
@@ -475,11 +475,11 @@ SEE ALSO
                 _self.unlock(r,_self)
         else:
             try:
-                _self.lock(_self)   
+                _self.lock(_self)
                 r = _cmd.onoff(_self._COb,str(name),0,0);
             finally:
                 _self.unlock(r,_self)
-        if _self._raising(r,_self): raise QuietException            
+        if _self._raising(r,_self): raise QuietException
         return r
 
     def _rep_to_repmask(rep):
@@ -526,7 +526,7 @@ SEE ALSO
                 repn = -2
             else:
                 repn = _rep_to_repmask(representation)
-                # preprocess selection 
+                # preprocess selection
                 selection = selector.process(selection)
             r = _cmd.toggle(_self._COb,str(selection),int(repn));
         finally:
@@ -741,7 +741,7 @@ SEE ALSO
                     _self.log("_  %14.9f, %14.9f, %14.9f,\\\n"%r[16:19],
                               "  %14.9f, %14.9f, %14.9f,\\\n"%r[16:19])
                     _self.log("_  %14.9f, %14.9f, %14.9f,\\\n"%r[19:22],
-                              "  %14.9f, %14.9f, %14.9f,\\\n"%r[19:22]) 
+                              "  %14.9f, %14.9f, %14.9f,\\\n"%r[19:22])
                     _self.log("_  %14.9f, %14.9f, %14.9f )\n"%r[22:25] ,
                               "  %14.9f, %14.9f, %14.9f ))\n"%r[22:25])
                     if output<2: # suppress if we have a log file open
@@ -864,18 +864,18 @@ SEE ALSO
     scene, set_view, get_view
         '''
         pymol=_self._pymol
-        
+
         if key=='*':
             action = view_sc.auto_err(action,'action')
             if action=='clear':
                 pymol._view_dict = {}
-                pymol._view_dict_sc = Shortcut(pymol._view_dict.keys())                        
+                pymol._view_dict_sc = Shortcut(pymol._view_dict.keys())
             else:
                 print(" view: stored views:")
                 lst = list(pymol._view_dict.keys())
                 lst.sort()
                 parsing.dump_str_list(lst)
-                
+
         else:
             action = view_sc.auto_err(action,'action')
             if action=='recall':
@@ -892,7 +892,7 @@ SEE ALSO
                 key = pymol._view_dict_sc.auto_err(key,'view')
                 if key in pymol._view_dict:
                     del pymol._view_dict[key]
-                    pymol._view_dict_sc = Shortcut(pymol._view_dict.keys())            
+                    pymol._view_dict_sc = Shortcut(pymol._view_dict.keys())
                     if _feedback(fb_module.scene,fb_mask.actions,_self): # redundant
                         print(" view: '%s' deleted."%key)
 
@@ -952,7 +952,7 @@ PYMOL API
         return r
 
     def get_vis(_self=cmd):
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             r = _cmd.get_vis(_self._COb)
@@ -962,9 +962,9 @@ PYMOL API
         return r
 
     def set_vis(dict,_self=cmd):
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
-            _self.lock(_self)         
+            _self.lock(_self)
             r = _cmd.set_vis(_self._COb,dict)
         finally:
             _self.unlock(r,_self)
@@ -972,9 +972,9 @@ PYMOL API
         return r
 
     def get_colorection(key,_self=cmd):
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
-            _self.lock(_self)         
+            _self.lock(_self)
             r = _cmd.get_colorection(_self._COb,key)
         finally:
             _self.unlock(r,_self)
@@ -982,9 +982,9 @@ PYMOL API
         return r
 
     def set_colorection(dict,key,_self=cmd):
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
-            _self.lock(_self)         
+            _self.lock(_self)
             r = _cmd.set_colorection(_self._COb,dict,key)
         finally:
             _self.unlock(r,_self)
@@ -992,9 +992,9 @@ PYMOL API
         return r
 
     def del_colorection(dict,key,_self=cmd):
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
-            _self.lock(_self)         
+            _self.lock(_self)
             r = _cmd.del_colorection(_self._COb,dict,key)
         finally:
             _self.unlock(r,_self)
@@ -1013,7 +1013,7 @@ PYMOL API
         re_pat = re.compile("[0-9]+\.")
         if len(session_file): # find next session file, if it exists
             mo = re_pat.search(session_file)
-            if mo!=None:
+            if mo is not None:
                 pat = mo.group(0)
                 if len(pat):
                     file_no = int(float(pat)) + 1
@@ -1173,7 +1173,7 @@ SEE ALSO
 
         # presentation auto quit
         if (pymol._scene_quit_on_action == action and
-                action in ('next', 'previous') and 
+                action in ('next', 'previous') and
                 _self.get_setting_boolean("presentation") and
                 _self.get_setting_boolean("presentation_auto_quit") and
                 _self.get("scene_current_name") == ""):
@@ -1194,7 +1194,7 @@ SEE ALSO
         pymol._scene_quit_on_action = action
 
         return r
-                        
+
     def _legacy_scene(key='auto', action='recall', message=None, view=1,
               color=1, active=1, rep=1, frame=1, animate=-1,
               new_key=None, hand=1, quiet=1, _self=cmd):
@@ -1218,7 +1218,7 @@ SEE ALSO
                         scene_list = pymol._scene_dict[key]
                         if len(scene_list)>3:
                             colorection = scene_list[3]
-                            if colorection!=None:
+                            if colorection is not None:
                                 _self.del_colorection(colorection,key)
                         name = "_scene_"+key+"_*"
                         _self.delete(name)
@@ -1256,7 +1256,7 @@ SEE ALSO
         return r
 
     def session_save_views(session,_self=cmd):
-        pymol=_self._pymol        
+        pymol=_self._pymol
         session['view_dict']=copy.deepcopy(pymol._view_dict)
         return 1
 
@@ -1366,10 +1366,10 @@ PYMOL API
     cmd.stereo(string toggle)
         '''
         toggle = stereo_dict[stereo_sc.auto_err(str(toggle),'toggle')]
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
             _self.lock(_self)
-            if(toggle>0) : # stereo mode code 
+            if(toggle>0) : # stereo mode code
                 _self.set("stereo_mode",str(toggle),quiet=quiet)
                 toggle=1
             r = _cmd.stereo(_self._COb,toggle)
@@ -1405,7 +1405,7 @@ SEE ALSO
 
     move, rotate, translate, zoom, center, clip
         '''
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             r = _cmd.turn(_self._COb,str(axis),float(angle))
@@ -1441,7 +1441,7 @@ NOTES
     '''
         toggle = toggle_dict[toggle_sc.auto_err(str(toggle),'toggle')]
         if thread.get_ident() == pymol.glutThread:
-            try: 
+            try:
                 _self.lock(_self)
                 r = _cmd.full_screen(_self._COb,int(toggle))
             finally:
@@ -1470,9 +1470,9 @@ PYMOL API
 
     cmd.rock()
         '''
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.rock(_self._COb,int(mode))
         finally:
             _self.unlock(r,_self)
@@ -1522,7 +1522,7 @@ NOTES
         # preprocess selection
         selection = selector.process(selection)
         #
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             if len(str(expression))==0:
@@ -1530,7 +1530,7 @@ NOTES
             else:
                 r = _cmd.label(_self._COb,"("+str(selection)+")",str(expression),quiet)
         finally:
-            _self.unlock(r,_self)   
+            _self.unlock(r,_self)
         if _self._raising(r,_self): raise QuietException
         return r
 
@@ -1538,7 +1538,7 @@ NOTES
         # preprocess selection
         selection = selector.process(selection)
         #
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             if len(str(expression))==0:
@@ -1546,7 +1546,7 @@ NOTES
             else:
                 r = _cmd.label2(_self._COb,"("+str(selection)+")",str(expression),quiet)
         finally:
-            _self.unlock(r,_self)   
+            _self.unlock(r,_self)
         if _self._raising(r,_self): raise QuietException
         return r
 
@@ -1568,7 +1568,7 @@ PYMOL API
         action = window_sc.auto_err(action,'action')
         action = window_dict[str(action)]
 
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             from pymol.gui import get_qtwindow as getPyMOLWindow
@@ -1582,7 +1582,7 @@ PYMOL API
             _self.unlock(r,_self)
         if _self._raising(r,_self): raise QuietException
         return r
-        
+
     def viewport(width=-1,height=-1,_self=cmd):
         '''
 DESCRIPTION
@@ -1650,7 +1650,7 @@ PYMOL API
 
         '''
         color = _self._interpret_color(_self,color)
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             r = _cmd.bg_color(_self._COb,str(color))
@@ -1709,9 +1709,9 @@ NOTES
         selection = selector.process(selection)
         #
         type = cartoon_dict[cartoon_sc.auto_err(str(type),'type')];
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.cartoon(_self._COb,"("+str(selection)+")",int(type))
         finally:
             _self.unlock(r,_self)
@@ -1738,7 +1738,7 @@ NOTES
 
     def capture(quiet=1, _self=cmd):
         _self.draw(antialias=-2,quiet=quiet)
-        
+
     def draw(width=0, height=0, antialias=-1, quiet=1, _self=cmd):
         '''
 DESCRIPTION
@@ -1799,7 +1799,7 @@ SEE ALSO
             r = _cmd.draw(_self._COb,int(width),int(height),
                           int(antialias),int(quiet))
         finally:
-            _self.unlock(r,_self)      
+            _self.unlock(r,_self)
         if _self._raising(r,_self): raise QuietException
         return r
 
@@ -1945,9 +1945,9 @@ PYMOL API
 
     cmd.reset()
         '''
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.reset(_self._COb,0,str(object))
         finally:
             _self.unlock(r,_self)
@@ -1956,7 +1956,7 @@ PYMOL API
 
 
     def dirty(_self=cmd): # OBSOLETE?
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             r = _cmd.dirty(_self._COb)
@@ -1975,9 +1975,9 @@ USAGE
 
     meter_reset
         '''
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
-            _self.lock(_self)   
+            _self.lock(_self)
             r = _cmd.reset_rate(_self._COb)
         finally:
             _self.unlock(r,_self)
@@ -2000,8 +2000,8 @@ NOTES
     reduced 2-fold repeatedly until it fits.
     
     '''
-        
-        r = DEFAULT_ERROR      
+
+        r = DEFAULT_ERROR
         filename = _self.exp_path(str(filename))
         try:
             _self.lock(_self)
@@ -2040,7 +2040,7 @@ SEE ALSO
         selection = selector.process(selection)
         representation = repres_sc.auto_err(representation,'representation')
         repn = repres[representation];
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             r = _cmd.rebuild(_self._COb,selection,repn)
@@ -2048,7 +2048,7 @@ SEE ALSO
             _self.unlock(r,_self)
         if _self._raising(r,_self): raise QuietException
         return r
-    
+
     def recolor(selection='all', representation='everything', _self=cmd):
         '''
 DESCRIPTION
@@ -2081,7 +2081,7 @@ SEE ALSO
         selection = selector.process(selection)
         representation = repres_sc.auto_err(representation,'representation')
         repn = repres[representation];
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             r = _cmd.recolor(_self._COb,selection,repn)
@@ -2130,7 +2130,7 @@ EXAMPLE
         selection = selector.process(selection)
         color = _self._interpret_color(_self,str(color))
 
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             r = _cmd.color(_self._COb,str(color),str(selection),int(flags),int(quiet))
@@ -2217,7 +2217,7 @@ DESCRIPTION
     def spectrum(expression="count", palette="rainbow",
                  selection="(all)", minimum=None, maximum=None,
                  byres=0, quiet=1, _self=cmd):
-        
+
         '''
 DESCRIPTION
 
@@ -2285,17 +2285,17 @@ PYMOL API
         if not expression.replace('_', '').isalpha() or not palette_hit:
             return spectrumany(expression, palette, selection,
                     minimum, maximum, quiet, _self)
-        
+
         (prefix,digits,first,last) = palette_dict[str(palette)]
 
-        if (maximum==None) or (minimum==None):
+        if (maximum is None) or (minimum is None):
             minimum = 0 # signal to auto-adjust levels
             maximum = -1
 
         # preprocess selection
         selection = selector.process(selection)
         #
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             r = _cmd.spectrum(_self._COb,str(selection),str(expression),
@@ -2306,7 +2306,7 @@ PYMOL API
             _self.unlock(r,_self)
         if _self._raising(r,_self): raise QuietException
         return r
-    
+
     def set_color(name, rgb, mode=0, quiet=1, _self=cmd):
         '''
 DESCRIPTION
@@ -2360,7 +2360,7 @@ PYMOL API
                 # these days, we'll accept 0-1 or 0-255, so long as [1,1,1] is white
                 rgb[0] = rgb[0]/255.0
                 rgb[1] = rgb[1]/255.0
-                rgb[2] = rgb[2]/255.0            
+                rgb[2] = rgb[2]/255.0
             try:
                 _self.lock(_self)
                 if len(rgb)==3:
@@ -2379,7 +2379,6 @@ PYMOL API
     set_colour = set_color
     bg_colour = bg_color
     recolour = recolor
-    
+
 
     from . import setting
-    
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/annotation.py pymol-open-source-2.3.3/modules/pymol/wizard/annotation.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/annotation.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/annotation.py	2019-08-22 10:24:47.862619142 +0200
@@ -8,16 +8,16 @@ class Annotation(Wizard):
 
     def get_event_mask(self):
         return Wizard.event_mask_scene+Wizard.event_mask_state+Wizard.event_mask_frame
-    
+
     def do_scene(self):
         self.cmd.dirty_wizard()
-        
+
     def do_frame(self,frame):
         self.cmd.dirty_wizard()
 
     def do_state(self,state):
         self.cmd.dirty_wizard()
-            
+
     def get_prompt(self):
         prompt = []
         pymol = self.cmd._pymol
@@ -44,10 +44,10 @@ from chempy.sdf import SDF
 def load_annotated_sdf(filename, object=None, state=1, discrete=1, _self=cmd):
     pymol=_self._pymol
     cmd=_self
-    
+
     # get object name from file prefix
 
-    if object==None:
+    if object is None:
         object = re.sub(r"\.[sS][dD][fF]$","",filename)
 
     # open the SD file
@@ -66,7 +66,7 @@ def load_annotated_sdf(filename, object=
 
     while 1:
 
-        # get next record 
+        # get next record
 
         sdf_rec = inp_sdf.read()
 
@@ -95,7 +95,7 @@ def load_annotated_sdf(filename, object=
                     ' '.join(map(str.strip, sdf_rec.data[key]))))
         state_dict[state] = anno_list
 
-        # increment the state index 
+        # increment the state index
 
         state = state + 1
 
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/appearance.py pymol-open-source-2.3.3/modules/pymol/wizard/appearance.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/appearance.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/appearance.py	2019-08-22 10:24:47.862619142 +0200
@@ -48,7 +48,7 @@ class Appearance(Wizard):
         8 : ['\\595lime'      , 'lime' ],
         9 : ['\\967pink'  , 'pink' ],
         10 : ['\\559slate' ,  'slate' ],
-        11 : ['\\949violet' , 'violet' ],    
+        11 : ['\\949violet' , 'violet' ],
         12 : ['\\950orange'  , 'orange' ],
         13 : ['\\059marine'   ,  'marine' ],
         14 : ['\\905hotpink' , 'hotpink' ],
@@ -68,7 +68,7 @@ class Appearance(Wizard):
         self.cmd.deselect()
         self.cmd.unpick()
         self.selection_mode = self.cmd.get_setting_int("mouse_selection_mode")
-        self.cmd.set("mouse_selection_mode",0) # set selection mode to atomic      
+        self.cmd.set("mouse_selection_mode",0) # set selection mode to atomic
         self.current_mode = saved_mode
         self.current_what = saved_what
         self.current_scope = saved_scope
@@ -77,11 +77,11 @@ class Appearance(Wizard):
             [2, 'Mode', '' ],
             [1, self.mode_dict[0][0], 'cmd.get_wizard().set_mode(0)' ],
             [1, self.mode_dict[1][0], 'cmd.get_wizard().set_mode(1)' ],
-            [ 0, ''           , '' ],         
+            [ 0, ''           , '' ],
             [1, self.mode_dict[2][0], 'cmd.get_wizard().set_mode(2)' ],
             [1, self.mode_dict[3][0], 'cmd.get_wizard().set_mode(3)' ],
             [1, self.mode_dict[4][0], 'cmd.get_wizard().set_mode(4)' ],
-#         [1, self.mode_dict[5][0], 'cmd.get_wizard().set_mode(4)' ],         
+#         [1, self.mode_dict[5][0], 'cmd.get_wizard().set_mode(4)' ],
             ]
 
         self.menu['what'] = [
@@ -93,7 +93,7 @@ class Appearance(Wizard):
             [1, self.what_dict[5][0], 'cmd.get_wizard().set_what(5)' ],
             [0, '', '' ],
             [1, self.what_dict[6][0], 'cmd.get_wizard().set_what(6)' ],
-            [0, '', '' ],         
+            [0, '', '' ],
             [1, self.what_dict[7][0], 'cmd.get_wizard().set_what(7)' ],
             [1, self.what_dict[8][0], 'cmd.get_wizard().set_what(8)' ],
             [1, self.what_dict[9][0], 'cmd.get_wizard().set_what(9)' ],
@@ -117,7 +117,7 @@ class Appearance(Wizard):
             [1, self.color_dict[11][0], 'cmd.get_wizard().set_color(11)' ],
             [1, self.color_dict[12][0], 'cmd.get_wizard().set_color(12)' ],
             [1, self.color_dict[13][0], 'cmd.get_wizard().set_color(13)' ],
-            [1, self.color_dict[14][0], 'cmd.get_wizard().set_color(14)' ],         
+            [1, self.color_dict[14][0], 'cmd.get_wizard().set_color(14)' ],
             ]
 
         self.menu['scope'] = [
@@ -126,9 +126,9 @@ class Appearance(Wizard):
             [ 1, self.scope_dict[1][0], 'cmd.get_wizard().set_scope(1)' ],
             [ 1, self.scope_dict[2][0], 'cmd.get_wizard().set_scope(2)' ],
             [ 1, self.scope_dict[3][0], 'cmd.get_wizard().set_scope(3)' ],
-            [ 1, self.scope_dict[4][0], 'cmd.get_wizard().set_scope(4)' ],        
+            [ 1, self.scope_dict[4][0], 'cmd.get_wizard().set_scope(4)' ],
             [ 0, ''           , '' ],
-            [ 1, self.scope_dict[5][0], 'cmd.get_wizard().set_scope(5)' ],                 
+            [ 1, self.scope_dict[5][0], 'cmd.get_wizard().set_scope(5)' ],
             ]
 
     def set_scope(self,scope):
@@ -157,7 +157,7 @@ class Appearance(Wizard):
 
     def undo(self):
         print("no undo!")
-        
+
     def get_prompt(self):
         self.prompt = []
         return self.prompt
@@ -176,14 +176,14 @@ class Appearance(Wizard):
         else: # select mode
             panel.append(
                 [ 1, 'Atoms' , '' ])
-            
+
         panel.extend([
                 [ 3, self.scope_dict[self.current_scope][0], 'scope' ],
                 #         [ 2, 'Undo', 'cmd.get_wizard().undo()' ],
                 [ 2, 'Done','cmd.set_wizard()'],
                 ])
         return panel
-            
+
 
     def do_pick(self,bondFlag):
         if self.current_mode in [0,1]: # color
@@ -224,7 +224,7 @@ class Appearance(Wizard):
         return 1
 
     def cleanup(self):
-        self.cmd.set("mouse_selection_mode",self.selection_mode) # restore selection mode      
+        self.cmd.set("mouse_selection_mode",self.selection_mode) # restore selection mode
         global saved_scope
         saved_scope = self.current_scope
         global saved_mode
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/benchmark.py pymol-open-source-2.3.3/modules/pymol/wizard/benchmark.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/benchmark.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/benchmark.py	2019-08-22 10:24:47.862619142 +0200
@@ -7,7 +7,7 @@ import pymol
 import types
 import time
 
-    
+
 class Benchmark(Wizard):
 
     def bench_fn(self,action):
@@ -23,17 +23,17 @@ class Benchmark(Wizard):
 
     def configure(self):
         self.cmd.reinitialize()
-        
+
     def __init__(self,arg0=None,_self=cmd):
-        Wizard.__init__(self,_self)        
+        Wizard.__init__(self,_self)
         self.gl = 5.0
         self.short_cpu = 8.0
         self.long_cpu = 16.0
         self.message = []
-        if arg0!=None:
+        if arg0 is not None:
             if hasattr(self,arg0):
                 getattr(self,arg0)()
-                
+
     def reset(self):
         pass
 
@@ -78,7 +78,7 @@ class Benchmark(Wizard):
         self.cmd.refresh()
         self.cmd.meter_reset()
         start = time.time()
-        while elapsed<self.gl: 
+        while elapsed<self.gl:
             self.cmd.turn("x",1)
             self.cmd.turn("y",1)
             self.cmd.refresh()
@@ -93,16 +93,16 @@ class Benchmark(Wizard):
         elapsed = 0.0
         cnt = 0
         self.cmd.refresh()
-        self.cmd.meter_reset()      
+        self.cmd.meter_reset()
         start = time.time()
-        while elapsed<self.gl: 
+        while elapsed<self.gl:
             self.cmd.turn("x",15)
             self.cmd.turn("y",15)
             self.cmd.refresh()
             cnt = cnt + 1
             elapsed = time.time()-start
         self.report('SMOOTH_LINES_V1',cnt/elapsed)
-        
+
     def jagged_lines(self):
         self.cmd.load("$PYMOL_DATA/demo/1tii.pdb")
         self.cmd.show("mesh")
@@ -111,9 +111,9 @@ class Benchmark(Wizard):
         cnt = 0
         elapsed = 0.0
         self.cmd.refresh()
-        self.cmd.meter_reset()      
+        self.cmd.meter_reset()
         start = time.time()
-        while elapsed<self.gl: 
+        while elapsed<self.gl:
             self.cmd.turn("x",15)
             self.cmd.turn("y",15)
             self.cmd.refresh()
@@ -129,9 +129,9 @@ class Benchmark(Wizard):
         elapsed = 0.0
         cnt = 0
         self.cmd.refresh()
-        self.cmd.meter_reset()      
+        self.cmd.meter_reset()
         start = time.time()
-        while elapsed<self.gl: 
+        while elapsed<self.gl:
             self.cmd.turn("x",15)
             self.cmd.turn("y",15)
             self.cmd.refresh()
@@ -147,9 +147,9 @@ class Benchmark(Wizard):
         cnt = 0
         elapsed = 0.0
         self.cmd.refresh()
-        self.cmd.meter_reset()      
+        self.cmd.meter_reset()
         start = time.time()
-        while elapsed<self.gl: 
+        while elapsed<self.gl:
             self.cmd.turn("x",15)
             self.cmd.turn("y",15)
             self.cmd.refresh()
@@ -165,9 +165,9 @@ class Benchmark(Wizard):
         cnt = 0
         elapsed = 0.0
         self.cmd.refresh()
-        self.cmd.meter_reset()      
+        self.cmd.meter_reset()
         start = time.time()
-        while elapsed<self.gl: 
+        while elapsed<self.gl:
             self.cmd.turn("x",15)
             self.cmd.turn("y",15)
             self.cmd.refresh()
@@ -183,9 +183,9 @@ class Benchmark(Wizard):
         cnt = 0
         elapsed = 0.0
         self.cmd.refresh()
-        self.cmd.meter_reset()      
+        self.cmd.meter_reset()
         start = time.time()
-        while elapsed<self.gl: 
+        while elapsed<self.gl:
             self.cmd.turn("x",15)
             self.cmd.turn("y",15)
             self.cmd.refresh()
@@ -202,9 +202,9 @@ class Benchmark(Wizard):
         cnt = 0
         elapsed = 0.0
         self.cmd.refresh()
-        self.cmd.meter_reset()      
+        self.cmd.meter_reset()
         start = time.time()
-        while elapsed<self.gl: 
+        while elapsed<self.gl:
             self.cmd.turn("x",15)
             self.cmd.turn("y",15)
             self.cmd.refresh()
@@ -224,7 +224,7 @@ class Benchmark(Wizard):
         cnt = 0
         elapsed = 0.0
         self.cmd.refresh()
-        self.cmd.meter_reset()      
+        self.cmd.meter_reset()
         start = time.time()
         while elapsed<self.gl:
             self.cmd.frame(1)
@@ -245,7 +245,7 @@ class Benchmark(Wizard):
         elapsed = 0.0
         self.cmd.refresh()
         start = time.time()
-        while (elapsed)<self.short_cpu: 
+        while (elapsed)<self.short_cpu:
             self.cmd.rebuild()
             self.cmd.refresh()
             cnt = cnt + 1
@@ -262,7 +262,7 @@ class Benchmark(Wizard):
         elapsed = 0.0
         self.cmd.refresh()
         start = time.time()
-        while (elapsed)<self.short_cpu: 
+        while (elapsed)<self.short_cpu:
             self.cmd.rebuild()
             self.cmd.refresh()
             cnt = cnt + 1
@@ -306,7 +306,7 @@ class Benchmark(Wizard):
             [11,200],
             [12,200],
             ],width=3600,height=2700)
-        
+
     def ray_tracing(self,conditions,width=640,height=480):
         self.cmd.load("$PYMOL_DATA/demo/1tii.pdb")
         self.cmd.zoom(complete=1)
@@ -316,14 +316,14 @@ class Benchmark(Wizard):
         self.cmd.show("mesh","A/10-20/")
         self.cmd.show("sticks","41-50/")
         self.cmd.show("lines","51-55/")
-        self.cmd.show("dots","61-65/")      
+        self.cmd.show("dots","61-65/")
         self.cmd.show("cartoon","80-90/")
         self.cmd.turn('x',25)
         self.cmd.turn('y',25)
         for cond in conditions:
             (max_threads,hash_max) = cond
-            self.cmd.set('max_threads',max_threads) 
-            self.cmd.set('hash_max',hash_max) 
+            self.cmd.set('max_threads',max_threads)
+            self.cmd.set('hash_max',hash_max)
             cnt = 0
             elapsed = 0.0
             self.cmd.refresh()
@@ -334,7 +334,7 @@ class Benchmark(Wizard):
                 elapsed = time.time()-start
             self.report('RAY_V2_PX%d_TH%02d_HSH%03d'%(width*height,
                                                                       max_threads,hash_max),60*cnt/elapsed)
-        
+
     def get_prompt(self):
         self.prompt = self.message
         return self.prompt
@@ -347,25 +347,24 @@ class Benchmark(Wizard):
         t = threading.Thread(target=self.bench_fn,args=(action,))
         t.setDaemon(1)
         t.start()
-        
+
     def get_panel(self):
         return [
             [ 1, 'Benchmarks', '' ],
             [ 2, 'Run All', 'cmd.get_wizard().delay_launch("run_all")' ],
             [ 2, 'Run GL', 'cmd.get_wizard().delay_launch("run_gl")' ],
-            [ 2, 'Run CPU', 'cmd.get_wizard().delay_launch("run_cpu")' ],                  
+            [ 2, 'Run CPU', 'cmd.get_wizard().delay_launch("run_cpu")' ],
             [ 2, 'Updates', 'cmd.get_wizard().delay_launch("updates")'],
             [ 2, 'Smooth Lines', 'cmd.get_wizard().delay_launch("smooth_lines")'],
             [ 2, 'Jagged Lines', 'cmd.get_wizard().delay_launch("jagged_lines")'],
-            [ 2, 'Dots', 'cmd.get_wizard().delay_launch("dots")'],         
+            [ 2, 'Dots', 'cmd.get_wizard().delay_launch("dots")'],
             [ 2, 'Sticks', 'cmd.get_wizard().delay_launch("sticks")'],
             [ 2, 'Surface', 'cmd.get_wizard().delay_launch("surface")'],
             [ 2, 'Spheres', 'cmd.get_wizard().delay_launch("spheres")'],
             [ 2, 'Cartoon', 'cmd.get_wizard().delay_launch("cartoon")'],
-            [ 2, 'Blits', 'cmd.get_wizard().delay_launch("blits")'],                                    
+            [ 2, 'Blits', 'cmd.get_wizard().delay_launch("blits")'],
             [ 2, 'Surface Calculation', 'cmd.get_wizard().delay_launch("surface_calculation")'],
             [ 2, 'Mesh Calculation', 'cmd.get_wizard().delay_launch("mesh_calculation")'],
             [ 2, 'Ray Tracing', 'cmd.get_wizard().delay_launch("ray_trace0")'],
             [ 2, 'End Demonstration', 'cmd.set_wizard()' ]
             ]
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/box.py pymol-open-source-2.3.3/modules/pymol/wizard/box.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/box.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/box.py	2019-08-22 10:24:47.862619142 +0200
@@ -33,17 +33,17 @@ class Box(Wizard):
 
     def __init__(self,_self=cmd):
         Wizard.__init__(self,_self)
-        
+
         self.editing_name = 0
         self.copying = 0
-        
+
         self.points_name = ''
         self.set_name(default_name)
-    
+
         self.mode = default_mode
         self.modes = [
             'box',
-            'walls', 
+            'walls',
             'plane',
 	    'quad',
             ]
@@ -62,14 +62,14 @@ class Box(Wizard):
         self.menu['mode']=smm
 
         self.update_box()
-        
+
     def set_mode(self,mode):
         if mode in self.modes:
             self.mode = mode
         self.status = 0
         self.update_box()
         self.cmd.refresh_wizard()
-        
+
     def get_prompt(self):
         self.prompt = []
         return self.prompt
@@ -125,7 +125,7 @@ class Box(Wizard):
                 [ -plane_size, -plane_size, plane_z2 ],
                 ]
 
-            # then transform plane coordinates into model space 
+            # then transform plane coordinates into model space
 
             plane = list(map( lambda p,v=view: [
                v[0] * p[0] + v[1] * p[1] + v[2]* p[2],
@@ -155,26 +155,26 @@ class Box(Wizard):
     def set_name(self,name):
 
         hidden_name = None
-        
+
         if self.points_name != '':
             if self.points_name in self.cmd.get_names("all"):
                 hidden_name = "_"+self.cgo_name
                 self.cmd.disable(self.points_name)
-                self.cmd.set_name(self.points_name, hidden_name) # hide 
+                self.cmd.set_name(self.points_name, hidden_name) # hide
 
         self.name = name
         self.points_name = self.name + "_points"
         self.cgo_name = self.name
-        if self.copying and hidden_name != None:
+        if self.copying and hidden_name is not None:
             self.cmd.copy(self.points_name, hidden_name, zoom=0)
             print("copy")
         else:
             hidden_name = "_"+self.cgo_name
             if hidden_name in self.cmd.get_names("all"):
-                self.cmd.set_name(hidden_name, self.points_name) 
+                self.cmd.set_name(hidden_name, self.points_name)
         self.copying = 0
-        
-        if not self.points_name in self.cmd.get_names():
+
+        if self.points_name not in self.cmd.get_names():
             model = Indexed()
             origin = self.cmd.get_view()[12:15]
             for a in pseudo_atoms:
@@ -185,7 +185,7 @@ class Box(Wizard):
                 new_atom.coord[2] = new_atom.coord[2] + origin[2]
                 new_atom.flags = 0x2200000 # set surface ignore flag
                 model.atom.append(new_atom)
-                
+
             self.cmd.load_model(model,self.points_name,zoom=0)
             self.cmd.set("surface_mode",0,self.points_name) # make sure no surface is shown
             self.coord = None
@@ -199,7 +199,7 @@ class Box(Wizard):
 
         self.cmd.enable(self.points_name)
         self.points_enabled = 1
-        
+
     def update_box(self):
 
         if self.points_name in self.cmd.get_names():
@@ -382,9 +382,9 @@ class Box(Wizard):
             self.cmd.load_cgo(obj,self.cgo_name,zoom=0)
             self.cmd.order(self.cgo_name+" "+self.points_name,sort=1,location='bottom')
             self.cmd.set("nonbonded_size",math.sqrt(dot_product(d10,d10))/10,self.points_name)
-        
+
     def get_panel(self):
-        
+
         return [
             [ 1, 'Box Wizard',''],
             [ 3, self.mode_name[self.mode],'mode'],
@@ -402,11 +402,11 @@ class Box(Wizard):
             return Wizard.event_mask_pick + Wizard.event_mask_select + \
                    Wizard.event_mask_scene + Wizard.event_mask_key
         else:
-            return Wizard.event_mask_pick + Wizard.event_mask_select + Wizard.event_mask_scene 
+            return Wizard.event_mask_pick + Wizard.event_mask_select + Wizard.event_mask_scene
 
     def do_scene(self):
         if self.points_name in self.cmd.get_names("objects"):
-            if self.coord == None:
+            if self.coord is None:
                 self.update_box()
             else:
                 model = self.cmd.get_model(self.points_name)
@@ -418,7 +418,7 @@ class Box(Wizard):
                     )
                 if self.coord != coord:
                     self.update_box()
-                
+
     def do_pick(self,bondFlag):
         pass
 
@@ -429,7 +429,7 @@ class Box(Wizard):
             self.new_name = self.new_name + chr(k)
         elif k==10 or k==13:
             self.editing_name = 0
-            self.new_name = string.strip(self.new_name)
+            self.new_name = self.new_name.strip()
             if self.new_name == '':
                 self.new_name = 'box'
             else:
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/charge.py pymol-open-source-2.3.3/modules/pymol/wizard/charge.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/charge.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/charge.py	2019-08-22 10:24:47.866619793 +0200
@@ -11,7 +11,7 @@ class Charge(Wizard):
 
     def __init__(self,_self=cmd):
         Wizard.__init__(self,_self)
-        
+
         self.modes = [
             'labchg',
             'addchg',
@@ -26,7 +26,7 @@ class Charge(Wizard):
 
         self.mode = default_mode
         self.status = 0
-        
+
         self.mode_name = {
             'labchg':'Show',
             'cpychg':'Copy',
@@ -38,20 +38,20 @@ class Charge(Wizard):
             'rbachg':'Move & Remove (resi)',
             'sumchg':'Get Total Charge'
             }
-        
+
         # initialize mode menu
-        
+
         smm = []
         smm.append([ 2, 'Atom Charge Mode', '' ])
         for a in self.modes:
             smm.append([ 1, self.mode_name[a], 'cmd.get_wizard().set_mode("'+a+'")'])
 
         self.menu['mode']=smm
-        
+
         self.memory = 0
 
         _self.edit_mode()
-            
+
 
     def get_panel(self):
         return [
@@ -65,7 +65,7 @@ class Charge(Wizard):
         global default_mode
         default_mode = self.mode
         self.clear()
-        
+
     def clear(self):
         self.set_status(0)
         if 'wcharge' in self.cmd.get_names('selections'):
@@ -73,12 +73,12 @@ class Charge(Wizard):
                 self.cmd.edit("wcharge")
                 self.cmd.label("pkmol",'') # fastest clear command
             else:
-                self.cmd.label("wcharge",'') # fastest clear command            
+                self.cmd.label("wcharge",'') # fastest clear command
             self.cmd.delete("wcharge")
             self.cmd.unpick()
         self.cmd.unpick()
         self.cmd.refresh_wizard()
-        
+
     def get_prompt(self):
         self.prompt = None
         if self.mode == 'cpychg':
@@ -129,15 +129,15 @@ class Charge(Wizard):
             if self.cmd.iterate("(byres wcharge)",
                                 "stored.charge = stored.charge + partial_charge"):
                 self.prompt.insert(0,"Total charge on the residue is %6.4f"%pymol.stored.charge)
-                
+
         return self.prompt
-    
+
     def set_mode(self,mode):
         if mode in self.modes:
             self.mode = mode
         self.status = 0
         self.cmd.refresh_wizard()
-        
+
     def set_status(self,status):
         self.status = status
         self.cmd.refresh_wizard()
@@ -145,7 +145,7 @@ class Charge(Wizard):
     def do_pick(self,bondFlag):
         if bondFlag:
             print(" Error: please select a single atom")
-            
+
         if self.mode == 'cpychg':
             # picking up
             if self.status==0:
@@ -156,7 +156,7 @@ class Charge(Wizard):
                     self.cmd.select("wcharge","(pk1)")
                     self.cmd.unpick()
                     self.cmd.enable("wcharge")
-                    
+
             # dropping off
             elif self.status==1:
                 pymol.stored.charge=self.partial_charge
@@ -178,7 +178,7 @@ class Charge(Wizard):
                     self.cmd.select("wcharge","(byres pk1)")
                     self.cmd.unpick()
                     self.cmd.enable("wcharge")
-                    
+
             # dropping off
             elif self.status==1:
                 pymol.stored.valid_atoms = []
@@ -218,7 +218,7 @@ class Charge(Wizard):
                     self.cmd.select("wcharge","(pk1)")
                     self.cmd.unpick()
                     self.cmd.enable("wcharge")
-                    
+
             # dropping off
             elif self.status==1:
                 pymol.stored.charge=self.partial_charge
@@ -228,7 +228,7 @@ class Charge(Wizard):
                     self.cmd.select("wcharge","(pk1)")
                     self.cmd.unpick()
                     self.cmd.enable("wcharge")
-                    
+
         if self.mode == 'mzochg':
             # picking up
             if self.status==0:
@@ -239,7 +239,7 @@ class Charge(Wizard):
                     self.cmd.select("wcharge","(pk1)")
                     self.cmd.unpick()
                     self.cmd.enable("wcharge")
-                    
+
             # dropping off
             elif self.status==1:
                 pymol.stored.charge=self.partial_charge
@@ -247,7 +247,7 @@ class Charge(Wizard):
                     self.status = 0
                     self.cmd.label("(pk1)","'%6.4f'%partial_charge")
                     self.cmd.alter("(wcharge)","partial_charge=0")
-                    self.cmd.label("(wcharge)","'%6.4f'%partial_charge")               
+                    self.cmd.label("(wcharge)","'%6.4f'%partial_charge")
                     self.cmd.select("wcharge","(pk1)")
                     self.cmd.unpick()
                     self.cmd.enable("wcharge")
@@ -262,7 +262,7 @@ class Charge(Wizard):
                     self.cmd.select("wcharge","(pk1)")
                     self.cmd.unpick()
                     self.cmd.enable("wcharge")
-                    
+
             # dropping off
             elif self.status==1:
                 pymol.stored.charge=self.partial_charge
@@ -280,13 +280,13 @@ class Charge(Wizard):
                 self.cmd.select("wcharge","(pk1)")
                 self.cmd.unpick()
                 self.cmd.enable("wcharge")
-                    
+
         if self.mode == 'labchg':
             self.cmd.label("(pk1)","'%6.4f'%partial_charge")
             self.cmd.select("wcharge","(pk1)")
             self.cmd.unpick()
             self.cmd.enable("wcharge")
-                    
+
         if self.mode == 'sumchg':
             pymol.stored.charge = 0.0
             if self.cmd.iterate("(pkmol)","stored.charge = stored.charge + partial_charge"):
@@ -295,5 +295,5 @@ class Charge(Wizard):
                 self.cmd.select("wcharge","(pkmol)")
                 self.cmd.unpick()
                 self.cmd.enable("wcharge")
-            
+
         self.cmd.refresh_wizard()
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/cleanup.py pymol-open-source-2.3.3/modules/pymol/wizard/cleanup.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/cleanup.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/cleanup.py	2019-08-22 10:24:47.866619793 +0200
@@ -12,12 +12,12 @@ redo_object = "_w_cleanup_redo"
 
 def auto_configure():
     result = -1
-    
+
     global SZYBKI_EXE
     OE_DIR = os.environ.get("OE_DIR",None)
-    if OE_DIR == None:
+    if OE_DIR is None:
         OE_DIR = os.environ.get("OEDIR",None)
-    if OE_DIR != None:
+    if OE_DIR is not None:
         SZYBKI_EXE = os.path.join(OE_DIR,"bin/szybki")
         if os.path.exists(SZYBKI_EXE):
             result = 1
@@ -30,7 +30,7 @@ def auto_configure():
             SZYBKI_EXE = os.path.join(OE_DIR,"arch/microsoft-win32-i586/bin/szybki-1.0b7.exe")
             if os.path.exists(SZYBKI_EXE):
                  result = 1
-	
+
     return result
 
 class Cleanup(Wizard):
@@ -38,7 +38,7 @@ class Cleanup(Wizard):
     def update_menus(self):
         ligand = [ [2, 'Ligand', '']]
         target = [ [2, 'Target', ''], [1, '(none)',' cmd.get_wizard().set_target("(none)")' ]]
-        
+
         for a in self.cmd.get_names("public_objects"):
             ligand.append([1, a, 'cmd.get_wizard().set_ligand("'+a+'")'])
             if a!=self.ligand:
@@ -52,7 +52,7 @@ class Cleanup(Wizard):
         if auto_configure() < 1:
             raise pymol.CmdException('cannot find "szybki" executable, please '
                     'set OE_DIR environment variable')
-        
+
         self.ligand = ""
         for a in self.cmd.get_names("public_objects",1):
             if self.cmd.count_atoms(a) < 1000:
@@ -74,7 +74,7 @@ class Cleanup(Wizard):
             if self.ligand in self.cmd.get_names("objects"):
                 self.cmd.delete(redo_object)
                 self.cmd.set_name(self.ligand,redo_object)
-                self.cmd.disable(redo_object)            
+                self.cmd.disable(redo_object)
             self.cmd.create(self.ligand,undo_object,zoom=0)
 
     def redo(self):
@@ -84,13 +84,13 @@ class Cleanup(Wizard):
                 self.cmd.set_name(self.ligand,undo_object)
                 self.cmd.disable(undo_object)
             self.cmd.create(self.ligand,redo_object,zoom=0)
-        
+
     def run(self):
         exe = SZYBKI_EXE
         inp = "ligand_inp.mol"
         out = "ligand_out.mol"
         tmp_obj = "_cleanup_tmp_obj"
-        
+
         if self.ligand in self.cmd.get_names("objects"):
             self.save_undo()
             if os.path.exists(inp): os.unlink(inp)
@@ -114,15 +114,15 @@ class Cleanup(Wizard):
             self.cmd.delete(tmp_obj)
             self.cmd.sculpt_deactivate(self.ligand)
             self.cmd.sculpt_purge()
-            
+
     def set_target(self,target):
         self.target = target
         self.cmd.refresh_wizard()
-        
+
     def set_ligand(self,ligand):
         self.ligand = ligand
         self.cmd.refresh_wizard()
-        
+
     def get_panel(self):
         return [
             [ 1, 'Cleanup',''],
@@ -132,31 +132,31 @@ class Cleanup(Wizard):
             [ 2, "Redo", 'cmd.get_wizard().redo()' ],
             [ 3, "\\999Ligand:\\000 "+self.ligand,'ligand'],
 #         [ 3, "\\999Target:\\000 "+self.target,'target'],
-            [ 2, 'Refresh','cmd.get_wizard().update()'],         
+            [ 2, 'Refresh','cmd.get_wizard().update()'],
             [ 2, 'Done','cmd.set_wizard()'],
             ]
 
     def update(self):
         self.update_menus()
         self.cmd.refresh_wizard()
-        
+
     def cleanup(self):
         self.clear()
         self.cmd.delete(undo_object)
         self.cmd.delete(redo_object)
-        
+
     def clear(self):
         self.cmd.unpick()
         self.cmd.refresh_wizard()
-        
+
     def get_prompt(self):
         self.prompt = []
         if self.ligand=="":
             self.prompt = [ 'Please pick a ligand...' ]
-        if self.message!=None:
+        if self.message is not None:
             self.prompt.append(self.message)
         return self.prompt
-    
+
     def set_status(self,status):
         self.status = status
         self.cmd.refresh_wizard()
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/demo.py pymol-open-source-2.3.3/modules/pymol/wizard/demo.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/demo.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/demo.py	2019-08-22 10:24:47.866619793 +0200
@@ -15,7 +15,7 @@ class Demo(Wizard):
         self.last = None
         if 'last' in saved:
             self.last = saved['last']
-        if name!=None:
+        if name is not None:
             demo = DemoInfo(_self=_self)
             if self.last:
                 if hasattr(demo,self.last):
@@ -30,7 +30,7 @@ class Demo(Wizard):
             else:
                 self.last = None
             saved['last']=self.last
-        
+
     def get_prompt(self):
         saved['last']=self.last
         self.prompt = self.message
@@ -41,7 +41,7 @@ class Demo(Wizard):
             [ 1, 'Demonstrations', '' ],
             [ 2, 'Representations', 'replace_wizard demo,reps'],
             [ 2, 'Cartoon Ribbons', 'replace_wizard demo,cartoon'],
-            [ 2, 'Roving Detail', 'replace_wizard demo,roving'],         
+            [ 2, 'Roving Detail', 'replace_wizard demo,roving'],
             [ 2, 'Roving Density', 'replace_wizard demo,roving_density'],
             [ 2, 'Transparency', 'replace_wizard demo,trans'],
             [ 2, 'Ray Tracing', 'replace_wizard demo,ray'],
@@ -63,9 +63,9 @@ class DemoInfo:
 
     def __init__(self,_self=cmd):
         self.cmd=_self
-        
+
     message_dict = {
-        'roving' : [ 
+        'roving' : [
         "Middle-Click to rove...         CTRL-SHIFT-Middle-Click to center...",],
         'roving_density' : [
         "Middle-Click to rove...         CTRL-SHIFT-Middle-Click to center...",],
@@ -74,7 +74,7 @@ class DemoInfo:
         'sculpt' : [
         "CTRL-Left-Click to drag atoms...       CTRL-Right-Click to rotate bonds...",],
         }
-                                          
+
     def rep_old(self,cleanup=0):
         if not cleanup:
             try:
@@ -119,7 +119,7 @@ class DemoInfo:
                 util.cbac("rep3",_self=self.cmd)
                 util.cbas("rep4",_self=self.cmd)
                 util.cbab("rep5",_self=self.cmd)
-                util.cbaw("rep6",_self=self.cmd)            
+                util.cbaw("rep6",_self=self.cmd)
                 util.cbay("rep8",_self=self.cmd)
 
 
@@ -170,7 +170,7 @@ class DemoInfo:
                 self.cmd.set("movie_panel",1)
         except:
             traceback.print_exc()
-            
+
     def raster3d(self,cleanup=0):
         if not cleanup:
             self.cmd.disable()
@@ -219,7 +219,7 @@ class DemoInfo:
                     self.cmd.torsion("2")
                     self.cmd.unpick()
                 finally:
-                    self.cmd.set("suspend_updates",0,quiet=1)         
+                    self.cmd.set("suspend_updates",0,quiet=1)
                 self.cmd.refresh()
             self.cmd.feedback('ena','sel','res')
         else:
@@ -270,7 +270,7 @@ class DemoInfo:
                 self.cmd.move('z',2)
                 self.cmd.move('y',-0.12)
                 self.cmd.refresh()
-                                
+
         else:
             self.cmd.delete("1hpv_*")
 
@@ -304,7 +304,7 @@ class DemoInfo:
             self.cmd.set("roving_detail",0)
             self.cmd.refresh()
             self.cmd.delete("rov_*")
-            
+
     def roving_density(self,cleanup=0):
         if not cleanup:
             try:
@@ -325,7 +325,7 @@ class DemoInfo:
                 self.cmd.set("roving_map1_name","map")
                 self.cmd.isomesh("rov_m1","map",9999.0,"il2")
                 self.cmd.color("density","rov_m1")
-                
+
                 self.cmd.set_view ((\
           0.132852688,   -0.729740858,    0.670686543,\
           -0.228543565,    0.635894477,    0.737154961,\
@@ -348,13 +348,13 @@ class DemoInfo:
             self.cmd.set("roving_detail",0)
             self.cmd.delete("rov_*")
             self.cmd.sync()
-            
+
     def cartoon(self,cleanup=0):
         if not cleanup:
             try:
                 self.cmd.set("suspend_updates",1,quiet=1)
                 self.cmd.disable()
-                self.cmd.delete("1tii")      
+                self.cmd.delete("1tii")
                 self.cmd.load("$PYMOL_DATA/demo/1tii.pdb")
                 self.cmd.hide("(1tii)")
                 self.cmd.show("cartoon","1tii")
@@ -386,7 +386,7 @@ class DemoInfo:
             self.cmd.delete("pept")
             self.cmd.delete("e_pot")
             self.cmd.delete("e_lvl")
-            
+
     def trans(self,cleanup=0):
         if not cleanup:
             try:
@@ -423,7 +423,7 @@ class DemoInfo:
             self.cmd.do("ray")
         else:
             self.cmd.delete("ray")
-            
+
     def finish(self,cleanup=0):
         self.cmd.do("_ wizard")
 
@@ -452,4 +452,3 @@ class DemoInfo:
             self.cmd.set("auto_sculpt",0)
             self.cmd.delete("sculpt")
             self.cmd.mouse()
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/density.py pymol-open-source-2.3.3/modules/pymol/wizard/density.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/density.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/density.py	2019-08-22 10:24:47.866619793 +0200
@@ -17,17 +17,17 @@ class Density(Wizard):
 
         self.cmd = _self
         self.cmd.unpick()
-        
+
         Wizard.__init__(self,_self)
-        
+
         # mode selection subsystem
-        
+
         self.radius = default_radius
         self.map = copy.deepcopy(default_map)
         self.level = copy.deepcopy(default_level)
         self.track = copy.deepcopy(default_track)
         self.avail_maps = []
-        
+
         self.menu['radius'] = [
                                       [1, '4.0 A Radius','cmd.get_wizard().set_radius(4)'],
                                       [1, '5.0 A Radius','cmd.get_wizard().set_radius(5)'],
@@ -38,7 +38,7 @@ class Density(Wizard):
                                       [1, '20.0 A Radius','cmd.get_wizard().set_radius(20)'],
                                       [1, '50.0 A Radius','cmd.get_wizard().set_radius(50)'],
                                       ]
-                                        
+
         self.menu['map0'] = []
         self.menu['map1'] = []
         self.menu['map2'] = []
@@ -49,11 +49,11 @@ class Density(Wizard):
                                         [1, '3.0 sigma','cmd.get_wizard().set_level(%d,3.0)'%x],
                                         [1, '5.0 sigma','cmd.get_wizard().set_level(%d,5.0)'%x],
                                         [1, '-3.0 sigma','cmd.get_wizard().set_level(%d,-3.0)'%x]]
-        
+
         self.menu['level0'] = level_menu(0)
         self.menu['level1'] = level_menu(1)
         self.menu['level2'] = level_menu(2)
-        
+
         self.menu['track'] = [
         [ 1, "Track & Zoom", 'cmd.get_wizard().set_track(0)'],
         [ 1, "Track & Center", 'cmd.get_wizard().set_track(1)'],
@@ -69,12 +69,12 @@ class Density(Wizard):
         self.update_map_menus()
 
         self.cmd.set_key('pgup',lambda c=cmd:c.get_wizard().next_res(d=-1))
-        self.cmd.set_key('pgdn',lambda c=cmd:c.get_wizard().next_res())      
-        
+        self.cmd.set_key('pgdn',lambda c=cmd:c.get_wizard().next_res())
+
     def update_map_menus(self):
 
         self.avail_maps = []
-        
+
         for a in self.cmd.get_names('objects'):
             if self.cmd.get_type(a)=='object:map':
                 self.avail_maps.append(a)
@@ -92,7 +92,7 @@ class Density(Wizard):
     def set_track(self,track):
         self.track = track
         self.cmd.refresh_wizard()
-        
+
     def set_level(self,map,level):
         self.level[map] = level
         self.update_maps()
@@ -113,7 +113,7 @@ class Density(Wizard):
             sele_name = "center"
         if 1:
             save = self.cmd.get_setting_text('auto_zoom')
-            self.cmd.set('auto_zoom',0,quiet=1)                     
+            self.cmd.set('auto_zoom',0,quiet=1)
             c = 0
             for a in self.map:
                 oname = 'w'+str(c+1)+'_'+a
@@ -133,7 +133,7 @@ class Density(Wizard):
                         else:
                             self.cmd.color('magenta',oname)
                 c = c + 1
-            save = self.cmd.set('auto_zoom',save,quiet=1)            
+            save = self.cmd.set('auto_zoom',save,quiet=1)
             if self.track==0:
                 if zoom:
                     self.cmd.zoom(sele_name,self.radius,animate=0.67)
@@ -143,7 +143,7 @@ class Density(Wizard):
             elif self.track==2:
                 if zoom:
                     self.cmd.origin(sele_name)
-        self.cmd.refresh_wizard()      
+        self.cmd.refresh_wizard()
 # generic set routines
 
     def zoom(self):
@@ -158,13 +158,13 @@ class Density(Wizard):
                         self.cmd.zoom(oname,animate=0.67)
 
                 c = c + 1
-                
+
     def get_panel(self):
         self.update_map_menus()
         return [
             [ 1, 'Density Map Wizard',''],
             [ 2, 'Update Maps' , 'cmd.get_wizard().update_maps()'],
-            [ 2, 'Zoom' , 'cmd.get_wizard().zoom()'],         
+            [ 2, 'Zoom' , 'cmd.get_wizard().zoom()'],
             [ 2, 'Next Res. (PgDown)' , 'cmd.get_wizard().next_res()'],
             [ 2, 'Previous Res. (PgUp)' , 'cmd.get_wizard().next_res(d=-1)'],
             [ 3, "Radius: %3.1f A"%self.radius,'radius'],
@@ -187,7 +187,7 @@ class Density(Wizard):
         self.clear()
         self.cmd.set_key('pgup',None)
         self.cmd.set_key('pgdn',None)
-        
+
     def clear(self):
         pass
 
@@ -207,7 +207,7 @@ class Density(Wizard):
 
     def get_event_mask(self):
         return Wizard.event_mask_pick + Wizard.event_mask_select + Wizard.event_mask_position
-    
+
     def do_position(self):
         if '_dw' not in cmd.get_names("selections"):
             self.update_maps(zoom=0)
@@ -250,7 +250,7 @@ class Density(Wizard):
                 else:
                     n = self.cmd.select('_dw2', ''+obj+'/'+a0.segi+'/'+a0.chain+'/'+resids[next_i]+'/'+atn)
             if (n > 0):
-                self.cmd.hide("labels", "?_dw") 
+                self.cmd.hide("labels", "?_dw")
                 self.cmd.select('dw_resi', 'byres _dw2')
                 self.cmd.disable('dw_resi')
                 self.cmd.label('(_dw2)', '"  %s %s/%s/" % (resn,chain,resi)')
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/distance.py pymol-open-source-2.3.3/modules/pymol/wizard/distance.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/distance.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/distance.py	2019-08-22 10:24:47.866619793 +0200
@@ -19,18 +19,18 @@ dist_count = 0
 class Distance(Wizard):
 
     cutoff = 3.5
-    
+
     def __init__(self,_self=cmd):
 
         cmd.unpick();
         Wizard.__init__(self,_self)
-        
+
         self.status = 0 # 0 no atoms selections, 1 atom selected
         self.error = None
         self.object_name = None
 
         # mode selection subsystem
-        
+
         self.mode = default_mode
         self.modes = [
             'polar',
@@ -38,7 +38,7 @@ class Distance(Wizard):
             'neigh',
             'pairs',
             ]
-        
+
         self.mode_name = {
             'polar':'Polar Neighbors',
             'heavy':'Heavy Neighbors',
@@ -53,7 +53,7 @@ class Distance(Wizard):
         self.menu['mode']=smm
 
         # overwrite mode selection subsystem
-        
+
         self.object_mode=default_object_mode
         self.object_modes = [
             'overwr',
@@ -61,7 +61,7 @@ class Distance(Wizard):
             ]
         self.object_mode_name = {
             'overwr':'Replace Previous',
-            'append':'Create New',         
+            'append':'Create New',
             }
 
         smm = []
@@ -72,7 +72,7 @@ class Distance(Wizard):
         self.selection_mode = cmd.get_setting_int("mouse_selection_mode")
         cmd.set("mouse_selection_mode",0) # set selection mode to atomic
         cmd.deselect() # disable the active selection (if any)
-        
+
 # generic set routines
 
     def set_mode(self,mode):
@@ -88,7 +88,7 @@ class Distance(Wizard):
         self.status = 0
         cmd.refresh_wizard()
 
-        
+
     def get_panel(self):
         return [
             [ 1, 'Distance Measurement',''],
@@ -105,10 +105,10 @@ class Distance(Wizard):
         default_object_mode = self.object_mode
         self.clear()
         cmd.set("mouse_selection_mode",self.selection_mode) # restore selection mode
-        
+
     def clear(self):
         cmd.delete(sele_prefix+"*")
-        
+
     def get_prompt(self):
         self.prompt = None
         if self.mode == 'pairs':
@@ -118,10 +118,10 @@ class Distance(Wizard):
                 self.prompt = [ 'Please click on the second atom...' ]
         elif self.mode in [ 'polar', 'neigh' ]:
             self.prompt = [ 'Please click an atom...']
-        if self.error!=None:
+        if self.error is not None:
             self.prompt.append(self.error)
         return self.prompt
-    
+
     def delete_last(self):
         global dist_count
         if self.status==0:
@@ -147,7 +147,7 @@ class Distance(Wizard):
         cmd.edit(name)
         cmd.delete(name)
         self.do_pick(0)
-        
+
     def do_pick(self,bondFlag):
         global dist_count
 
@@ -157,7 +157,7 @@ class Distance(Wizard):
         else:
             if self.mode == 'pairs':
                 if self.status==0:
-                    name = sele_prefix 
+                    name = sele_prefix
                     cmd.select(name,"(pk1)")
                     self.status = 1
                     self.error = None
@@ -182,9 +182,9 @@ class Distance(Wizard):
                 if self.mode == 'neigh':
                     cnt = cmd.select(sele_prefix,"(v. and (pk1 a; %f) and (not (nbr. pk1)) and (not (nbr. (nbr. pk1))) and (not (nbr. (nbr. (nbr. pk1)))))"%self.__class__.cutoff)
                 elif self.mode == 'polar':
-                    cnt = cmd.select(sele_prefix,"(v. and (pk1 a; %f) and (e. n,o) and (not (nbr. pk1)) and (not (nbr. (nbr. pk1))) and (not (nbr. (nbr. (nbr. pk1)))))"%self.__class__.cutoff)            
+                    cnt = cmd.select(sele_prefix,"(v. and (pk1 a; %f) and (e. n,o) and (not (nbr. pk1)) and (not (nbr. (nbr. pk1))) and (not (nbr. (nbr. (nbr. pk1)))))"%self.__class__.cutoff)
                 elif self.mode == 'heavy':
-                    cnt = cmd.select(sele_prefix,"(v. and (pk1 a; %f) and (not h.) and (not (nbr. pk1)) and (not (nbr. (nbr. pk1))) and (not (nbr. (nbr. (nbr. pk1)))))"%self.__class__.cutoff)            
+                    cnt = cmd.select(sele_prefix,"(v. and (pk1 a; %f) and (not h.) and (not (nbr. pk1)) and (not (nbr. (nbr. pk1))) and (not (nbr. (nbr. (nbr. pk1)))))"%self.__class__.cutoff)
                 cmd.delete(name)
                 if cnt:
                     cmd.dist(name,"(pk1)",sele_prefix)
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/dragging.py pymol-open-source-2.3.3/modules/pymol/wizard/dragging.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/dragging.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/dragging.py	2019-08-22 10:24:47.866619793 +0200
@@ -13,7 +13,7 @@ drag_sele = "_drag"
 #    time.sleep(delay)
 #    from pymol import cmd
 #    cmd.disable(name)
-    
+
 class Dragging(Wizard):
 
     def __init__(self,*arg,**kw):
@@ -45,9 +45,9 @@ class Dragging(Wizard):
     def do_dirty(self):
         if self.valid:
             self.check_valid()
-        
+
     def check_valid(self):
-        if (not hasattr(self,"cmd")) or self.cmd == None:
+        if (not hasattr(self,"cmd")) or self.cmd is None:
             return 0
         elif self.cmd.get_editor_scheme()!=3:
             if self.valid:
@@ -60,10 +60,10 @@ class Dragging(Wizard):
 
     def get_event_mask(self):
         return Wizard.event_mask_pick + Wizard.event_mask_dirty
-        
+
     def set_old_button_mode(self,button_mode):
         self.old_button_mode = button_mode
-        
+
     def indicate(self):
         if self.check_valid():
             if drag_sele in self.cmd.get_names("all",enabled_only=1):
@@ -73,26 +73,26 @@ class Dragging(Wizard):
             self.cmd.refresh_wizard()
 
     def cleanup(self):
-        if (not hasattr(self,"cmd")) or self.cmd == None:
+        if (not hasattr(self,"cmd")) or self.cmd is None:
             return
         self.cmd.drag()
         if drag_sele in self.cmd.get_names("all",enabled_only=1):
             self.cmd.disable(drag_sele)
-        if self.old_button_mode != None:
+        if self.old_button_mode is not None:
             self.cmd.set("button_mode",self.old_button_mode,quiet=1)
             self.cmd.mouse()
-    
+
     def get_panel(self):
         if self.check_valid():
             if self.atom_count:
                 panel = [
                     [ 1, 'Dragging %d atoms in'%self.atom_count, ''],
                     [ 1, 'object "'+self.obj+'"', ''],
-                    [ 2, 'Undo (CTRL-Z)', 
+                    [ 2, 'Undo (CTRL-Z)',
                       'cmd.undo()'],
-                    [ 2, 'Redo (CTRL-A)', 
+                    [ 2, 'Redo (CTRL-A)',
                       'cmd.redo()'],
-                    [ 2, 'Indicate', 
+                    [ 2, 'Indicate',
                       'cmd.get_wizard().indicate()'],
                     [ 2, 'Done', 'cmd.set_wizard()' ]
                     ]
@@ -103,10 +103,7 @@ class Dragging(Wizard):
                     [ 2, 'Reset', 'cmd.reset(object="%s")'%self.obj],
                     [ 2, 'Done', 'cmd.set_wizard()' ]
                     ]
-                
+
         else:
             panel = None
         return panel
-
-
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/fedora.py pymol-open-source-2.3.3/modules/pymol/wizard/fedora.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/fedora.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/fedora.py	2019-08-22 10:24:47.866619793 +0200
@@ -16,7 +16,7 @@ class Fedora(Wizard):
                 self.message.append(a)
             else:
                 self.message.extend(a)
-            
+
     def get_prompt(self):
         self.prompt = self.message
         return self.prompt
@@ -29,12 +29,9 @@ class Fedora(Wizard):
     def do_select(self,name):
 #      cmd.deselect()
         pass
-        
+
     def get_panel(self):
         return [
             [ 1, 'Message', '' ],
             [ 2, 'Dismiss', 'cmd.set_wizard()' ]
             ]
-
-
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/filter.py pymol-open-source-2.3.3/modules/pymol/wizard/filter.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/filter.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/filter.py	2019-08-22 10:24:47.866619793 +0200
@@ -63,32 +63,32 @@ class Filter(Wizard):
     def __init__(self,_self=cmd):
 
         # initialize parent class
-        
+
         Wizard.__init__(self,_self)
 
         self.update_object_menu()
-        
+
         # restore previous state from global storage
 
         self.dict = static_dict
         self.object = default_object if default_object in self.avail_objects else None
         self.browse = default_browse
         self.state_dict = {}
-        
+
         # if we don't have a current object, choose the first multi-state object
-        
+
         if not self.object and self.avail_objects:
             self.object = self.avail_objects[0]
 
         # menu for
-        
+
         self.menu['browse'] = [
             [2, 'Browse Mode',''],
             [1, 'Browse All','cmd.get_wizard().set_browse(1)'],
             [1, 'Browse Accepted','cmd.get_wizard().set_browse(2)'],
             [1, 'Browse Rejected','cmd.get_wizard().set_browse(3)'],
             [1, 'Browse Deferred','cmd.get_wizard().set_browse(4)'],
-            [1, 'Browse Remaining','cmd.get_wizard().set_browse(5)'],         
+            [1, 'Browse Remaining','cmd.get_wizard().set_browse(5)'],
             ]
 
         self.menu['create'] = [
@@ -106,7 +106,7 @@ class Filter(Wizard):
         cmd.set_key('F3',lambda s=self:s.defer())
         cmd.set_key('right',lambda s=self:s.forward())
         cmd.set_key('left',lambda s=self:s.backward())
-        
+
     def do_select(self,name):
         try:
             obj_name = cmd.index('first ?' + name)[0][0]
@@ -128,39 +128,39 @@ class Filter(Wizard):
     def update_object_menu(self):
 
         # find objects with > 1 state
-        
+
         self.avail_objects = []
-        
+
         for a in cmd.get_names('objects'):
             if cmd.get_type(a)=='object:molecule':
                 if cmd.count_states(a)>1:
                     self.avail_objects.append(a)
 
         # now create the object menu
-        
-        self.menu['object'] = [[2,'Select Object','']] 
+
+        self.menu['object'] = [[2,'Select Object','']]
         for a in self.avail_objects:
             self.menu['object'].append([ 1,a,'cmd.get_wizard().set_object("%s")'%(a) ])
         self.menu['object'].append([ 1,'None','cmd.get_wizard().set_object(None)'])
-        
+
     def set_browse(self,browse):
         # allow user to focus on only a subset of the compounds
         self.browse = browse
         if self.browse == 1:
             print(" Filter: Browsing all compounds.")
             cmd.mset() # all states visible
-        elif self.object==None:
+        elif self.object is None:
             print(" Filter-Error: please choose an object first")
-        else: 
+        else:
             self.check_object_dict()
             if self.browse == 2:
                 print(" Filter: Browsing accepted compounds.")
                 target = accept_str
             elif self.browse == 3:
-                print(" Filter: Browsing rejected compounds.")            
+                print(" Filter: Browsing rejected compounds.")
                 target = reject_str
             elif self.browse == 4:
-                print(" Filter: Browsing deferred compounds.")                        
+                print(" Filter: Browsing deferred compounds.")
                 target = defer_str
             lst = []
             sd = self.state_dict
@@ -183,12 +183,12 @@ class Filter(Wizard):
 
     def check_object_dict(self):
         # make sure we have a valid entry for this object in our dictionary
-        
+
         if self.object not in self.dict:
             self.dict[self.object]={} # create dictionary to store results
 
     def adjust(self,decision,inc):
-        # utility routine to increment/decrement counters 
+        # utility routine to increment/decrement counters
         if decision == accept_str:
             self.acce = self.acce + inc
         elif decision == reject_str:
@@ -202,7 +202,7 @@ class Filter(Wizard):
         self.state_dict = {}
         sd = self.state_dict
         so = self.object
-        if so!=None:
+        if so is not None:
             cnt = cmd.count_states(so)
             for a in range(1,cnt+1):
                 sd[self.get_ident(so,a)] = a
@@ -210,7 +210,7 @@ class Filter(Wizard):
     def count_object(self):
         # record how many molecular are in an object, etc.
         self.check_object_dict()
-        if self.object!=None:
+        if self.object is not None:
             self.acce = 0
             self.reje = 0
             self.defe = 0
@@ -221,23 +221,23 @@ class Filter(Wizard):
             for a in list(sdo.keys()):
                 dec = sdo[a]
                 self.adjust(dec,1)
-        
+
     def set_object(self,obj_name):
         self.object = obj_name
         self.count_object()
         self.load_state_dict()
         cmd.refresh_wizard()
-        
+
     def get_panel(self):
 
         # returns Wizard panel for PyMOL to display
-        
+
         # 1 = title/text
         # 2 = button
         # 3 = pop-up menu
-        
+
         self.update_object_menu()
-        if self.object != None:
+        if self.object is not None:
             save_str = 'Save %s.txt'%self.object
         else:
             save_str = ""
@@ -248,11 +248,11 @@ class Filter(Wizard):
             [ 2, 'Accept (F1)','cmd.get_wizard().accept()'],
             [ 2, 'Reject (F2)','cmd.get_wizard().reject()'],
             [ 2, 'Defer (F3)','cmd.get_wizard().defer()'],
-            [ 2, 'Forward (->)','cmd.get_wizard().forward()'],                  
+            [ 2, 'Forward (->)','cmd.get_wizard().forward()'],
             [ 2, 'Back (<-)','cmd.get_wizard().backward()'],
             [ 3, 'Create Filtered Object', 'create'],
             [ 2, save_str,'cmd.get_wizard().save()'],
-            [ 2, 'Refresh','cmd.refresh_wizard()'],                  
+            [ 2, 'Refresh','cmd.refresh_wizard()'],
             [ 2, 'Done','cmd.set_wizard()'],
             ]
 
@@ -263,9 +263,9 @@ class Filter(Wizard):
     def get_prompt(self):
 
         # returns text prompt
-        
+
         self.prompt = None
-        if self.object == None:
+        if self.object is None:
             self.prompt = [ 'Please select a multi-state object...' ]
         else:
             self.prompt = [ '%s: %d accepted, %d rejected, %d deferred, %d remaining'%(
@@ -281,7 +281,7 @@ class Filter(Wizard):
 
     def count(self,entry,str):
         # keep track of how many compounds are in which category
-        
+
         self.check_object_dict()
         sdo = self.dict[self.object]
         if entry in sdo:
@@ -289,23 +289,23 @@ class Filter(Wizard):
         else:
             self.togo = self.togo - 1
         sdo[entry] = str
-        self.adjust(sdo[entry],1)      
-            
+        self.adjust(sdo[entry],1)
+
     def accept(self):
         # accept compound and advance
-        if self.object==None:
+        if self.object is None:
             print(" Filter-Error: Please choose an object first")
         else:
             state = cmd.get_object_state(self.object)
             ident = self.get_ident(self.object,state)
             print(" Filter: Accepting '%s'"%ident)
             self.count(ident,accept_str)
-        cmd.forward()         
+        cmd.forward()
         cmd.refresh_wizard()
-        
+
     def reject(self):
         # reject compound and advance
-        if self.object==None:
+        if self.object is None:
             print(" Filter-Error: Please choose an object first")
         else:
             state = cmd.get_object_state(self.object)
@@ -313,12 +313,12 @@ class Filter(Wizard):
             print(" Filter: Rejecting '%s'"%ident)
             self.check_object_dict()
             self.count(ident,reject_str)
-        cmd.forward()         
+        cmd.forward()
         cmd.refresh_wizard()
-        
+
     def defer(self):
         # defer compound and advance
-        if self.object==None:
+        if self.object is None:
             print(" Filter-Error: Please choose an object first")
         else:
             state = cmd.get_object_state(self.object)
@@ -333,12 +333,12 @@ class Filter(Wizard):
         # go forward and update information
         cmd.forward()
         cmd.refresh_wizard()
-        
+
     def backward(self):
-        # go backward and update information      
+        # go backward and update information
         cmd.backward()
         cmd.refresh_wizard()
-        
+
     def create_object(self, what='Accept'):
         if not self.object:
             print(" Filter-Error: Please choose an object first")
@@ -351,10 +351,10 @@ class Filter(Wizard):
 
     def save(self):
         # write compounds to a file
-        if self.object==None:
+        if self.object is None:
             print(" Filter-Error: please choose an object first")
         else:
-            self.check_object_dict()         
+            self.check_object_dict()
             fname = self.object+".txt"
             try:
                 f=open(fname,'w')
@@ -374,7 +374,7 @@ class Filter(Wizard):
                     self.reje,
                     self.defe,
                     self.togo))
-                # sort output in order of states            
+                # sort output in order of states
                 lst = []
                 for a in sd.keys():
                     lst.append((sd[a],a))
@@ -390,7 +390,7 @@ class Filter(Wizard):
             except:
                 traceback.print_exc()
                 print(" Filter-Error: Unable to write '%s'."%fname)
-                
+
     def cleanup(self):
         # save current state in global vars...
         global default_object,default_browse,static_dict
@@ -403,6 +403,3 @@ class Filter(Wizard):
         cmd.set_key('F3',None)
         cmd.set_key('right',cmd.forward)
         cmd.set_key('left',cmd.backward)
-
-
-            
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/__init__.py pymol-open-source-2.3.3/modules/pymol/wizard/__init__.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/__init__.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/__init__.py	2019-08-22 10:24:47.862619142 +0200
@@ -6,14 +6,14 @@ class Wizard:
     event_mask_pick    = 1
     event_mask_select  = 2
     event_mask_key     = 4
-    event_mask_special = 8 
+    event_mask_special = 8
     event_mask_scene   = 16 # scene changed
     event_mask_state   = 32 # state changed
     event_mask_frame   = 64 # frame changed
     event_mask_dirty   = 128 # anything changed (BEWARE FEEDBACK!)
     event_mask_view    = 256 # view (matrix) changed
     event_mask_position = 512 # center of the view changed
-    
+
     def migrate_session(self, version):
         '''A derived class might convert the pickled state from
         an older version here.'''
@@ -24,8 +24,8 @@ class Wizard:
         self.prompt = None
         self.panel = None
         self.cmd = _self
-        self._validate_instance() 
-        
+        self._validate_instance()
+
     def __getstate__(self):
         d = self.__dict__.copy()
         d.pop('cmd', None)
@@ -45,7 +45,7 @@ class Wizard:
         # create a dictionary for per-class storage in session
         if not self.session:
             wizard_storage[class_key] = self.session
-        
+
     def get_prompt(self):
         return self.prompt
 
@@ -72,7 +72,7 @@ class Wizard:
 
     def do_dirty(self):
         return None
-    
+
     def do_pick(self,bondFlag):
         return None
 
@@ -93,4 +93,3 @@ class Wizard:
         if tag in self.menu:
             result = self.menu[tag]
         return result
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/label.py pymol-open-source-2.3.3/modules/pymol/wizard/label.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/label.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/label.py	2019-08-22 10:24:47.866619793 +0200
@@ -48,13 +48,13 @@ class Label(Wizard):
     def set_mode(self, i):
         self.mode = i
         self.cmd.refresh_wizard()
-        
+
     def get_prompt(self):
         self.prompt = []
         if (not self.messages):
             return None
 
-        if (self.atom == None):
+        if (self.atom is None):
             self.prompt = ['Click atoms...']
         else:
             self.prompt = [
@@ -99,4 +99,3 @@ class Label(Wizard):
         self.cmd.label('first ?' + sele, label)
         self.cmd.deselect()
         self.cmd.refresh_wizard()
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/measurement.py pymol-open-source-2.3.3/modules/pymol/wizard/measurement.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/measurement.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/measurement.py	2019-08-22 10:24:47.870620445 +0200
@@ -70,10 +70,10 @@ class Measurement(Wizard):
 
         # mode selection subsystem
         self.mode = self.session.get('default_mode','pairs')
-        
+
         self.neighbor_target = ""
 
-        # TODO: 
+        # TODO:
         # make this a function, and call it when we call refresh wizard
         # to update the object/selection list
         smm = []
@@ -117,7 +117,7 @@ class Measurement(Wizard):
         for b in list:
             result.append( [ 1, b,  'cmd.get_wizard().set_neighbor_target("%s","%s")' % (a,b)])
         return result
-        
+
     def neighbor_selections(self,a):
         """
         get list of public selections for populating the menu
@@ -141,8 +141,8 @@ class Measurement(Wizard):
     def _validate_instance(self):
         Wizard._validate_instance(self)
         if not hasattr(self,'meas_count'):
-            self.meas_count = self.session.get('meas_count',0)            
-            
+            self.meas_count = self.session.get('meas_count',0)
+
     def get_name(self,untaken=1,increment=1):
         """
         get a name for the next measurement object
@@ -159,7 +159,7 @@ class Measurement(Wizard):
                 self.meas_count = self.meas_count + 1
                 obj_name = obj_prefix+"%02d"%self.meas_count
         return obj_name
-    
+
 # generic set routines
 
     def set_neighbor_target(self,mode,target):
@@ -171,7 +171,7 @@ class Measurement(Wizard):
         self.status = 0
         self.clear_input()
         self.cmd.refresh_wizard()
-        
+
     def set_mode(self,mode):
         """
         sets what we're measuring, distance, angle, dihedral, etc.
@@ -193,7 +193,7 @@ class Measurement(Wizard):
         self.status = 0
         self.cmd.refresh_wizard()
 
-        
+
     def get_panel(self):
         return [
             [ 1, 'Measurement',''],
@@ -212,12 +212,12 @@ class Measurement(Wizard):
         self.session['default_object_mode'] = self.object_mode
         self.clear_input()
         self.cmd.set("mouse_selection_mode",self.selection_mode) # restore selection mode
-        
+
     def clear_input(self):
         """
         delete our user selections for this wizard
         """
-        self.cmd.delete(sele_prefix+"*") 
+        self.cmd.delete(sele_prefix+"*")
         self.cmd.delete(indi_sele)
         self.cmd.delete("pk1")
         self.status = 0
@@ -240,7 +240,7 @@ class Measurement(Wizard):
             return ("molecule", " bm. ")
         elif self.cmd.get("mouse_selection_mode", quiet=1)=="6":
             return ("C-alpha", " bca. ")
-        
+
     def get_prompt(self):
         (what, code) = self.get_selection_name()
         self.prompt = None
@@ -261,10 +261,10 @@ class Measurement(Wizard):
             else:
                 letterN = ""
             self.prompt = [ 'Please click a%s %s...' % (letterN, what)]
-        if self.error!=None:
+        if self.error is not None:
             self.prompt.append(self.error)
         return self.prompt
-    
+
     def delete_last(self):
         """
         Corresponds to the "Delete Last Object" menu button
@@ -302,14 +302,14 @@ class Measurement(Wizard):
             self.do_pick(0)
         except pymol.CmdException:
             if self.status:
-                sele_name = sele_prefix + str(self.status-1)         
+                sele_name = sele_prefix + str(self.status-1)
                 self.cmd.select(indi_sele, sele_name)
                 self.cmd.enable(indi_sele)
 
     def do_pick(self,bondFlag):
         # update pk1 based on current mouse mode
         (what,code) = self.get_selection_name()
-        self.cmd.select( "(pk1)", code + "(pk1)")
+        self.cmd.select("pk1", code + "(pk1)")
         if bondFlag:
             self.error = "Error: please select an atom, not a bond."
             print(self.error)
@@ -461,7 +461,7 @@ class Measurement(Wizard):
                     cutoffType = self.heavy_neighbor_cutoff
                     cnt = self.cmd.select(sele_prefix,
 "(v. and (pk1 a; %f) and (not h.) and (not (nbr. pk1)) and (not (nbr. (nbr. pk1))) and (not (nbr. (nbr. (nbr. pk1)))) and (%s))"
-                    %(self.heavy_neighbor_cutoff, sel_mod))            
+                    %(self.heavy_neighbor_cutoff, sel_mod))
                 if cnt:
                     self.cmd.dist(obj_name,"(pk1)",sele_prefix,cutoff=cutoffType,reset=reset)
                 else:
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/message.py pymol-open-source-2.3.3/modules/pymol/wizard/message.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/message.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/message.py	2019-08-22 10:24:47.870620445 +0200
@@ -12,7 +12,7 @@ class Message(Wizard):
 
     def __init__(self,*arg,**kw):
         _self = kw.get('_self',cmd)
-        Wizard.__init__(self,_self)        
+        Wizard.__init__(self,_self)
         self.message = []
         for a in arg:
             if not isinstance(a,list):
@@ -37,8 +37,3 @@ class Message(Wizard):
                 ]
         else:
             return []
-
-
-
-
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/mutagenesis.py pymol-open-source-2.3.3/modules/pymol/wizard/mutagenesis.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/mutagenesis.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/mutagenesis.py	2019-08-22 10:24:47.870620445 +0200
@@ -41,16 +41,16 @@ class Mutagenesis(Wizard):
 
     count = 0
     cutoff = 3.5
-    
+
     def __init__(self,_self=cmd):
         Wizard.__init__(self,_self)
         cmd=self.cmd
 
         if self.cmd.get_movie_length() > 0:
             raise pymol.wizarding.WizardError('Mutagenesis Wizard cannot be used with Movie')
-        
+
         cmd.unpick()
-        
+
         self.stored = pymol.Scratch_Storage()
         self.space = {'stored': self.stored}
 
@@ -90,7 +90,7 @@ class Mutagenesis(Wizard):
         self.mode_label['current']="No Mutant"
 
         self.selection_mode = cmd.get_setting_int("mouse_selection_mode")
-        cmd.set("mouse_selection_mode",1) 
+        cmd.set("mouse_selection_mode",1)
 
         smm = []
         smm.append([ 2, 'Mutant', '' ])
@@ -132,8 +132,8 @@ class Mutagenesis(Wizard):
                         lst[start:stop] = [ [1, self.mode_label[a] + "... " , slice2 ] ]
                     else:
                         slice2 = [ slice[3] ] + [ [0,'',''] ] + slice[0:3]
-                        lst[start:stop] = [ [1, self.mode_label['HIS']+ "... ", slice2 ] ]                        
-                
+                        lst[start:stop] = [ [1, self.mode_label['HIS']+ "... ", slice2 ] ]
+
         self.menu['mode']=smm
 
 
@@ -178,25 +178,25 @@ class Mutagenesis(Wizard):
            'nmet' : 'N-methyl',
             }
         self.c_caps = [ 'none', 'nega', 'amin', 'nmet' ]
-                        
+
         smm = []
         smm.append([ 2, 'N-Cap', '' ])
         for a in self.n_caps:
             smm.append([ 1, self.n_cap_name[a], 'cmd.get_wizard().set_n_cap("'+a+'")'])
         self.menu['n_cap']=smm
-        
+
         smm = []
         smm.append([ 2, 'C-Cap', '' ])
         for a in self.c_caps:
             smm.append([ 1, self.c_cap_name[a], 'cmd.get_wizard().set_c_cap("'+a+'")'])
         self.menu['c_cap']=smm
-        
+
         smm = []
         smm.append([ 2, 'Hydrogens', '' ])
         for a in self.hyds:
             smm.append([ 1, self.hyd_name[a], 'cmd.get_wizard().set_hyd("'+a+'")'])
         self.menu['hyd']=smm
-        
+
         smm = []
         smm.append([ 2, 'Representation', '' ])
         for a in self.reps:
@@ -224,7 +224,7 @@ class Mutagenesis(Wizard):
             if not hasattr(self,'dep_library'):
                 self.dep_library = io.pkl.fromFile(os.environ['PYMOL_DATA']+
                                            "/chempy/sidechains/sc_bb_dep.pkl")
-            
+
     def set_mode(self,mode):
         cmd=self.cmd
         if mode in self.modes:
@@ -232,13 +232,13 @@ class Mutagenesis(Wizard):
         if self.status==1:
             self.do_library()
         cmd.refresh_wizard()
-        
+
     def set_rep(self,rep):
         cmd=self.cmd
         if rep in self.reps:
             self.rep=rep
         cmd.hide("("+obj_name+")")
-        cmd.show('lines',obj_name) # always show lines      
+        cmd.show('lines',obj_name) # always show lines
         cmd.show(self.rep,obj_name)
         cmd.refresh_wizard()
 
@@ -274,7 +274,7 @@ class Mutagenesis(Wizard):
             if src_sele in cmd.get_names("all"):
                 self.do_library()
             cmd.refresh_wizard()
-        
+
     def get_panel(self):
         cmd=self.cmd
         if int(cmd.get("mouse_selection_mode")!=1):
@@ -291,7 +291,7 @@ class Mutagenesis(Wizard):
             [ 3, self.hyd_name[self.hyd],'hyd'],
             [ 3, self.rep_name[self.rep],'rep'],
             [ 3, self.dep_name[self.dep],'dep'],
-            [ 2, 'Apply' , 'cmd.get_wizard().apply()'],         
+            [ 2, 'Apply' , 'cmd.get_wizard().apply()'],
             [ 2, 'Clear' , 'cmd.get_wizard().clear()'],
             [ 2, 'Done','cmd.set_wizard()'],
             ]
@@ -311,7 +311,7 @@ class Mutagenesis(Wizard):
         default_c_cap = self.c_cap
         cmd.set("mouse_selection_mode",self.selection_mode) # restore selection mode
         self.clear()
-        
+
     def clear(self):
         cmd=self.cmd
         self.status=0
@@ -323,7 +323,7 @@ class Mutagenesis(Wizard):
         cmd.delete(bump_name)
         cmd.delete("_seeker_hilight")
         cmd.refresh_wizard()
-        
+
     def apply(self):
         cmd=self.cmd
         if self.status==1:
@@ -364,7 +364,7 @@ class Mutagenesis(Wizard):
 
                     # fix N-H hydrogen position (if any exists)
                     cmd.h_fix('?%s & name N' % (tmp_sele2))
-                    
+
                     # delete temporary objects/selections
                     cmd.delete(tmp_sele1)
                     cmd.delete(tmp_sele2)
@@ -372,7 +372,7 @@ class Mutagenesis(Wizard):
                     self.clear()
                     # and return to frame 1
                     cmd.frame(1)
-                    cmd.refresh_wizard()               
+                    cmd.refresh_wizard()
                 else:
                     # create copy with conformation in correct state
                     cmd.create(tmp_obj2,obj_name,src_frame,1)
@@ -381,7 +381,7 @@ class Mutagenesis(Wizard):
                     cmd.remove("byres (name N and (%s in (neighbor %s)) and resn NME+NHH)"%
                                 (new_name,src_sele))
                     cmd.remove("(%s) and name OXT"%src_sele)
-                    
+
                     # remove existing n-cap in copy (if any)
                     cmd.remove("byres (name C and (%s in (neighbor %s)) and resn ACE)"%
                                 (new_name,src_sele))
@@ -396,9 +396,9 @@ class Mutagenesis(Wizard):
                     self.clear()
                     # and return to frame 1
                     cmd.frame(1)
-                    cmd.refresh_wizard()                              
+                    cmd.refresh_wizard()
                 cmd.set('auto_zoom',auto_zoom,quiet=1)
-                    
+
     def get_prompt(self):
         self.prompt = None
         if self.status==0:
@@ -407,7 +407,7 @@ class Mutagenesis(Wizard):
             self.prompt = [ 'Select a rotamer for %s or pick a new residue...'%self.res_text ]
         return self.prompt
 
-    
+
     def do_library(self):
         cmd=self.cmd
         pymol=cmd._pymol
@@ -427,7 +427,7 @@ class Mutagenesis(Wizard):
         cmd.iterate("first (%s)"%src_sele,'stored.name=model+"/"+segi+"/"+chain+"/"+resn+"`"+resi')
         self.res_text = pymol.stored.name
         cmd.select("_seeker_hilight",src_sele)
-        
+
         auto_zoom = cmd.get_setting_text('auto_zoom')
         cmd.set('auto_zoom',"0",quiet=1)
         cmd.frame(0)
@@ -446,7 +446,7 @@ class Mutagenesis(Wizard):
                 cmd.create(frag_name,src_sele,1,1)
                 if self.c_cap=='open':
                     cmd.remove("%s and name OXT"%frag_name)
-                    
+
         if self.lib_mode!='current':
             rot_type = self.lib_mode
             frag_type = self.lib_mode
@@ -511,7 +511,7 @@ class Mutagenesis(Wizard):
                                  "(%s & name OXT)"%frag_name,180.0+angle)
                 cmd.deprotect(frag_name)
 
-                
+
             # fix the hydrogen position (if any)
             if cmd.count_atoms("(hydro and bound_to (name N & (%s)))"%frag_name)==1:
                 if cmd.count_atoms("(hydro and bound_to (name N & (%s)))"%src_sele)==1:
@@ -548,7 +548,7 @@ class Mutagenesis(Wizard):
                         elif (self.hyd == 'auto'):
                             if cmd.count_atoms("("+src_sele+") and hydro")==0:
                                 cmd.remove("("+frag_name+" and hydro)")
-                         
+
             # add n-cap (if appropriate)
             if self.n_cap in [ 'acet' ]:
                 if not cmd.count_atoms("elem C & !(%s) & (bto. (name N & (%s))) & !resn ACE "%
@@ -564,13 +564,13 @@ class Mutagenesis(Wizard):
                         elif (self.hyd == 'auto'):
                             if cmd.count_atoms("("+src_sele+") and hydro")==0:
                                 cmd.remove("("+frag_name+" and hydro)")
- 
 
-                    
+
+
 
         cartoon = (cmd.count_atoms("(%s & name CA & rep cartoon)"%src_sele)>0)
         sticks = (cmd.count_atoms("(%s & name CA & rep sticks)"%src_sele)>0)
-            
+
         cmd.delete(obj_name)
         key = rot_type
         lib = None
@@ -583,24 +583,24 @@ class Mutagenesis(Wizard):
                     key = (rot_type,phi,psi)
                     if key not in self.dep_library:
                         (phi,psi) = (int(20*round(phi/20)),int(20*(round(psi/20))))
-                        key = (rot_type,phi,psi)                    
+                        key = (rot_type,phi,psi)
                         if key not in self.dep_library:
                             (phi,psi) = (int(60*round(phi/60)),int(60*(round(psi/60))))
                             key = (rot_type,phi,psi)
                     lib = self.dep_library.get(key,None)
             except:
                 pass
-        if lib == None:
+        if lib is None:
             key = rot_type
             lib = self.ind_library.get(key,None)
-            if (lib!= None) and self.dep == 'dep':
+            if (lib is not None) and self.dep == 'dep':
                 print(' Mutagenesis: no phi/psi, using backbone-independent rotamers.')
-        if lib != None:
+        if lib is not None:
             state = 1
             for a in lib:
                 cmd.create(obj_name,frag_name,1,state)
                 if state == 1:
-                    cmd.select(mut_sele,"(byres (%s like %s))"%(obj_name,src_sele)) 
+                    cmd.select(mut_sele,"(byres (%s like %s))"%(obj_name,src_sele))
                 if rot_type=='PRO':
                     cmd.unbond("(%s & name N)"%mut_sele,"(%s & name CD)"%mut_sele)
                 for b in a.keys():
@@ -613,7 +613,7 @@ class Mutagenesis(Wizard):
                     else:
                         cmd.set_title(obj_name,state,"%1.1f%%"%(a[b]*100))
                 if rot_type=='PRO':
-                    cmd.bond("(%s & name N)"%mut_sele,"(%s & name CD)"%mut_sele)                
+                    cmd.bond("(%s & name N)"%mut_sele,"(%s & name CD)"%mut_sele)
                 state = state + 1
             cmd.delete(frag_name)
             print(" Mutagenesis: %d rotamers loaded."%len(lib))
@@ -637,7 +637,7 @@ class Mutagenesis(Wizard):
                     cmd.bond(tmp_sele1,tmp_sele2)
                 cmd.delete(tmp_sele1)
                 cmd.delete(tmp_sele2)
-                
+
                 cmd.protect("%s and not (%s in (%s and not name N+C+CA+O+H+HA))"%
                             (bump_name,bump_name,mut_sele))
                 cmd.sculpt_activate(bump_name)
@@ -682,7 +682,7 @@ class Mutagenesis(Wizard):
             state = cmd.get_state()
             print(' Rotamer %d/%d, strain=%.2f' % (state,
                     cmd.count_states(obj_name), self.bump_scores[state - 1]))
-                
+
     def do_select(self,selection):
         print("Selected!")
         cmd=self.cmd
@@ -702,7 +702,7 @@ class Mutagenesis(Wizard):
         cmd.refresh_wizard()
         cmd.deselect()
         return 1
-    
+
     def do_pick(self,bondFlag):
         print("Picked!")
         cmd=self.cmd
@@ -719,6 +719,3 @@ class Mutagenesis(Wizard):
             self.error = None
             self.do_library()
         cmd.refresh_wizard()
-
-
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/pair_fit.py pymol-open-source-2.3.3/modules/pymol/wizard/pair_fit.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/pair_fit.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/pair_fit.py	2019-08-22 10:24:47.870620445 +0200
@@ -18,7 +18,7 @@ class Pair_fit(Wizard):
     def __init__(self,_self=cmd):
 
         Wizard.__init__(self,_self)
-        
+
         self.memory = 0
         self.n_pair = 0
         self.status = 0 # 0 no atoms selections, 1 atom selected
@@ -27,42 +27,42 @@ class Pair_fit(Wizard):
         self.selection_mode = cmd.get_setting_int("mouse_selection_mode")
         cmd.set("mouse_selection_mode",0) # set selection mode to atomic
         cmd.deselect() # disable the active selection (if any)
-        
+
     def get_panel(self):
         return [
             [ 1, 'Pair Fitting',''],
             [ 2, 'Fit %d Pairs'%self.n_pair,'cmd.get_wizard().fit()'],
             [ 2, 'Delete Last Pair','cmd.get_wizard().remove_last()'],
-            [ 2, 'Redraw','cmd.get_wizard().update_dashes()'],         
+            [ 2, 'Redraw','cmd.get_wizard().update_dashes()'],
             [ 2, 'Clear','cmd.get_wizard().clear()'],
             [ 2, 'Done','cmd.set_wizard()'],
             ]
 
     def cleanup(self):
         self.clear()
-        cmd.set("mouse_selection_mode",self.selection_mode) # restore selection mode        
-        
+        cmd.set("mouse_selection_mode",self.selection_mode) # restore selection mode
+
     def clear(self):
         cmd.delete(sele_prefix+"*")
         cmd.delete(dist_prefix+"*")
-        cmd.delete(indi_sele)        
+        cmd.delete(indi_sele)
         lst = cmd.get_names('selections')
         self.n_pair = 0
         self.status = 0
         self.message = None
         cmd.unpick()
         cmd.refresh_wizard()
-        
+
     def get_prompt(self):
         self.prompt = None
         if self.status==0:
             self.prompt = [ 'Pick the mobile atom...']
         elif self.status==1:
             self.prompt = [ 'Pick the target atom...' ]
-        if self.message!=None:
+        if self.message is not None:
             self.prompt.append(self.message)
         return self.prompt
-    
+
     def set_status(self,status):
         self.status = status
         cmd.refresh_wizard()
@@ -72,11 +72,11 @@ class Pair_fit(Wizard):
         lst = [x for x in lst if x[0:sele_prefix_len]==sele_prefix]
         lst.sort()
         if mode == 'mobile': # mobile
-            lst=[x for x in lst if x[-1:]=='b'] 
+            lst=[x for x in lst if x[-1:]=='b']
         elif mode == 'target': # target
             lst=[x for x in lst if x[-1:]=='a']
         return lst
-    
+
     def fit(self):
         # build up the pair-wise list of selections
         cmd.delete(dist_prefix+"*")
@@ -97,7 +97,7 @@ class Pair_fit(Wizard):
             self.message = "RMS over %d pairs = %5.3f"%(self.n_pair,dist)
             cmd.refresh_wizard()
         self.update_dashes()
-                                    
+
     def remove_last(self):
         # build up the pair-wise list of selections
         cmd.delete(dist_prefix+"*")
@@ -105,12 +105,12 @@ class Pair_fit(Wizard):
         if len(lst):
             cmd.delete(lst.pop())
             if len(lst):
-                cmd.delete(lst.pop())         
+                cmd.delete(lst.pop())
             self.n_pair = self.n_pair - 1
         self.update_dashes()
         self.status=0
         cmd.refresh_wizard()
-        
+
     def update_dashes(self):
         cmd.delete(dist_prefix+"*")
         lst = self.get_sele_list()
@@ -189,5 +189,5 @@ class Pair_fit(Wizard):
                         self.n_pair = self.n_pair + 1
                         self.status = 0
                         self.update_dashes()
-                
+
         cmd.refresh_wizard()
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/pseudoatom.py pymol-open-source-2.3.3/modules/pymol/wizard/pseudoatom.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/pseudoatom.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/pseudoatom.py	2019-08-22 10:24:47.870620445 +0200
@@ -3,7 +3,6 @@ from pymol.wizard import Wizard
 from pymol import cmd
 import pymol
 import types
-import string
 
 class Pseudoatom(Wizard):
 
@@ -14,7 +13,7 @@ class Pseudoatom(Wizard):
             self.prefix = 'Label text: \888'
         self.text = ''
         self.pos = pos
-        
+
     def get_event_mask(self):
         return Wizard.event_mask_key
 
@@ -28,14 +27,14 @@ class Pseudoatom(Wizard):
         elif k>32:
             self.text = self.text + chr(k)
         elif k==10 or k==13:
-            self.text = string.strip(self.text)
+            self.text = self.text.strip()
             if self.mode=='label':
-                obj_name = self.cmd.get_unused_name(string.lower(self.text[0:14]),0)
+                obj_name = self.cmd.get_unused_name(self.text[0:14].lower(),0)
                 self.cmd.pseudoatom(obj_name,pos=self.pos,label=self.text)
             self.cmd.set_wizard()
         self.cmd.refresh_wizard()
         return 1
-        
+
     def get_prompt(self):
         self.prompt = [ self.prefix + self.text + "_" ]
         return self.prompt
@@ -44,5 +43,3 @@ class Pseudoatom(Wizard):
         return [
             [ 2, 'Cancel', 'cmd.set_wizard()' ]
             ]
-
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/renaming.py pymol-open-source-2.3.3/modules/pymol/wizard/renaming.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/renaming.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/renaming.py	2019-08-22 10:24:47.870620445 +0200
@@ -3,18 +3,17 @@ from pymol.wizard import Wizard
 from pymol import cmd
 import pymol
 import types
-import string
 
 class Renaming(Wizard):
 
     def __init__(self,old_name,mode='object',_self=cmd):
         Wizard.__init__(self,_self)
-        
+
         self.prefix = 'Renaming \\999%s\\--- to: \\999'%old_name
         self.old_name = old_name
         self.new_name = old_name
         self.mode = mode
-        
+
     def get_event_mask(self):
         return Wizard.event_mask_key
 
@@ -28,17 +27,17 @@ class Renaming(Wizard):
         elif k>32:
             self.new_name= self.new_name + chr(k)
         elif k==10 or k==13:
-            self.new_name = string.strip(self.new_name)
+            self.new_name = self.new_name.strip()
             if self.mode=='object':
                 cmd.do("set_name %s,%s"%
                        (self.old_name,self.new_name),log=0)
             elif self.mode=='scene':
                 cmd.do("scene %s,rename,new_key=%s"%
-                       (self.old_name,self.new_name),log=0)                
+                       (self.old_name,self.new_name),log=0)
             cmd.set_wizard()
         cmd.refresh_wizard()
         return 1
-        
+
     def get_prompt(self):
         self.prompt = [ self.prefix + self.new_name + "_" ]
         return self.prompt
@@ -48,5 +47,3 @@ class Renaming(Wizard):
             [ 1, 'Renaming', '' ],
             [ 2, 'Cancel', 'cmd.set_wizard()' ]
             ]
-
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/sculpting.py pymol-open-source-2.3.3/modules/pymol/wizard/sculpting.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/sculpting.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/sculpting.py	2019-08-22 10:24:47.870620445 +0200
@@ -25,11 +25,11 @@ NO_SELECTIONS = 0
 class Sculpting(Wizard):
 
     cutoff = 3.5
-    
+
     def __init__(self,_self=cmd):
 
         Wizard.__init__(self,_self)
-        
+
         self.status = NO_SELECTIONS
         self.error = None
         self.object_name = None
@@ -62,11 +62,11 @@ class Sculpting(Wizard):
         self.cmd.unmask("all")
 
         # mode selection subsystem
-        
+
         self.mode = default_mode
         self.modes = [
             'ligand_rx',
-#         'ligand_re',         
+#         'ligand_re',
 #         'by_atom',
             'by_resi',
             ]
@@ -75,9 +75,9 @@ class Sculpting(Wizard):
             'by_atom':'Atom Shells',
             'by_resi':'Residue Shells',
             'ligand_rx' :'One Residue',
-            'ligand_re' :'Residue v. Free',                  
+            'ligand_re' :'Residue v. Free',
             'ligand_cx' :'Chain v. Fixed',
-            'ligand_ce' :'Chain v. Free',                  
+            'ligand_ce' :'Chain v. Free',
             }
 
         smm = []
@@ -95,7 +95,7 @@ class Sculpting(Wizard):
                                       [1, '15.0 A Radius','cmd.get_wizard().set_radius(15)'],
                                       [1, '20.0 A Radius','cmd.get_wizard().set_radius(20)'],
                                       ]
-                                        
+
         self.menu['cushion'] = [[ 2, 'Fixed Atom Cushion', '' ],
             [1, '2.0 A Cushion','cmd.get_wizard().set_cushion(2)'],
             [1, '3.0 A Cushion','cmd.get_wizard().set_cushion(3)'],
@@ -103,7 +103,7 @@ class Sculpting(Wizard):
             [1, '6.0 A Cushion','cmd.get_wizard().set_cushion(6)'],
             [1, '8.0 A Cushion','cmd.get_wizard().set_cushion(8)'],
             [1, '10.0 A Cushion','cmd.get_wizard().set_cushion(10)'],
-            [1, '12.0 A Cushion','cmd.get_wizard().set_cushion(12)'],                              
+            [1, '12.0 A Cushion','cmd.get_wizard().set_cushion(12)'],
             ]
 
 # generic set routines
@@ -117,12 +117,12 @@ class Sculpting(Wizard):
         self.radius=radius
         self.update_selections()
         self.cmd.refresh_wizard()
-        
+
     def set_cushion(self,cushion):
         self.cushion=cushion
         self.update_selections()
         self.cmd.refresh_wizard()
-        
+
     def update_selections(self):
         if self.status == HAVE_SELECTIONS:
             if self.mode=='by_resi':
@@ -151,7 +151,7 @@ class Sculpting(Wizard):
             util.cbac(fix_sele,_self=self.cmd)
             util.cbag(free_sele,_self=self.cmd)
             self.cmd.disable('indicate')
-            self.cmd.disable(cent_sele)            
+            self.cmd.disable(cent_sele)
             self.cmd.disable(free_sele)
             self.cmd.disable(fix_sele)
             self.cmd.disable(excl_sele)
@@ -159,13 +159,13 @@ class Sculpting(Wizard):
             for obj in self.cmd.get_names(selection=cent_sele):
                 self.cmd.push_undo(obj)
                 self.cmd.sculpt_activate(obj)
-                        
+
     def set_object_mode(self,mode):
         if mode in self.object_modes:
             self.object_mode = mode
         self.status = NO_SELECTIONS
         self.cmd.refresh_wizard()
-        
+
     def get_panel(self):
         return [
             [ 1, 'Sculpting',''],
@@ -181,7 +181,7 @@ class Sculpting(Wizard):
 
     def free_all(self):
         self.clear()
-        
+
     def clear(self):
         self.cmd.unmask("all")
         self.cmd.deprotect("all")
@@ -192,32 +192,32 @@ class Sculpting(Wizard):
         self.status = NO_SELECTIONS
         self.cmd.delete(sele_pre+"*")
         self.cmd.refresh_wizard()
-        
+
     def cleanup(self):
         global default_mode, default_radius, default_cushion
         default_mode = self.mode
         default_radius = self.radius
         default_cushion = self.cushion
-        if self.restore_edit_mode != None:
+        if self.restore_edit_mode is not None:
             self.cmd.edit_mode(self.restore_edit_mode)
         self.cmd.set("sculpt_vdw_vis_mode",self.restore_sculpt_vdw_vis_mode)
         self.cmd.set("sculpting",0)
         self.clear()
-        
+
     def get_prompt(self):
         self.prompt = None
         if self.status == NO_SELECTIONS:
             self.prompt = [ 'Please pick the center atom...']
-        if self.error!=None:
+        if self.error is not None:
             self.prompt.append(self.error)
         return self.prompt
-    
+
     def do_pick(self,bondFlag):
         global dist_count
         if self.status == NO_SELECTIONS:
             if self.cmd.select(cent_sele,"pk1"):
                 self.status = HAVE_SELECTIONS
-                # save current coordinates 
+                # save current coordinates
                 for obj in self.cmd.get_names(selection=cent_sele):
                     self.cmd.push_undo(obj)
             self.update_selections()
@@ -225,4 +225,3 @@ class Sculpting(Wizard):
             return 1
         else:
             return 0
-        
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/security.py pymol-open-source-2.3.3/modules/pymol/wizard/security.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/security.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/security.py	2019-08-22 10:24:47.870620445 +0200
@@ -10,10 +10,10 @@ import pymol
 class Security(Wizard):
 
     def __init__(self,_self=cmd):
-        Wizard.__init__(self,_self)        
+        Wizard.__init__(self,_self)
         for a in self.get_prompt():
             print(a)
-            
+
     def get_prompt(self):
         self.prompt = [ '========================= PyMOL SECURITY WARNING =========================',
                              '',
@@ -45,5 +45,3 @@ class Security(Wizard):
             [ 1, '',''],
             [ 2, 'mdump','cmd.mdump()'],
             ]
-
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/stereodemo.py pymol-open-source-2.3.3/modules/pymol/wizard/stereodemo.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/stereodemo.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/stereodemo.py	2019-08-22 10:24:47.870620445 +0200
@@ -14,7 +14,7 @@ class Stereodemo(Wizard):
                 getattr(demo,self.last)(cleanup=1)
         if hasattr(demo,name):
             cmd.delete("all")
-            if pretty_name != None:
+            if pretty_name is not None:
                 cmd.do("_ wizard message, Please wait while the %s example loads..., dismiss=0"%pretty_name)
             self.message = demo.message_dict.get(name,None)
             cmd.refresh_wizard()
@@ -29,7 +29,7 @@ class Stereodemo(Wizard):
 
     def __init__(self,*arg,**kw):
         _self=kw.get('_self',cmd)
-        Wizard.__init__(self,_self)        
+        Wizard.__init__(self,_self)
         self.message = []
         self.last = None
         cmd.full_screen("off")
@@ -52,14 +52,14 @@ class Stereodemo(Wizard):
         return [
             [ 1, 'Structural Biology', '' ],
             [ 2, 'X-ray Crystallography', 'cmd.get_wizard().launch("roving_density")'],
-            [ 2, 'Electron Tomography', 
+            [ 2, 'Electron Tomography',
 	      'cmd.get_wizard().launch("electomo", "Electron Tomography")'],
-            [ 1, 'Drug Discovery', '' ],	    
-            [ 2, 'Medicinal Chemistry', 
+            [ 1, 'Drug Discovery', '' ],
+            [ 2, 'Medicinal Chemistry',
 	      'cmd.get_wizard().launch("medchem","Medicinal Chemistry")'],
             [ 2, 'Computational Chemistry', 'cmd.get_wizard().launch("electro","Computational Chemistry")'],
-            [ 1, 'Presentation Graphics', '' ],	    
-            [ 2, 'Molecular Animation', 'cmd.get_wizard().launch("animate","Molecular Animation")'],         
+            [ 1, 'Presentation Graphics', '' ],
+            [ 2, 'Molecular Animation', 'cmd.get_wizard().launch("animate","Molecular Animation")'],
             [ 2, 'Multiprocessor Raytracing', 'cmd.get_wizard().launch("ray")'],
 	    [ 1, 'Bioinformatics', ''],
             [ 2, 'Structure Alignments', 'cmd.get_wizard().launch("structure","Structure Alignment")'],
@@ -68,9 +68,9 @@ class Stereodemo(Wizard):
 	    [ 1, 'Science Education', ''],
             [ 2, 'Interactive Modeling', 'cmd.get_wizard().launch("sculpt")'],
             [ 1, 'Configuration', ''],
-	    [ 2, 'Toggle Fullscreen', 
+	    [ 2, 'Toggle Fullscreen',
 	      'cmd.full_screen()'],
-	    [ 2, 'Toggle Stereo 3D', 
+	    [ 2, 'Toggle Stereo 3D',
               'cmd.stereo("off" if cmd.get_setting_int("stereo") else "on")'],
 #            [ 2, 'End Demonstration', 'cmd.get_wizard().launch("finish")' ],
 #            [ 2, 'Swap Left/Right Stereo', 'stereo swap'],
@@ -85,7 +85,7 @@ import threading
 class DemoInfo:
 
     message_dict = {
-        'roving' : [ 
+        'roving' : [
         "Middle-click-and-drag to move...",],
         'roving_density' : [
         "Middle-click-and-drag to move..."],
@@ -204,7 +204,7 @@ class DemoInfo:
                 util.cbac("rep3")
                 util.cbas("rep4")
                 util.cbab("rep5")
-                util.cbaw("rep6")            
+                util.cbaw("rep6")
                 util.cbay("rep8")
 
 
@@ -255,8 +255,8 @@ class DemoInfo:
                 cmd.mstop()
         except:
             traceback.print_exc()
-            
- 
+
+
     def roving(self,cleanup=0):
         if not cleanup:
             cmd.load("$PYMOL_DATA/demo/il2.pdb")
@@ -281,7 +281,7 @@ class DemoInfo:
             cmd.set("roving_detail",0)
             cmd.refresh()
             cmd.delete("rov_*")
-            
+
     def roving_density(self,cleanup=0):
         if not cleanup:
             try:
@@ -302,7 +302,7 @@ class DemoInfo:
                 cmd.set("roving_map1_name","map")
                 cmd.isomesh("rov_m1","map",9999.0,"il2")
                 cmd.color("density","rov_m1")
-                
+
                 cmd.set_view ((\
           0.132852688,   -0.729740858,    0.670686543,\
           -0.228543565,    0.635894477,    0.737154961,\
@@ -325,13 +325,13 @@ class DemoInfo:
             cmd.set("roving_detail",0)
             cmd.delete("rov_*")
             cmd.sync()
-            
+
     def cartoon(self,cleanup=0):
         if not cleanup:
             try:
                 cmd.set("suspend_updates",1,quiet=1)
                 cmd.disable()
-                cmd.delete("1tii")      
+                cmd.delete("1tii")
                 cmd.load("$PYMOL_DATA/demo/1tii.pdb")
                 cmd.hide("(1tii)")
                 cmd.show("cartoon","1tii")
@@ -363,7 +363,7 @@ class DemoInfo:
             cmd.delete("pept")
             cmd.delete("e_pot")
             cmd.delete("e_lvl")
-            
+
     def trans(self,cleanup=0):
         if not cleanup:
             try:
@@ -404,7 +404,7 @@ class DemoInfo:
             cmd.do("ray")
         else:
             cmd.delete("ray")
-            
+
     def finish(self,cleanup=0):
         cmd.do("_ wizard")
 
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizard/toggle.py pymol-open-source-2.3.3/modules/pymol/wizard/toggle.py
--- pymol-open-source-2.3.0/modules/pymol/wizard/toggle.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizard/toggle.py	2019-08-22 10:24:47.870620445 +0200
@@ -18,7 +18,7 @@ class Toggle(Wizard):
         for a in self.message:
             print(a)
         self.message_visible = 1
-            
+
     def toggle(self):
         self.message_visible = not self.message_visible
         cmd.refresh_wizard()
@@ -32,17 +32,14 @@ class Toggle(Wizard):
 
     def get_panel(self):
         panel = [
-            [ 2, 'Toggle Fullscreen', 
+            [ 2, 'Toggle Fullscreen',
               'cmd.full_screen()'],
-            [ 2, 'Toggle Stereo 3D', 
+            [ 2, 'Toggle Stereo 3D',
               'cmd.stereo("off" if cmd.get_setting_int("stereo") else "on")'],
-            [ 2, 'Toggle Message', 
+            [ 2, 'Toggle Message',
               'cmd.get_wizard().toggle()'],
             [ 2, 'Dismiss', 'cmd.set_wizard()' ]
             ]
         if len(self.message)==0:
             del panel[2]
         return panel
-
-
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/wizarding.py pymol-open-source-2.3.3/modules/pymol/wizarding.py
--- pymol-open-source-2.3.0/modules/pymol/wizarding.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/wizarding.py	2019-08-22 10:24:47.870620445 +0200
@@ -1,14 +1,14 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
@@ -22,7 +22,7 @@ if True:
     from .cmd import _cmd,lock,unlock,Shortcut,QuietException,_raising, \
           _feedback,fb_module,fb_mask, \
           DEFAULT_ERROR, DEFAULT_SUCCESS, _raising, is_ok, is_error
-    
+
     try:
         import cPickle
     except ImportError:
@@ -31,7 +31,7 @@ if True:
 
     class WizardError(Exception):
         pass
-    
+
     def _wizard(name,arg,kwd,replace,_self=cmd):
         r = DEFAULT_ERROR
         from . import wizard
@@ -56,11 +56,11 @@ if True:
                         _self.set_wizard(wiz,replace)
                         _self.do("_ refresh_wizard")
                 else:
-                    print("Error: Sorry, couldn't find the '"+oname+"' class.")                             
+                    print("Error: Sorry, couldn't find the '"+oname+"' class.")
             else:
-                print("Error: Sorry, couldn't import the '"+name+"' wizard.")         
+                print("Error: Sorry, couldn't import the '"+name+"' wizard.")
         return r
-    
+
     def wizard(name=None,*arg,**kwd):
         '''
 DESCRIPTION
@@ -83,7 +83,7 @@ EXAMPLE
     '''
         _self = kwd.get('_self',cmd)
         r = DEFAULT_ERROR
-        if name==None:
+        if name is None:
             _self.set_wizard()
             r = DEFAULT_SUCCESS
         else:
@@ -93,7 +93,7 @@ EXAMPLE
             r = _wizard(name,arg,kwd,0,_self=_self)
         if _self._raising(r,_self): raise pymol.CmdException
         return r
-        
+
     def replace_wizard(name=None,*arg,**kwd):
         '''
 DESCRIPTION
@@ -103,7 +103,7 @@ DESCRIPTION
     '''
         _self = kwd.get('_self',cmd)
         r = DEFAULT_ERROR
-        if name==None:
+        if name is None:
             _self.set_wizard()
             r = DEFAULT_SUCCESS
         else:
@@ -138,7 +138,7 @@ DESCRIPTION
     "refresh_wizard" is in unsupported internal command.
     
     '''
-        r = DEFAULT_ERROR      
+        r = DEFAULT_ERROR
         try:
             _self.lock(_self)
             r = _cmd.refresh_wizard(_self._COb)
@@ -184,7 +184,7 @@ DESCRIPTION
         return 1
 
     def session_restore_wizard(session,_self=cmd):
-        if session!=None:
+        if session is not None:
             version = session.get('version', 0)
             if 'wizard' in session:
                 from chempy.io import pkl
@@ -198,5 +198,3 @@ DESCRIPTION
                     print(e)
                     print("Session-Warning: unable to restore wizard.")
         return 1
-
-
diff -upNr pymol-open-source-2.3.0/modules/pymol/xray.py pymol-open-source-2.3.3/modules/pymol/xray.py
--- pymol-open-source-2.3.0/modules/pymol/xray.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/xray.py	2019-08-22 10:24:47.874621096 +0200
@@ -1,21 +1,21 @@
 #A* -------------------------------------------------------------------
 #B* This file contains source code for the PyMOL computer program
-#C* Copyright (c) Schrodinger, LLC. 
+#C* Copyright (c) Schrodinger, LLC.
 #D* -------------------------------------------------------------------
 #E* It is unlawful to modify or remove this copyright notice.
 #F* -------------------------------------------------------------------
-#G* Please see the accompanying LICENSE file for further information. 
+#G* Please see the accompanying LICENSE file for further information.
 #H* -------------------------------------------------------------------
 #I* Additional authors of this source file include:
-#-* 
-#-* 
+#-*
+#-*
 #-*
 #Z* -------------------------------------------------------------------
 
 from __future__ import division
 from __future__ import print_function
 
-# xray.py 
+# xray.py
 # This section contains python code for supporting
 # x-ray crystallography functions
 
@@ -33,7 +33,7 @@ def sg_register_if_unknown(sg, sym_op):
 def sg_sym_to_mat_list(sgsymbol): # TODO _self
     result = None
     sym_op = sym_dict.get(sg_canonicalize(sgsymbol))
-    if sym_op != None:
+    if sym_op is not None:
         result = []
         for op in sym_op:
             mat = []
@@ -44,7 +44,7 @@ def sg_sym_to_mat_list(sgsymbol): # TODO
     else:
         try:
             from .cmd import QuietException, \
-                 _feedback,fb_module,fb_mask 
+                 _feedback,fb_module,fb_mask
             if(_feedback(fb_module.symmetry,fb_mask.errors)):
                 print("Symmetry-Error: Unrecognized space group symbol '"+sgsymbol+"'.")
         except:
@@ -54,18 +54,18 @@ def sg_sym_to_mat_list(sgsymbol): # TODO
 hex_to_rhom_xHM = {
     #  extended Hermann Mauguin symbol translation
     #  from CCP4's syminfo.lib
-    
+
     'H 3'      : 'R 3 :H',
     'H -3'     : 'R -3 :H',
     'H 3 2'    : 'R 3 2 :H',
-    
+
     'H 3 m'    : 'R 3 m :H',
     'H 3 c'    : 'R 3 c :H',
     'H -3 2/m' : 'R -3 m :H',
     'H -3 m'   : 'R -3 m :H',
     'H -3 2/c' : 'R -3 c :H',
     'H -3 c'   : 'R -3 c :H',
-    
+
     'H 3 M'    : 'R 3 m :H',
     'H 3 C'    : 'R 3 c :H',
     'H -3 2/M' : 'R -3 m :H',
@@ -8504,15 +8504,15 @@ for key in list(sym_base.keys()):
 
 space_group_map = {
     ""       : "",
-    "P1"     : "P 1",       
-    "P111"   : "P 1 1 1",    
+    "P1"     : "P 1",
+    "P111"   : "P 1 1 1",
     "A111"   : "A 1 1 1",
     "P-1"    : "P -1",
     "P1-"    : "P 1-",
     "P2"     : "P 2",
     "P121"   : "P 1 2 1",
-    "P21"    : "P 21", 
-    "P1211"  : "P 1 21 1", 
+    "P21"    : "P 21",
+    "P1211"  : "P 1 21 1",
     "P1121"  : "P 1 1 21",
     "B2"     : "B 2",
     "B112"   : "B 1 1 2",
@@ -8546,7 +8546,7 @@ space_group_map = {
     "P4322"  : "P 43 2 2",
     "P43212" : "P 43 21 2",
     "I422"   : "I 4 2 2",
-    "I4132"  : "I 41 3 2",     
+    "I4132"  : "I 41 3 2",
     "I432"   : "I 4 3 2",
     "I4122"  : "I 41 2 2",
     "P3"     : "P 3",
@@ -8559,7 +8559,7 @@ space_group_map = {
     "P3112"  : "P 31 1 2",
     "P3121"  : "P 31 2 1",
     "P3212"  : "P 32 1 2",
-    "P3221"  : "P 32 2 1", 
+    "P3221"  : "P 32 2 1",
     "H32"    : "H 3 2",
     "R32"    : "R 3 2",
     "P6"     : "P 6",
diff -upNr pymol-open-source-2.3.0/modules/pymol/xwin.py pymol-open-source-2.3.3/modules/pymol/xwin.py
--- pymol-open-source-2.3.0/modules/pymol/xwin.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol/xwin.py	2019-08-22 10:24:47.874621096 +0200
@@ -18,6 +18,3 @@ def machine_get_clipboard():
         p.stdin.close()
         result = p.stdout.readlines()
     return result
-
-                      
-    
diff -upNr pymol-open-source-2.3.0/modules/pymol2/cmd2.py pymol-open-source-2.3.3/modules/pymol2/cmd2.py
--- pymol-open-source-2.3.0/modules/pymol2/cmd2.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol2/cmd2.py	2019-08-22 10:24:47.874621096 +0200
@@ -15,24 +15,24 @@ class Cmd:
         self._weakrefproxy = weakref.proxy(self)
 
         # store parent
-        
+
         self._pymol = weakref.proxy(_pymol)
 
         # store C object for easy access
-    
+
         self._COb = _COb
-        
+
         # private data
-    
+
         self.color_sc = None
         self.reaper = None
-        
+
         # deferred initiailization
-        
+
         global_cmd._deferred_init_pymol_internals(_pymol)
-        
+
         # PRIVATE FUNCTIONS (requiring '_self' as a keyword argument)
-        
+
         # locking.py
 
         self.reaper = None
@@ -41,14 +41,14 @@ class Cmd:
             # use own locks (for performance)
             self.lock_api = _pymol.lock_api
             self.lock_api_c = _pymol.lock_api_c
-            self.lock_api_data = _pymol.lock_api_data            
+            self.lock_api_data = _pymol.lock_api_data
             self.lock_api_glut = _pymol.lock_api_glut
             self.lock_api_status = _pymol.lock_api_status
         else:
             # use global locks (for debugging)
             self.lock_api = global_cmd._pymol.lock_api
             self.lock_api_c = global_cmd._pymol.lock_api_c
-            self.lock_api_data = global_cmd._pymol.lock_api_data            
+            self.lock_api_data = global_cmd._pymol.lock_api_data
             self.lock_api_glut = global_cmd._pymol.lock_api_glut
             self.lock_api_status = global_cmd._pymol.lock_api_status
 
@@ -70,7 +70,7 @@ class Cmd:
         self.help_sc = self.Shortcut(
             itertools.chain(self.keyword, self.help_only))
 
-        
+
         self.selection_sc = lambda sc=self.Shortcut,gn=self.get_names:sc(gn('public')+['all'])
         self.object_sc = lambda sc=self.Shortcut,gn=self.get_names:sc(gn('objects'))
         self.map_sc = lambda sc=self.Shortcut,gnot=self.get_names_of_type:sc(gnot('object:map'))
@@ -80,16 +80,16 @@ class Cmd:
         self.fb_action_sc = pymol.feedingback.fb_action_sc
         self.fb_module_sc = pymol.feedingback.fb_module_sc
         self.fb_mask_sc = pymol.feedingback.fb_mask_sc
-        
+
         self.auto_arg = pymol.completing.get_auto_arg_list(self)
         self.color_sc = None
 
         # keyboard configuration
-                
+
         from pymol import keyboard
-        
+
         self.key_mappings = keyboard.get_default_keys(self)
-        
+
 # PUBLIC API METHODS which expect "self" as the first argument
 
     def __getattr__(self, key):
diff -upNr pymol-open-source-2.3.0/modules/pymol2/__init__.py pymol-open-source-2.3.3/modules/pymol2/__init__.py
--- pymol-open-source-2.3.0/modules/pymol2/__init__.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/pymol2/__init__.py	2019-08-22 10:24:47.874621096 +0200
@@ -21,7 +21,7 @@ from pymol import _cmd
 import threading
 import sys
 
-pymol2_lock = threading.RLock() 
+pymol2_lock = threading.RLock()
 
 ##
 ## FIXME: The PyMOL and SingletonPyMOL classes are partly redundant with the
@@ -98,7 +98,7 @@ class PyMOL(SingletonPyMOL):
 
             options = self.invocation.options
 
-            if scheme!=None: #
+            if scheme is not None: #
                 if scheme == 'presentation':
                     options.quiet = 0
                     options.show_splash = 0
@@ -115,13 +115,13 @@ class PyMOL(SingletonPyMOL):
                     options.no_quit = 1
             else:
                 options.show_splash = 0 # suppress this annoyance by default
-                    
+
             self._COb = _cmd._new(self,self.invocation.options)
 
             # initialize the cmd API
 
             self.cmd = Cmd(self,self._COb)
-            
+
             # begin assembling the instance member by member
 
             self.glutThread = None
@@ -129,10 +129,10 @@ class PyMOL(SingletonPyMOL):
     def __del__(self):
         _cmd._del(self._COb)
         self.cmd.__dict__.clear()
-        
+
     def start(self):
         with pymol2_lock:
             _cmd._start(self._COb, self.cmd)
-        
+
     def stop(self):
         _cmd._stop(self._COb)
diff -upNr pymol-open-source-2.3.0/modules/sitecustomize.py pymol-open-source-2.3.3/modules/sitecustomize.py
--- pymol-open-source-2.3.0/modules/sitecustomize.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/modules/sitecustomize.py	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-# NOTE: This only works for module-based PyMOL builds.
-# Embedded versions of PyMOL call PyUnicode_SetDefaultEncoding at startup
-import sys
-if sys.version_info[0] < 3:
-    sys.setdefaultencoding("utf-8")
diff -upNr pymol-open-source-2.3.0/monkeypatch_distutils.py pymol-open-source-2.3.3/monkeypatch_distutils.py
--- pymol-open-source-2.3.0/monkeypatch_distutils.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/monkeypatch_distutils.py	2019-08-22 10:24:47.874621096 +0200
@@ -105,9 +105,6 @@ def compile(self, sources, output_dir=No
 
     To do a clean build, please remove the "build" directory.
     '''
-    if os.getenv('DEBUG', ''):
-        debug = 1
-
     macros, objects, extra_postargs, pp_opts, build = self._setup_compile(
             output_dir, macros, include_dirs, sources, depends, extra_postargs)
     cc_args = self._get_cc_args(pp_opts, debug, extra_preargs)
diff -upNr pymol-open-source-2.3.0/ov/src/ov_defines.h pymol-open-source-2.3.3/ov/src/ov_defines.h
--- pymol-open-source-2.3.0/ov/src/ov_defines.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/ov/src/ov_defines.h	2019-08-22 10:24:47.874621096 +0200
@@ -14,13 +14,8 @@
 
 /* defines */
 
-#ifdef WIN32
-#define OV_INLINE static
+#define OV_INLINE inline
 #define OV_STATIC static
-#else
-#define OV_INLINE __inline__ static
-#define OV_STATIC static
-#endif
 
 #ifndef OV_FALSE
 #define OV_FALSE 0
diff -upNr pymol-open-source-2.3.0/PACKAGING pymol-open-source-2.3.3/PACKAGING
--- pymol-open-source-2.3.0/PACKAGING	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/PACKAGING	2019-08-22 10:24:47.654585268 +0200
@@ -6,46 +6,17 @@ PyMOL Packaging Guide
 PyMOL environment variables
 ===========================
 
-PyMOL is designed to run under two types of environments.  They are:
-
-(1) Single-directory self-contained install. (Windows, Mac, Unix Standalone)
-
-(2) Package-managed with files spread all over the OS. (RedHat, Debian)
-
-Environment (1)
----------------
-
-Environment variable PYMOL_PATH serves as the root directory
-and tells PyMOL where to find everything, including its code.
-
-Required: PYMOL_PATH
-
-Environment (2)
----------------
-
-PyMOL code is installed in the system Python namespace, so no explicit
-environment variable is required to access it.  The root python
-modules defined in site-packages are "pymol", "pmg_tk", and "chempy".
-
-Required: PYMOL_DATA, PYMOL_SCRIPTS
-
-PYMOL_DATA is usually /usr/share/pymol/data
-PYMOL_SCRIPTS is usually /usr/share/pymol/scripts
-
-Mechanism
----------
-
-PYMOL_DATA and PYMOL_SCRIPTS dominate if provided.  Otherwise, if
-PYMOL_PATH is defined, PYMOL_DATA becomes $PYMOL_PATH/data, and
-PYMOL_SCRIPTS becomes $PYMOL_PATH/scripts.
-
-if $PYMOL_PATH is defined and $PYMOL_PATH/modules exists, then
-$PYMOL_PATH/modules is added to the Python module search path.
-
-Under MacOS X, PYMOL_PATH is self-defining.  Under Windows, this
-environment variable is stored in the registry during installation.
-Under Unix, PYMOL_PATH needs to be defined prior to startup, usually
-by "pymol.com".
+Typical installations don't require any environment variables to run
+PyMOL. PyMOL will automatically assign the following variables if they
+are unset:
+
+PYMOL_PATH = First of:
+  - <pymol python module> + "/pymol_path"
+  - parent of the "modules" directory if launch script matches
+    "modules/pymol/__init__.py"
+  - sys.prefix + "/share/pymol"
+PYMOL_DATA = $PYMOL_PATH/data
+PYMOL_SCRIPTS = $PYMOL_PATH/scripts
 
 =======================================================
 Suggested File Locations (for package managed installs)
@@ -57,18 +28,10 @@ modules/pymol  -> /usr/lib/pythonX.X/sit
 modules/chempy -> /usr/lib/pythonX.X/site-packages/chempy
 modules/pmg_tk -> /usr/lib/pythonX.X/site-packages/pmg_tk
 
+== pymol-data package ==
+
 scripts     -> /usr/share/pymol/scripts (RUNTIME REQUIREMENT)
 data        -> /usr/share/pymol/data (RUNTIME REQUIREMENT)
 
-examples    -> /usr/share/doc/pymol/examples
-doc         -> /usr/share/doc/pymol/doc
-LICENSE     -> /usr/share/doc/pymol/LICENSE
-CHANGES     -> /usr/share/doc/pymol/CHANGES
-README      -> /usr/share/doc/pymol/README
-
-== pymol-devel package ==
-
-test        -> /usr/share/pymol/test (TESTING RUNTIME REQUIREMENT)
-
-DEVELOPERS  -> /usr/share/doc/pymol/DEVELOPERS
-PACKAGING   -> /usr/share/doc/pymol/PACKAGING
+Installable with:
+python setup.py install --pymol-path=/usr/share/pymol
diff -upNr pymol-open-source-2.3.0/README.md pymol-open-source-2.3.3/README.md
--- pymol-open-source-2.3.0/README.md	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/README.md	2019-08-22 10:24:47.658585920 +0200
@@ -1,3 +1,5 @@
+<img src="./data/pymol/icons/icon2.svg" height="100" align="right" />
+
 # Open-Source PyMOL
 
 [Open-source foundation](https://pymol.org/#opensource) of the user-sponsored PyMOL molecular visualization system.
@@ -8,6 +10,10 @@ The commercial PyMOL product ("Incentive
 
 See [INSTALL](INSTALL).
 
+## Contributing
+
+See [DEVELOPERS](DEVELOPERS).
+
 ## License
 
 Copyright (c) [Schrodinger, LLC](https://www.schrodinger.com/)
diff -upNr pymol-open-source-2.3.0/setup/sample.pymolrc pymol-open-source-2.3.3/setup/sample.pymolrc
--- pymol-open-source-2.3.0/setup/sample.pymolrc	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/setup/sample.pymolrc	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-_ feedback push
-_ feedback disable,all,everything
-# RENAME TO .pymolrc AND INSERT COMMANDS HERE
-
-
-# END COMMANDS
-_ feedback pop
-
diff -upNr pymol-open-source-2.3.0/setup/setup.sh pymol-open-source-2.3.3/setup/setup.sh
--- pymol-open-source-2.3.0/setup/setup.sh	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/setup/setup.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,56 +0,0 @@
-#!/bin/bash
-echo ' '
-echo '============================================'
-echo 'Creating "./pymol" startup script with '
-echo "PYMOL_PATH=`pwd`"
-echo '============================================'
-
-touch pymol || exit 1
-
-echo 'If you need to move PyMOL in the future,'
-echo 're-run "./setup.sh" afterwards.'
-echo '============================================'
-echo 'You may now want to copy or link:'
-echo "\"`pwd`/pymol\"" 
-echo 'to something like "/usr/local/bin/pymol"'
-echo '============================================'
-echo 'Enjoy!'
-echo ' '
-echo '#!/bin/sh' > pymol
-echo '#' >> pymol
-echo '# PyMOL startup script' >> ./pymol
-echo '#' >> ./pymol
-echo '# Set PYMOL_PATH to point to this directory' >> ./pymol
-echo '#' >> ./pymol
-echo '# ================================================' >> ./pymol
-echo "PYMOL_PATH=`pwd`" >> ./pymol
-echo '# ================================================' >> ./pymol
-echo '#' >> ./pymol
-echo 'export PYMOL_PATH' >> ./pymol
-echo 'PYTHONHOME=$PYMOL_PATH/ext' >> ./pymol
-echo 'PYTHONPATH=$PYTHONHOME/lib/python2.7:$PYTHONPATH' >> ./pymol
-echo 'PYTHONPATH=$PYTHONHOME/lib/python2.7/lib-tk:$PYTHONPATH' >> ./pymol
-echo 'LD_LIBRARY_PATH=$PYMOL_PATH/ext/lib:$LD_LIBRARY_PATH' >> ./pymol
-echo 'LANG=C' >> ./pymol
-echo 'export LD_LIBRARY_PATH' >> ./pymol
-echo 'export PYTHONHOME' >> ./pymol
-echo 'export PYTHONPATH' >> ./pymol
-echo 'export LANG' >> ./pymol
-echo 'exec $PYMOL_PATH/pymol.exe "$@"' >> ./pymol
-chmod 755 ./pymol
-
-# remove extra libs from ext/lib
-(cd ext/libextra && names=`ls` && cd ../lib && rm -f $names)
-
-# add extra libs to ext/lib if there seems to be a problem like
-# missing library or incompatible library
-while true; do
-    name=(`./pymol -cq 2>&1 | grep 'lib[^ /]*\.so' | sed 's!.*\(lib[^ /]*\.so[.0-9]*\).*!\1!'`)
-    test -z "$name" && break
-    if [ -e "ext/lib/$name" -o ! -e "ext/libextra/$name" ]; then
-        echo "warning: problem with $name"
-        break
-    fi
-    (cd ext/lib && ln -s ../libextra/$name .)
-done
-
diff -upNr pymol-open-source-2.3.0/setup.py pymol-open-source-2.3.3/setup.py
--- pymol-open-source-2.3.0/setup.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/setup.py	2019-08-22 10:24:47.874621096 +0200
@@ -8,9 +8,6 @@
 
 from distutils.core import setup, Extension
 from distutils.util import change_root
-from distutils.errors import *
-from distutils.command.install import install
-from distutils.command.build_py import build_py
 from glob import glob
 import shutil
 import sys, os, re
@@ -125,6 +122,17 @@ def guess_msgpackc():
     return 'no'
 
 
+# Important: import 'distutils.command' modules after monkeypatch_distutils
+from distutils.command.build_ext import build_ext
+from distutils.command.build_py import build_py
+from distutils.command.install import install
+
+class build_ext_pymol(build_ext):
+    def initialize_options(self):
+        build_ext.initialize_options(self)
+        if DEBUG and not WIN:
+            self.debug = True
+
 class build_py_pymol(build_py):
     def run(self):
         build_py.run(self)
@@ -165,7 +173,8 @@ class install_pymol(install):
         return name
 
     def copy_tree_nosvn(self, src, dst):
-        ignore = lambda src, names: set(['.svn']).intersection(names)
+        ignore = lambda src, names: set([
+        ]).intersection(names)
         if os.path.exists(dst):
             shutil.rmtree(dst)
         print('copying %s -> %s' % (src, dst))
@@ -245,7 +254,6 @@ pymol_src_dirs = [
 def_macros = [
     ("_PYMOL_LIBPNG", None),
     ("_PYMOL_FREETYPE", None),
-    ("_PYMOL_INLINE", None),
 ]
 
 libs = ["png", "freetype"]
@@ -257,7 +265,7 @@ ext_comp_args = [
     # optimizations
     "-ffast-math",
     "-funroll-loops",
-    "-O0" if DEBUG else "-O3",
+    "-Og" if DEBUG else "-O3",
     "-fcommon",
 ]
 ext_link_args = []
@@ -335,7 +343,6 @@ if WIN:
 
         def_macros += [
             ("WIN32", None),
-            ("CINTERFACE", None),   # avoid "Alloc" macro conflict
         ]
 
         libs += [
@@ -440,6 +447,7 @@ ext_modules += [
 
 distribution = setup ( # Distribution meta-data
     cmdclass  = {
+        'build_ext': build_ext_pymol,
         'build_py': build_py_pymol,
         'install': install_pymol,
     },
diff -upNr pymol-open-source-2.3.0/.svnignore pymol-open-source-2.3.3/.svnignore
--- pymol-open-source-2.3.0/.svnignore	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/.svnignore	1970-01-01 01:00:00.000000000 +0100
@@ -1,12 +0,0 @@
-.git
-.gitignore
-.svn
-.svnignore
-*.pyc
-*.d
-contrib/sglite
-generated
-build
-pymol
-debug
-data/mm
diff -upNr pymol-open-source-2.3.0/test/run pymol-open-source-2.3.3/test/run
--- pymol-open-source-2.3.0/test/run	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/test/run	2019-08-22 10:24:47.874621096 +0200
@@ -4,7 +4,6 @@ import os
 import sys
 import re
 import glob
-import string
 
 # list of tests to run ...
 
@@ -44,9 +43,7 @@ ref = "ref"
 inp = "inp"
 tmp = "tmp"
 
-python_exe = "../ext/bin/python"
-if not os.path.exists(python_exe):
-   python_exe = "/usr/bin/python"
+python_exe = sys.executable
 if not os.path.exists(python_exe):
    python_exe = "python"
 
@@ -70,14 +67,14 @@ for test in tests:
    for ifil in flist:
       # get options
       f = open(ifil)
-      opt = string.strip(f.readline())
+      opt = f.readline().strip()
       opt = re.sub("^\s*\#","",opt)
       f.close()
       
       tst = re.sub(r".*/","",ifil) # get exact test name without suffix
       tst = re.sub(r"\..*","",tst)
       
-      print " run_tests: "+tst+"..."
+      print(" run_tests: "+tst+"...")
 
       syscmd = cmd+" "+opt+" "+ifil+" 2>&1 | "+python_exe+" trim.py > "+cmp+"/"+tst+".log 2>&1"
 
@@ -93,14 +90,14 @@ for test in tests:
                df = os.popen(diff_cmd+" "+ref_fil+" "+cmp_fil)
                diffs = df.readlines()
                df.close()
-               print " run_tests: "+ \
-                  postfx+" DIFFERS over about %d lines." % int(len(diffs)/2)
+               print(" run_tests: "+ \
+                  postfx+" DIFFERS over about %d lines." % int(len(diffs)/2))
                if os.path.isdir('diffs'):
                   f = open('diffs/' + postfx + '.diff', 'w')
                   f.writelines(diffs)
                   f.close()
          else:
-            print " run_tests: "+postfx+" is missing."
+            print(" run_tests: "+postfx+" is missing.")
             
       # check for extraneous, unverifiable files
       
@@ -108,6 +105,6 @@ for test in tests:
          postfx = re.sub(r".*/","",cmp_fil)
          ref_fil = ref+"/"+postfx
          if not os.path.exists(ref_fil):
-            print " run_tests: no reference version for "+cmp+"/"+postfx+"."
+            print(" run_tests: no reference version for "+cmp+"/"+postfx+".")
 
 # vi:sw=3:expandtab
diff -upNr pymol-open-source-2.3.0/test/trim.py pymol-open-source-2.3.3/test/trim.py
--- pymol-open-source-2.3.0/test/trim.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.3/test/trim.py	2019-08-22 10:24:47.874621096 +0200
@@ -1,5 +1,4 @@
 import sys
-import string
 
 f = sys.stdin
 g = sys.stdout
@@ -8,11 +7,11 @@ echo = 0
 while 1:
    l = f.readline()
    if not l: break
-   ll=string.strip(l)
+   ll=l.strip()
    if ll=='BEGIN-LOG':
       echo = 1
    elif ll=='END-LOG':
       echo = 0
    elif echo:
-      l=string.replace(l,"-0.000"," 0.000") # squish annoying negative zeros
+      l=l.replace("-0.000"," 0.000") # squish annoying negative zeros
       g.write(l)
