diff -upNr pymol-open-source-2.3.0/layer0/Isosurf.cpp pymol-open-source-2.3.2/layer0/Isosurf.cpp
--- pymol-open-source-2.3.0/layer0/Isosurf.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer0/Isosurf.cpp	2019-05-27 15:31:39.008719515 +0200
@@ -83,8 +83,6 @@ static int IsosurfAlloc(PyMOLGlobals * G
 static void IsosurfPurge(CIsosurf * II);
 static int IsosurfCurrent(CIsosurf * II);
 static int IsosurfCodeVertices(CIsosurf * II);
-static void IsosurfInterpolate(CIsosurf * II, float *v1, float *l1, float *v2, float *l2,
-                               float *pt);
 static int IsosurfFindActiveEdges(CIsosurf * II);
 static int IsosurfFindLines(CIsosurf * II);
 static int IsosurfDrawLines(CIsosurf * II);
@@ -128,9 +126,7 @@ PyObject *IsosurfAsPyList(PyMOLGlobals *
 
 
 /*===========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
+inline
 static void IsosurfInterpolate(CIsosurf * I, float *v1, float *l1, float *v2, float *l2,
                                float *pt)
 {
diff -upNr pymol-open-source-2.3.0/layer0/os_predef.h pymol-open-source-2.3.2/layer0/os_predef.h
--- pymol-open-source-2.3.0/layer0/os_predef.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer0/os_predef.h	2019-05-27 15:31:39.008719515 +0200
@@ -49,10 +49,6 @@ typedef float aliased_float;
 
 /* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in "os_proprietary.h") */
 
-#if defined(_MSC_VER)
-#define __inline__ __inline
-#endif
-
 #ifdef WIN32
 #define PATH_SEP "\\"
 #else
diff -upNr pymol-open-source-2.3.0/layer0/Tetsurf.cpp pymol-open-source-2.3.2/layer0/Tetsurf.cpp
--- pymol-open-source-2.3.0/layer0/Tetsurf.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer0/Tetsurf.cpp	2019-05-27 15:31:39.008719515 +0200
@@ -690,9 +690,7 @@ static void TetsurfPurge(CTetsurf * II)
 
 
 /*===========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
+inline
 static void TetsurfInterpolate2(float *pt, float *v0, float l0, float *v1, float l1,
                                 float level)
 {
@@ -705,9 +703,6 @@ static void TetsurfInterpolate2(float *p
 
 
 /*===========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static void TetsurfInterpolate4(float *pt, float *v0, float l0, float *v1, float l1,
                                 float l2, float l3, float level)
 {
@@ -730,9 +725,6 @@ static void TetsurfInterpolate4(float *p
 
 
 /*===========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static void TetsurfInterpolate8(float *pt, float *v0, float l0, float *v1, float l1,
                                 float l2, float l3, float l4,
                                 float l5, float l6, float l7, float level)
diff -upNr pymol-open-source-2.3.0/layer0/Vector.h pymol-open-source-2.3.2/layer0/Vector.h
--- pymol-open-source-2.3.0/layer0/Vector.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer0/Vector.h	2019-05-27 15:31:39.008719515 +0200
@@ -398,7 +398,7 @@ inline void cross_product3f(const float
   cross[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);
 }
 
-__inline__ static double inline_sqrt1f(float f)
+inline double inline_sqrt1f(float f)
 {                               /* no good as a macro because f is used twice */
   if(f > _0f_inline)
     return (sqrt(f));
@@ -406,7 +406,7 @@ __inline__ static double inline_sqrt1f(f
     return (_0d_inline);
 }
 
-__inline__ static double inline_sqrt1d(double f)
+inline double inline_sqrt1d(double f)
 {                               /* no good as a macro because f is used twice */
   if(f > _0d_inline)
     return (sqrt(f));
@@ -422,7 +422,7 @@ inline float length2f(const float * v1)
   return sqrt1f((v1[0] * v1[0]) + (v1[1] * v1[1]));
 }
 
-__inline__ static void inline_normalize3f(float *v1)
+inline void inline_normalize3f(float *v1)
 {
   double vlen = length3f(v1);
   if(vlen > R_SMALLd_inline) {
@@ -435,7 +435,7 @@ __inline__ static void inline_normalize3
   }
 }
 
-__inline__ static double inline_diff3f(const float *v1, const float *v2)
+inline double inline_diff3f(const float *v1, const float *v2)
 {
   float dx, dy, dz;
   dx = (v1[0] - v2[0]);
@@ -444,7 +444,7 @@ __inline__ static double inline_diff3f(c
   return (sqrt1d(dx * dx + dy * dy + dz * dz));
 }
 
-__inline__ static float inline_diffsq3f(const float *v1, const float *v2)
+inline float inline_diffsq3f(const float *v1, const float *v2)
 {
   float dx, dy, dz;
   dx = (v1[0] - v2[0]);
@@ -455,7 +455,7 @@ __inline__ static float inline_diffsq3f(
   return (dz * dz + (dx + dy));
 }
 
-__inline__ static int inline_within3f(const float *v1, const float *v2, float dist)
+inline int inline_within3f(const float *v1, const float *v2, float dist)
 {
   float dx, dy, dz, dist2;
   dx = (float) fabs(v1[0] - v2[0]);
@@ -473,7 +473,7 @@ __inline__ static int inline_within3f(co
   return (((dx + dy) + dz * dz) <= dist2);
 }
 
-__inline__ static int inline_within3fsq(const float *v1, const float *v2, float dist, float dist2)
+inline int inline_within3fsq(const float *v1, const float *v2, float dist, float dist2)
 {
   /* manually optimized to take advantage of parallel execution units */
   float dx, dy, dz;
@@ -498,7 +498,7 @@ __inline__ static int inline_within3fsq(
   return ((dx + dz) <= (dist2));
 }
 
-__inline__ static int inline_within3fret(const float *v1, const float *v2, float cutoff,
+inline int inline_within3fret(const float *v1, const float *v2, float cutoff,
                                          const float cutoff2, float *diff, float *dist)
 {
   float dx, dy, dz, dist2;
@@ -519,7 +519,7 @@ __inline__ static int inline_within3fret
   return 1;
 }
 
-__inline__ static void inline_remove_component3f(const float *v1, const float *unit, float *result)
+inline void inline_remove_component3f(const float *v1, const float *unit, float *result)
 {
   float dot;
 
@@ -529,7 +529,7 @@ __inline__ static void inline_remove_com
   result[2] = v1[2] - unit[2] * dot;
 }
 
-__inline__ static float inline_project3f(const float *v1, const float *v2, float *proj)
+inline float inline_project3f(const float *v1, const float *v2, float *proj)
 {
   float dot;
 
diff -upNr pymol-open-source-2.3.0/layer0/Version.h pymol-open-source-2.3.2/layer0/Version.h
--- pymol-open-source-2.3.0/layer0/Version.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer0/Version.h	2019-05-27 15:34:08.013339345 +0200
@@ -1,5 +1,5 @@
 #ifndef _PyMOL_VERSION
-#define _PyMOL_VERSION "2.3.0"
+#define _PyMOL_VERSION "2.3.2"
 #endif
 
 /* for session file compatibility */
diff -upNr pymol-open-source-2.3.0/layer0/Word.cpp pymol-open-source-2.3.2/layer0/Word.cpp
--- pymol-open-source-2.3.0/layer0/Word.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer0/Word.cpp	2019-05-27 15:31:39.008719515 +0200
@@ -52,7 +52,6 @@ struct _CWordMatcher {
 #define cMatchAlphaRange  cWordMatchOptionAlphaRanges
 #define cMatchWildcard 3
 
-#ifndef _PYMOL_INLINE
 int WordCompare(PyMOLGlobals * G, const char *p, const char *q, int ignCase)
 
 
@@ -93,7 +92,6 @@ int WordCompare(PyMOLGlobals * G, const
     return 1;
   return 0;
 }
-#endif
 
 void WordMatchOptionsConfigInteger(CWordMatchOptions * I)
 {
diff -upNr pymol-open-source-2.3.0/layer0/Word.h pymol-open-source-2.3.2/layer0/Word.h
--- pymol-open-source-2.3.0/layer0/Word.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer0/Word.h	2019-05-27 15:31:39.008719515 +0200
@@ -91,52 +91,8 @@ int WordIndex(PyMOLGlobals * G, WordType
 int WordKey(PyMOLGlobals * G, WordKeyValue * list, const char *word, int minMatch, int ignCase,
             int *exact);
 
-#ifdef _PYMOL_INLINE
-__inline__ static int WordCompare(PyMOLGlobals * G, const char *p, const char *q, int ignCase)
-
-
-/* all things equal, shorter is smaller */
-{
-  int result = 0;
-  char cp, cq, tlp, tlq;
-  if(ignCase) {
-    while((cp = *p) && (cq = *q)) {
-      p++;
-      q++;
-      if(cp != cq) {
-        (tlp = tolower(cp));
-        (tlq = tolower(cq));
-        if(tlp < tlq)
-          return -1;
-        else if(tlp > tlq) {
-          return 1;
-        }
-      }
-    }
-  } else {
-    while((cp = *p) && (cq = *q)) {
-      p++;
-      q++;
-      if(cp != cq) {
-        if(cp < cq) {
-          return -1;
-        } else if(cp > cq) {
-          return 1;
-        }
-      }
-    }
-  }
-  if((!result) && (!*p) && (*q))
-    return -1;
-  else if((!result) && (*p) && (!*q))
-    return 1;
-  return 0;
-}
-#else
 int WordCompare(PyMOLGlobals * G, const char *p, const char *q, int ignCase);
 
-#endif
-
 inline int WordCompare(PyMOLGlobals * G, const lexidx_t& s1, const lexidx_t& s2, int ignCase) {
   if (s1 == s2)
     return 0;
diff -upNr pymol-open-source-2.3.0/layer1/Basis.cpp pymol-open-source-2.3.2/layer1/Basis.cpp
--- pymol-open-source-2.3.0/layer1/Basis.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer1/Basis.cpp	2019-05-27 15:31:39.008719515 +0200
@@ -15,8 +15,6 @@ I* Additional authors of this source fil
 Z* -------------------------------------------------------------------
 */
 
-#ifndef _PYMOL_INLINE
-
 #include"os_predef.h"
 #include"os_std.h"
 
@@ -34,9 +32,6 @@ static const float kR_SMALL5 = 0.0001F;
 #define EPSILON 0.000001F
 
 /*========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int ZLineToSphere(float *base, float *point, float *dir, float radius,
                          float maxial, float *sphere, float *asum, float *pre)
 {
@@ -159,9 +154,6 @@ static int ZLineToSphere(float *base, fl
   return (1);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int LineToSphere(float *base, float *ray, float *point, float *dir, float radius,
                         float maxial, float *sphere, float *asum)
 {
@@ -315,9 +307,6 @@ static int LineToSphere(float *base, flo
   return (1);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int FrontToInteriorSphere(float *front,
                                  float *point,
                                  float *dir, float radius, float radius2, float maxial)
@@ -347,9 +336,6 @@ static int FrontToInteriorSphere(float *
 
 
 /*========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int ZLineToSphereCapped(float *base, float *point,
                                float *dir, float radius, float maxial,
                                float *sphere, float *asum, int cap1, int cap2, float *pre)
@@ -572,9 +558,6 @@ static int ZLineToSphereCapped(float *ba
   return (1);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int LineToSphereCapped(float *base, float *ray,
                               float *point, float *dir, float radius, float maxial,
                               float *sphere, float *asum, int cap1, int cap2)
@@ -1073,9 +1056,6 @@ static int ConeLineToSphereCapped(float
   return 0;
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int FrontToInteriorSphereCapped(float *front,
                                        float *point,
                                        float *dir,
@@ -1108,9 +1088,6 @@ static int FrontToInteriorSphereCapped(f
 
 
 /*========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static float ZLineClipPoint(float *base, float *point, float *alongNormalSq, float cutoff)
 {
   float hyp0, hyp1, hyp2;
@@ -1143,9 +1120,6 @@ static float ZLineClipPoint(float *base,
   return result;
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static float ZLineClipPointNoZCheck(float *base, float *point, float *alongNormalSq,
                                     float cutoff)
 {
@@ -1178,9 +1152,6 @@ static float ZLineClipPointNoZCheck(floa
   return result;
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int LineClipPoint(float *base, float *ray,
                          float *point, float *dist, float cutoff, float cutoff2)
 {
@@ -1524,9 +1495,6 @@ int n_sausages = 0;
 int n_skipped = 0;
 #endif
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 int BasisHitPerspective(BasisCallRec * BC)
 {
   CBasis *BI = BC->Basis;
@@ -2021,9 +1989,6 @@ int BasisHitPerspective(BasisCallRec * B
   }
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 int BasisHitOrthoscopic(BasisCallRec * BC)
 {
   const float _0 = 0.0F, _1 = 1.0F;
@@ -2345,9 +2310,6 @@ int BasisHitOrthoscopic(BasisCallRec * B
   return (-1);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 int BasisHitShadow(BasisCallRec * BC)
 {
   const float _0 = 0.0F;
@@ -3681,8 +3643,3 @@ void BasisCylinderSausagePrecompute(floa
   pre[0] = dir[1] * ln;
   pre[1] = -dir[0] * ln;
 }
-
-#else
-typedef int this_file_is_no_longer_empty;
-
-#endif
diff -upNr pymol-open-source-2.3.0/layer1/CGO.cpp pymol-open-source-2.3.2/layer1/CGO.cpp
--- pymol-open-source-2.3.0/layer1/CGO.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer1/CGO.cpp	2019-05-27 15:31:38.996719531 +0200
@@ -4162,14 +4162,15 @@ CGO *CGOSimplify(const CGO * I, int est,
         float mid[3];
         mult3f(cyl->axis, .5f, mid);
         add3f(cyl->origin, mid, mid);
+        float alpha2 = cyl->alpha >= 0.f ? cyl->alpha : cgo->alpha;
         if (cap & cCylShaderInterpColor){
-          ok &= CGOSimpleCylinder(cgo, cyl->origin, v1, cyl->tube_size, color1, cyl->color2, cyl->alpha, cyl->alpha, true, bcap, fcap, &pickcolor2, stick_round_nub);
+          ok &= CGOSimpleCylinder(cgo, cyl->origin, v1, cyl->tube_size, color1, cyl->color2, cgo->alpha, alpha2, true, bcap, fcap, &pickcolor2, stick_round_nub);
         } else {
           ok &= CGOColorv(cgo, color1);
-          ok &= CGOSimpleCylinder(cgo, cyl->origin, mid, cyl->tube_size, color1, NULL, cyl->alpha, cyl->alpha, false, fcap, 0, nullptr, stick_round_nub);
+          ok &= CGOSimpleCylinder(cgo, cyl->origin, mid, cyl->tube_size, color1, NULL, cgo->alpha, alpha2, false, fcap, 0, nullptr, stick_round_nub);
           ok &= CGOColorv(cgo, cyl->color2);
           ok &= CGOPickColor(cgo, pickcolor2.index, pickcolor2.bond);
-          ok &= CGOSimpleCylinder(cgo, mid, v1, cyl->tube_size, cyl->color2, NULL, cyl->alpha, cyl->alpha, false, 0, bcap, nullptr, stick_round_nub);
+          ok &= CGOSimpleCylinder(cgo, mid, v1, cyl->tube_size, cyl->color2, NULL, cgo->alpha, alpha2, false, 0, bcap, nullptr, stick_round_nub);
         }
       }
       break;
@@ -4471,14 +4472,15 @@ CGO *CGOSimplifyNoCompress(const CGO * I
         float mid[3];
         mult3f(cyl->axis, .5f, mid);
         add3f(cyl->origin, mid, mid);
+        float alpha2 = cyl->alpha >= 0.f ? cyl->alpha : cgo->alpha;
         if (cap & cCylShaderInterpColor){
-          ok &= CGOSimpleCylinder(cgo, cyl->origin, v1, cyl->tube_size, color1, cyl->color2, cyl->alpha, cyl->alpha, true, bcap, fcap, &pickcolor2, stick_round_nub);
+          ok &= CGOSimpleCylinder(cgo, cyl->origin, v1, cyl->tube_size, color1, cyl->color2, cgo->alpha, alpha2, true, bcap, fcap, &pickcolor2, stick_round_nub);
         } else {
           ok &= CGOColorv(cgo, color1);
-          ok &= CGOSimpleCylinder(cgo, cyl->origin, mid, cyl->tube_size, color1, NULL, cyl->alpha, cyl->alpha, false, fcap, 0, NULL, stick_round_nub);
+          ok &= CGOSimpleCylinder(cgo, cyl->origin, mid, cyl->tube_size, color1, NULL, cgo->alpha, alpha2, false, fcap, 0, NULL, stick_round_nub);
           ok &= CGOColorv(cgo, cyl->color2);
           ok &= CGOPickColor(cgo, pickcolor2.index, pickcolor2.bond);
-          ok &= CGOSimpleCylinder(cgo, mid, v1, cyl->tube_size, cyl->color2, NULL, cyl->alpha, cyl->alpha, false, 0, bcap, NULL, stick_round_nub);
+          ok &= CGOSimpleCylinder(cgo, mid, v1, cyl->tube_size, cyl->color2, NULL, cgo->alpha, alpha2, false, 0, bcap, NULL, stick_round_nub);
         }
       }
       break;
@@ -5687,17 +5689,19 @@ int CGORenderRay(CGO * I, CRay * ray, Re
         const float *color1 = c0;
         const float *color2 = cyl->color2;
         add3f(cyl->origin, cyl->axis, v1);
+        float alpha1 = I->G->CGORenderer->alpha;
+        float alpha2 = cyl->alpha >= 0.f ? cyl->alpha : alpha1;
         if (colorinterp || equal3f(color1, color2)) {
-          ok &= ray->customCylinder3fv(pc, v1, cyl->tube_size, color1, color2, fcap, bcap, cyl->alpha, cyl->alpha);
+          ok &= ray->customCylinder3fv(pc, v1, cyl->tube_size, color1, color2, fcap, bcap, alpha1, alpha2);
         } else {
           float mid[3];
           mult3f(cyl->axis, .5f, mid);
           add3f(cyl->origin, mid, mid);
 
           ray->color3fv(c0);
-          ok &= ray->customCylinder3fv(cyl->origin, mid, cyl->tube_size, color1, color1, fcap, 0, cyl->alpha, cyl->alpha);
+          ok &= ray->customCylinder3fv(cyl->origin, mid, cyl->tube_size, color1, color1, fcap, 0, alpha1, alpha2);
           ray->color3fv(cyl->color2);
-          ok &= ray->customCylinder3fv(mid, v1, cyl->tube_size, color2, color2, 0, bcap, cyl->alpha, cyl->alpha);
+          ok &= ray->customCylinder3fv(mid, v1, cyl->tube_size, color2, color2, 0, bcap, alpha1, alpha2);
         }
       }
       break;
diff -upNr pymol-open-source-2.3.0/layer1/CGO.h pymol-open-source-2.3.2/layer1/CGO.h
--- pymol-open-source-2.3.0/layer1/CGO.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer1/CGO.h	2019-05-27 15:31:38.996719531 +0200
@@ -585,7 +585,7 @@ namespace cgo {
       static const int op_code = CGO_SHADER_CYLINDER_WITH_2ND_COLOR;
       shadercylinder2ndcolor(CGO *I, const float *_origin, const float *_axis, const float _radius,
                              int _cap, const float *_color2, Pickable *pickcolor2 = NULL,
-                             const float alpha = 1.0f);
+                             const float alpha = -1.f);
       float origin[3], axis[3], tube_size;
       int cap;
       float color2[3];
diff -upNr pymol-open-source-2.3.0/layer1/FontType.cpp pymol-open-source-2.3.2/layer1/FontType.cpp
--- pymol-open-source-2.3.0/layer1/FontType.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer1/FontType.cpp	2019-05-27 15:31:39.008719515 +0200
@@ -75,9 +75,6 @@ typedef struct {
   CTypeFace *TypeFace;
 } CFontType;
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static const char *_FontTypeRenderOpenGL(RenderInfo * info,
                                    CFontType * I, const char *st,
                                    float size, int flat, float *rpos, short needSize, short relativeMode, short shouldRender SHADERCGOARG)
diff -upNr pymol-open-source-2.3.0/layer1/Ray.cpp pymol-open-source-2.3.2/layer1/Ray.cpp
--- pymol-open-source-2.3.0/layer1/Ray.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer1/Ray.cpp	2019-05-27 15:31:39.008719515 +0200
@@ -43,11 +43,7 @@ Z* -------------------------------------
 
 #define SettingGetfv SettingGetGlobal_3fv
 
-#ifdef _PYMOL_INLINE
-#undef _PYMOL_INLINE
-#include"Basis.cpp"
-#define _PYMOL_INLINE
-#endif
+#include"Basis.h"
 
 #ifndef RAY_SMALL
 #define RAY_SMALL 0.00001
@@ -218,9 +214,6 @@ int RayGetNPrimitives(CRay * I)
 
 /*========================================================================*/
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static void RayGetSphereNormal(CRay * I, RayInfo * r)
 {
 
@@ -235,9 +228,6 @@ static void RayGetSphereNormal(CRay * I,
   normalize3f(r->surfnormal);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static void RayGetSphereNormalPerspective(CRay * I, RayInfo * r)
 {
 
@@ -463,9 +453,6 @@ static void fill_gradient(CRay * I, int
 }
 
 /*========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static void RayReflectAndTexture(CRay * I, RayInfo * r, int perspective)
 {
   if(r->prim->wobble)
@@ -6898,7 +6885,6 @@ int CRay::cylinder3fv(const float *v1, c
 
   p->type = cPrimCylinder;
   p->r1 = r;
-  p->trans = I->Trans;
   p->cap1 = cCylCapFlat;
   p->cap2 = cCylCapFlat;
   p->wobble = I->Wobble;
@@ -6939,7 +6925,8 @@ int CRay::cylinder3fv(const float *v1, c
   (*vv++) = (*c2++);
   (*vv++) = (*c2++);
 
-  p->trans = 1.0 - alpha1;
+  // FIXME: alpha1 is not used
+  p->trans = 1.0 - alpha2;
   {
     float *v;
     vv = p->ic;
@@ -6994,7 +6981,6 @@ int CRay::customCylinder3fv(const float
 
   p->type = cPrimCylinder;
   p->r1 = r;
-  p->trans = I->Trans;
   p->cap1 = cap1;
   p->cap2 = cap2;
   p->wobble = I->Wobble;
@@ -7036,7 +7022,8 @@ int CRay::customCylinder3fv(const float
   (*vv++) = (*c2++);
   vv = p->ic;
 
-  p->trans = 1.0f - alpha1;
+  // FIXME: alpha1 is not used
+  p->trans = 1.0f - alpha2;
 
   {
     float *v;
diff -upNr pymol-open-source-2.3.0/layer1/Scene.cpp pymol-open-source-2.3.2/layer1/Scene.cpp
--- pymol-open-source-2.3.0/layer1/Scene.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer1/Scene.cpp	2019-05-27 15:31:39.000719526 +0200
@@ -2117,6 +2117,9 @@ int SceneMakeMovieImage(PyMOLGlobals * G
   PRINTFB(G, FB_Scene, FB_Blather)
     " Scene: Making movie image.\n" ENDFB(G);
 
+  // PYMOL-3209 objects inside hidden groups become visible
+  ExecutiveUpdateSceneMembers(G);
+
   mode = SceneValidateImageMode(G, mode, width || height);
 
   I->DirtyFlag = false;
diff -upNr pymol-open-source-2.3.0/layer2/CoordSet.cpp pymol-open-source-2.3.2/layer2/CoordSet.cpp
--- pymol-open-source-2.3.0/layer2/CoordSet.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer2/CoordSet.cpp	2019-05-27 15:31:39.008719515 +0200
@@ -851,12 +851,12 @@ bool CoordSetInsureOrthogonal(PyMOLGloba
 }
 
 /*========================================================================*/
-static char RotateU(const double *matrix, float *anisou)
 /* Rotates the ANISOU vector
  *
  * matrix: flat 4x4, but only rotation (upper left 3x3) is considered
  * anisou: has 6 elements (of symmetric 3x3) and will be rotated in-place
  */
+bool RotateU(const double *matrix, float *anisou)
 {
   int i, j, k;
   float Re[3][3];
diff -upNr pymol-open-source-2.3.0/layer2/CoordSet.h pymol-open-source-2.3.2/layer2/CoordSet.h
--- pymol-open-source-2.3.0/layer2/CoordSet.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer2/CoordSet.h	2019-05-27 15:31:39.008719515 +0200
@@ -221,4 +221,7 @@ template <typename V> void SettingSet(in
   SettingSet(cs->State.G, &cs->Setting, index, value);
 }
 
+// Rotates the ANISOU vector
+bool RotateU(const double *matrix, float *anisou);
+
 #endif
diff -upNr pymol-open-source-2.3.0/layer2/ObjectGadgetRamp.cpp pymol-open-source-2.3.2/layer2/ObjectGadgetRamp.cpp
--- pymol-open-source-2.3.0/layer2/ObjectGadgetRamp.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer2/ObjectGadgetRamp.cpp	2019-05-27 15:31:39.008719515 +0200
@@ -51,9 +51,6 @@ void ObjectGadgetRampFree(ObjectGadgetRa
   OOFreeP(I);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static void ObjectGadgetRampCalculate(ObjectGadgetRamp * I, float v, float *result)
 {
   const float _1 = 1.0F;
@@ -219,9 +216,6 @@ static int _ObjectGadgetRampInterpolate(
   return (ok);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int _ObjectGadgetRampBlend(ObjectGadgetRamp * I, float *color,
                                   const float *table, int mode)
 {
diff -upNr pymol-open-source-2.3.0/layer2/ObjectMesh.cpp pymol-open-source-2.3.2/layer2/ObjectMesh.cpp
--- pymol-open-source-2.3.0/layer2/ObjectMesh.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer2/ObjectMesh.cpp	2019-05-27 15:31:39.000719526 +0200
@@ -782,7 +782,7 @@ static short ObjectMeshStateRenderShader
     RenderInfo *info, short mesh_as_cylinders, float mesh_width)
 {
   PyMOLGlobals *G = I->Obj.G;
-  CShaderPrg *shaderPrg;
+  CShaderPrg *shaderPrg  = nullptr;
 
   if (!mesh_as_cylinders) {
     shaderPrg = G->ShaderMgr->Enable_DefaultShader(info->pass);
@@ -795,6 +795,10 @@ static short ObjectMeshStateRenderShader
 
   CGORenderGL(ms->shaderCGO, NULL, NULL, NULL, info, NULL);
 
+  if (shaderPrg) {
+    shaderPrg->Disable();
+  }
+
   if (ms->shaderUnitCellCGO){
     shaderPrg = G->ShaderMgr->Enable_DefaultShader(info->pass);
     shaderPrg->SetLightingEnabled(0);
diff -upNr pymol-open-source-2.3.0/layer2/Sculpt.cpp pymol-open-source-2.3.2/layer2/Sculpt.cpp
--- pymol-open-source-2.3.0/layer2/Sculpt.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer2/Sculpt.cpp	2019-05-27 15:31:39.008719515 +0200
@@ -70,9 +70,6 @@ Z* -------------------------------------
 (((((a)^((a)>>5)))&0x00FF)|\
  (((    ((b)<<5)))&0xFF00))
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static float ShakerDoDist(float target, float *v0, float *v1, float *d0to1, float *d1to0,
                           float wt)
 {
@@ -104,9 +101,6 @@ static float ShakerDoDist(float target,
   return result;
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static float ShakerDoTors(int type, float *v0, float *v1, float *v2, float *v3,
                           float *p0, float *p1, float *p2, float *p3, float tole,
                           float wt)
@@ -193,9 +187,6 @@ static float ShakerDoTors(int type, floa
 
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static float ShakerDoDistLimit(float target, float *v0, float *v1, float *d0to1,
                                float *d1to0, float wt)
 {
@@ -217,9 +208,6 @@ static float ShakerDoDistLimit(float tar
   }
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static float ShakerDoDistMinim(float target, float *v0, float *v1, float *d0to1,
                                float *d1to0, float wt)
 {
@@ -1417,9 +1405,6 @@ void SculptMeasureObject(CSculpt * I, Ob
 
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int SculptCheckBump(float *v1, float *v2, float *diff, float *dist, float cutoff)
 {
   float d2;
@@ -1440,9 +1425,6 @@ static int SculptCheckBump(float *v1, fl
   return (false);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int SculptCGOBump(float *v1, float *v2,
                          float vdw1, float vdw2,
                          float cutoff,
@@ -1552,9 +1534,6 @@ static int SculptCGOBump(float *v1, floa
   }
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int SculptDoBump(float target, float actual, float *d,
                         float *d0to1, float *d1to0, float wt, float *strain)
 {
@@ -1579,9 +1558,6 @@ static int SculptDoBump(float target, fl
   return 0;
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int SculptCheckAvoid(float *v1, float *v2, float *diff,
                             float *dist, float avoid, float range)
 {
@@ -1607,9 +1583,6 @@ static int SculptCheckAvoid(float *v1, f
   return (false);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int SculptDoAvoid(float avoid, float range, float actual, float *d,
                          float *d0to1, float *d1to0, float wt, float *strain)
 {
diff -upNr pymol-open-source-2.3.0/layer3/Executive.cpp pymol-open-source-2.3.2/layer3/Executive.cpp
--- pymol-open-source-2.3.0/layer3/Executive.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer3/Executive.cpp	2019-05-27 15:31:39.004719520 +0200
@@ -1580,7 +1580,7 @@ static void ExecutiveInvalidateSceneMemb
   I->ValidSceneMembers = false;
 }
 
-static void ExecutiveUpdateSceneMembers(PyMOLGlobals * G)
+void ExecutiveUpdateSceneMembers(PyMOLGlobals * G)
 {
   CExecutive *I = G->Executive;
   ExecutiveUpdateGroups(G, false);
diff -upNr pymol-open-source-2.3.0/layer3/Executive.h pymol-open-source-2.3.2/layer3/Executive.h
--- pymol-open-source-2.3.0/layer3/Executive.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer3/Executive.h	2019-05-27 15:31:39.004719520 +0200
@@ -167,6 +167,7 @@ int ExecutiveScrollTo(PyMOLGlobals * G,
 
 void ExecutiveInvalidateGroups(PyMOLGlobals * G, int force);
 void ExecutiveUpdateGroups(PyMOLGlobals * G, int force);
+void ExecutiveUpdateSceneMembers(PyMOLGlobals*);
 
 int *ExecutiveGetG3d(PyMOLGlobals * G);
 int ExecutiveOrder(PyMOLGlobals * G, const char *s1, int sort, int location);
diff -upNr pymol-open-source-2.3.0/layer3/MaeExportHelpers.cpp pymol-open-source-2.3.2/layer3/MaeExportHelpers.cpp
--- pymol-open-source-2.3.0/layer3/MaeExportHelpers.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer3/MaeExportHelpers.cpp	2019-05-27 15:31:39.004719520 +0200
@@ -197,3 +197,39 @@ std::string MaeExportGetSubGroupId(PyMOL
 
   return subgroupid;
 }
+
+/*
+ * Get parsable string representation, with quotes and escaped
+ * quotes/backslashes if needed.
+ */
+std::string MaeExportStrRepr(const char * text)
+{
+  if (text[0] /* not empty string */) {
+    bool needquotes = false;
+
+    // check accepted ascii characters
+    for (const char * p = text; *p; ++p) {
+      if (*p < '$' || *p > 'z' || *p == '\\') {
+        needquotes = true;
+        break;
+      }
+    }
+
+    if (!needquotes) {
+      return text;
+    }
+  }
+
+  std::string quoted_text;
+  quoted_text.reserve(strlen(text) + 2);
+  quoted_text += '"';
+
+  for (const char * p = text; *p; ++p) {
+    if (*p == '"' || *p == '\\')
+      quoted_text += '\\';
+    quoted_text += *p;
+  }
+
+  quoted_text += '"';
+  return quoted_text;
+}
diff -upNr pymol-open-source-2.3.0/layer3/MaeExportHelpers.h pymol-open-source-2.3.2/layer3/MaeExportHelpers.h
--- pymol-open-source-2.3.0/layer3/MaeExportHelpers.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer3/MaeExportHelpers.h	2019-05-27 15:31:39.004719520 +0200
@@ -31,4 +31,6 @@ std::string MaeExportGetLabelUserText(Py
 std::string MaeExportGetSubGroupId(PyMOLGlobals * G,
     const CObject * obj);
 
+std::string MaeExportStrRepr(const char * text);
+
 // vi:sw=2:expandtab
diff -upNr pymol-open-source-2.3.0/layer3/MoleculeExporter.cpp pymol-open-source-2.3.2/layer3/MoleculeExporter.cpp
--- pymol-open-source-2.3.0/layer3/MoleculeExporter.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer3/MoleculeExporter.cpp	2019-05-27 15:31:39.008719515 +0200
@@ -1063,6 +1063,55 @@ struct MoleculeExporterMAE : public Mole
   int m_n_atoms_offset;
   int m_n_arom_bonds;
   std::map<int, const AtomInfoType *> m_atoms;
+  bool m_has_anisou;
+
+#ifdef _PYMOL_MAE_PROP_EXPORT
+#endif
+
+  /* Check if current object has any ANISOU data
+   */
+  bool currentObjectHasAnisou() const {
+    for (auto i = 0; i < m_iter.obj->NAtom; ++i) {
+      if (m_iter.obj->AtomInfo[i].has_anisou()) {
+        return true;
+      }
+    }
+
+    return false;
+  }
+
+  /* Write a single string value to the output buffer
+   */
+  void writeMaeValue(const char * s) {
+    auto s_quoted = MaeExportStrRepr(s);
+    m_offset += VLAprintf(m_buffer, m_offset, "%s\n", s_quoted.c_str());
+  }
+
+  /* Write the given keys to the output buffer.
+   * Add type prefix and make key unique if necessary.
+   */
+  void writeMaeKeys(const std::vector<std::string> &keys) {
+    std::set<std::string> unique_keys;
+
+    for (auto key : keys) {
+      // check for "<type>_" prefix or add one
+      if (key.size() < 2 || key[1] != '_' || !strchr("irsb", key[0])) {
+        key = "s_pymol_" + key;
+      }
+
+      auto key_size = key.size();
+
+      // make key unique (append numbers)
+      for (unsigned i = 1; unique_keys.count(key); ++i) {
+        key.resize(key_size);
+        key += std::to_string(i);
+      }
+
+      unique_keys.insert(key);
+
+      writeMaeValue(key.c_str());
+    }
+  }
 
   // quasi constructor
   void init(PyMOLGlobals * G_) override {
@@ -1089,43 +1138,91 @@ struct MoleculeExporterMAE : public Mole
 
     m_offset += VLAprintf(m_buffer, m_offset,
         "\nf_m_ct {\n"
-        "s_m_subgroupid\n"
-        "s_m_title\n"
+        );
+
+    std::vector<std::string> keys {
+      "s_m_title",
+    };
+
+    if (!groupid.empty()) {
+      keys.emplace_back("s_m_subgroupid");
+    }
+
+#ifdef _PYMOL_MAE_PROP_EXPORT
+#endif
+
+    writeMaeKeys(keys);
+
+    m_offset += VLAprintf(m_buffer, m_offset,
         ":::\n"
-        "\"%s\"\n"
-        "\"%s\"\n",
-        groupid.c_str(),
-        getTitleOrName());
+        );
+
+    // title may contain spaces or quotes
+    writeMaeValue(getTitleOrName());
+
+    if (!groupid.empty()) {
+      m_offset += VLAprintf(m_buffer, m_offset, "\"%s\"\n", groupid.c_str());
+    }
+
+#ifdef _PYMOL_MAE_PROP_EXPORT
+#endif
 
     // defer until number of atoms known
     m_n_atoms_offset = m_offset;
 
+    keys = {
+      "i_m_mmod_type",
+      "r_m_x_coord",
+      "r_m_y_coord",
+      "r_m_z_coord",
+      "i_m_residue_number",
+      "s_m_insertion_code",
+      "s_m_chain_name",
+      "s_m_pdb_residue_name",
+      "s_m_pdb_atom_name",
+      "i_m_atomic_number",
+      "i_m_formal_charge",
+      "s_m_color_rgb",
+      "i_m_secondary_structure",
+      "r_m_pdb_occupancy",
+      "i_pdb_PDB_serial",
+
+      "r_m_pdb_tfactor",
+      "r_m_charge1",
+
+      "i_m_visibility",
+      "i_m_representation",
+      "i_m_ribbon_style",
+      "i_m_ribbon_color",
+      "s_m_ribbon_color_rgb",
+      "s_m_label_format",
+      "i_m_label_color",
+      "s_m_label_user_text",
+    };
+
+    // ANISOU
+    if ((m_has_anisou = currentObjectHasAnisou())) {
+      keys.insert(keys.end(), {
+        "i_pdb_anisou_u11",
+        "i_pdb_anisou_u22",
+        "i_pdb_anisou_u33",
+        "i_pdb_anisou_u12",
+        "i_pdb_anisou_u13",
+        "i_pdb_anisou_u23",
+      });
+    }
+
     m_offset += VLAprintf(m_buffer, m_offset,
         "m_atom[X]            {\n" // place holder
         "# First column is atom index #\n"
-        "i_m_mmod_type\n"
-        "r_m_x_coord\n"
-        "r_m_y_coord\n"
-        "r_m_z_coord\n"
-        "i_m_residue_number\n"
-        "s_m_insertion_code\n"
-        "s_m_chain_name\n"
-        "s_m_pdb_residue_name\n"
-        "s_m_pdb_atom_name\n"
-        "i_m_atomic_number\n"
-        "i_m_formal_charge\n"
-        "s_m_color_rgb\n"
-        "i_m_secondary_structure\n"
-        "r_m_pdb_occupancy\n"
-        "i_pdb_PDB_serial\n"
-        "i_m_visibility\n"
-        "i_m_representation\n"
-        "i_m_ribbon_style\n"
-        "i_m_ribbon_color\n"
-        "s_m_ribbon_color_rgb\n"
-        "s_m_label_format\n"
-        "i_m_label_color\n"
-        "s_m_label_user_text\n"
+        );
+
+#ifdef _PYMOL_MAE_PROP_EXPORT
+#endif
+
+    writeMaeKeys(keys);
+
+    m_offset += VLAprintf(m_buffer, m_offset,
         ":::\n");
 
     m_n_atoms = 0;
@@ -1152,16 +1249,25 @@ struct MoleculeExporterMAE : public Mole
     if (ai->name)
       AtomInfoGetAlignedPDBAtomName(G, ai, resn, name);
 
+    // 4-letter padding for atom name
+    for (auto i = strlen(name); i < 4; ++i) {
+      name[i] = ' ';
+    }
+    name[4] = '\0';
+
+    // 1-letter padding for chain
+    const char* chain = ai->chain ? LexStr(G, ai->chain) : " ";
+
     m_offset += VLAprintf(m_buffer, m_offset,
-        "%d %d %.3f %.3f %.3f %d %s %s \"%-4s\" \"%-4s\" %d %d %02X%02X%02X %d %.2f %d\n",
+        "%d %d %.3f %.3f %.3f %d %s %s \"%-4s\" %s %d %d %02X%02X%02X %d %.2f %d\n",
         getTmpID(),
         getMacroModelAtomType(ai),
         m_coord[0], m_coord[1], m_coord[2],
         ai->resv,
         inscode,
-        ai->chain ? LexStr(G, ai->chain) : "\" \"",
+        MaeExportStrRepr(chain).c_str(),
         resn,
-        name,
+        MaeExportStrRepr(name).c_str(),
         ai->protons,
         ai->formalCharge,
         int(rgb[0] * 255),
@@ -1171,6 +1277,11 @@ struct MoleculeExporterMAE : public Mole
         ai->q,
         ai->id);
 
+    m_offset += VLAprintf(m_buffer, m_offset,
+        "%.2f %.2f ",
+        ai->b,
+        ai->partialCharge);
+
     char ribbon_color_rgb[7] = "<>";
     MaeExportGetRibbonColor(G, m_iter, ribbon_color_rgb);
     std::string label_user_text = MaeExportGetLabelUserText(G, ai);
@@ -1185,6 +1296,28 @@ struct MoleculeExporterMAE : public Mole
         label_user_text.empty() ? "" : "%UT",
         label_user_text.c_str());
 
+    // ANISOU
+    if (m_has_anisou) {
+      if (ai->has_anisou()) {
+        float anisou[6];
+        std::copy_n(ai->get_anisou(), 6, anisou);
+
+        if (m_mat_full.ptr) {
+          RotateU(m_mat_full.ptr, anisou);
+        }
+
+        m_offset += VLAprintf(m_buffer, m_offset,
+            "%.0f %.0f %.0f %.0f %.0f %.0f\n",
+            anisou[0] * 1e4, anisou[1] * 1e4, anisou[2] * 1e4,
+            anisou[3] * 1e4, anisou[4] * 1e4, anisou[5] * 1e4);
+      } else {
+        m_offset += VLAprintf(m_buffer, m_offset, "<> <> <> <> <> <>\n");
+      }
+    }
+
+#ifdef _PYMOL_MAE_PROP_EXPORT
+#endif
+
     m_atoms[getTmpID()] = ai;
 
     ++m_n_atoms;
diff -upNr pymol-open-source-2.3.0/layer3/Selector.cpp pymol-open-source-2.3.2/layer3/Selector.cpp
--- pymol-open-source-2.3.0/layer3/Selector.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer3/Selector.cpp	2019-05-27 15:31:39.008719515 +0200
@@ -14,6 +14,8 @@ I* Additional authors of this source fil
 Z* -------------------------------------------------------------------
 */
 
+#include <algorithm>
+#include <string>
 #include <vector>
 
 #include"os_python.h"
@@ -65,37 +67,6 @@ Z* -------------------------------------
 /* special selections, unknown to executive */
 #define cColorectionFormat "_!c_%s_%d"
 
-#if 0
-// A lot of PyMOL's utility code used to select with lower case atomic
-// identifiers, making the code dependent on "ignore_case=1". The default
-// for this setting was changed to "0 (off)", which required to fix all
-// affected scripts (e.g. mutagenesis wizard, PYMOL-2487).
-// This is a debug/helper function to identify use of lower case
-// identifiers in selection expressions. Remove before the next official
-// release.
-void WARN_IF_LOWERCASE(PyMOLGlobals * G, const char * label, const char * text) {
-  if (!*text)
-    return;
-  for (const char * p = text; *p; ++p)
-    if (isupper(*p))
-      return;
-  PRINTFB(G, FB_Selector, FB_Warnings)
-    "SELECTOR-LOWER-WARNING: %s '%s'\n", label, text
-    ENDFB(G);
-}
-#else
-#define WARN_IF_LOWERCASE(G, a, b)
-#endif
-
-// Count how often `c` occurs in `s`
-static int strchrcount(const char *s, char c) {
-  int i = 0;
-  while(*s)
-    if(*(s++) == c)
-      i++;
-  return i;
-}
-
 static WordKeyValue rep_names[] = {
   {"spheres", cRepSphereBit},
   {"sticks", cRepCylBit},
@@ -129,8 +100,11 @@ typedef struct {
   int level, imp_op_level;
   int type;                     /* 0 = value 1 = operation 2 = pre-operation */
   unsigned int code;
-  SelectorWordType text;
+  std::string m_text;
   int *sele;
+
+  /// read-only access to text
+  const char* text() const { return m_text.c_str(); }
 } EvalElem;
 
 typedef struct {
@@ -155,8 +129,8 @@ static int SelectorSelect2(PyMOLGlobals
 static int SelectorLogic1(PyMOLGlobals * G, EvalElem * base, int state);
 static int SelectorLogic2(PyMOLGlobals * G, EvalElem * base);
 static int SelectorOperator22(PyMOLGlobals * G, EvalElem * base, int state);
-static int *SelectorEvaluate(PyMOLGlobals * G, SelectorWordType * word, int state, int quiet);
-static SelectorWordType *SelectorParse(PyMOLGlobals * G, const char *s);
+static int *SelectorEvaluate(PyMOLGlobals* G, std::vector<std::string>& word, int state, int quiet);
+static std::vector<std::string> SelectorParse(PyMOLGlobals * G, const char *s);
 static void SelectorPurgeMembers(PyMOLGlobals * G, int sele);
 static int SelectorEmbedSelection(PyMOLGlobals * G, int *atom, const char *name,
                                   ObjectMolecule * obj, int no_dummies, int exec_manage);
@@ -670,6 +644,8 @@ static WordKeyValue Keyword[] = {
   {"sidechain", SELE_SC_z},
   {"sc.", SELE_SC_z},
 
+  {"p.", SELE_PROP},
+
   {"x", SELE_XVLx},
   {"y", SELE_YVLx},
   {"z", SELE_ZVLx},
@@ -7919,27 +7895,13 @@ int SelectorUpdateTableImpl(PyMOLGlobals
 /*========================================================================*/
 static int *SelectorSelect(PyMOLGlobals * G, const char *sele, int state, int domain, int quiet)
 {
-  SelectorWordType *parsed;
   int *result = NULL;
   PRINTFD(G, FB_Selector)
     "SelectorSelect-DEBUG: sele = \"%s\"\n", sele ENDFD;
   SelectorUpdateTable(G, state, domain);
-  parsed = SelectorParse(G, sele);
-  if(parsed) {
-    if(Feedback(G, FB_Selector, FB_Debugging)) {
-      SelectorWordType *a;
-      fprintf(stderr, "SelectorSelect-DEBUG: parsed tokens:\n");
-      a = parsed;
-      while(1) {
-        if(!a[0][0])
-          break;
-        fprintf(stderr, "  \"%s\"\n", (a[0]));
-        a++;
-      }
-      fprintf(stderr, "SelectorSelect-DEBUG: end of tokens.\n");
-    }
+  auto parsed = SelectorParse(G, sele);
+  if (!parsed.empty()) {
     result = SelectorEvaluate(G, parsed, state, quiet);
-    VLAFreeP(parsed);
   }
   return (result);
 }
@@ -7979,7 +7941,7 @@ static int SelectorModulate1(PyMOLGlobal
   switch (base[1].code) {
   case SELE_ARD_:
   case SELE_EXP_:
-    if(!sscanf(base[2].text, "%f", &dist))
+    if(!sscanf(base[2].text(), "%f", &dist))
       ok = ErrMessage(G, "Selector", "Invalid distance.");
     if(ok) {
       for(d = 0; d < I->NCSet; d++) {
@@ -8048,7 +8010,7 @@ static int SelectorModulate1(PyMOLGlobal
     break;
 
   case SELE_EXT_:
-    if(sscanf(base[2].text, "%d", &nbond) != 1)
+    if(sscanf(base[2].text(), "%d", &nbond) != 1)
       ok = ErrMessage(G, "Selector", "Invalid bond count.");
     if(ok) {
       ObjectMolecule *lastObj = NULL;
@@ -8084,7 +8046,7 @@ static int SelectorModulate1(PyMOLGlobal
     break;
 
   case SELE_GAP_:
-    if(!sscanf(base[2].text, "%f", &dist))
+    if(!sscanf(base[2].text(), "%f", &dist))
       ok = ErrMessage(G, "Selector", "Invalid distance.");
     if(ok) {
       for(a = 0; a < I->NAtom; a++) {
@@ -8434,7 +8396,6 @@ static int SelectorSelect1(PyMOLGlobals
   int flag;
   int ok = true;
   int index, state;
-  char *np;
   int rep_mask;
   const char *wildcard = SettingGetGlobal_s(G, cSetting_wildcard);
 
@@ -8448,13 +8409,13 @@ static int SelectorSelect1(PyMOLGlobals
   ErrChkPtr(G, base->sele);
   switch (base->code) {
   case SELE_PEPs:
-    if(base[1].text[0]) {
+    if(base[1].text()[0]) {
       AtomInfoType *last_ai0 = NULL, *ai0;
       for(a = cNDummyAtoms; a < I_NAtom; a++) {
         ai0 = i_obj[i_table[a].model]->AtomInfo + i_table[a].atom;
         if(!AtomInfoSameResidueP(G, ai0, last_ai0)) {   /* new starting residue */
           int match_found = false;
-          char *ch = base[1].text;      /* sequence argument */
+          const char *ch = base[1].text();      /* sequence argument */
           AtomInfoType *ai1, *last_ai1 = NULL;
           for(b = a; b < I_NAtom; b++) {
             ai1 = i_obj[i_table[b].model]->AtomInfo + i_table[b].atom;
@@ -8473,7 +8434,7 @@ static int SelectorSelect1(PyMOLGlobals
             }
           }
           if(match_found) {
-            char *ch = base[1].text;    /* sequence argument */
+            const char *ch = base[1].text();    /* sequence argument */
             AtomInfoType *ai1, *last_ai1 = NULL, *ai2;
             for(b = a; b < I_NAtom; b++) {
               ai1 = i_obj[i_table[b].model]->AtomInfo + i_table[b].atom;
@@ -8508,7 +8469,7 @@ static int SelectorSelect1(PyMOLGlobals
 
       WordMatchOptionsConfigInteger(&options);
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8529,7 +8490,7 @@ static int SelectorSelect1(PyMOLGlobals
 
       WordMatchOptionsConfigInteger(&options);
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8554,7 +8515,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8572,7 +8533,6 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_NAMs:
-    WARN_IF_LOWERCASE(G, "name", base[1].text);
     {
       CWordMatchOptions options;
       const char *atom_name_wildcard = SettingGetGlobal_s(G, cSetting_atom_name_wildcard);
@@ -8582,7 +8542,7 @@ static int SelectorSelect1(PyMOLGlobals
 
       WordMatchOptionsConfigAlphaList(&options, atom_name_wildcard[0], ignore_case);
 
-      matcher = WordMatcherNew(G, base[1].text, &options, false);
+      matcher = WordMatcherNew(G, base[1].text(), &options, false);
 
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
@@ -8604,9 +8564,9 @@ static int SelectorSelect1(PyMOLGlobals
             options.wildcard = atom_name_wildcard[0];
             if(matcher)
               WordMatcherFree(matcher);
-            matcher = WordMatcherNew(G, base[1].text, &options, false);
+            matcher = WordMatcherNew(G, base[1].text(), &options, false);
             if(!matcher)
-              WordPrimeCommaMatch(G, base[1].text);
+              WordPrimeCommaMatch(G, &base[1].m_text[0] /* replace '+' with ',' */);
           }
           last_obj = obj;
         }
@@ -8617,7 +8577,7 @@ static int SelectorSelect1(PyMOLGlobals
             WordMatcherMatchAlpha(matcher,
                                   name);
         else
-          hit_flag = (WordMatchCommaExact(G, base[1].text,
+          hit_flag = (WordMatchCommaExact(G, base[1].text(),
                                           name,
                                           ignore_case) < 0);
 
@@ -8639,7 +8599,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
 	AtomInfoType * ai;
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
@@ -8660,7 +8620,6 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_ELEs:
-    WARN_IF_LOWERCASE(G, "element", base[1].text);
     {
       CWordMatchOptions options;
 
@@ -8669,7 +8628,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8694,7 +8653,7 @@ static int SelectorSelect1(PyMOLGlobals
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 #ifndef NO_MMLIBS
@@ -8716,9 +8675,9 @@ static int SelectorSelect1(PyMOLGlobals
     break;
   case SELE_REPs:
     rep_mask = 0;
-    WordPrimeCommaMatch(G, base[1].text);
+    WordPrimeCommaMatch(G, &base[1].m_text[0] /* replace '+' with ',' */);
     for(a = 0; rep_names[a].word[0]; a++) {
-      if(WordMatchComma(G, base[1].text, rep_names[a].word, ignore_case) < 0)
+      if(WordMatchComma(G, base[1].text(), rep_names[a].word, ignore_case) < 0)
         rep_mask |= rep_names[a].value;
     }
     for(SelectorAtomIterator iter(I); iter.next();) {
@@ -8731,7 +8690,7 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_COLs:
-    col_idx = ColorGetIndex(G, base[1].text);
+    col_idx = ColorGetIndex(G, base[1].text());
     for(a = cNDummyAtoms; a < I_NAtom; a++) {
       base[0].sele[a] = false;
       if(i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].color == col_idx) {
@@ -8744,7 +8703,7 @@ static int SelectorSelect1(PyMOLGlobals
   case SELE_RCLs:
     // setting index
     index = (base->code == SELE_CCLs) ? cSetting_cartoon_color : cSetting_ribbon_color;
-    col_idx = ColorGetIndex(G, base[1].text);
+    col_idx = ColorGetIndex(G, base[1].text());
     for(a = cNDummyAtoms; a < I_NAtom; a++) {
       base[0].sele[a] = false;
       {
@@ -8789,7 +8748,7 @@ static int SelectorSelect1(PyMOLGlobals
           printf("coding error: missing case\n");
       }
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8808,7 +8767,6 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_SSTs:
-    WARN_IF_LOWERCASE(G, "ss", base[1].text);
     {
       CWordMatchOptions options;
 
@@ -8817,7 +8775,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8835,7 +8793,7 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_STAs:
-    sscanf(base[1].text, "%d", &state);
+    sscanf(base[1].text(), "%d", &state);
     state = state - 1;
     obj = NULL;
 
@@ -8869,7 +8827,6 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_ALTs:
-    WARN_IF_LOWERCASE(G, "alt", base[1].text);
     {
       CWordMatchOptions options;
 
@@ -8878,7 +8835,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8895,7 +8852,7 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_FLGs:
-    sscanf(base[1].text, "%d", &flag);
+    sscanf(base[1].text(), "%d", &flag);
     flag = (1 << flag);
     for(a = cNDummyAtoms; a < I_NAtom; a++) {
       if(i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].flags & flag) {
@@ -8911,7 +8868,7 @@ static int SelectorSelect1(PyMOLGlobals
 
       WordMatchOptionsConfigInteger(&options);
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8938,7 +8895,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8956,7 +8913,6 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_RSNs:
-    WARN_IF_LOWERCASE(G, "resn", base[1].text);
     {
       CWordMatchOptions options;
 
@@ -8965,7 +8921,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8983,7 +8939,8 @@ static int SelectorSelect1(PyMOLGlobals
     break;
   case SELE_SELs:
     {
-      char *word = base[1].text;
+      const char *word = base[1].text();
+      WordType activeselename = "";
       int enabled_only = false;
       CWordMatchOptions options;
 
@@ -9052,7 +9009,16 @@ static int SelectorSelect1(PyMOLGlobals
           ExecutiveFreeGroupList(G, group_list_id);
         }
 
-      } else if((!enabled_only) || ExecutiveGetActiveSeleName(G, word, false, false)) {
+      } else if((!enabled_only) || ExecutiveGetActiveSeleName(G, activeselename, false, false)) {
+        if (activeselename[0]) {
+          // TODO not sure if this is intentional. If the active selection is
+          // "foo", then the expression "??bar" will evaluate to "foo". I assume
+          // the intention was to evaluate to the empty selection if "bar" is
+          // not active, and to "bar" in case it's active.
+          // Used with cmd.select(..., merge=2)
+          base[1].m_text = activeselename;
+          word = base[1].text();
+        }
         sele = SelectGetNameOffset(G, word, 1, ignore_case);
         if(sele >= 0) {
           MemberType *I_Member = I->Member;
@@ -9086,7 +9052,7 @@ static int SelectorSelect1(PyMOLGlobals
                 c++;
             }
             ExecutiveFreeGroupList(G, group_list_id);
-          } else if(base[1].text[0] == '?') {   /* undefined ?sele allowed */
+          } else if(base[1].m_text[0] == '?') {   /* undefined ?sele allowed */
             for(a = cNDummyAtoms; a < I_NAtom; a++)
               base[0].sele[a] = false;
           } else {
@@ -9105,12 +9071,14 @@ static int SelectorSelect1(PyMOLGlobals
     /* first, trim off and record the atom index if one exists */
 
     index = -1;
-    if((np = strstr(base[1].text, "`"))) {
-      *np = 0;
+    auto pos = base[1].m_text.find('`');
+    if (pos != std::string::npos) {
+      const char* np = base[1].text() + pos;
       if(sscanf(np + 1, "%d", &index) != 1)
         index = -1;
       else
         index--;
+      base[1].m_text.resize(pos);
     }
     model = 0;
 
@@ -9118,7 +9086,7 @@ static int SelectorSelect1(PyMOLGlobals
       CWordMatchOptions options;
       WordMatchOptionsConfigAlpha(&options, wildcard[0], ignore_case);
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, false))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, false))) {
 
         int obj_matches = false;
 
@@ -9147,7 +9115,7 @@ static int SelectorSelect1(PyMOLGlobals
         WordMatcherFree(matcher);
       } else {
 
-        obj = (ObjectMolecule *) ExecutiveFindObjectByName(G, base[1].text);
+        obj = (ObjectMolecule *) ExecutiveFindObjectByName(G, base[1].text());
         if(obj) {
           for(a = cNDummyModels; a < I->NModel; a++)
             if(i_obj[a] == obj) {
@@ -9156,7 +9124,7 @@ static int SelectorSelect1(PyMOLGlobals
             }
         }
         if(!model)
-          if(sscanf(base[1].text, "%i", &model) == 1) {
+          if(sscanf(base[1].text(), "%i", &model) == 1) {
             if(model <= 0)
               model = 0;
             else if(model > I->NModel)
@@ -9188,7 +9156,7 @@ static int SelectorSelect1(PyMOLGlobals
           }
         } else {
           PRINTFB(G, FB_Selector, FB_Errors)
-            " Selector-Error: invalid model \"%s\".\n", base[1].text ENDFB(G);
+            " Selector-Error: invalid model \"%s\".\n", base[1].text() ENDFB(G);
           ok = false;
         }
       }
@@ -9221,12 +9189,12 @@ static int SelectorSelect2(PyMOLGlobals
   case SELE_XVLx:
   case SELE_YVLx:
   case SELE_ZVLx:
-    oper = WordKey(G, AtOper, base[1].text, 4, ignore_case, &exact);
+    oper = WordKey(G, AtOper, base[1].text(), 4, ignore_case, &exact);
     switch (oper) {
     case SCMP_GTHN:
     case SCMP_LTHN:
     case SCMP_EQAL:
-      if(sscanf(base[2].text, "%f", &comp1) != 1)
+      if(sscanf(base[2].text(), "%f", &comp1) != 1)
         ok = ErrMessage(G, "Selector", "Invalid Number");
       break;
     default:
@@ -9278,7 +9246,7 @@ static int SelectorSelect2(PyMOLGlobals
   case SELE_FCHx:
   case SELE_BVLx:
   case SELE_QVLx:
-    oper = WordKey(G, AtOper, base[1].text, 4, ignore_case, &exact);
+    oper = WordKey(G, AtOper, base[1].text(), 4, ignore_case, &exact);
     if(!oper)
       ok = ErrMessage(G, "Selector", "Invalid Operator.");
     if(ok) {
@@ -9286,7 +9254,7 @@ static int SelectorSelect2(PyMOLGlobals
       case SCMP_GTHN:
       case SCMP_LTHN:
       case SCMP_EQAL:
-        if(sscanf(base[2].text, "%f", &comp1) != 1)
+        if(sscanf(base[2].text(), "%f", &comp1) != 1)
           ok = ErrMessage(G, "Selector", "Invalid Number");
         break;
       }
@@ -9450,6 +9418,13 @@ static int SelectorSelect2(PyMOLGlobals
 /*========================================================================*/
 static int SelectorSelect3(PyMOLGlobals * G, EvalElem * base, int state)
 {
+  switch (base->code) {
+  case SELE_PROP:
+    ErrMessage(G, "Selector", "properties (p.) not supported in Open-Source PyMOL");
+    return false;
+  }
+  return true;
+ok_except1:
   return false;
 }
 
@@ -10244,7 +10219,7 @@ int SelectorOperator22(PyMOLGlobals * G,
   case SELE_WIT_:
   case SELE_BEY_:
   case SELE_NTO_:
-    if(!sscanf(base[2].text, "%f", &dist))
+    if(!sscanf(base[2].text(), "%f", &dist))
       ok = ErrMessage(G, "Selector", "Invalid distance.");
     if(ok) {
       if(dist < 0.0)
@@ -10337,16 +10312,32 @@ int SelectorOperator22(PyMOLGlobals * G,
   return (1);
 }
 
-static void remove_quotes(char *st)
+/**
+ * Removes matching quotes from a string, at string start as well as after word
+ * list separators ("+" and ","). Does not consider backslash escaping.
+ *
+ * Examples (not sure if all of these are intentional):
+ * @verbatim
+   "foo bar" -> foo bar
+   'foo bar' -> foo bar
+   "foo"+'bar' -> foo+bar
+   "foo bar\" -> foo bar\       # backslash has no escape function
+   "foo" "bar" -> foo "bar"     # second pair of quotes not after separator
+   foo''+''bar -> foo''+bar     # first pair of quotes not after separator
+   "foo"bar" -> foobar"         # third quote unmatched
+   foo'+'bar -> foo'+'bar       # no matching quotes after separator
+   @endverbatim
+ */
+static void remove_quotes(std::string& str)
 {
   /* nasty */
 
-  SelectorWordType store;
+  char *st = &str[0];
   char *p, *q;
   char *quote_start = NULL;
   char active_quote = 0;
   p = st;
-  q = store;
+  q = st;
 
   while(*p) {
     if(((*p) == 34) || ((*p) == 39)) {
@@ -10358,8 +10349,8 @@ static void remove_quotes(char *st)
         q--;
         quote_start = NULL;
         p++;
+        continue;
       } else if(quote_start) {
-        *(q++) = *(p++);
       } else {
         if(p == st) {           /* at start => real quote */
           quote_start = q;
@@ -10368,38 +10359,35 @@ static void remove_quotes(char *st)
           quote_start = q;
           active_quote = *p;
         }
-        *(q++) = *(p++);
       }
-    } else {
-      /* UNWORKABLE -- hopelly getting rid of this kludge will not cause major grief 
-         if((*p=='+')&&(!quote_start))
-         if(!((*(p+1)==0)||(*(p+1)==',')||(*(p+1)=='+')))
-         *p=',';
-       */
-      *(q++) = *(p++);
     }
+    if (q < p) {
+      *q = *p;
+    }
+    ++q;
+    ++p;
+  }
+  if (q < p) {
+    str.resize(q - st);
   }
-  *(q++) = 0;
-  strcpy(st, store);
-
 }
 
 #define STACK_PUSH_VALUE(value) { \
   depth++; \
-  VLACheck(Stack, EvalElem, depth); \
-  e = Stack + depth; \
+  VecCheck(Stack, depth); \
+  e = Stack.data() + depth; \
   e->level = (level << 4) + 1; \
   e->imp_op_level = (imp_op_level << 4) + 1; \
   imp_op_level = level; \
   e->type = STYP_VALU; \
-  strcpy(e->text, value); \
-  remove_quotes(e->text); \
+  e->m_text = value; \
+  remove_quotes(e->m_text); \
 }
 
 #define STACK_PUSH_OPERATION(ocode) { \
   depth++; \
-  VLACheck(Stack, EvalElem, depth); \
-  e = Stack + depth; \
+  VecCheck(Stack, depth); \
+  e = Stack.data() + depth; \
   e->code = ocode; \
   e->level = (level << 4) + ((e->code & 0xF0) >> 4); \
   e->imp_op_level = (imp_op_level << 4) + 1; \
@@ -10408,7 +10396,9 @@ static void remove_quotes(char *st)
 }
 
 /*========================================================================*/
-int *SelectorEvaluate(PyMOLGlobals * G, SelectorWordType * word, int state, int quiet)
+int* SelectorEvaluate(PyMOLGlobals* G,
+    std::vector<std::string>& word,
+    int state, int quiet)
 {
   int level = 0, imp_op_level = 0;
   int depth = 0;
@@ -10418,27 +10408,20 @@ int *SelectorEvaluate(PyMOLGlobals * G,
   int valueFlag = 0;            /* are we expecting? */
   int *result = NULL;
   int opFlag, maxLevel;
-  char *q;
   int totDepth = 0;
   int exact = 0;
 
   int ignore_case = SettingGetGlobal_b(G, cSetting_ignore_case);
   /* CFGs can efficiently be parsed by stacks; use a clean stack w/space
-   * for 100 elements */
-  EvalElem *Stack = NULL, *e;
-  SelectorWordType tmpKW;
-  Stack = VLAlloc(EvalElem, 100);
-  CHECKOK(ok, Stack);
-  if (!ok)
-    return NULL;
-  UtilZeroMem(Stack, sizeof(EvalElem)); /* blank first entry */
+   * for 10 (was: 100) elements */
+  EvalElem *e;
+  auto Stack = std::vector<EvalElem>(10);
 
   /* converts all keywords into code, adds them into a operation list */
-  while(ok && word[c][0]) {
+  while(ok && c < word.size()) {
     if(word[c][0] == '#') {
       if((!valueFlag) && (!level)) {
-        word[c][0] = 0;         /* terminate selection if we encounter a comment */
-        word[c + 1][0] = 0;
+        word.resize(c);         /* terminate selection if we encounter a comment */
         break;
       }
     }
@@ -10472,28 +10455,34 @@ int *SelectorEvaluate(PyMOLGlobals * G,
         valueFlag--;
       } else if(valueFlag < 0) {        /* operation parameter i.e. around X<-- */
         depth++;
-        VLACheck(Stack, EvalElem, depth);
-        e = Stack + depth;
+        VecCheck(Stack, depth);
+        e = Stack.data() + depth;
         e->level = (level << 4) + 1;
         e->imp_op_level = (imp_op_level << 4) + 1;
         imp_op_level = level;
         e->type = STYP_PVAL;
-        strcpy(e->text, word[c]);
+        e->m_text = word[c];
         valueFlag++;
       } else {                  /* possible keyword... */
-        code = WordKey(G, Keyword, word[c], 4, ignore_case, &exact);
+        code = WordKey(G, Keyword, word[c].c_str(), 4, ignore_case, &exact);
         if(!code) {
-          b = strlen(word[c]) - 1;
+          b = word[c].size() - 1;
           if((b > 2) && (word[c][b] == ';')) {
             /* kludge to accomodate unnec. ';' usage */
-            word[c][b] = 0;
-            code = WordKey(G, Keyword, word[c], 4, ignore_case, &exact);
+            word[c].resize(b);
+            code = WordKey(G, Keyword, word[c].c_str(), 4, ignore_case, &exact);
+          } else if(!word[c].compare(0, 2, "p.")) {
+            // kludge to parse p.propertyname without space after p.
+            code = SELE_PROP;
+            exact = 1;
+            word[c].erase(0, 2);
+            c--;
           }
         }
         PRINTFD(G, FB_Selector)
           " Selector: code %x\n", code ENDFD;
         if((code > 0) && (!exact))
-          if(SelectorIndexByName(G, word[c]) >= 0)
+          if(SelectorIndexByName(G, word[c].c_str()) >= 0)
             code = 0;           /* favor selections over partial keyword matches */
         if(code) {
           /* this is a known operation */
@@ -10525,9 +10514,8 @@ int *SelectorEvaluate(PyMOLGlobals * G,
             break;
           }
         } else {
-          strcpy(tmpKW, word[c]);
-
-          if((a = strchrcount(tmpKW, '/'))) { /* handle slash notation */
+          if((a = std::count(word[c].begin(), word[c].end(),
+                  '/'))) { /* handle slash notation */
             if(a > 5) {
               ok = ErrMessage(G, "Selector", "too many slashes in macro");
               break;
@@ -10540,7 +10528,8 @@ int *SelectorEvaluate(PyMOLGlobals * G,
             int codes[] = {0, 0, 0}; // null-terminated
             char * values[2];
 
-            q = tmpKW;
+            std::string tmpKW = word[c];
+            char* q = &tmpKW[0];
 
             // if macro starts with "/" then read from left, otherwise
             // read from right
@@ -10599,7 +10588,7 @@ int *SelectorEvaluate(PyMOLGlobals * G,
             if(!b)
               STACK_PUSH_OPERATION(SELE_ALLz);
 
-          } else if(strstr(tmpKW, "`")) { /* handle <object`index> syntax */
+          } else if(word[c].find('`') != std::string::npos) { /* handle <object`index> syntax */
             STACK_PUSH_OPERATION(SELE_MODs);
             valueFlag = 1;
             c--;
@@ -10623,11 +10612,6 @@ int *SelectorEvaluate(PyMOLGlobals * G,
     opFlag = true;
     maxLevel = -1;
     for(a = 1; a <= totDepth; a++) {
-      PRINTFD(G, FB_Selector)
-        " Selector initial stack %d-%p lv: %x co: %d type: %x sele %p\n",
-        a, (void *) (Stack + a), Stack[a].level, Stack[a].code,
-        Stack[a].type, (void *) Stack[a].sele ENDFD;
-
       if(Stack[a].level > maxLevel)
         maxLevel = Stack[a].level;
     }
@@ -10644,12 +10628,6 @@ int *SelectorEvaluate(PyMOLGlobals * G,
         depth = 1;
         opFlag = true;
         while(ok && opFlag) {   /* loop through all entries looking for ops at the current level */
-          PRINTFD(G, FB_Selector)
-            " Selector: lvl: %d de:%d-%p slv:%d co: %x typ %x sele %p td: %d\n",
-            level, depth, (void *) (Stack + depth), Stack[depth].level,
-            Stack[depth].code,
-            Stack[depth].type, (void *) Stack[depth].sele, totDepth ENDFD;
-
           opFlag = false;
 
           if(Stack[depth].level >= level) {
@@ -10687,7 +10665,7 @@ int *SelectorEvaluate(PyMOLGlobals * G,
                   /* two adjacent lists at zeroth priority level
                      for the scope (lowest nibble of level is
                      zero) is an implicit OR action */
-                  VLACheck(Stack, EvalElem, totDepth);
+                  VecCheck(Stack, totDepth + 1);
                   for(a = totDepth; a >= depth; a--)
                     Stack[a + 1] = Stack[a];
                   totDepth++;
@@ -10695,7 +10673,7 @@ int *SelectorEvaluate(PyMOLGlobals * G,
                   Stack[depth].code = SELE_IOR2;
                   Stack[depth].level = Stack[depth].imp_op_level;
                   Stack[depth].sele = NULL;
-                  Stack[depth].text[0] = 0;
+                  Stack[depth].m_text.clear();
                   if(level < Stack[depth].level)
                     level = Stack[depth].level;
                   opFlag = true;
@@ -10812,24 +10790,14 @@ int *SelectorEvaluate(PyMOLGlobals * G,
       if(Stack[a].type == STYP_LIST)
         FreeP(Stack[a].sele);
     }
-    depth = 0;
-    {
-      OrthoLineType line;
-      for(a = 0; a <= c; a++) {
-        q = line;
-        if(a && word[a][0])
-          q = UtilConcat(q, " ");
-        q = UtilConcat(q, word[a]);
-	  PRINTFB(G, FB_Selector, FB_Errors)
-	    "%s", line ENDFB(G);
-      }
-      q = line;
-      q = UtilConcat(q, "<--");
-	PRINTFB(G, FB_Selector, FB_Errors)
-	  "%s\n", line ENDFB(G);
+    for (a = 0; a <= c && a < word.size(); a++) {
+      const char* space = (a && word[a][0]) ? " " : "";
+      PRINTFB(G, FB_Selector, FB_Errors)
+        "%s%s", space, word[a].c_str() ENDFB(G);
     }
+    PRINTFB(G, FB_Selector, FB_Errors)
+      "<--\n" ENDFB(G);
   }
-  VLAFreeP(Stack);
   if(!ok) {
     FreeP(result);
     result = NULL;
@@ -10839,38 +10807,36 @@ int *SelectorEvaluate(PyMOLGlobals * G,
 
 
 /*========================================================================*/
-SelectorWordType *SelectorParse(PyMOLGlobals * G, const char *s)
+/**
+ * Break a selection down into tokens and return them in a vector.
+ * E.g. "(name CA+CB)" -> {"(", "name", "CA+CB", ")"}.
+ * @param s selection expression to parse
+ * @return tokens
+ */
+std::vector<std::string> SelectorParse(PyMOLGlobals * G, const char *s)
 {
-
-  /* break a selection down into its constituent strings and
-     return them in a SelectorWordType VLA, null string terminated */
-
-  SelectorWordType *r = NULL;
-  int c = 0;
   int w_flag = false;
   int quote_flag = false;
   char quote_char = '"';
   const char *p = s;
-  char *q = NULL, *q_base = NULL;
-  r = VLAlloc(SelectorWordType, 100);
+  std::string* q = nullptr;
+  std::vector<std::string> r;
   while(*p) {
     if(w_flag) {                /* currently in a word, thus q is a valid pointer */
       if(quote_flag) {
         if(*p != quote_char) {
-          *q++ = *p;
+          *q += *p;
         } else {
           quote_flag = false;
-          *q++ = *p;
+          *q += *p;
         }
       } else
         switch (*p) {
         case ' ':
-          *q = 0;
           w_flag = false;
           break;
         case ';':              /* special word terminator */
-          *q++ = *p;
-          *q = 0;
+          *q += *p;
           w_flag = false;
           break;
         case '!':              /* single words */
@@ -10882,31 +10848,18 @@ SelectorWordType *SelectorParse(PyMOLGlo
         case '<':
         case '=':
         case '%':
-          *q = 0;               /* terminate current word */
-          c++;
-          VLACheck(r, SelectorWordType, c);     /* add new word */
-          q = r[c - 1];
-          *q++ = *p;
-          *q = 0;               /* terminate current word */
+          r.emplace_back(1, *p); /* add new word */
+          q = &r.back();
           w_flag = false;
           break;
         case '"':
           quote_flag = true;
-          *q++ = *p;
+          *q += *p;
           break;
         default:
-          *q++ = *p;
+          *q += *p;
           break;
         }
-      if(w_flag) {
-        if((q - q_base) >= sizeof(SelectorWordType)) {
-          q_base[sizeof(SelectorWordType) - 1] = 0;
-          w_flag = false;
-          PRINTFB(G, FB_Selector, FB_Errors)
-            "Selector-Error: Word too long. Truncated:\nSelector-Error: %s...\n", q_base
-            ENDFB(G);
-        }
-      }
     } else {                    /*outside a word -- q is undefined */
 
       switch (*p) {
@@ -10919,11 +10872,8 @@ SelectorWordType *SelectorParse(PyMOLGlo
       case '<':
       case '=':
       case '%':
-        c++;
-        VLACheck(r, SelectorWordType, c);
-        q = r[c - 1];
-        *q++ = (*p);
-        *q = 0;
+        r.emplace_back(1, *p); /* add new word */
+        q = &r.back();
         break;
       case ' ':
         break;
@@ -10931,36 +10881,22 @@ SelectorWordType *SelectorParse(PyMOLGlo
         quote_flag = true;
         quote_char = *p;
         w_flag = true;
-        c++;
-        VLACheck(r, SelectorWordType, c);
-        q = r[c - 1];
-        q_base = q;
-        *q++ = *p;
+        r.emplace_back(1, *p); /* add new word */
+        q = &r.back();
         break;
       default:
         w_flag = true;
-        c++;
-        VLACheck(r, SelectorWordType, c);
-        q = r[c - 1];
-        q_base = q;
-        *q++ = *p;
+        r.emplace_back(1, *p); /* add new word */
+        q = &r.back();
         break;
       }
     }
     p++;
   }
-  /* end current word */
-  if(w_flag)
-    *q = 0;
-
-  /* null strings terminate the list */
-  q = r[c];
-  *q = 0;
+
   if(Feedback(G, FB_Selector, FB_Debugging)) {
-    c = 0;
-    while(r[c][0]) {
-      fprintf(stderr, "word: %s\n", r[c]);
-      c++;
+    for (auto& word : r) {
+      fprintf(stderr, "word: %s\n", word.c_str());
     }
   }
   return (r);
diff -upNr pymol-open-source-2.3.0/layer5/PyMOL.cpp pymol-open-source-2.3.2/layer5/PyMOL.cpp
--- pymol-open-source-2.3.0/layer5/PyMOL.cpp	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/layer5/PyMOL.cpp	2019-05-27 15:31:39.008719515 +0200
@@ -230,13 +230,7 @@ typedef struct _CPyMOL {
 
 /* convenience functions -- inline */
 
-#ifdef _PYMOL_INLINE
-#define CC_INLINE __inline__
-#else
-#define CC_INLINE
-#endif
-
-CC_INLINE static PyMOLstatus get_status_ok(int ok)
+inline PyMOLstatus get_status_ok(int ok)
 {
   if(ok)
     return PyMOLstatus_SUCCESS;
@@ -244,14 +238,14 @@ CC_INLINE static PyMOLstatus get_status_
     return PyMOLstatus_FAILURE;
 }
 
-CC_INLINE static PyMOLreturn_status return_status_ok(int ok)
+inline PyMOLreturn_status return_status_ok(int ok)
 {
   PyMOLreturn_status result;
   result.status = get_status_ok(ok);
   return result;
 }
 
-CC_INLINE static PyMOLreturn_status return_status(int status)
+inline PyMOLreturn_status return_status(int status)
 {
   PyMOLreturn_status result;
   result.status = status;
diff -upNr pymol-open-source-2.3.0/modules/pmg_qt/mimic_tk.py pymol-open-source-2.3.2/modules/pmg_qt/mimic_tk.py
--- pymol-open-source-2.3.0/modules/pmg_qt/mimic_tk.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/modules/pmg_qt/mimic_tk.py	2019-05-27 15:31:39.008719515 +0200
@@ -127,17 +127,23 @@ class _qtFileDialog:
                 options.get('initialdir', ''))
 
 
+qtMessageBox = _qtMessageBox()
+qtFileDialog = _qtFileDialog()
+
+# for all Python versions - allows plugin manager to import this with Python 3
+# without importing "tkinter"
+sys.modules['tkMessageBox'] = qtMessageBox
+sys.modules['tkFileDialog'] = qtFileDialog
+
 if sys.version_info[0] < 3:
-    sys.modules['tkMessageBox'] = _qtMessageBox()
-    sys.modules['tkFileDialog'] = _qtFileDialog()
     sys.modules['tkSimpleDialog'] = _qtSimpleDialog()
 else:
     # injecting 'X.Y' into sys.modules without assigning the attribute
     # (import X;X.Y = ...) doesn't work. Use a meta_path solution instead.
 
     mapping = {
-        'tkinter.messagebox': _qtMessageBox(),
-        'tkinter.filedialog': _qtFileDialog(),
+        'tkinter.messagebox': qtMessageBox,
+        'tkinter.filedialog': qtFileDialog,
     }
 
     class MimicTkImporter:
diff -upNr pymol-open-source-2.3.0/modules/pmg_qt/pymol_qt_gui.py pymol-open-source-2.3.2/modules/pmg_qt/pymol_qt_gui.py
--- pymol-open-source-2.3.0/modules/pmg_qt/pymol_qt_gui.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/modules/pmg_qt/pymol_qt_gui.py	2019-05-27 15:31:39.008719515 +0200
@@ -848,7 +848,7 @@ PyMOL> color ye<TAB>    (will autocomple
         msg = [
             'The PyMOL Molecular Graphics System\n',
             'Version %s' % (self.cmd.get_version()[0]),
-            'Copyright (C) Schrodinger LLC.',
+            u'Copyright (C) Schr\xF6dinger LLC.',
             'All rights reserved.\n',
             'License information:',
         ]
@@ -1081,6 +1081,15 @@ class PyMOLApplication(QtWidgets.QApplic
         if ev.type() != QtCore.QEvent.FileOpen:
             return False
 
+        # When double clicking a file in Finder, open it in a new instance
+        if not pymol.invocation.options.reuse_helper and pymol.cmd.get_names():
+            window.new_window([ev.file()])
+            return True
+
+        # pymol -I -U
+        if pymol.invocation.options.auto_reinitialize:
+            pymol.cmd.reinitialize()
+
         # PyMOL Show
         if ev.file().endswith('.psw'):
             pymol.cmd.set('presentation')
diff -upNr pymol-open-source-2.3.0/modules/pymol/plugins/__init__.py pymol-open-source-2.3.2/modules/pymol/plugins/__init__.py
--- pymol-open-source-2.3.0/modules/pymol/plugins/__init__.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/modules/pymol/plugins/__init__.py	2019-05-27 15:31:39.004719520 +0200
@@ -428,7 +428,10 @@ def initialize(pmgapp=-1):
 
     if os.path.exists(PYMOLPLUGINSRC):
         from pymol import parsing
-        parsing.run_file(PYMOLPLUGINSRC, {'__script__': PYMOLPLUGINSRC}, {})
+        try:
+            parsing.run_file(PYMOLPLUGINSRC, {'__script__': PYMOLPLUGINSRC}, {})
+        except SyntaxError as e:
+            colorprinting.warning(str(e))
 
     autoload = (pmgapp != -2)
     for parent in [startup]:
diff -upNr pymol-open-source-2.3.0/modules/pymol/plugins/legacysupport.py pymol-open-source-2.3.2/modules/pymol/plugins/legacysupport.py
--- pymol-open-source-2.3.0/modules/pymol/plugins/legacysupport.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/modules/pymol/plugins/legacysupport.py	2019-05-27 15:31:39.008719515 +0200
@@ -153,9 +153,10 @@ def createlegacypmgapp():
 
 class _tkMessageBox(object):
     def __getattr__(self, name):
-        if sys.version_info[0] == 2:
+        try:
+            # pmg_qt.mimic_tk provides this for all Python versions
             import tkMessageBox as module
-        else:
+        except ImportError:
             import tkinter.messagebox as module
         from . import pref_get
         wrapped = getattr(module, name)
@@ -170,9 +171,10 @@ class _tkMessageBox(object):
 
 class _tkFileDialog(object):
     def __getattr__(self, name):
-        if sys.version_info[0] == 2:
+        try:
+            # pmg_qt.mimic_tk provides this for all Python versions
             import tkFileDialog as module
-        else:
+        except ImportError:
             import tkinter.filedialog as module
         wrapped = getattr(module, name)
         def dialog(parent=None, *args, **kwargs):
diff -upNr pymol-open-source-2.3.0/ov/src/ov_defines.h pymol-open-source-2.3.2/ov/src/ov_defines.h
--- pymol-open-source-2.3.0/ov/src/ov_defines.h	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/ov/src/ov_defines.h	2019-05-27 15:31:39.008719515 +0200
@@ -14,13 +14,8 @@
 
 /* defines */
 
-#ifdef WIN32
-#define OV_INLINE static
+#define OV_INLINE inline
 #define OV_STATIC static
-#else
-#define OV_INLINE __inline__ static
-#define OV_STATIC static
-#endif
 
 #ifndef OV_FALSE
 #define OV_FALSE 0
diff -upNr pymol-open-source-2.3.0/setup.py pymol-open-source-2.3.2/setup.py
--- pymol-open-source-2.3.0/setup.py	2019-02-11 15:08:10.000000000 +0100
+++ pymol-open-source-2.3.2/setup.py	2019-05-27 15:31:39.008719515 +0200
@@ -245,7 +245,6 @@ pymol_src_dirs = [
 def_macros = [
     ("_PYMOL_LIBPNG", None),
     ("_PYMOL_FREETYPE", None),
-    ("_PYMOL_INLINE", None),
 ]
 
 libs = ["png", "freetype"]
