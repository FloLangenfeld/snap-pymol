diff -upNr pymol-open-source-2.3.0.orig/contrib/mmtf-c/mmtf_parser.cpp pymol-open-source-2.3.0/contrib/mmtf-c/mmtf_parser.cpp
--- pymol-open-source-2.3.0.orig/contrib/mmtf-c/mmtf_parser.cpp	2020-03-10 19:31:10.280691382 +0100
+++ pymol-open-source-2.3.0/contrib/mmtf-c/mmtf_parser.cpp	2020-03-10 19:31:34.083006282 +0100
@@ -28,7 +28,21 @@
 #define __STDC_LIMIT_MACROS
 
 #include "mmtf_parser.h"
-#include "mmtf_parser_private.h"
+
+//*** Standard libs
+#include <stdbool.h>
+
+//*** MsgPack lib
+#ifdef MMTF_MSGPACK_USE_CPP11
+#include <msgpack.hpp>
+#define msgpack_object msgpack::object
+#define msgpack_object_kv msgpack::object_kv
+#define msgpack_object_str msgpack::object_str
+#define MMTF_MSGPACK_TYPE(T) msgpack::type::T
+#else
+#include <msgpack.h>
+#define MMTF_MSGPACK_TYPE(T) MSGPACK_OBJECT_##T
+#endif
 
 #if MSGPACK_VERSION_MAJOR < 1
 #error "msgpack-c >= 1.0 required (https://github.com/msgpack/msgpack-c)"
@@ -251,7 +265,7 @@ enum {
     }
 
 #define CODEGEN_MMTF_parser_fetch_List(type_, suffix) \
-    type_* MMTF_parser_fetch_##suffix##List( \
+    static type_* MMTF_parser_fetch_##suffix##List( \
             const msgpack_object* object, size_t* length) { \
         CODEGEN_BODY_fetch_OBJECT_ARRAY(type_, { \
             MMTF_parser_put_##suffix(iter, result + i); \
@@ -365,6 +379,7 @@ void array_copy_bigendian_2(void* dst, c
     }
 }
 
+static
 float* MMTF_parser_float_from_bytes(const char* input, uint32_t input_length, uint32_t* output_length) {
     IF_NOT_MULTIPLE_ERROR_RETURN(input_length, 4, NULL);
 
@@ -378,6 +393,7 @@ float* MMTF_parser_float_from_bytes(cons
     return output;
 }
 
+static
 int8_t* MMTF_parser_int8_from_bytes(const char* input, uint32_t input_length, uint32_t* output_length) {
     (*output_length) = input_length;
 
@@ -389,6 +405,7 @@ int8_t* MMTF_parser_int8_from_bytes(cons
     return output;
 }
 
+static
 int16_t* MMTF_parser_int16_from_bytes(const char* input, uint32_t input_length, uint32_t* output_length) {
     IF_NOT_MULTIPLE_ERROR_RETURN(input_length, 2, NULL);
 
@@ -402,6 +419,7 @@ int16_t* MMTF_parser_int16_from_bytes(co
     return output;
 }
 
+static
 int32_t* MMTF_parser_int32_from_bytes(const char* input, const uint32_t input_length, uint32_t* output_length) {
     IF_NOT_MULTIPLE_ERROR_RETURN(input_length, 4, NULL);
 
@@ -415,6 +433,7 @@ int32_t* MMTF_parser_int32_from_bytes(co
     return output;
 }
 
+static
 char** MMTF_parser_strings_from_bytes(const char* input, uint32_t input_length, uint32_t parameter, uint32_t* output_length) {
     IF_NOT_MULTIPLE_ERROR_RETURN(input_length, parameter, NULL);
 
@@ -436,6 +455,7 @@ char** MMTF_parser_strings_from_bytes(co
 
 //*** Array decoders
 // Run-length decode
+static
 int32_t* MMTF_parser_run_length_decode(const int32_t* input, uint32_t input_length, uint32_t* output_length) {
     (*output_length) = 0;
 
@@ -468,6 +488,7 @@ int32_t* MMTF_parser_run_length_decode(c
 }
 
 // Delta decode
+static
 int32_t* MMTF_parser_delta_decode(const int32_t* input, uint32_t input_length, uint32_t* output_length) {
     (*output_length) = input_length;
     int32_t* output = MALLOC_ARRAY(int32_t, (*output_length)); // The output needs to be freed by the calling process
@@ -486,6 +507,7 @@ int32_t* MMTF_parser_delta_decode(const
 }
 
 // Recursive indexing decode
+static
 int32_t* MMTF_parser_recursive_indexing_decode_from_16(const int16_t* input, uint32_t input_length, uint32_t* output_length) {
     (*output_length) = 0;
     uint32_t i;
@@ -517,6 +539,7 @@ int32_t* MMTF_parser_recursive_indexing_
     return output;
 }
 
+static
 int32_t* MMTF_parser_recursive_indexing_decode_from_8(const int8_t* input, uint32_t input_length, uint32_t* output_length) {
     (*output_length) = 0;
     uint32_t i;
@@ -545,6 +568,7 @@ int32_t* MMTF_parser_recursive_indexing_
 }
 
 // Integer decoding
+static
 float* MMTF_parser_integer_decode_from_16(const int16_t* input, uint32_t input_length, int32_t parameter, uint32_t* output_length) {
     (*output_length) = input_length;
     float* output = (float*)MALLOC_ARRAY(float, (*output_length));
@@ -559,6 +583,7 @@ float* MMTF_parser_integer_decode_from_1
     return output;
 }
 
+static
 float* MMTF_parser_integer_decode_from_32(const int32_t* input, uint32_t input_length, int32_t parameter, uint32_t* output_length) {
     (*output_length) = input_length;
     float* output = (float*)MALLOC_ARRAY(float, (*output_length));
@@ -744,6 +769,7 @@ void MMTF_parser_put_string(const msgpac
 }
 
 //*** Unpacking from MsgPack and applying strategy
+static
 char* MMTF_parser_fetch_string(const msgpack_object* object) {
     switch (object->type) {
 #ifdef MMTF_ACCEPT_MSGPACK_BIN_AS_STR
@@ -781,6 +807,7 @@ char MMTF_parser_fetch_char(const msgpac
     return *(object->via.str.ptr);
 }
 
+static
 int64_t MMTF_parser_fetch_int(const msgpack_object* object) {
     int64_t result;
 
@@ -796,6 +823,7 @@ int64_t MMTF_parser_fetch_int(const msgp
     return result;
 }
 
+static
 float MMTF_parser_fetch_float(const msgpack_object* object) {
     switch (object->type) {
     case /* FLOAT64 */ MMTF_MSGPACK_TYPE(FLOAT):
@@ -867,6 +895,7 @@ bool MMTF_parser_compare_msgpack_string_
 
 static
 void MMTF_parser_put_entity(const msgpack_object* object, MMTF_Entity* entity) {
+    MMTF_Entity_init(entity);
     MAP_ITERATE_BEGIN(object);
     FETCH_AND_ASSIGN(entity, string, description);
     FETCH_AND_ASSIGN(entity, string, type);
@@ -877,6 +906,7 @@ void MMTF_parser_put_entity(const msgpac
 
 static
 void MMTF_parser_put_group(const msgpack_object* object, MMTF_GroupType* group_type) {
+    MMTF_GroupType_init(group_type);
     MAP_ITERATE_BEGIN(object);
     FETCH_AND_ASSIGN_DUMMYCOUNT(group_type, int32_array, formalChargeList);
     FETCH_AND_ASSIGN_WITHCOUNT(group_type, string_array, atomNameList);
@@ -890,7 +920,11 @@ void MMTF_parser_put_group(const msgpack
 }
 
 static
+MMTF_Transform* MMTF_parser_fetch_transformList(const msgpack_object*, size_t*);
+
+static
 void MMTF_parser_put_bioAssembly(const msgpack_object* object, MMTF_BioAssembly* bio_assembly) {
+    MMTF_BioAssembly_init(bio_assembly);
     MAP_ITERATE_BEGIN(object);
     FETCH_AND_ASSIGN(bio_assembly, string, name);
     FETCH_AND_ASSIGN_WITHCOUNT(bio_assembly, transformList, transformList);
diff -upNr pymol-open-source-2.3.0.orig/contrib/mmtf-c/mmtf_parser_private.h pymol-open-source-2.3.0/contrib/mmtf-c/mmtf_parser_private.h
--- pymol-open-source-2.3.0.orig/contrib/mmtf-c/mmtf_parser_private.h	2020-03-10 19:31:10.280691382 +0100
+++ pymol-open-source-2.3.0/contrib/mmtf-c/mmtf_parser_private.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,84 +0,0 @@
-// *************************************************************************
-// Copyright [2016] [RCSB]
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-//
-// This is a private header file for mmtf_parser.c and must not be included
-// by other files.
-//
-// The authors of this code are: Julien Ferte (http://www.julienferte.com/),
-// Anthony Bradley, Thomas Holder.
-//
-//
-// Other contributors: Yana Valasatava, Alexander Rose.
-//
-// *************************************************************************
-
-#ifndef MMTF_PRIVATE_H
-#define MMTF_PRIVATE_H
-
-#include "mmtf_parser.h"
-
-//*** Standard libs
-#include <stdbool.h>
-
-//*** MsgPack lib
-#ifdef MMTF_MSGPACK_USE_CPP11
-#include <msgpack.hpp>
-#define msgpack_object msgpack::object
-#define msgpack_object_kv msgpack::object_kv
-#define msgpack_object_str msgpack::object_str
-#define MMTF_MSGPACK_TYPE(T) msgpack::type::T
-#else
-#include <msgpack.h>
-#define MMTF_MSGPACK_TYPE(T) MSGPACK_OBJECT_##T
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-//*** Array converters
-float* MMTF_parser_float_from_bytes(const char*, uint32_t, uint32_t*);
-int8_t* MMTF_parser_int8_from_bytes(const char*, uint32_t, uint32_t*);
-int16_t* MMTF_parser_int16_from_bytes(const char*, uint32_t, uint32_t*);
-int32_t* MMTF_parser_int32_from_bytes(const char*, const uint32_t, uint32_t*);
-char** MMTF_parser_strings_from_bytes(const char*, uint32_t, uint32_t, uint32_t*);
-
-//*** Array decoders
-int32_t* MMTF_parser_run_length_decode(const int32_t*, uint32_t, uint32_t*);
-int32_t* MMTF_parser_delta_decode(const int32_t*, uint32_t, uint32_t*);
-int32_t* MMTF_parser_recursive_indexing_decode_from_16(const int16_t*, uint32_t, uint32_t*);
-int32_t* MMTF_parser_recursive_indexing_decode_from_8(const int8_t*, uint32_t, uint32_t*);
-float* MMTF_parser_integer_decode_from_16(const int16_t*, uint32_t, int32_t, uint32_t*);
-float* MMTF_parser_integer_decode_from_32(const int32_t*, uint32_t, int32_t, uint32_t*);
-
-//*** Unpacking from MsgPack and applying strategy
-char* MMTF_parser_fetch_string(const msgpack_object*);
-int64_t MMTF_parser_fetch_int(const msgpack_object*);
-float MMTF_parser_fetch_float(const msgpack_object*);
-
-MMTF_Entity* MMTF_parser_fetch_entityList(const msgpack_object*, size_t*);
-
-MMTF_GroupType* MMTF_parser_fetch_groupList(const msgpack_object*, size_t*);
-
-MMTF_BioAssembly* MMTF_parser_fetch_bioAssemblyList(const msgpack_object*, size_t*);
-MMTF_Transform* MMTF_parser_fetch_transformList(const msgpack_object*, size_t*);
-
-#ifdef __cplusplus
-}
-#endif
-#endif
-
-// vi:sw=4:expandtab
diff -upNr pymol-open-source-2.3.0.orig/layer0/Isosurf.cpp pymol-open-source-2.3.0/layer0/Isosurf.cpp
--- pymol-open-source-2.3.0.orig/layer0/Isosurf.cpp	2020-03-10 19:31:10.408700489 +0100
+++ pymol-open-source-2.3.0/layer0/Isosurf.cpp	2020-03-10 19:31:34.087006769 +0100
@@ -83,8 +83,6 @@ static int IsosurfAlloc(PyMOLGlobals * G
 static void IsosurfPurge(CIsosurf * II);
 static int IsosurfCurrent(CIsosurf * II);
 static int IsosurfCodeVertices(CIsosurf * II);
-static void IsosurfInterpolate(CIsosurf * II, float *v1, float *l1, float *v2, float *l2,
-                               float *pt);
 static int IsosurfFindActiveEdges(CIsosurf * II);
 static int IsosurfFindLines(CIsosurf * II);
 static int IsosurfDrawLines(CIsosurf * II);
@@ -128,9 +126,7 @@ PyObject *IsosurfAsPyList(PyMOLGlobals *
 
 
 /*===========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
+inline
 static void IsosurfInterpolate(CIsosurf * I, float *v1, float *l1, float *v2, float *l2,
                                float *pt)
 {
diff -upNr pymol-open-source-2.3.0.orig/layer0/os_predef.h pymol-open-source-2.3.0/layer0/os_predef.h
--- pymol-open-source-2.3.0.orig/layer0/os_predef.h	2020-03-10 19:31:10.412700773 +0100
+++ pymol-open-source-2.3.0/layer0/os_predef.h	2020-03-10 19:31:34.087006769 +0100
@@ -49,10 +49,6 @@ typedef float aliased_float;
 
 /* BEGIN PROPRIETARY CODE SEGMENT (see disclaimer in "os_proprietary.h") */
 
-#if defined(_MSC_VER)
-#define __inline__ __inline
-#endif
-
 #ifdef WIN32
 #define PATH_SEP "\\"
 #else
diff -upNr pymol-open-source-2.3.0.orig/layer0/Tetsurf.cpp pymol-open-source-2.3.0/layer0/Tetsurf.cpp
--- pymol-open-source-2.3.0.orig/layer0/Tetsurf.cpp	2020-03-10 19:31:10.412700773 +0100
+++ pymol-open-source-2.3.0/layer0/Tetsurf.cpp	2020-03-10 19:31:34.091007255 +0100
@@ -690,9 +690,7 @@ static void TetsurfPurge(CTetsurf * II)
 
 
 /*===========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
+inline
 static void TetsurfInterpolate2(float *pt, float *v0, float l0, float *v1, float l1,
                                 float level)
 {
@@ -705,9 +703,6 @@ static void TetsurfInterpolate2(float *p
 
 
 /*===========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static void TetsurfInterpolate4(float *pt, float *v0, float l0, float *v1, float l1,
                                 float l2, float l3, float level)
 {
@@ -730,9 +725,6 @@ static void TetsurfInterpolate4(float *p
 
 
 /*===========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static void TetsurfInterpolate8(float *pt, float *v0, float l0, float *v1, float l1,
                                 float l2, float l3, float l4,
                                 float l5, float l6, float l7, float level)
diff -upNr pymol-open-source-2.3.0.orig/layer0/Vector.h pymol-open-source-2.3.0/layer0/Vector.h
--- pymol-open-source-2.3.0.orig/layer0/Vector.h	2020-03-10 19:31:10.412700773 +0100
+++ pymol-open-source-2.3.0/layer0/Vector.h	2020-03-10 19:31:34.091007255 +0100
@@ -398,7 +398,7 @@ inline void cross_product3f(const float
   cross[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);
 }
 
-__inline__ static double inline_sqrt1f(float f)
+inline double inline_sqrt1f(float f)
 {                               /* no good as a macro because f is used twice */
   if(f > _0f_inline)
     return (sqrt(f));
@@ -406,7 +406,7 @@ __inline__ static double inline_sqrt1f(f
     return (_0d_inline);
 }
 
-__inline__ static double inline_sqrt1d(double f)
+inline double inline_sqrt1d(double f)
 {                               /* no good as a macro because f is used twice */
   if(f > _0d_inline)
     return (sqrt(f));
@@ -422,7 +422,7 @@ inline float length2f(const float * v1)
   return sqrt1f((v1[0] * v1[0]) + (v1[1] * v1[1]));
 }
 
-__inline__ static void inline_normalize3f(float *v1)
+inline void inline_normalize3f(float *v1)
 {
   double vlen = length3f(v1);
   if(vlen > R_SMALLd_inline) {
@@ -435,7 +435,7 @@ __inline__ static void inline_normalize3
   }
 }
 
-__inline__ static double inline_diff3f(const float *v1, const float *v2)
+inline double inline_diff3f(const float *v1, const float *v2)
 {
   float dx, dy, dz;
   dx = (v1[0] - v2[0]);
@@ -444,7 +444,7 @@ __inline__ static double inline_diff3f(c
   return (sqrt1d(dx * dx + dy * dy + dz * dz));
 }
 
-__inline__ static float inline_diffsq3f(const float *v1, const float *v2)
+inline float inline_diffsq3f(const float *v1, const float *v2)
 {
   float dx, dy, dz;
   dx = (v1[0] - v2[0]);
@@ -455,7 +455,7 @@ __inline__ static float inline_diffsq3f(
   return (dz * dz + (dx + dy));
 }
 
-__inline__ static int inline_within3f(const float *v1, const float *v2, float dist)
+inline int inline_within3f(const float *v1, const float *v2, float dist)
 {
   float dx, dy, dz, dist2;
   dx = (float) fabs(v1[0] - v2[0]);
@@ -473,7 +473,7 @@ __inline__ static int inline_within3f(co
   return (((dx + dy) + dz * dz) <= dist2);
 }
 
-__inline__ static int inline_within3fsq(const float *v1, const float *v2, float dist, float dist2)
+inline int inline_within3fsq(const float *v1, const float *v2, float dist, float dist2)
 {
   /* manually optimized to take advantage of parallel execution units */
   float dx, dy, dz;
@@ -498,7 +498,7 @@ __inline__ static int inline_within3fsq(
   return ((dx + dz) <= (dist2));
 }
 
-__inline__ static int inline_within3fret(const float *v1, const float *v2, float cutoff,
+inline int inline_within3fret(const float *v1, const float *v2, float cutoff,
                                          const float cutoff2, float *diff, float *dist)
 {
   float dx, dy, dz, dist2;
@@ -519,7 +519,7 @@ __inline__ static int inline_within3fret
   return 1;
 }
 
-__inline__ static void inline_remove_component3f(const float *v1, const float *unit, float *result)
+inline void inline_remove_component3f(const float *v1, const float *unit, float *result)
 {
   float dot;
 
@@ -529,7 +529,7 @@ __inline__ static void inline_remove_com
   result[2] = v1[2] - unit[2] * dot;
 }
 
-__inline__ static float inline_project3f(const float *v1, const float *v2, float *proj)
+inline float inline_project3f(const float *v1, const float *v2, float *proj)
 {
   float dot;
 
diff -upNr pymol-open-source-2.3.0.orig/layer0/Version.h pymol-open-source-2.3.0/layer0/Version.h
--- pymol-open-source-2.3.0.orig/layer0/Version.h	2020-03-10 19:31:10.412700773 +0100
+++ pymol-open-source-2.3.0/layer0/Version.h	2020-03-10 19:31:34.091007255 +0100
@@ -1,5 +1,5 @@
 #ifndef _PyMOL_VERSION
-#define _PyMOL_VERSION "2.3.0"
+#define _PyMOL_VERSION "2.3.5"
 #endif
 
 /* for session file compatibility */
diff -upNr pymol-open-source-2.3.0.orig/layer0/Word.cpp pymol-open-source-2.3.0/layer0/Word.cpp
--- pymol-open-source-2.3.0.orig/layer0/Word.cpp	2020-03-10 19:31:10.412700773 +0100
+++ pymol-open-source-2.3.0/layer0/Word.cpp	2020-03-10 19:31:34.091007255 +0100
@@ -52,7 +52,6 @@ struct _CWordMatcher {
 #define cMatchAlphaRange  cWordMatchOptionAlphaRanges
 #define cMatchWildcard 3
 
-#ifndef _PYMOL_INLINE
 int WordCompare(PyMOLGlobals * G, const char *p, const char *q, int ignCase)
 
 
@@ -93,7 +92,6 @@ int WordCompare(PyMOLGlobals * G, const
     return 1;
   return 0;
 }
-#endif
 
 void WordMatchOptionsConfigInteger(CWordMatchOptions * I)
 {
diff -upNr pymol-open-source-2.3.0.orig/layer0/Word.h pymol-open-source-2.3.0/layer0/Word.h
--- pymol-open-source-2.3.0.orig/layer0/Word.h	2020-03-10 19:31:10.412700773 +0100
+++ pymol-open-source-2.3.0/layer0/Word.h	2020-03-10 19:31:34.091007255 +0100
@@ -91,52 +91,8 @@ int WordIndex(PyMOLGlobals * G, WordType
 int WordKey(PyMOLGlobals * G, WordKeyValue * list, const char *word, int minMatch, int ignCase,
             int *exact);
 
-#ifdef _PYMOL_INLINE
-__inline__ static int WordCompare(PyMOLGlobals * G, const char *p, const char *q, int ignCase)
-
-
-/* all things equal, shorter is smaller */
-{
-  int result = 0;
-  char cp, cq, tlp, tlq;
-  if(ignCase) {
-    while((cp = *p) && (cq = *q)) {
-      p++;
-      q++;
-      if(cp != cq) {
-        (tlp = tolower(cp));
-        (tlq = tolower(cq));
-        if(tlp < tlq)
-          return -1;
-        else if(tlp > tlq) {
-          return 1;
-        }
-      }
-    }
-  } else {
-    while((cp = *p) && (cq = *q)) {
-      p++;
-      q++;
-      if(cp != cq) {
-        if(cp < cq) {
-          return -1;
-        } else if(cp > cq) {
-          return 1;
-        }
-      }
-    }
-  }
-  if((!result) && (!*p) && (*q))
-    return -1;
-  else if((!result) && (*p) && (!*q))
-    return 1;
-  return 0;
-}
-#else
 int WordCompare(PyMOLGlobals * G, const char *p, const char *q, int ignCase);
 
-#endif
-
 inline int WordCompare(PyMOLGlobals * G, const lexidx_t& s1, const lexidx_t& s2, int ignCase) {
   if (s1 == s2)
     return 0;
diff -upNr pymol-open-source-2.3.0.orig/layer1/Basis.cpp pymol-open-source-2.3.0/layer1/Basis.cpp
--- pymol-open-source-2.3.0.orig/layer1/Basis.cpp	2020-03-10 19:31:10.416701058 +0100
+++ pymol-open-source-2.3.0/layer1/Basis.cpp	2020-03-10 19:31:34.095007741 +0100
@@ -15,8 +15,6 @@ I* Additional authors of this source fil
 Z* -------------------------------------------------------------------
 */
 
-#ifndef _PYMOL_INLINE
-
 #include"os_predef.h"
 #include"os_std.h"
 
@@ -34,9 +32,6 @@ static const float kR_SMALL5 = 0.0001F;
 #define EPSILON 0.000001F
 
 /*========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int ZLineToSphere(float *base, float *point, float *dir, float radius,
                          float maxial, float *sphere, float *asum, float *pre)
 {
@@ -159,9 +154,6 @@ static int ZLineToSphere(float *base, fl
   return (1);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int LineToSphere(float *base, float *ray, float *point, float *dir, float radius,
                         float maxial, float *sphere, float *asum)
 {
@@ -315,9 +307,6 @@ static int LineToSphere(float *base, flo
   return (1);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int FrontToInteriorSphere(float *front,
                                  float *point,
                                  float *dir, float radius, float radius2, float maxial)
@@ -347,9 +336,6 @@ static int FrontToInteriorSphere(float *
 
 
 /*========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int ZLineToSphereCapped(float *base, float *point,
                                float *dir, float radius, float maxial,
                                float *sphere, float *asum, int cap1, int cap2, float *pre)
@@ -572,9 +558,6 @@ static int ZLineToSphereCapped(float *ba
   return (1);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int LineToSphereCapped(float *base, float *ray,
                               float *point, float *dir, float radius, float maxial,
                               float *sphere, float *asum, int cap1, int cap2)
@@ -1073,9 +1056,6 @@ static int ConeLineToSphereCapped(float
   return 0;
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int FrontToInteriorSphereCapped(float *front,
                                        float *point,
                                        float *dir,
@@ -1108,9 +1088,6 @@ static int FrontToInteriorSphereCapped(f
 
 
 /*========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static float ZLineClipPoint(float *base, float *point, float *alongNormalSq, float cutoff)
 {
   float hyp0, hyp1, hyp2;
@@ -1143,9 +1120,6 @@ static float ZLineClipPoint(float *base,
   return result;
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static float ZLineClipPointNoZCheck(float *base, float *point, float *alongNormalSq,
                                     float cutoff)
 {
@@ -1178,9 +1152,6 @@ static float ZLineClipPointNoZCheck(floa
   return result;
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int LineClipPoint(float *base, float *ray,
                          float *point, float *dist, float cutoff, float cutoff2)
 {
@@ -1524,9 +1495,6 @@ int n_sausages = 0;
 int n_skipped = 0;
 #endif
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 int BasisHitPerspective(BasisCallRec * BC)
 {
   CBasis *BI = BC->Basis;
@@ -2021,9 +1989,6 @@ int BasisHitPerspective(BasisCallRec * B
   }
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 int BasisHitOrthoscopic(BasisCallRec * BC)
 {
   const float _0 = 0.0F, _1 = 1.0F;
@@ -2345,9 +2310,6 @@ int BasisHitOrthoscopic(BasisCallRec * B
   return (-1);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 int BasisHitShadow(BasisCallRec * BC)
 {
   const float _0 = 0.0F;
@@ -3681,8 +3643,3 @@ void BasisCylinderSausagePrecompute(floa
   pre[0] = dir[1] * ln;
   pre[1] = -dir[0] * ln;
 }
-
-#else
-typedef int this_file_is_no_longer_empty;
-
-#endif
diff -upNr pymol-open-source-2.3.0.orig/layer1/CGO.cpp pymol-open-source-2.3.0/layer1/CGO.cpp
--- pymol-open-source-2.3.0.orig/layer1/CGO.cpp	2020-03-10 19:31:10.416701058 +0100
+++ pymol-open-source-2.3.0/layer1/CGO.cpp	2020-03-10 19:31:52.873555720 +0100
@@ -274,6 +274,14 @@ int CGO_sz[] = {
   CGO_NULL_SZ
 };
 
+/**
+ * Get the number of elements in `CGO_sz`
+ */
+size_t CGO_sz_size()
+{
+  return sizeof(CGO_sz) / sizeof(*CGO_sz);
+}
+
 typedef void CGO_op(CCGORenderer * I, float **);
 typedef CGO_op *CGO_op_fn;
 
@@ -371,11 +379,14 @@ static int CGOArrayFromPyListInPlace(PyO
   if (!list || !PyList_Check(list))
     return false;
 
+  auto G = I->G;
+
 #define GET_FLOAT(i) ((float) CPythonVal_PyFloat_AsDouble_From_List(I->G, list, i))
 #define GET_INT(i)   ((int)   CPythonVal_PyFloat_AsDouble_From_List(I->G, list, i))
 
   for (int i = 0, l = PyList_Size(list); i < l;) {
-    int op = CGO_MASK & GET_INT(i++);
+    unsigned op = GET_INT(i++);
+    ok_assert(1, op < CGO_sz_size());
     int sz = CGO_sz[op];
     float * fdata = I->add_to_buffer(sz + 1);
     CGO_write_int(fdata, op);
@@ -391,12 +402,14 @@ static int CGOArrayFromPyListInPlace(PyO
     case CGO_DISABLE:
     case CGO_SPECIAL:
       // first member int
+      ok_assert(1, i < l);
       CGO_write_int(fdata, GET_INT(i++));
       sz--;
       break;
     case CGO_DRAW_ARRAYS:
       {
         // has abstract superclass, need to be constructed!
+        ok_assert(1, i + 3 < l);
         auto sp = new (fdata) cgo::draw::arrays(
             GET_INT(i),
             GET_INT(i + 1),
@@ -421,6 +434,7 @@ static int CGOArrayFromPyListInPlace(PyO
 
     // float members
     for(; sz; --sz) {
+      ok_assert(1, i < l);
       *(fdata++) = GET_FLOAT(i++);
     }
   }
@@ -429,6 +443,10 @@ static int CGOArrayFromPyListInPlace(PyO
 #undef GET_INT
 
   return true;
+
+ok_except1:
+  PRINTFB(G, FB_CGO, FB_Errors) " %s-Error: Corrupt data\n", __func__ ENDFB(G);
+  return false;
 }
 
 CGO *CGONewFromPyList(PyMOLGlobals * G, PyObject * list, int version, bool shouldCombine)
@@ -4162,14 +4180,15 @@ CGO *CGOSimplify(const CGO * I, int est,
         float mid[3];
         mult3f(cyl->axis, .5f, mid);
         add3f(cyl->origin, mid, mid);
+        float alpha2 = cyl->alpha >= 0.f ? cyl->alpha : cgo->alpha;
         if (cap & cCylShaderInterpColor){
-          ok &= CGOSimpleCylinder(cgo, cyl->origin, v1, cyl->tube_size, color1, cyl->color2, cyl->alpha, cyl->alpha, true, bcap, fcap, &pickcolor2, stick_round_nub);
+          ok &= CGOSimpleCylinder(cgo, cyl->origin, v1, cyl->tube_size, color1, cyl->color2, cgo->alpha, alpha2, true, bcap, fcap, &pickcolor2, stick_round_nub);
         } else {
           ok &= CGOColorv(cgo, color1);
-          ok &= CGOSimpleCylinder(cgo, cyl->origin, mid, cyl->tube_size, color1, NULL, cyl->alpha, cyl->alpha, false, fcap, 0, nullptr, stick_round_nub);
+          ok &= CGOSimpleCylinder(cgo, cyl->origin, mid, cyl->tube_size, color1, NULL, cgo->alpha, alpha2, false, fcap, 0, nullptr, stick_round_nub);
           ok &= CGOColorv(cgo, cyl->color2);
           ok &= CGOPickColor(cgo, pickcolor2.index, pickcolor2.bond);
-          ok &= CGOSimpleCylinder(cgo, mid, v1, cyl->tube_size, cyl->color2, NULL, cyl->alpha, cyl->alpha, false, 0, bcap, nullptr, stick_round_nub);
+          ok &= CGOSimpleCylinder(cgo, mid, v1, cyl->tube_size, cyl->color2, NULL, cgo->alpha, alpha2, false, 0, bcap, nullptr, stick_round_nub);
         }
       }
       break;
@@ -4471,14 +4490,15 @@ CGO *CGOSimplifyNoCompress(const CGO * I
         float mid[3];
         mult3f(cyl->axis, .5f, mid);
         add3f(cyl->origin, mid, mid);
+        float alpha2 = cyl->alpha >= 0.f ? cyl->alpha : cgo->alpha;
         if (cap & cCylShaderInterpColor){
-          ok &= CGOSimpleCylinder(cgo, cyl->origin, v1, cyl->tube_size, color1, cyl->color2, cyl->alpha, cyl->alpha, true, bcap, fcap, &pickcolor2, stick_round_nub);
+          ok &= CGOSimpleCylinder(cgo, cyl->origin, v1, cyl->tube_size, color1, cyl->color2, cgo->alpha, alpha2, true, bcap, fcap, &pickcolor2, stick_round_nub);
         } else {
           ok &= CGOColorv(cgo, color1);
-          ok &= CGOSimpleCylinder(cgo, cyl->origin, mid, cyl->tube_size, color1, NULL, cyl->alpha, cyl->alpha, false, fcap, 0, NULL, stick_round_nub);
+          ok &= CGOSimpleCylinder(cgo, cyl->origin, mid, cyl->tube_size, color1, NULL, cgo->alpha, alpha2, false, fcap, 0, NULL, stick_round_nub);
           ok &= CGOColorv(cgo, cyl->color2);
           ok &= CGOPickColor(cgo, pickcolor2.index, pickcolor2.bond);
-          ok &= CGOSimpleCylinder(cgo, mid, v1, cyl->tube_size, cyl->color2, NULL, cyl->alpha, cyl->alpha, false, 0, bcap, NULL, stick_round_nub);
+          ok &= CGOSimpleCylinder(cgo, mid, v1, cyl->tube_size, cyl->color2, NULL, cgo->alpha, alpha2, false, 0, bcap, NULL, stick_round_nub);
         }
       }
       break;
@@ -5687,17 +5707,19 @@ int CGORenderRay(CGO * I, CRay * ray, Re
         const float *color1 = c0;
         const float *color2 = cyl->color2;
         add3f(cyl->origin, cyl->axis, v1);
+        float alpha1 = I->G->CGORenderer->alpha;
+        float alpha2 = cyl->alpha >= 0.f ? cyl->alpha : alpha1;
         if (colorinterp || equal3f(color1, color2)) {
-          ok &= ray->customCylinder3fv(pc, v1, cyl->tube_size, color1, color2, fcap, bcap, cyl->alpha, cyl->alpha);
+          ok &= ray->customCylinder3fv(pc, v1, cyl->tube_size, color1, color2, fcap, bcap, alpha1, alpha2);
         } else {
           float mid[3];
           mult3f(cyl->axis, .5f, mid);
           add3f(cyl->origin, mid, mid);
 
           ray->color3fv(c0);
-          ok &= ray->customCylinder3fv(cyl->origin, mid, cyl->tube_size, color1, color1, fcap, 0, cyl->alpha, cyl->alpha);
+          ok &= ray->customCylinder3fv(cyl->origin, mid, cyl->tube_size, color1, color1, fcap, 0, alpha1, alpha2);
           ray->color3fv(cyl->color2);
-          ok &= ray->customCylinder3fv(mid, v1, cyl->tube_size, color2, color2, 0, bcap, cyl->alpha, cyl->alpha);
+          ok &= ray->customCylinder3fv(mid, v1, cyl->tube_size, color2, color2, 0, bcap, alpha1, alpha2);
         }
       }
       break;
diff -upNr pymol-open-source-2.3.0.orig/layer1/CGO.cpp.orig pymol-open-source-2.3.0/layer1/CGO.cpp.orig
--- pymol-open-source-2.3.0.orig/layer1/CGO.cpp.orig	1970-01-01 01:00:00.000000000 +0100
+++ pymol-open-source-2.3.0/layer1/CGO.cpp.orig	2020-03-10 19:31:34.103008714 +0100
@@ -0,0 +1,12089 @@
+
+/* 
+A* -------------------------------------------------------------------
+B* This file contains source code for the PyMOL computer program
+C* copyright 1998-2000 by Warren Lyford Delano of DeLano Scientific. 
+D* -------------------------------------------------------------------
+E* It is unlawful to modify or remove this copyright notice.
+F* -------------------------------------------------------------------
+G* Please see the accompanying LICENSE file for further information. 
+H* --------------------------------------------------\-----------------
+I* Additional authors of this source file include:
+-* 
+-* 
+-*
+Z* -------------------------------------------------------------------
+*/
+#include"os_python.h"
+
+#include"os_predef.h"
+#include"os_std.h"
+#include"os_gl.h"
+
+#include"Feedback.h"
+#include"CGO.h"
+#include"Base.h"
+#include"OOMac.h"
+#include"Setting.h"
+#include"Sphere.h"
+#include"PConv.h"
+#include"GadgetSet.h"
+#include"VFont.h"
+#include"P.h"
+#include"PyMOLGlobals.h"
+#include"Ray.h"
+#include"Util.h"
+#include"Scene.h"
+#include"ScenePicking.h"
+#include"Matrix.h"
+#include"ShaderMgr.h"
+#include"CoordSet.h"
+#include"Rep.h"
+#include"Vector.h"
+#include"ObjectGadgetRamp.h"
+#include"Triangle.h"
+
+#if defined(_PYMOL_IOS) && !defined(_WEBGL)
+#define ALIGN_VBOS_TO_4_BYTE_ARRAYS
+#define VAR_FOR_NORMAL  plc
+#define VAR_FOR_NORMAL_CNT_PLUS   + (cnt / 3)
+#define VERTEX_NORMAL_SIZE 4
+#else
+#define VAR_FOR_NORMAL  pl
+#define VERTEX_NORMAL_SIZE 3
+#define VAR_FOR_NORMAL_CNT_PLUS   
+#endif
+
+#define VALUES_PER_IMPOSTER_SPACE_COORD 1
+
+#if defined(PURE_OPENGL_ES_2)
+#define VERTICES_PER_SPHERE 6
+#else
+#define VERTICES_PER_SPHERE 4
+#endif
+
+#if defined(_PYMOL_IOS) && !defined(_WEBGL)
+#define NUM_VERTICES_PER_CYLINDER 4
+#define NUM_TOTAL_VERTICES_PER_CYLINDER 6
+#else
+#define NUM_VERTICES_PER_CYLINDER 8
+#define NUM_TOTAL_VERTICES_PER_CYLINDER 36
+#endif
+
+#ifdef PURE_OPENGL_ES_2
+#define glVertexAttrib4ubv(loc, data) glVertexAttrib4f(loc, \
+    (data)[0] / 255.f, (data)[1] / 255.f, (data)[2] / 255.f, (data)[3] / 255.f);
+#endif
+
+#include <iostream>
+#include <algorithm>
+
+using namespace std;
+
+#define MAX_INDICES_FOR_IOS 65536
+
+const float g_ones4f[4] = {1.f, 1.f, 1.f, 1.f};
+
+template <typename T>
+inline T CLAMPVALUE(T val, T minimum, T maximum) {
+  return 
+    (val < minimum) ? minimum :
+    (val > maximum) ? maximum : val;
+}
+
+#if defined(_PYMOL_IOS) && !defined(_WEBGL) 
+extern "C" void firePyMOLLimitationWarning();
+#define CHECK_GL_ERROR_OK(printstr)			\
+  if ((err = glGetError())!=0 || I->G->Interrupt != 0){		\
+      if (err)        \
+	PRINTFB(I->G, FB_CGO, FB_Errors) printstr, err ENDFB(I->G);	   \
+  }
+#else
+#define CHECK_GL_ERROR_OK(printstr)	\
+  if ((err = glGetError()) != 0){						\
+     PRINTFB(I->G, FB_CGO, FB_Errors) printstr, err ENDFB(I->G);	   \
+  }
+#endif
+
+struct _CCGORenderer {
+  PyMOLGlobals *G;
+  RenderInfo *info;
+  Rep *rep;
+  const float *color;
+  float alpha;
+  short sphere_quality;
+  bool isPicking;
+  bool pick_mode; // bit 1 of (*pick)[0].src.bond 0 - first pass, 1 - second pass
+  bool use_shader; // OpenGL 1.4+, e.g., glEnableVertexAttribArray() (on) vs. glEnableClientState() (off)
+  bool debug;
+  bool picking_32bit;
+  CSetting *set1, *set2;
+};
+
+static
+void set_current_pick_color(
+    CGO * cgo,
+    Picking * p,
+    const PickContext * context,
+    unsigned int idx,
+    int bnd)
+{
+  p->context = (*context);
+  p->src.index = idx;
+  p->src.bond = bnd; // actually holds state information
+  if (cgo) {
+    cgo->current_pick_color_index = idx;
+    cgo->current_pick_color_bond = bnd;
+  }
+}
+
+bool AssignNewPickColor(CGO *cgo, unsigned int &i, std::vector<Picking>* pick, PickContext * context, unsigned char *color, unsigned int index, int bond){
+  i++;
+  if(!(pick->begin()->src.bond & 1)) {
+    /* pass 1 - low order bits */
+    color[0] = (uchar)((i & 0xF) << 4);
+    color[1] = (uchar)((i & 0xF0) | 0x8);
+    color[2] = (uchar)((i & 0xF00) >> 4);
+    if (pick->size() <= i) {
+      pick->resize((i + 1) * 3 / 2); // grow by 50%
+    }
+    set_current_pick_color(cgo, pick->data() + i, context, index, bond);
+  } else {
+    int j = i >> 12;
+    color[0] = (uchar)((j & 0xF) << 4);
+    color[1] = (uchar)((j & 0xF0) | 0x8);
+    color[2] = (uchar)((j & 0xF00) >> 4);
+  }
+  color[3] = 255;
+  return true;
+}
+
+static
+int CGOConvertDebugMode(int debug, int modeArg){
+  int mode = modeArg;
+  if (debug==1){
+    switch (mode){
+    case GL_TRIANGLES:
+      mode = GL_LINES;
+      break;
+    case GL_TRIANGLE_STRIP:
+      mode = GL_LINE_STRIP;
+      break;
+    case GL_TRIANGLE_FAN:
+      mode = GL_LINES;
+      break;
+    }
+  } else {
+    mode = GL_POINTS;
+  }
+  return mode;
+}
+
+
+int CGORendererInit(PyMOLGlobals * G)
+{
+  CCGORenderer *I = NULL;
+
+  I = (G->CGORenderer = Calloc(CCGORenderer, 1));
+  if(I) {
+    I->G = G;
+    I->isPicking = false;
+    I->alpha = 1.0F;
+    return 1;
+  } else
+    return 0;
+}
+
+void CGORendererFree(PyMOLGlobals * G)
+{
+  FreeP(G->CGORenderer);
+}
+
+int CGO_sz[] = {
+  CGO_NULL_SZ,
+  CGO_NULL_SZ,
+  CGO_BEGIN_SZ,
+  CGO_END_SZ,
+
+  CGO_VERTEX_SZ,
+  CGO_NORMAL_SZ,
+  CGO_COLOR_SZ,
+  CGO_SPHERE_SZ,
+
+  CGO_TRIANGLE_SZ,
+  fsizeof<cgo::draw::cylinder>(),
+  CGO_LINEWIDTH_SZ,
+  CGO_WIDTHSCALE_SZ,
+
+  CGO_ENABLE_SZ,
+  CGO_DISABLE_SZ,
+  fsizeof<cgo::draw::sausage>(),
+  fsizeof<cgo::draw::custom_cylinder>(),
+
+  CGO_DOTWIDTH_SZ,
+  CGO_ALPHA_TRIANGLE_SZ,
+  CGO_ELLIPSOID_SZ,
+  CGO_FONT_SZ,
+
+  CGO_FONT_SCALE_SZ,
+  CGO_FONT_VERTEX_SZ,
+  CGO_FONT_AXES_SZ,
+  CGO_CHAR_SZ,
+
+  CGO_INDENT_SZ,
+  CGO_ALPHA_SZ,
+  CGO_QUADRIC_SZ,
+  CGO_CONE_SZ,
+
+  fsizeof<cgo::draw::arrays>(),
+  CGO_NULL_SZ,
+  CGO_RESET_NORMAL_SZ,
+  CGO_PICK_COLOR_SZ,
+
+  CGO_NULL_SZ, // CGO_DRAW_BUFFERS_SZ no longer used
+  fsizeof<cgo::draw::buffers_indexed>(),
+  CGO_BOUNDING_BOX_SZ,
+  fsizeof<cgo::draw::buffers_not_indexed>(),
+  CGO_SPECIAL_SZ,
+  fsizeof<cgo::draw::cylinder_buffers>(),
+  fsizeof<cgo::draw::shadercylinder>(),
+  fsizeof<cgo::draw::shadercylinder2ndcolor>(),
+  fsizeof<cgo::draw::sphere_buffers>(),
+  CGO_ACCESSIBILITY_SZ,
+  CGO_DRAW_TEXTURE_SZ,
+  fsizeof<cgo::draw::textures>(),
+  fsizeof<cgo::draw::screen_textures>(),
+  CGO_TEX_COORD_SZ,
+  fsizeof<cgo::draw::label>(),
+  fsizeof<cgo::draw::labels>(),
+  CGO_DRAW_CONNECTOR_SZ,
+  fsizeof<cgo::draw::connectors>(),
+  CGO_DRAW_TRILINES_SZ,  CGO_UNIFORM3F_SZ,
+  CGO_SPECIAL_WITH_ARG_SZ,
+  fsizeof<cgo::draw::line>(),
+  fsizeof<cgo::draw::splitline>(),
+  fsizeof<cgo::draw::custom>(),
+  fsizeof<cgo::draw::vertex_attribute_3f>(),
+  fsizeof<cgo::draw::vertex_attribute_4ub>(),
+  fsizeof<cgo::draw::vertex_attribute_1f>(),
+  fsizeof<cgo::draw::mask_attribute_if_picking>(),
+  fsizeof<cgo::draw::bind_vbo_for_picking>(),
+  CGO_VERTEX_BEGIN_LINE_STRIP_SZ,  CGO_INTERPOLATED_SZ,  CGO_VERTEX_CROSS_SZ,
+  fsizeof<cgo::draw::vertex_attribute_4ub_if_picking>(),
+  fsizeof<cgo::draw::custom_cylinder_alpha>(),
+  CGO_NULL_SZ
+};
+
+typedef void CGO_op(CCGORenderer * I, float **);
+typedef CGO_op *CGO_op_fn;
+
+static float *CGO_add(CGO * I, int c);
+static float *CGO_size(CGO * I, int sz);
+static int CGOSimpleCylinder(CGO * I, const float *v1, const float *v2, const float tube_size, const float *c1,
+                             const float *c2, float a1, const float a2, const bool interp, const int cap1, const int cap2,
+                             const Pickable *pickcolor2 = nullptr, const bool stick_round_nub = false);
+template<typename CylinderT>
+static int CGOSimpleCylinder(CGO * I, const CylinderT &cyl, const float a1, const float a2, const bool interp, const int cap1,
+                             const int cap2, const Pickable *pickcolor2 = nullptr, const bool stick_round_nub = false);
+static int CGOSimpleEllipsoid(CGO * I, float *v, float vdw, float *n0, float *n1,
+			      float *n2);
+static int CGOSimpleQuadric(CGO * I, float *v, float vdw, float *q);
+static int CGOSimpleSphere(CGO * I, float *v, float vdw, short sphere_quality);
+static int CGOSimpleCone(CGO * I, float *v1, float *v2, float r1, float r2, float *c1,
+			 float *c2, int cap1, int cap2);
+
+
+/*
+ * Inverse function of CGOArrayFromPyListInPlace
+ *
+ * I: (input) Primitive CGO (may contain CGO_DRAW_ARRAYS)
+ *
+ * Return: All-float Python list primitive CGO
+ */
+static PyObject *CGOArrayAsPyList(const CGO * I)
+{
+  std::vector<float> flat;
+  flat.reserve(I->c);
+
+  for (auto it = I->begin(); !it.is_stop(); ++it) {
+    auto op = it.op_code();
+    auto pc = it.data();
+    auto sz = CGO_sz[op];
+
+    flat.push_back(op);
+
+    switch (op) {
+    case CGO_BEGIN:
+    case CGO_ENABLE:
+    case CGO_DISABLE:
+    case CGO_SPECIAL:
+      // first member int
+      flat.push_back(*reinterpret_cast<const int*>(pc));
+      ++pc;
+      --sz;
+      break;
+    case CGO_DRAW_ARRAYS:
+      {
+        auto sp = reinterpret_cast<const cgo::draw::arrays*>(pc);
+        flat.push_back(sp->mode);
+        flat.push_back(sp->arraybits);
+        flat.push_back(sp->narrays); // (redundant)
+        flat.push_back(sp->nverts);
+        pc = sp->get_data();
+        sz = sp->get_data_length();
+      }
+    }
+
+    // float members
+    for(; sz; --sz) {
+      flat.push_back(*(pc++));
+    }
+  }
+
+  return PConvToPyObject(flat);
+}
+
+PyObject *CGOAsPyList(CGO * I)
+{
+  PyObject *result;
+  result = PyList_New(2);
+  PyObject *list = CGOArrayAsPyList(I);
+  PyList_SetItem(result, 0, PyInt_FromLong(PyList_Size(list)));
+  PyList_SetItem(result, 1, list);
+  return (result);
+}
+
+static float CPythonVal_PyFloat_AsDouble_From_List(void * G, PyObject * list, size_t i) {
+  float out;
+  PConvPyFloatToFloat(PyList_GetItem(list, i), &out);
+  return out;
+}
+
+/*
+ * Inverse function of CGOArrayAsPyList
+ *
+ * list: (input) All-float Python list primitive CGO (may contain CGO_DRAW_ARRAYS)
+ * I: (output) empty CGO
+ */
+static int CGOArrayFromPyListInPlace(PyObject * list, CGO * I)
+{
+  // sanity check
+  if (!list || !PyList_Check(list))
+    return false;
+
+#define GET_FLOAT(i) ((float) CPythonVal_PyFloat_AsDouble_From_List(I->G, list, i))
+#define GET_INT(i)   ((int)   CPythonVal_PyFloat_AsDouble_From_List(I->G, list, i))
+
+  for (int i = 0, l = PyList_Size(list); i < l;) {
+    int op = CGO_MASK & GET_INT(i++);
+    int sz = CGO_sz[op];
+    float * fdata = I->add_to_buffer(sz + 1);
+    CGO_write_int(fdata, op);
+
+    switch (op) {
+    case CGO_STOP:
+      // don't increment size for null terminator
+      I->c -= 1;
+      return true;
+    case CGO_BEGIN:
+      I->has_begin_end = true;
+    case CGO_ENABLE:
+    case CGO_DISABLE:
+    case CGO_SPECIAL:
+      // first member int
+      CGO_write_int(fdata, GET_INT(i++));
+      sz--;
+      break;
+    case CGO_DRAW_ARRAYS:
+      {
+        // has abstract superclass, need to be constructed!
+        auto sp = new (fdata) cgo::draw::arrays(
+            GET_INT(i),
+            GET_INT(i + 1),
+            GET_INT(i + 3));
+
+        // sanity check
+        int narrays_check = GET_INT(i + 2);
+        if (sp->narrays != narrays_check) {
+          PRINTFB(I->G, FB_CGO, FB_Warnings)
+            " CGO-Warning: narrays mismatch: %d != %d\n",
+            sp->narrays, narrays_check ENDFB(I->G);
+        }
+
+        // data
+        sz = sp->get_data_length();
+        sp->floatdata = fdata = I->allocate_in_data_heap(sz);
+
+        i += 4;
+      }
+      break;
+    }
+
+    // float members
+    for(; sz; --sz) {
+      *(fdata++) = GET_FLOAT(i++);
+    }
+  }
+
+#undef GET_FLOAT
+#undef GET_INT
+
+  return true;
+}
+
+CGO *CGONewFromPyList(PyMOLGlobals * G, PyObject * list, int version, bool shouldCombine)
+{
+  int ok = true;
+  auto I = CGONew(G);
+  if(ok)
+    ok = (list != NULL);
+  if(ok)
+    ok = PyList_Check(list);
+  /* TO ENABLE BACKWARDS COMPATIBILITY...
+     Always check ll when adding new PyList_GetItem's */
+  if((version > 0) && (version <= 86)) {
+    if(ok)
+      ok = PConvPyIntToInt(PyList_GetItem(list, 0), &I->c);
+    if(ok)
+      VLACheck(I->op, float, I->c);
+    if(ok)
+      ok = PConvPyListToFloatArrayInPlace(PyList_GetItem(list, 1), I->op, I->c);
+  } else {
+    if(ok)
+      ok = CGOArrayFromPyListInPlace(PyList_GetItem(list, 1), I);
+  }
+  if(!ok) {
+    CGOFree(I);
+  }
+  {
+    CGO *cgo = NULL;
+    if (shouldCombine && I && I->has_begin_end){
+      cgo = CGOCombineBeginEnd(I, 0);
+      CGOFree(I);
+    } else {
+      cgo = I;
+    }
+    return cgo;
+  }
+}
+
+CGO *CGONew(PyMOLGlobals * G, int size)
+{
+  auto I = new CGO();
+  I->G = G;
+  I->op = VLACalloc(float, size + 32);
+#ifdef _PYMOL_IOS
+  if (!I->op){
+    delete I;
+    return NULL;
+  }
+#endif
+  I->normal[0] = 0.f; I->normal[1] = 0.f; I->normal[2] = 1.f;
+  I->color[0] = 0.f; I->color[1] = 0.f; I->color[2] = 1.f;
+  I->pickColor[0] = 0; I->pickColor[1] = 0; I->pickColor[2] = 0; I->pickColor[3] = 255;
+  I->cgo_shader_ub_color = SettingGetGlobal_i(G, cSetting_cgo_shader_ub_color);
+  I->cgo_shader_ub_normal = SettingGetGlobal_i(G, cSetting_cgo_shader_ub_normal);
+  return (I);
+}
+
+void CGOSetUseShader(CGO *I, int use_shader){
+  I->use_shader = use_shader;
+  if (use_shader){
+    I->cgo_shader_ub_color = SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_color);
+    I->cgo_shader_ub_normal = SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_normal);
+  } else {
+    I->cgo_shader_ub_color = 0;
+    I->cgo_shader_ub_normal = 0;
+  }
+}
+void CGOReset(CGO * I)
+{
+  I->c = 0;
+  I->z_flag = false;
+  I->alpha = 1.f;
+  I->has_begin_end = false;
+  I->has_draw_buffers = false;
+  I->has_draw_cylinder_buffers = false;
+  I->normal[0] = 0.f; I->normal[1] = 0.f; I->normal[2] = 1.f;
+  I->color[0] = 0.f; I->color[1] = 0.f; I->color[2] = 1.f;
+  I->pickColor[0] = 0; I->pickColor[1] = 0; I->pickColor[2] = 0; I->pickColor[3] = 255;
+  I->current_accessibility = 1.f;
+}
+
+void CGOFree(CGO * &I, bool withVBOs)
+{
+  if(I) {
+    if (withVBOs && I->has_draw_buffers){
+      CGOFreeStruct(I, true);
+    } else {
+      CGOFreeStruct(I, false);
+    }
+    if(I->i_start) {
+      FreeP(I->i_start);
+    }
+    VLAFreeP(I->op);
+    DeleteP(I);
+  }
+}
+
+static float *CGO_add(CGO * I, int c)
+{
+  float *at;
+  VLACheck(I->op, float, I->c + c);
+  if (!I->op){
+    return NULL;
+  }
+  at = I->op + I->c;
+  I->c += c;
+  return (at);
+}
+
+static float *CGO_size(CGO * I, int sz)
+{
+  float *at;
+  VLASize(I->op, float, sz);
+  if (!I->op){
+      return NULL;
+  }
+  at = I->op + I->c;
+  I->c = sz;
+  return (at);
+}
+
+
+/*===== Object Creation Routines =======*/
+
+int CGOFromFloatArray(CGO * I, const float *src, int len)
+{
+  int op, iarg;
+  int ok;
+  int all_ok = true;
+  int bad_entry = 0;
+  int sz;
+  int a;
+  int cc = 0;
+  float val;
+  float *pc, *save_pc, *tf;
+  VLACheck(I->op, float, I->c + len + 32);
+  save_pc = I->op + I->c;
+  while(len-- > 0) {
+    cc++;
+    op = CGO_MASK & ((int) (*(src++)));
+    sz = CGO_sz[op];
+    if(len < sz)
+      break;                    /* discard short instruction */
+    len -= sz;
+    pc = save_pc;
+    CGO_write_int(pc, op);
+    ok = true;
+    for(a = 0; a < sz; a++) {
+      cc++;
+      val = *(src++);
+      if((FLT_MAX - val) > 0.0F) {      /* make sure we have a real float */
+        *(pc++) = val;
+      } else {
+        *(pc++) = 0.0;
+        ok = false;
+      }
+    }
+    if(ok) {
+      switch (op) {
+      case CGO_END:
+      case CGO_VERTEX:
+      case CGO_BEGIN:
+	I->has_begin_end = true;
+      }
+      switch (op) {             /* now convert any instructions with int arguments */
+      case CGO_BEGIN:
+      case CGO_ENABLE:
+      case CGO_DISABLE:
+      case CGO_SPECIAL:
+        tf = save_pc + 1;
+        iarg = (int) *(tf);
+        CGO_write_int(tf, iarg);
+        break;
+      }
+      save_pc = pc;
+      I->c += sz + 1;
+    } else {                    /* discard illegal instructions */
+      if(all_ok)
+        bad_entry = cc;
+      all_ok = false;
+    }
+  }
+  return (bad_entry);
+}
+
+int CGOBegin(CGO * I, int mode)
+{
+  float *pc = CGO_add(I, CGO_BEGIN_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_BEGIN);
+  CGO_write_int(pc, mode);
+  I->has_begin_end = true;
+  I->texture[0] = 0.f;
+  I->texture[1] = 0.f;
+  return true;
+}
+
+int CGOEnd(CGO * I)
+{
+  float *pc = CGO_add(I, CGO_END_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_END);
+  I->has_begin_end = true;
+  return true;
+}
+
+int CGOEnable(CGO * I, int mode)
+{
+  float *pc = CGO_add(I, CGO_ENABLE_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_ENABLE);
+  CGO_write_int(pc, mode);
+  return true;
+}
+
+int CGODisable(CGO * I, int mode)
+{
+  float *pc = CGO_add(I, CGO_DISABLE_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_DISABLE);
+  CGO_write_int(pc, mode);
+  return true;
+}
+
+int CGOLinewidth(CGO * I, float v)
+{
+  float *pc = CGO_add(I, CGO_LINEWIDTH_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_LINEWIDTH);
+  *(pc++) = v;
+  return true;
+}
+
+/*
+ * implements special-case operations inside a CGO
+ *
+ * v: lookup value defined for each special operation (see CGO.h)
+ */
+int CGOSpecial(CGO * I, int v)
+{
+  float *pc = CGO_add(I, CGO_SPECIAL_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_SPECIAL);
+  CGO_write_int(pc, v);
+  return true;
+}
+
+/*
+ * implements special-case operations with an argument
+ * inside a CGO
+ *
+ * v: lookup value defined for each special operation (see CGO.h)
+ * argval : argument value
+ */
+int CGOSpecialWithArg(CGO * I, int v, float argval)
+{
+  float *pc = CGO_add(I, CGO_SPECIAL_WITH_ARG_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_SPECIAL_WITH_ARG);
+  CGO_write_int(pc, v);
+  *pc = argval;
+  return true;
+}
+
+int CGODotwidth(CGO * I, float v)
+{
+  float *pc = CGO_add(I, CGO_DOTWIDTH_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_DOTWIDTH);
+  *(pc++) = v;
+  return true;
+}
+
+/* CGOUniform3f - specifies a 3f uniform variable and
+   its value.  This function returns the offset of where
+   these values are stored inside the CGO float array
+   so that they can be accessed and changed from outside
+   the CGO.
+   
+ */
+int CGOUniform3f(CGO *I, int uniform_id, const float *value){
+  float *pc = CGO_add(I, CGO_UNIFORM3F_SZ + 1);
+  if (!pc)
+    return 0;
+  CGO_write_int(pc, CGO_UNIFORM3F);
+  CGO_write_int(pc, uniform_id);
+  copy3f(value, pc);
+  return pc - I->op;
+}
+
+int CGOBoundingBox(CGO *I, const float *min, const float *max){
+  float *pc = CGO_add(I, CGO_BOUNDING_BOX_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_BOUNDING_BOX);
+  *(pc++) = *(min);
+  *(pc++) = *(min+1);
+  *(pc++) = *(min+2);
+  *(pc++) = *(max);
+  *(pc++) = *(max+1);
+  *(pc++) = *(max+2);
+  return true;
+}
+
+int CGOAccessibility(CGO * I, float a)
+{
+  float *pc = CGO_add(I, CGO_ACCESSIBILITY_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_ACCESSIBILITY);
+  *(pc++) = a;
+  return true;
+}
+
+int CGODrawTexture(CGO *I, int texture_id, float *worldPos, float *screenMin, float *screenMax, float *textExtent)
+{
+  float *pc = CGO_add(I, CGO_DRAW_TEXTURE_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_DRAW_TEXTURE);
+  *(pc++) = worldPos[0];
+  *(pc++) = worldPos[1];
+  *(pc++) = worldPos[2];
+  *(pc++) = screenMin[0];
+  *(pc++) = screenMin[1];
+  *(pc++) = screenMin[2];
+  *(pc++) = screenMax[0];
+  *(pc++) = screenMax[1];
+  *(pc++) = screenMax[2];
+  *(pc++) = textExtent[0];
+  *(pc++) = textExtent[1];
+  *(pc++) = textExtent[2];
+  *(pc++) = textExtent[3];
+  return true;
+}
+
+int CGODrawConnector(CGO *I, float *targetPt3d, float *labelCenterPt3d, float text_width, float text_height, float *indentFactor, float *screenWorldOffset, float *connectorColor, short relativeMode, int draw_flags, float bkgrd_transp, float *bkgrd_color, float rel_ext_length, float connectorWidth)
+{
+  float *pc = CGO_add(I, CGO_DRAW_CONNECTOR_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_DRAW_CONNECTOR);
+  *(pc++) = targetPt3d[0];
+  *(pc++) = targetPt3d[1];
+  *(pc++) = targetPt3d[2];
+  *(pc++) = labelCenterPt3d[0];
+  *(pc++) = labelCenterPt3d[1];
+  *(pc++) = labelCenterPt3d[2];
+  *(pc++) = indentFactor[0];
+  *(pc++) = indentFactor[1];
+  *(pc++) = rel_ext_length; /* place for ext_length relative to height (i.e., text_height which is total height */
+  *(pc++) = screenWorldOffset[0];
+  *(pc++) = screenWorldOffset[1];
+  *(pc++) = screenWorldOffset[2];
+  *(pc++) = text_width;
+  *(pc++) = text_height;
+  *(pc++) = connectorColor[0];
+  *(pc++) = connectorColor[1];
+  *(pc++) = connectorColor[2];
+  *(pc++) = (float)relativeMode;
+  *(pc++) = (float)draw_flags;
+  *(pc++) = bkgrd_color[0];
+  *(pc++) = bkgrd_color[1];
+  *(pc++) = bkgrd_color[2];
+  *(pc++) = bkgrd_transp;
+  *(pc++) = connectorWidth; // place for label_connector_width
+  return true;
+}
+
+int CGODrawLabel(CGO *I, int texture_id, float *targetPos, float *worldPos, float *screenWorldOffset, float *screenMin, float *screenMax, float *textExtent, short relativeMode)
+{
+  float *pc = CGO_add(I, CGO_DRAW_LABEL_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_DRAW_LABEL);
+  *(pc++) = worldPos[0];
+  *(pc++) = worldPos[1];
+  *(pc++) = worldPos[2];
+  *(pc++) = screenWorldOffset[0];
+  *(pc++) = screenWorldOffset[1];
+  *(pc++) = screenWorldOffset[2];
+  *(pc++) = screenMin[0];
+  *(pc++) = screenMin[1];
+  *(pc++) = screenMin[2];
+  *(pc++) = screenMax[0];
+  *(pc++) = screenMax[1];
+  *(pc++) = screenMax[2];
+  *(pc++) = textExtent[0];
+  *(pc++) = textExtent[1];
+  *(pc++) = textExtent[2];
+  *(pc++) = textExtent[3];
+  *(pc++) = (float)relativeMode;
+  *(pc++) = targetPos[0];
+  *(pc++) = targetPos[1];
+  *(pc++) = targetPos[2];
+  return true;
+}
+
+int CGOConev(CGO * I,
+    const float *p1,
+    const float *p2, float r1, float r2,
+    const float *c1,
+    const float *c2,
+              float cap1, float cap2)
+{
+  float *pc = CGO_add(I, CGO_CONE_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_CONE);
+  *(pc++) = *(p1++);
+  *(pc++) = *(p1++);
+  *(pc++) = *(p1++);
+  *(pc++) = *(p2++);
+  *(pc++) = *(p2++);
+  *(pc++) = *(p2++);
+  *(pc++) = r1;
+  *(pc++) = r2;
+  *(pc++) = *(c1++);
+  *(pc++) = *(c1++);
+  *(pc++) = *(c1++);
+  *(pc++) = *(c2++);
+  *(pc++) = *(c2++);
+  *(pc++) = *(c2++);
+  *(pc++) = cap1;
+  *(pc++) = cap2;
+  return true;
+}
+
+void SetCGOPickColor(float *begPickColorVals, int nverts, int pl, unsigned int index, int bond){
+  float *colorVals = begPickColorVals + nverts;
+  int pld = pl / 3;
+  /* Picking Color stores atom/bond info in the second 2/3rds of the array */
+  CGO_put_uint(colorVals + (pld*2), index);
+  CGO_put_int(colorVals + (pld*2) + 1, bond);
+}
+int CGOPickColor(CGO * I, unsigned int index, int bond)
+{
+  // check if uchar is -1 since extrude does this for masked atoms
+  if (index == (unsigned int)-1){
+    bond = cPickableNoPick;
+  }
+  if (I->current_pick_color_index==index &&
+      I->current_pick_color_bond==bond)
+    return true;
+  float *pc = CGO_add(I, CGO_PICK_COLOR_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_PICK_COLOR);
+  CGO_write_uint(pc, index);
+  CGO_write_int(pc, bond);
+  I->current_pick_color_index = index;
+  I->current_pick_color_bond = bond;
+  return true;
+}
+
+int CGOAlpha(CGO * I, float alpha)
+{
+  float *pc = CGO_add(I, CGO_ALPHA_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_ALPHA);
+  *(pc++) = alpha;
+  I->alpha = alpha;
+  return true;
+}
+
+int CGOSphere(CGO * I, const float *v1, float r)
+{
+  float *pc = CGO_add(I, CGO_SPHERE_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_SPHERE);
+  *(pc++) = *(v1++);
+  *(pc++) = *(v1++);
+  *(pc++) = *(v1++);
+  *(pc++) = r;
+  return true;
+}
+
+int CGOEllipsoid(CGO * I, const float *v1, float r,
+    const float *n1,
+    const float *n2,
+    const float *n3)
+{
+  float *pc = CGO_add(I, CGO_ELLIPSOID_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_ELLIPSOID);
+
+  *(pc++) = *(v1++);
+  *(pc++) = *(v1++);
+  *(pc++) = *(v1++);
+  *(pc++) = r;
+  *(pc++) = *(n1++);
+  *(pc++) = *(n1++);
+  *(pc++) = *(n1++);
+  *(pc++) = *(n2++);
+  *(pc++) = *(n2++);
+  *(pc++) = *(n2++);
+  *(pc++) = *(n3++);
+  *(pc++) = *(n3++);
+  *(pc++) = *(n3++);
+  return true;
+}
+
+int CGOQuadric(CGO * I, const float *v, float r, const float *q)
+{
+  float *pc = CGO_add(I, CGO_QUADRIC_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_QUADRIC);
+
+  *(pc++) = *(v++);
+  *(pc++) = *(v++);
+  *(pc++) = *(v++);
+  *(pc++) = r;
+
+  *(pc++) = *(q++);
+  *(pc++) = *(q++);
+  *(pc++) = *(q++);
+  *(pc++) = *(q++);
+  *(pc++) = *(q++);
+
+  *(pc++) = *(q++);
+  *(pc++) = *(q++);
+  *(pc++) = *(q++);
+  *(pc++) = *(q++);
+  *(pc++) = *(q++);
+  return true;
+}
+
+void CGOSetZVector(CGO * I, float z0, float z1, float z2)
+{
+  I->z_flag = true;
+  I->z_vector[0] = z0;
+  I->z_vector[1] = z1;
+  I->z_vector[2] = z2;
+  I->z_min = FLT_MAX;
+  I->z_max = -FLT_MAX;
+}
+
+const static float one_third = 1.0F / 3.0F;
+const static float _0 = 0.0F;
+
+int CGOAlphaTriangle(CGO * I,
+                      const float *v1, const float *v2, const float *v3,
+                      const float *n1, const float *n2, const float *n3,
+                      const float *c1, const float *c2, const float *c3,
+                      float a1, float a2, float a3, int reverse)
+{
+  if(v1 && v2 && v3) {
+    float *pc = CGO_add(I, CGO_ALPHA_TRIANGLE_SZ + 1);
+    float z = _0;
+    if (!pc)
+      return false;
+    CGO_write_int(pc, CGO_ALPHA_TRIANGLE);
+    CGO_write_int(pc, 0);  // this is the place for the next triangle in the bin
+    *(pc++) = (v1[0] + v2[0] + v3[0]) * one_third;
+    *(pc++) = (v1[1] + v2[1] + v3[1]) * one_third;
+    *(pc++) = (v1[2] + v2[2] + v3[2]) * one_third;
+    if(I->z_flag) {
+      float *zv = I->z_vector;
+      z = pc[-3] * zv[0] + pc[-2] * zv[1] + pc[-1] * zv[2];
+      if(z > I->z_max)
+        I->z_max = z;
+      if(z < I->z_min)
+        I->z_min = z;
+    }
+    *(pc++) = z;
+
+    if(reverse) {
+      *(pc++) = *(v2++);        /* vertices @ +5 */
+      *(pc++) = *(v2++);
+      *(pc++) = *(v2++);
+      *(pc++) = *(v1++);
+      *(pc++) = *(v1++);
+      *(pc++) = *(v1++);
+    } else {
+      *(pc++) = *(v1++);        /* vertices @ +5 */
+      *(pc++) = *(v1++);
+      *(pc++) = *(v1++);
+      *(pc++) = *(v2++);
+      *(pc++) = *(v2++);
+      *(pc++) = *(v2++);
+    }
+
+    *(pc++) = *(v3++);
+    *(pc++) = *(v3++);
+    *(pc++) = *(v3++);
+
+    if(reverse) {
+      *(pc++) = *(n2++);        /* normals @ +14 */
+      *(pc++) = *(n2++);
+      *(pc++) = *(n2++);
+      *(pc++) = *(n1++);
+      *(pc++) = *(n1++);
+      *(pc++) = *(n1++);
+    } else {
+      *(pc++) = *(n1++);        /* normals @ +14 */
+      *(pc++) = *(n1++);
+      *(pc++) = *(n1++);
+      *(pc++) = *(n2++);
+      *(pc++) = *(n2++);
+      *(pc++) = *(n2++);
+    }
+    *(pc++) = *(n3++);
+    *(pc++) = *(n3++);
+    *(pc++) = *(n3++);
+
+    if(reverse) {
+      *(pc++) = *(c2++);        /* colors @ +23 */
+      *(pc++) = *(c2++);
+      *(pc++) = *(c2++);
+      *(pc++) = a2;
+      *(pc++) = *(c1++);
+      *(pc++) = *(c1++);
+      *(pc++) = *(c1++);
+      *(pc++) = a1;
+    } else {
+      *(pc++) = *(c1++);        /* colors @ +23 */
+      *(pc++) = *(c1++);
+      *(pc++) = *(c1++);
+      *(pc++) = a1;
+      *(pc++) = *(c2++);
+      *(pc++) = *(c2++);
+      *(pc++) = *(c2++);
+      *(pc++) = a2;
+    }
+    *(pc++) = *(c3++);
+    *(pc++) = *(c3++);
+    *(pc++) = *(c3++);
+    *(pc++) = a3;
+  }
+  return true;
+}
+
+int CGOVertex(CGO * I, float v1, float v2, float v3)
+{
+  float *pc = CGO_add(I, CGO_VERTEX_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_VERTEX);
+  *(pc++) = v1;
+  *(pc++) = v2;
+  *(pc++) = v3;
+  return true;
+}
+
+int CGOVertexv(CGO * I, const float *v)
+{
+  float *pc = CGO_add(I, CGO_VERTEX_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_VERTEX);
+  *(pc++) = *(v++);
+  *(pc++) = *(v++);
+  *(pc++) = *(v++);
+  return true;
+}
+
+int CGOVertexBeginLineStripv(CGO * I, const float *v)
+{
+  float *pc = CGO_add(I, CGO_VERTEX_BEGIN_LINE_STRIP_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_VERTEX_BEGIN_LINE_STRIP);
+  *(pc++) = *(v++);
+  *(pc++) = *(v++);
+  *(pc++) = *(v++);
+  return true;
+}
+
+int CGOVertexCrossv(CGO * I, const float *v)
+{
+  float *pc = CGO_add(I, CGO_VERTEX_CROSS_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_VERTEX_CROSS);
+  *(pc++) = *(v++);
+  *(pc++) = *(v++);
+  *(pc++) = *(v++);
+  return true;
+}
+int CGOInterpolated(CGO * I, const bool interp)
+{
+  float *pc = CGO_add(I, CGO_INTERPOLATED_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_INTERPOLATED);
+  *(pc++) = interp ? 1.f : 0.f;
+  I->interpolated = interp;
+  return true;
+}
+
+int CGOColor(CGO * I, float v1, float v2, float v3)
+{
+  float *pc = CGO_add(I, CGO_COLOR_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_COLOR);
+  *(pc++) = v1;
+  *(pc++) = v2;
+  *(pc++) = v3;
+  I->color[0] = v1;
+  I->color[1] = v2;
+  I->color[2] = v3;
+  return true;
+}
+
+int CGOColorv(CGO * I, const float *v)
+{
+  return CGOColor(I, v[0], v[1], v[2]);
+}
+
+int CGOTexCoord2f(CGO * I, float v1, float v2){
+  float *pc = CGO_add(I, CGO_TEX_COORD_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_TEX_COORD);
+  *(pc++) = v1;
+  *(pc++) = v2;
+  I->texture[0] = v1;
+  I->texture[1] = v2;
+  return true;
+}
+
+int CGONormal(CGO * I, float v1, float v2, float v3)
+{
+  float *pc = CGO_add(I, CGO_NORMAL_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_NORMAL);
+  *(pc++) = v1;
+  *(pc++) = v2;
+  *(pc++) = v3;
+  I->normal[0] = v1;
+  I->normal[1] = v2;
+  I->normal[2] = v3;
+  return true;
+}
+
+int CGOResetNormal(CGO * I, int mode)
+{
+  float *pc = CGO_add(I, CGO_RESET_NORMAL_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_RESET_NORMAL);
+  CGO_write_int(pc, mode);
+  SceneGetResetNormal(I->G, I->normal, mode);
+  return true;
+}
+
+int CGOFontVertexv(CGO * I, const float *v)
+{
+  float *pc = CGO_add(I, CGO_FONT_VERTEX_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_FONT_VERTEX);
+  *(pc++) = *(v++);
+  *(pc++) = *(v++);
+  *(pc++) = *(v++);
+  return true;
+}
+
+int CGOFontVertex(CGO * I, float x, float y, float z)
+{
+  float *pc = CGO_add(I, CGO_FONT_VERTEX_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_FONT_VERTEX);
+  *(pc++) = x;
+  *(pc++) = y;
+  *(pc++) = z;
+  return true;
+}
+
+int CGOFontScale(CGO * I, float v1, float v2)
+{
+  float *pc = CGO_add(I, CGO_FONT_SCALE_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_FONT_SCALE);
+  *(pc++) = v1;
+  *(pc++) = v2;
+  return true;
+}
+
+int CGOChar(CGO * I, char c)
+{
+  float *pc = CGO_add(I, CGO_CHAR_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_CHAR);
+  *(pc++) = (float) c;
+  return true;
+}
+
+int CGOIndent(CGO * I, char c, float dir)
+{
+  float *pc = CGO_add(I, CGO_INDENT_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_INDENT);
+  *(pc++) = (float) c;
+  *(pc++) = dir;
+  return true;
+}
+
+int CGOWrite(CGO * I, const char *str)
+{
+  float *pc;
+
+  while(*str) {
+    pc = CGO_add(I, CGO_CHAR_SZ + 1);
+    if (!pc)
+      return false;
+    CGO_write_int(pc, CGO_CHAR);
+    *(pc++) = (float) *(str++);
+  }
+  return true;
+}
+
+int CGOWriteLeft(CGO * I, const char *str)
+{
+  float *pc;
+  const char *s = str;
+  while(*s) {
+    pc = CGO_add(I, CGO_INDENT_SZ + 1);
+    if (!pc)
+      return false;
+    CGO_write_int(pc, CGO_INDENT);
+    *(pc++) = (float) *(s++);
+    *(pc++) = -1.0F;
+  }
+  s = str;
+  while(*s) {
+    pc = CGO_add(I, CGO_CHAR_SZ + 1);
+    if (!pc)
+      return false;
+    CGO_write_int(pc, CGO_CHAR);
+    *(pc++) = (float) *(s++);
+  }
+  return true;
+}
+
+int CGOWriteIndent(CGO * I, const char *str, float indent)
+{
+  float *pc;
+  const char *s = str;
+  while(*s) {
+    pc = CGO_add(I, CGO_INDENT_SZ + 1);
+    if (!pc)
+      return false;
+    CGO_write_int(pc, CGO_INDENT);
+    *(pc++) = (float) *(s++);
+    *(pc++) = indent;
+  }
+  s = str;
+  while(*s) {
+    pc = CGO_add(I, CGO_CHAR_SZ + 1);
+    if (!pc)
+      return false;
+    CGO_write_int(pc, CGO_CHAR);
+    *(pc++) = (float) *(s++);
+  }
+  return true;
+}
+
+int CGONormalv(CGO * I, const float *v)
+{
+  float *pc = CGO_add(I, CGO_NORMAL_SZ + 1);
+  if (!pc)
+    return false;
+  CGO_write_int(pc, CGO_NORMAL);
+  *(pc++) = *(v++);
+  *(pc++) = *(v++);
+  *(pc++) = *(v++);
+  return true;
+}
+
+/*
+ * Add a null terminator to the CGO buffer, but don't increment
+ * the size variable (CGO::c).
+ */
+int CGOStop(CGO * I)
+{
+#define CGO_STOP_ZEROS 1
+
+  float *pc = CGO_size(I, I->c + CGO_STOP_ZEROS);
+  if (!pc)
+    return false;
+  UtilZeroMem(pc, sizeof(float) * CGO_STOP_ZEROS);
+  I->c -= CGO_STOP_ZEROS;
+  return true;
+}
+
+int CGOCheckComplex(CGO * I)
+{
+  float *pc = I->op;
+  int fc = 0;
+  int nEdge;
+  int op;
+  SphereRec *sp;
+
+  sp = I->G->Sphere->Sphere[1];
+
+  /* stick_quality needs to match *every* CGO? */
+  nEdge = SettingGetGlobal_i(I->G, cSetting_stick_quality);
+
+  while((op = (CGO_MASK & CGO_read_int(pc)))) {
+    switch (op) {
+    case CGO_CYLINDER:
+    case CGO_CONE:
+    case CGO_SAUSAGE:
+    case CGO_CUSTOM_CYLINDER:
+    case CGO_CUSTOM_CYLINDER_ALPHA:
+      fc += 3 * (3 + (nEdge + 1) * 9) + 9;
+      break;
+    case CGO_ELLIPSOID:
+    case CGO_QUADRIC:
+    case CGO_SPHERE:
+      fc += (sp->NVertTot * 6) + (sp->NStrip * 3) + 3;
+      break;
+    case CGO_DRAW_ARRAYS:
+      {
+        cgo::draw::arrays * sp = reinterpret_cast<decltype(sp)>(pc);
+	fc += sp->nverts;
+      }
+      break;
+    case CGO_DRAW_BUFFERS_INDEXED:
+      {
+        cgo::draw::buffers_indexed * sp = reinterpret_cast<decltype(sp)>(pc);
+	switch(sp->mode){
+	case GL_TRIANGLES:
+	  fc += sp->nindices / 3;
+	  break;
+	case GL_LINES:
+	  fc += sp->nindices / 2;
+	  break;
+	}
+      }
+      break;
+    case CGO_DRAW_BUFFERS_NOT_INDEXED:
+      {
+        cgo::draw::buffers_not_indexed * sp = reinterpret_cast<decltype(sp)>(pc);
+	switch(sp->mode){
+	case GL_TRIANGLES:
+	  fc += sp->nverts / 3;
+	  break;
+	case GL_LINES:
+	  fc += sp->nverts / 2;
+	  break;
+	}
+      }
+      break;
+    case CGO_DRAW_SPHERE_BUFFERS:
+      {
+        cgo::draw::sphere_buffers * sp = reinterpret_cast<decltype(sp)>(pc);
+        fc += sp->num_spheres * VERTICES_PER_SPHERE;
+      }
+      break;
+    case CGO_DRAW_CYLINDER_BUFFERS:
+      {
+        cgo::draw::cylinder_buffers * sp = reinterpret_cast<decltype(sp)>(pc);
+        fc += sp->num_cyl * NUM_VERTICES_PER_CYLINDER;
+      }
+      break;
+    }
+    pc += CGO_sz[op];
+  }
+  return (fc);
+}
+
+int CGOPreloadFonts(CGO * I)
+{
+  int ok = true;
+  float *pc = I->op;
+  int op;
+  int font_seen = false;
+  int font_id;
+  int blocked = false;
+
+  blocked = PAutoBlock(I->G);
+  while((op = (CGO_MASK & CGO_read_int(pc)))) {
+    switch (op) {
+    case CGO_FONT:
+      ok = ok && (VFontLoad(I->G, 1.0, 1, 1, true));
+      font_seen = true;
+      break;
+    case CGO_CHAR:
+      if(!font_seen) {
+        font_id = VFontLoad(I->G, 1.0, 1, 1, true);
+        ok = ok && font_id;
+        font_seen = true;
+      }
+      break;
+    }
+    pc += CGO_sz[op];
+  }
+  if(blocked)
+    PUnblock(I->G);
+  return (ok);
+}
+
+int CGOCheckForText(CGO * I)
+{
+  float *pc = I->op;
+  int fc = 0;
+  int op;
+
+  while((op = (CGO_MASK & CGO_read_int(pc)))) {
+    switch (op) {
+    case CGO_FONT:
+    case CGO_FONT_AXES:
+    case CGO_FONT_SCALE:
+      fc++;
+      break;
+    case CGO_INDENT:
+    case CGO_FONT_VERTEX:
+      fc++;
+      break;
+    case CGO_CHAR:
+      fc += 3 + 2 * 3 * 10;     /* est 10 lines per char */
+      break;
+    }
+    pc += CGO_sz[op];
+  }
+  PRINTFD(I->G, FB_CGO)
+    " CGOCheckForText-Debug: %d\n", fc ENDFD;
+
+  return (fc);
+}
+
+CGO *CGODrawText(CGO * I, int est, float *camera)
+{                               /* assumes blocked intepreter */
+  CGO *cgo;
+  float *pc = I->op;
+  int op;
+  float *save_pc;
+  int font_id = 0;
+  char text[2] = " ";
+  float pos[] = { 0.0F, 0.0F, 0.0F };
+  float axes[] = { 1.0F, 0.0F, 0.0F,
+    0.0F, 1.0F, 0.0F,
+    0.0F, 0.0F, 1.0F
+  };
+  float scale[2] = { 1.0, 1.0 };
+
+  cgo = CGONewSized(I->G, I->c + est);
+
+  while((op = (CGO_MASK & CGO_read_int(pc)))) {
+    save_pc = pc;
+    switch (op) {
+    case CGO_FONT:
+      break;
+    case CGO_FONT_AXES:
+      break;
+    case CGO_FONT_SCALE:
+      scale[0] = pc[0];
+      scale[1] = pc[1];
+      break;
+    case CGO_FONT_VERTEX:
+      copy3f(pc, pos);
+      break;
+    case CGO_INDENT:
+      text[0] = (unsigned char) *pc;
+      VFontIndent(I->G, font_id, text, pos, scale, axes, pc[1]);
+      break;
+    case CGO_CHAR:
+      if(!font_id) {
+        font_id = VFontLoad(I->G, 1.0, 1, 1, false);
+      }
+      text[0] = (unsigned char) *pc;
+      VFontWriteToCGO(I->G, font_id, cgo, text, pos, scale, axes, cgo->color);
+      break;
+    case CGO_COLOR:
+      cgo->color[0] = *pc; cgo->color[1] = *(pc + 1); cgo->color[2] = *(pc + 2);
+    default:
+      cgo->add_to_cgo(op, pc);
+    }
+    pc = save_pc;
+    pc += CGO_sz[op];
+  }
+  CGOStop(cgo);
+  if (cgo && cgo->has_begin_end){
+    /* this is mainly for VFontWriteToCGO() that still creates CGOBegin/CGOEnd */
+    if(cgo && cgo->has_begin_end){
+      CGO *convertcgo = NULL;
+      convertcgo = CGOCombineBeginEnd(cgo, 0);
+      CGOFree(cgo);
+      cgo = convertcgo;
+    }
+  }
+  return (cgo);
+}
+
+static
+void CGOAddVertexToDrawArrays(CGO *cgo, int pl, int plc, int pla, const float *vertex,
+                              short notHaveValue, float *vertexVals, float *normalVals,
+                              float *colorVals, float *pickColorVals, float *accessibilityVals){
+  float *tmp_ptr;
+  if (notHaveValue & CGO_NORMAL_ARRAY){
+    if (pl){
+      tmp_ptr = &normalVals[pl-3];
+      copy3f(tmp_ptr, &normalVals[pl]);
+    } else {
+      copy3f(cgo->normal, &normalVals[pl]);
+    }
+  }
+  if (notHaveValue & CGO_COLOR_ARRAY){
+    if (plc){
+      tmp_ptr = &colorVals[plc-4];
+      copy4f(tmp_ptr, &colorVals[plc]);
+    } else {
+      copy3f(&colorVals[plc], cgo->color);
+      colorVals[plc+3] = cgo->alpha;
+    }
+  }
+  if (pickColorVals){
+    CGO_put_uint(pickColorVals + pla * 2, cgo->current_pick_color_index);
+    CGO_put_int(pickColorVals + pla * 2 + 1, cgo->current_pick_color_bond);
+  }
+  if (accessibilityVals){
+    accessibilityVals[pla] = cgo->current_accessibility;
+  }
+  copy3f(vertex, &vertexVals[pl]);
+}
+
+bool CGOCombineBeginEnd(CGO ** I, bool do_not_split_lines) {
+  CGO *cgo = CGOCombineBeginEnd(*I, 0, do_not_split_lines);
+  CGOFree(*I);
+  *I = cgo;
+  return (cgo != NULL);
+}
+
+CGO *CGOCombineBeginEnd(const CGO * I, int est, bool do_not_split_lines)
+{
+  CGO *cgo;
+
+  int ok = true;
+  if (!I)
+      return NULL;
+  cgo = CGONewSized(I->G, 0);
+  ok &= cgo ? true : false;
+
+  for (auto it = I->begin(); ok && !it.is_stop(); ++it) {
+    auto pc = it.data();
+    int op = it.op_code();
+
+    switch (op) {
+    case CGO_END:
+    case CGO_VERTEX:
+      PRINTFB(I->G, FB_CGO, FB_Warnings)
+        " CGOCombineBeginEnd: op=0x%02x encountered without CGO_BEGIN\n", op
+        ENDFB(I->G);
+      break;
+    case CGO_BEGIN:
+      {
+	float firstColor[3], firstAlpha;
+	char hasFirstColor = 0, hasFirstAlpha = 0;
+	int nverts = 0, damode = CGO_VERTEX_ARRAY, err = 0;
+
+        // read int argument of the BEGIN operation
+        int mode = CGO_get_int(it.data());
+        ++it;
+
+        // we want to iterate twice over the BEGIN/END block
+        auto it2 = it;
+
+        // first iteration over BEGIN/END block (consumes 'it')
+        for (; !err && it != CGO_END; ++it) {
+          auto pc = it.data();
+          switch (it.op_code()) {
+	  case CGO_DRAW_ARRAYS:
+	  case CGO_STOP:
+	    PRINTFB(I->G, FB_CGO, FB_Errors)
+	      " CGO-Error: CGOCombineBeginEnd: invalid op=0x%02x inside BEGIN/END\n",
+	      it.op_code() ENDFB(I->G);
+	    err = true;
+	    continue;
+	  case CGO_NORMAL:
+	    damode |= CGO_NORMAL_ARRAY;
+	    break;
+	  case CGO_COLOR:
+	    if (!nverts){
+	      hasFirstColor = 1;
+	      copy3f(pc, firstColor);
+	    } else {
+	      hasFirstColor = 0;
+	      damode |= CGO_COLOR_ARRAY;
+	    } 
+	    copy3f(pc, cgo->color);
+	    break;
+	  case CGO_PICK_COLOR:
+	    damode |= CGO_PICK_COLOR_ARRAY;
+	    break;
+	  case CGO_ACCESSIBILITY:
+	    damode |= CGO_ACCESSIBILITY_ARRAY;
+	    break;
+	  case CGO_VERTEX:
+	    nverts++;
+	    break;
+	  case CGO_ALPHA:
+	    cgo->alpha = *pc;
+	    if (!nverts){
+	      hasFirstAlpha = 1;
+	      firstAlpha = cgo->alpha;
+	    } else {
+	      hasFirstAlpha = 0;
+	      damode |= CGO_COLOR_ARRAY;
+	    }
+            break;
+          case CGO_LINE:
+            nverts+=2;
+            break;
+          case CGO_SPLITLINE:
+            {
+              auto splitline = reinterpret_cast<const cgo::draw::splitline *>(pc);
+              if (do_not_split_lines || (splitline->flags & cgo::draw::splitline::equal_colors)){
+                nverts+=2;
+              } else {
+                nverts+=4;
+              }
+            }
+            break;
+	  }
+	}
+	if (nverts>0 && !err){
+	  int pl = 0, plc = 0, pla = 0;
+	  float *vertexVals;
+	  float *normalVals = 0, *colorVals = 0, *nxtVals = 0, *pickColorVals = 0, *accessibilityVals = 0;
+	  short notHaveValue = 0, nxtn = 3;
+	  if (hasFirstAlpha || hasFirstColor){
+	    if (hasFirstAlpha){
+	      CGOAlpha(cgo, firstAlpha);
+	    }
+	    if (hasFirstColor){
+	      CGOColorv(cgo, firstColor);
+	    }
+	  }
+	  nxtVals = vertexVals = cgo->add<cgo::draw::arrays>(mode, damode, nverts);
+	  ok &= vertexVals ? true : false;
+	  if (!ok)
+	    continue;
+	  if (damode & CGO_NORMAL_ARRAY){
+	    nxtVals = normalVals = vertexVals + (nxtn*nverts);
+	    nxtn = 3;
+	  }
+	  if (damode & CGO_COLOR_ARRAY){
+	    nxtVals = colorVals = nxtVals + (nxtn*nverts);
+	    nxtn = 4;
+	  }
+	  if (damode & CGO_PICK_COLOR_ARRAY){
+	    nxtVals = nxtVals + (nxtn*nverts);
+	    pickColorVals = nxtVals + nverts;
+	    nxtn = 3;
+	  }
+	  if (damode & CGO_ACCESSIBILITY_ARRAY){
+	    nxtVals = nxtVals + (nxtn*nverts);
+	    accessibilityVals = nxtVals;
+	    nxtn = 1;
+	  }
+	  notHaveValue = damode;
+
+          // second iteration (with copy of iterator, doesn't consume 'it')
+          for (; ok && it2 != CGO_END; ++it2) {
+            auto pc = it2.data();
+            switch (it2.op_code()) {
+	    case CGO_NORMAL:
+	      copy3f(pc, &normalVals[pl]);
+	      notHaveValue &= ~CGO_NORMAL_ARRAY;
+	      break;
+	    case CGO_COLOR:
+	      if (colorVals){
+		copy3f(pc, &colorVals[plc]);
+		colorVals[plc+3] = cgo->alpha;
+		notHaveValue &= ~CGO_COLOR_ARRAY;
+	      }
+	      copy3f(pc, cgo->color);
+	      break;
+	    case CGO_PICK_COLOR:
+	      cgo->current_pick_color_index = CGO_get_uint(pc);
+	      cgo->current_pick_color_bond = CGO_get_int(pc + 1);
+	      notHaveValue &= ~CGO_PICK_COLOR_ARRAY;
+	      break;
+	    case CGO_ACCESSIBILITY:
+	      cgo->current_accessibility = pc[0];
+	      break;
+	    case CGO_SPLITLINE:
+              {
+                auto splitline = reinterpret_cast<const cgo::draw::splitline *>(pc);
+                float color2[] = { CONVERT_COLOR_VALUE(splitline->color2[0]),
+                                   CONVERT_COLOR_VALUE(splitline->color2[1]),
+                                   CONVERT_COLOR_VALUE(splitline->color2[2]) };
+                if (do_not_split_lines || (splitline->flags & cgo::draw::splitline::equal_colors)){
+                  CGOAddVertexToDrawArrays(cgo, pl, plc, pla, splitline->vertex1, notHaveValue, vertexVals,
+                                           normalVals, colorVals, pickColorVals, accessibilityVals);
+                  pl+=3; plc+=4; pla++;
+                  notHaveValue = damode;
+
+                  if (!(splitline->flags & cgo::draw::splitline::equal_colors)){
+                    if (colorVals){
+                      copy3f(color2, &colorVals[plc]);
+                      colorVals[plc+3] = cgo->alpha;
+                      notHaveValue = notHaveValue & ~CGO_COLOR_ARRAY;
+                    }
+                    copy3f(color2, cgo->color);
+                  }
+                  if (pickColorVals){
+                    cgo->current_pick_color_index = splitline->index;
+                    cgo->current_pick_color_bond = splitline->bond;
+                    notHaveValue = notHaveValue & ~CGO_PICK_COLOR_ARRAY;
+                  }
+                  CGOAddVertexToDrawArrays(cgo, pl, plc, pla, splitline->vertex2, notHaveValue, vertexVals,
+                                           normalVals, colorVals, pickColorVals, accessibilityVals);
+                  pl+=3; plc+=4; pla++;
+                  notHaveValue = damode;
+                } else {
+                  float mid[3];
+                  add3f(splitline->vertex1, splitline->vertex2, mid);
+                  mult3f(mid, .5f, mid);
+                  CGOAddVertexToDrawArrays(cgo, pl, plc, pla, splitline->vertex1, notHaveValue, vertexVals,
+                                           normalVals, colorVals, pickColorVals, accessibilityVals);
+                  notHaveValue = damode;
+                  pl+=3; plc+=4; pla++;
+                  CGOAddVertexToDrawArrays(cgo, pl, plc, pla, mid, notHaveValue, vertexVals,
+                                           normalVals, colorVals, pickColorVals, accessibilityVals);
+                  pl+=3; plc+=4; pla++;
+                  if (colorVals){
+                    copy3f(color2, &colorVals[plc]);
+                    colorVals[plc+3] = cgo->alpha;
+                    notHaveValue = notHaveValue & ~CGO_COLOR_ARRAY;
+                  }
+                  copy3f(color2, cgo->color);
+                  if (pickColorVals){
+                    cgo->current_pick_color_index = splitline->index;
+                    cgo->current_pick_color_bond = splitline->bond;
+                    notHaveValue = notHaveValue & ~CGO_PICK_COLOR_ARRAY;
+                  }
+                  CGOAddVertexToDrawArrays(cgo, pl, plc, pla, mid, notHaveValue, vertexVals,
+                                           normalVals, colorVals, pickColorVals, accessibilityVals);
+                  notHaveValue = damode;
+                  pl+=3; plc+=4; pla++;
+                  CGOAddVertexToDrawArrays(cgo, pl, plc, pla, splitline->vertex2, notHaveValue, vertexVals,
+                                           normalVals, colorVals, pickColorVals, accessibilityVals);
+                  pl+=3; plc+=4; pla++;
+                  notHaveValue = damode;
+                }
+              }
+              break;
+	    case CGO_LINE:
+              {
+                auto line = reinterpret_cast<const cgo::draw::line *>(pc);
+                CGOAddVertexToDrawArrays(cgo, pl, plc, pla, line->vertex1, notHaveValue, vertexVals,
+                                         normalVals, colorVals, pickColorVals, accessibilityVals);
+                pl+=3; plc+=4; pla++;
+                notHaveValue = damode;
+                CGOAddVertexToDrawArrays(cgo, pl, plc, pla, line->vertex2, notHaveValue, vertexVals,
+                                         normalVals, colorVals, pickColorVals, accessibilityVals);
+                pl+=3; plc+=4; pla++;
+              }
+	      break;
+	    case CGO_VERTEX:
+              CGOAddVertexToDrawArrays(cgo, pl, plc, pla, pc, notHaveValue, vertexVals,
+                                       normalVals, colorVals, pickColorVals, accessibilityVals);
+	      pl+=3; plc+=4; pla++;
+	      notHaveValue = damode;
+	      break;
+	    case CGO_ALPHA:
+	      // in case we're before CGO_COLOR
+	      cgo->alpha = *pc;
+	      if (colorVals) {
+		// in case we're after CGO_COLOR
+		colorVals[plc + 3] = *pc;
+	      }
+	      break;
+	    }
+	  }
+	}
+      }
+      break;
+    case CGO_PICK_COLOR:
+      cgo->current_pick_color_index = CGO_get_uint(pc);
+      cgo->current_pick_color_bond = CGO_get_int(pc + 1);
+      cgo->add_to_cgo(op, pc);
+      break;
+    case CGO_ALPHA:
+      cgo->alpha = *pc;
+    default:
+      cgo->add_to_cgo(op, pc);
+    }
+  }
+  if (ok){
+    ok &= CGOStop(cgo);
+    if (ok){
+      cgo->use_shader = I->use_shader;
+      if (cgo->use_shader){
+	cgo->cgo_shader_ub_color = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_color);
+	cgo->cgo_shader_ub_normal = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_normal);
+      }
+    }
+  }
+  if (!ok){
+    CGOFree(cgo);
+  }
+  return (cgo);
+}
+
+void CGOFreeVBOs(CGO * I) {
+  CGOFreeStruct(I, true);
+}
+void CGOFreeStruct(CGO *I, bool freevbos){
+  float *pc = I->op;
+  int op = 0;
+  while((op = (CGO_MASK & CGO_read_int(pc)))) {
+    switch (op) {
+    case CGO_DRAW_TRILINES:
+    {
+      int buf = CGO_get_int(pc + 1);
+      if (freevbos)
+        I->G->ShaderMgr->AddVBOToFree(buf);
+    }
+    break;
+    case CGO_DRAW_CUSTOM:
+    {
+      cgo::draw::custom * sp = reinterpret_cast<decltype(sp)>(pc);
+      if (freevbos) {
+        I->G->ShaderMgr->freeGPUBuffer(sp->vboid);
+        I->G->ShaderMgr->freeGPUBuffer(sp->iboid);
+        I->G->ShaderMgr->freeGPUBuffer(sp->pickvboid);
+      }
+    }
+    break;
+    case CGO_DRAW_SPHERE_BUFFERS:
+    {
+      cgo::draw::sphere_buffers * sp = reinterpret_cast<decltype(sp)>(pc);
+      if (freevbos) {
+        I->G->ShaderMgr->freeGPUBuffer(sp->vboid);
+        I->G->ShaderMgr->freeGPUBuffer(sp->pickvboid);
+      }
+    }
+    break;
+    case CGO_DRAW_LABELS:
+    {
+      cgo::draw::labels * sp;
+      sp = reinterpret_cast<decltype(sp)>(pc);
+      if (freevbos) {
+        I->G->ShaderMgr->freeGPUBuffer(sp->vboid);
+        I->G->ShaderMgr->freeGPUBuffer(sp->pickvboid);
+      }
+    }
+    break;
+    case CGO_DRAW_TEXTURES:
+    {
+      cgo::draw::textures * sp = reinterpret_cast<decltype(sp)>(pc);
+      if (freevbos)
+        I->G->ShaderMgr->freeGPUBuffer(sp->vboid);
+    }
+    break;
+    case CGO_DRAW_SCREEN_TEXTURES_AND_POLYGONS:
+    {
+      cgo::draw::screen_textures * sp;
+      sp = reinterpret_cast<decltype(sp)>(pc);
+      if (freevbos)
+        I->G->ShaderMgr->freeGPUBuffer(sp->vboid);
+    }
+    break;
+    case CGO_DRAW_CYLINDER_BUFFERS:
+    {
+      cgo::draw::cylinder_buffers * sp = reinterpret_cast<decltype(sp)>(pc);
+      if (freevbos) {
+        I->G->ShaderMgr->freeGPUBuffer(sp->vboid);
+        I->G->ShaderMgr->freeGPUBuffer(sp->iboid);
+        I->G->ShaderMgr->freeGPUBuffer(sp->pickvboid);
+      }
+    }
+    break;
+    case CGO_DRAW_BUFFERS_NOT_INDEXED:
+    {
+      cgo::draw::buffers_not_indexed * sp;
+      sp = reinterpret_cast<decltype(sp)>(pc);
+      if (freevbos) {
+        I->G->ShaderMgr->freeGPUBuffer(sp->vboid);
+        I->G->ShaderMgr->freeGPUBuffer(sp->pickvboid);
+      }
+    }
+    break;
+    case CGO_DRAW_BUFFERS_INDEXED:
+    {
+      cgo::draw::buffers_indexed * sp = reinterpret_cast<decltype(sp)>(pc);
+      if (freevbos) {
+        I->G->ShaderMgr->freeGPUBuffers({ sp->vboid, sp->iboid, sp->pickvboid });
+      }
+    }
+    break;
+    case CGO_DRAW_CONNECTORS:
+    {
+      cgo::draw::connectors * sp;
+      sp = reinterpret_cast<decltype(sp)>(pc);
+      if (freevbos)
+        I->G->ShaderMgr->freeGPUBuffer(sp->vboid);
+    }
+    break;
+    default:
+      break;
+    }
+    pc += CGO_sz[op];
+  }
+}
+
+#define set_min_max(mn, mx, pt) {		\
+  if (mn[0]>*pt) mn[0] = *pt; \
+  if (mn[1]>*(pt+1)) mn[1] = *(pt+1);		\
+  if (mn[2]>*(pt+2)) mn[2] = *(pt+2);		\
+  if (mx[0]<*pt) mx[0] = *pt; \
+  if (mx[1]<*(pt+1)) mx[1] = *(pt+1);		\
+  if (mx[2]<*(pt+2)) mx[2] = *(pt+2);}
+
+
+static void CGOCountNumVertices(const CGO *I, int *num_total_vertices, int *num_total_indexes,
+			 int *num_total_vertices_lines, int *num_total_indexes_lines,
+			 int *num_total_vertices_points);
+
+void CGOCountNumVerticesDEBUG(const CGO *I){
+  int num_total_vertices=0, num_total_indexes=0, num_total_vertices_lines=0, num_total_indexes_lines=0, num_total_vertices_points=0;
+  CGOCountNumVertices(I, &num_total_vertices, &num_total_indexes, &num_total_vertices_lines, &num_total_indexes_lines, &num_total_vertices_points);
+  printf("CGOCountNumVerticesDEBUG: num_total_vertices=%d num_total_indexes=%d num_total_vertices_lines=%d num_total_indexes_lines=%d num_total_vertices_points=%d\n", num_total_vertices, num_total_indexes, num_total_vertices_lines, num_total_indexes_lines, num_total_vertices_points);
+  
+}
+static void CGOCountNumVertices(const CGO *I, int *num_total_vertices, int *num_total_indexes,
+			 int *num_total_vertices_lines, int *num_total_indexes_lines,
+			 int *num_total_vertices_points){
+  float *pc = I->op;
+  int op = 0;
+  int verts_skipped = 0;
+  short err = 0;
+
+  while((op = (CGO_MASK & CGO_read_int(pc)))) {
+    err = 0;
+    switch (op) {
+    case CGO_DRAW_ARRAYS:
+      {
+        cgo::draw::arrays * sp = reinterpret_cast<decltype(sp)>(pc);
+	short shouldCompress = false, shouldCompressLines = false, shouldCompressPoints = false;
+	switch(sp->mode){
+	case GL_TRIANGLE_FAN:
+	case GL_TRIANGLE_STRIP:
+	case GL_TRIANGLES:
+	  shouldCompress = true;
+	  break;
+	case GL_LINES:
+	case GL_LINE_STRIP:
+	case GL_LINE_LOOP:
+	  shouldCompressLines = true;
+	  break;
+	case GL_POINTS:
+	  shouldCompressPoints = true;
+	  break;
+	default:
+	  break;
+	}
+	if (!shouldCompress && !shouldCompressLines && !shouldCompressPoints){
+	  verts_skipped += sp->nverts;
+	} else if (shouldCompressLines) {
+	  *num_total_vertices_lines += sp->nverts;
+	  switch(sp->mode){
+	  case GL_LINE_LOOP:
+	    *num_total_indexes_lines += 2 * sp->nverts;
+	    break;
+	  case GL_LINE_STRIP:
+	    *num_total_indexes_lines += 2 * (sp->nverts - 1);
+	    break;
+	  case GL_LINES:
+	    *num_total_indexes_lines += sp->nverts;
+	    break;
+	  }
+	} else if (shouldCompress){
+	  *num_total_vertices += sp->nverts;
+	  switch(sp->mode){
+	  case GL_TRIANGLE_FAN:
+	    *num_total_indexes += 3 * (sp->nverts - 2);
+	    break;
+	  case GL_TRIANGLE_STRIP:
+	    *num_total_indexes += 3 * (sp->nverts - 2);
+	    break;
+	  case GL_TRIANGLES:
+	    *num_total_indexes += sp->nverts;
+	    break;
+	  }
+	} else if (shouldCompressPoints){
+	  *num_total_vertices_points += sp->nverts;
+	}
+      }
+	break;
+    case CGO_END:
+      if (!err){
+	PRINTFB(I->G, FB_CGO, FB_Warnings) " CGOCountNumVertices: CGO_END encountered, should call CGOCombineBeginEnd before CGOCountNumVertices\n" ENDFB(I->G);
+	err = true;
+      }
+    case CGO_VERTEX:
+      if (!err){
+	PRINTFB(I->G, FB_CGO, FB_Warnings) " CGOCountNumVertices: CGO_VERTEX encountered, should call CGOCombineBeginEnd before CGOCountNumVertices\n" ENDFB(I->G);
+	err = true;
+      }
+    case CGO_BEGIN:
+      if (!err){
+	PRINTFB(I->G, FB_CGO, FB_Warnings) " CGOCountNumVertices: CGO_BEGIN encountered, should call CGOCombineBeginEnd before CGOCountNumVertices\n" ENDFB(I->G);
+	err = true;
+      }
+    default:
+      break;
+    }
+    pc += CGO_sz[op];
+  }
+}
+
+static void CGOCountNumVerticesForScreen(const CGO *I, int *num_total_vertices, int *num_total_indexes){
+  float *pc = I->op;
+  int op = 0;
+  float *save_pc = NULL;
+  short err = 0;
+  *num_total_vertices = 0;
+  *num_total_indexes = 0;
+
+  while((op = (CGO_MASK & CGO_read_int(pc)))!=0) {
+    save_pc = pc;
+    err = 0;
+    switch (op) {
+    case CGO_DRAW_ARRAYS:
+      if (!err){
+	PRINTFB(I->G, FB_CGO, FB_Warnings) " CGOCountNumVerticesForScreen:CGO_DRAW_ARRAYS encountered, should not call CGOCombineBeginEnd before CGOCountNumVerticesForScreen\n" ENDFB(I->G);
+	err = true;
+      }
+      break;
+    case CGO_BEGIN:
+      {
+	int nverts = 0, err = 0, end = 0;
+	int mode = CGO_read_int(pc);
+	int sz;
+	while(!err && !end && (op = (CGO_MASK & CGO_read_int(pc)))) {
+	  switch (op) {
+	  case CGO_DRAW_ARRAYS:
+	    PRINTFB(I->G, FB_CGO, FB_Warnings) " CGOSimplify: CGO_DRAW_ARRAYS encountered inside CGO_BEGIN/CGO_END\n" ENDFB(I->G);
+	    err = true;
+	    continue;
+	  case CGO_VERTEX:
+	    nverts++;
+	    break;
+	  case CGO_END:
+	    end = 1;
+	    break;
+	  default:
+	    break;
+	  }
+	  sz = CGO_sz[op];
+	  pc += sz;
+	}
+	*num_total_vertices += nverts;
+	switch(mode){
+	case GL_TRIANGLE_FAN:
+	  *num_total_indexes += 3 * (nverts - 2);
+	  break;
+	case GL_TRIANGLE_STRIP:
+	  *num_total_indexes += 3 * (nverts - 2);
+	  break;
+	case GL_TRIANGLES:
+	  *num_total_indexes += nverts;
+	  break;
+	}
+      }
+      continue;
+    case CGO_END:
+      if (!err){
+	PRINTFB(I->G, FB_CGO, FB_Warnings) " CGOCountNumVerticesForScreen: CGO_END encountered without a matching CGO_BEGIN\n" ENDFB(I->G);
+	err = true;
+      }
+    case CGO_VERTEX:
+      if (!err){
+	PRINTFB(I->G, FB_CGO, FB_Warnings) " CGOCountNumVerticesForScreen: CGO_VERTEX encountered outside CGO_BEGIN/CGO_END block\n" ENDFB(I->G);      
+	err = true;
+      }
+    default:
+      break;
+    }
+    pc = save_pc;
+    pc += CGO_sz[op];
+  }
+}
+
+static
+void SetVertexValuesForVBO(PyMOLGlobals * G, CGO *cgo, int pl, int plc, int cnt, int incr,
+                           float *vertexValsDA, float *normalValsDA,
+                           float *colorValsDA, float *pickColorValsDA, 
+			   float *vertexVals, uchar *normalValsC,
+                           float *normalVals, uchar *colorValsUC, float *colorVals,
+                           float *pickColorVals, 
+                           float *accessibilityVals=NULL, float *accessibilityValsDA=NULL){
+  int pl2 = pl + 1, pl3 = pl + 2;
+  int pln1 = VAR_FOR_NORMAL, pln2 = VAR_FOR_NORMAL + 1, pln3 = VAR_FOR_NORMAL + 2;
+  int plc2 = plc + 1, plc3 = plc + 2, plc4 = plc + 3;
+  int c, c2, c3;
+  int cc, cc2, cc3, cc4;
+  int pcc = incr * 2, pcco = cnt * 2;
+  c = cnt * 3; c2 = c + 1; c3 = c + 2;
+  cc = cnt * 4; cc2 = cc + 1; cc3 = cc + 2; cc4 = cc + 3;
+  vertexVals[pl] = vertexValsDA[c]; vertexVals[pl2] = vertexValsDA[c2]; vertexVals[pl3] = vertexValsDA[c3];
+
+    if (normalValsC){
+      if (normalValsDA){
+	normalValsC[pln1] = CLIP_NORMAL_VALUE(normalValsDA[c]); normalValsC[pln2] = CLIP_NORMAL_VALUE(normalValsDA[c2]); normalValsC[pln3] = CLIP_NORMAL_VALUE(normalValsDA[c3]);
+      } else {
+	normalValsC[pln1] = CLIP_NORMAL_VALUE(cgo->normal[0]); normalValsC[pln2] = CLIP_NORMAL_VALUE(cgo->normal[1]); normalValsC[pln3] = CLIP_NORMAL_VALUE(cgo->normal[2]);
+      }
+    
+#ifdef ALIGN_VBOS_TO_4_BYTE_ARRAYS
+      normalValsC[pln3+1] = 127;
+#endif
+  } else {
+    if (normalValsDA){
+	normalVals[pln1] = normalValsDA[c]; normalVals[pln2] = normalValsDA[c2]; normalVals[pln3] = normalValsDA[c3];
+      } else {
+	normalVals[pln1] = cgo->normal[0]; normalVals[pln2] = cgo->normal[1]; normalVals[pln3] = cgo->normal[2];
+      }
+  }
+
+  if (colorValsUC){
+    if (colorValsDA){
+      colorValsUC[plc] = CLIP_COLOR_VALUE(colorValsDA[cc]); colorValsUC[plc2] = CLIP_COLOR_VALUE(colorValsDA[cc2]); 
+      colorValsUC[plc3] = CLIP_COLOR_VALUE(colorValsDA[cc3]); colorValsUC[plc4] = CLIP_COLOR_VALUE(colorValsDA[cc4]);
+    } else {
+      colorValsUC[plc] = CLIP_COLOR_VALUE(cgo->color[0]); colorValsUC[plc2] = CLIP_COLOR_VALUE(cgo->color[1]);
+      colorValsUC[plc3] = CLIP_COLOR_VALUE(cgo->color[2]); colorValsUC[plc4] = CLIP_COLOR_VALUE(cgo->alpha);
+    }
+  } else {
+    if (colorValsDA){
+      colorVals[plc] = colorValsDA[cc]; colorVals[plc2] = colorValsDA[cc2];
+      colorVals[plc3] = colorValsDA[cc3]; colorVals[plc4] = colorValsDA[cc4];
+    } else {
+      colorVals[plc] = cgo->color[0]; colorVals[plc2] = cgo->color[1];
+      colorVals[plc3] = cgo->color[2]; colorVals[plc4] = cgo->alpha;
+    }
+  }
+  if (pickColorValsDA){
+    cgo->current_pick_color_index = CGO_get_uint(pickColorValsDA + pcco);
+    cgo->current_pick_color_bond = CGO_get_int(pickColorValsDA + pcco + 1);
+  }
+  CGO_put_uint(pickColorVals + pcc, cgo->current_pick_color_index);
+  CGO_put_int(pickColorVals + pcc + 1, cgo->current_pick_color_bond);
+  if (accessibilityValsDA){
+    accessibilityVals[pl/3] = accessibilityValsDA[cnt];
+  }
+}
+
+static int OptimizePointsToVBO(const CGO *I, CGO *cgo, int num_total_vertices_points, float *min, float *max, short *has_draw_buffer, bool addshaders){
+  float *vertexVals = 0, *colorVals = 0, *normalVals = 0;
+  float *pickColorVals;
+  int pl = 0, plc = 0, idxpl = 0, vpl = 0, tot, nxtn;
+  uchar *colorValsUC = 0;
+  uchar *normalValsC = 0;
+  bool has_normals = false, has_colors = false;
+  float *pc = I->op;
+  int op;
+  float *save_pc;
+  int ok = true;
+  
+  cgo->alpha = 1.f;
+  cgo->color[0] = 1.f; cgo->color[1] = 1.f; cgo->color[2] = 1.f;
+  
+  tot = num_total_vertices_points * (3 * 5) ;
+  //    tot = num_total_indexes * (3 * 3 + 2) ;
+  /* NOTE/TODO: Not sure why 3*5 needs to be used, but 3*3+2, which is the 
+     correct length, crashes in glBufferData */
+  vertexVals = Alloc(float, tot);
+  CHECKOK(ok, vertexVals);
+  if (!ok){
+    PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: OptimizePointsToVBO() vertexVals could not be allocated\n" ENDFB(I->G);	
+    return 0;
+  }
+  normalVals = vertexVals + 3 * num_total_vertices_points;
+  nxtn = 3;
+  if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_normal)){
+    normalValsC = (uchar*) normalVals;
+    nxtn = 1;
+  }
+  colorVals = normalVals + nxtn * num_total_vertices_points;
+  if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_color)){
+    colorValsUC = (uchar*) colorVals;
+    nxtn = 1;
+  } else {
+    nxtn = 4;
+  }
+  pickColorVals = (colorVals + nxtn * num_total_vertices_points);
+  while(ok && (op = (CGO_MASK & CGO_read_int(pc)))) {
+    save_pc = pc;
+    switch (op) {
+    case CGO_BOUNDING_BOX:
+    case CGO_DRAW_SPHERE_BUFFERS:
+    case CGO_DRAW_LABELS:
+    case CGO_DRAW_TEXTURES:
+    case CGO_DRAW_SCREEN_TEXTURES_AND_POLYGONS:
+    case CGO_DRAW_CYLINDER_BUFFERS:
+    case CGO_DRAW_BUFFERS_NOT_INDEXED:
+    case CGO_DRAW_BUFFERS_INDEXED:
+      PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: OptimizePointsToVBO used with unsupported CGO ops" ENDFB(I->G);
+      return 0;
+      break;
+    case CGO_NORMAL:
+      cgo->normal[0] = *pc; cgo->normal[1] = *(pc + 1); cgo->normal[2] = *(pc + 2);
+      has_normals = true;
+      break;
+    case CGO_COLOR:
+      cgo->color[0] = *pc; cgo->color[1] = *(pc + 1); cgo->color[2] = *(pc + 2);
+      has_colors = true;
+      break;
+    case CGO_ALPHA:
+      cgo->alpha = *pc;
+      break;
+    case CGO_PICK_COLOR:
+      cgo->current_pick_color_index = CGO_get_uint(pc);
+      cgo->current_pick_color_bond = CGO_get_int(pc + 1);
+      break;
+    case CGO_DRAW_ARRAYS:
+      {
+        cgo::draw::arrays * sp = reinterpret_cast<decltype(sp)>(pc);
+	short shouldCompress = false;
+	switch(sp->mode){
+	case GL_POINTS:
+	  shouldCompress = true;
+	default:
+	  break;
+	}
+	/*	TODO : DO WE NEED TO COMPENSATE FOR THIS? if (!has_normals && arrays & CGO_NORMAL_ARRAY){
+	  arrays = arrays ^ CGO_NORMAL_ARRAY;
+	  narrays -= 1;
+	  }*/
+	if (shouldCompress){	
+	  int cnt, nxtn = 3 ,incr=0;
+	  float *vertexValsDA = NULL, *nxtVals = NULL, *colorValsDA = NULL, *normalValsDA = NULL;
+	  float *pickColorValsDA = NULL, *pickColorValsTMP;
+
+	  nxtVals = vertexValsDA = sp->floatdata;
+
+	  for (cnt=0; cnt<sp->nverts*3; cnt+=3){
+	    set_min_max(min, max, &vertexValsDA[cnt]);
+	  }
+	  if (sp->arraybits & CGO_NORMAL_ARRAY){
+	    has_normals = true;
+	    nxtVals = normalValsDA = vertexValsDA + (nxtn*sp->nverts);
+	  }
+	  if (sp->arraybits & CGO_COLOR_ARRAY){
+	    has_colors = true;
+	    nxtVals = colorValsDA = nxtVals + (nxtn*sp->nverts);
+	    nxtn = 4;
+	  }
+	  if (sp->arraybits & CGO_PICK_COLOR_ARRAY){
+	    nxtVals = nxtVals + (nxtn*sp->nverts);
+	    pickColorValsDA = nxtVals + sp->nverts;
+	    nxtn = 3;
+	  }
+	  pickColorValsTMP = pickColorVals + (idxpl * 2);
+	  switch (sp->mode){
+	  case GL_POINTS:
+	    for (cnt = 0; cnt < sp->nverts; cnt++){
+	      SetVertexValuesForVBO(I->G, cgo, pl, plc, cnt, incr++, 
+				    vertexValsDA, normalValsDA, colorValsDA, pickColorValsDA, 
+				    vertexVals, normalValsC, normalVals, colorValsUC, colorVals, 
+				    pickColorValsTMP);
+	      idxpl++; pl += 3; plc += 4;
+	    }
+	    break;
+	  }
+	  vpl += sp->nverts;
+        }
+      }
+      break;
+    default:
+      break;
+    }
+    pc = save_pc;
+    pc += CGO_sz[op];
+    ok &= !I->G->Interrupt;
+  }
+  if (ok){
+    short arrays = CGO_VERTEX_ARRAY | CGO_PICK_COLOR_ARRAY;
+    short nsz = 12;
+    GLenum ntp = GL_FLOAT;
+    bool nnorm = GL_FALSE;
+    if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_normal)){
+      nsz = 3;
+      ntp = GL_BYTE;
+      nnorm = GL_TRUE;
+    }
+
+    short csz = 4;
+    GLenum ctp = GL_FLOAT;
+    bool cnorm = GL_FALSE;
+    if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_color)){
+      csz = 1;
+      ctp = GL_UNSIGNED_BYTE;
+      cnorm = GL_TRUE;
+    }
+
+    VertexBuffer * vbo = I->G->ShaderMgr->newGPUBuffer<VertexBuffer>();
+
+    BufferDataDesc bufData =
+      { { "a_Vertex", GL_FLOAT, 3, sizeof(float) * num_total_vertices_points * 3, vertexVals, GL_FALSE } };
+
+    if (has_normals){
+      bufData.push_back( { "a_Normal", ntp,      3, (size_t)(num_total_vertices_points * nsz), normalVals, nnorm } );
+    }
+    if (has_colors){
+      bufData.push_back( { "a_Color",  ctp,      4, sizeof(float) * num_total_vertices_points * csz, colorVals, cnorm } );
+    }
+    ok = vbo->bufferData(std::move(bufData));
+
+    if (ok && has_colors){
+      arrays |= CGO_COLOR_ARRAY;
+    }
+
+    size_t vboid = vbo->get_hash_id();
+
+    if (ok){
+      float *newPickColorVals ;
+      if (addshaders)
+	CGOEnable(cgo, GL_DEFAULT_SHADER);
+      newPickColorVals = cgo->add<cgo::draw::buffers_not_indexed>(GL_POINTS, arrays, num_total_vertices_points, vboid);
+      CHECKOK(ok, newPickColorVals);
+      if (ok && addshaders)
+	ok &= CGODisable(cgo, GL_DEFAULT_SHADER);
+      if (!newPickColorVals)
+	I->G->ShaderMgr->freeGPUBuffer(vboid);
+      if (ok)
+	memcpy(newPickColorVals + num_total_vertices_points, pickColorVals, num_total_vertices_points * 2 * sizeof(float));
+      *has_draw_buffer = true;
+    } else {
+      I->G->ShaderMgr->freeGPUBuffer(vboid);
+    }
+  }
+  FreeP(vertexVals);
+  return ok;
+  /* END GL_POINTS */
+  //    printf("num_total_vertices_points=%d\n", num_total_vertices_points);
+}
+
+static
+void FixPickColorsForLine(float *pick1, float *pick2){
+  unsigned int p1 = CGO_get_uint(pick1);
+  unsigned int p2 = CGO_get_uint(pick2);
+  int b1 = CGO_get_int(pick1 + 1);
+  int b2 = CGO_get_int(pick2 + 1);
+  if (p1 != p2 || b1 != b2){
+    // if the pick colors are different, then pick the first one
+    CGO_put_uint(pick1, p2);
+    CGO_put_int(pick1 + 1, b2);
+  }
+}
+
+static
+void FixPickColorsForTriangle(float *pick1, float *pick2, float *pick3){
+  unsigned int p1 = CGO_get_uint(pick1);
+  unsigned int p2 = CGO_get_uint(pick2);
+  unsigned int p3 = CGO_get_uint(pick3);
+  int b1 = CGO_get_int(pick1 + 1);
+  int b2 = CGO_get_int(pick2 + 1);
+  int b3 = CGO_get_int(pick3 + 1);
+  if (p1 != p2 || p1 != p3 || p2 != p3 ||
+      b1 != b2 || b1 != b3 || b2 != b3){
+    // right now, if the pick colors are different, then pick majority, otherwise, pick first one
+    if (p1 == p2 && b1 == b2){
+      CGO_put_uint(pick3, p1);
+      CGO_put_int(pick3 + 1, b1);
+    } else if (p1 == p3 && b1 == b3){
+      CGO_put_uint(pick2, p1);
+      CGO_put_int(pick2 + 1, b1);
+    } else if (p2 == p3 && b2 == b3){
+      CGO_put_uint(pick1, p2);
+      CGO_put_int(pick1 + 1, b2);
+    } else {
+      CGO_put_uint(pick2, p1);
+      CGO_put_int(pick2 + 1, b1);
+      CGO_put_uint(pick3, p1);
+      CGO_put_int(pick3 + 1, b1);
+    }
+  }
+}
+
+static
+int CGOProcessCGOtoArrays(PyMOLGlobals * G, float *pcarg, CGO *cgo, CGO *addtocgo, float *min, float *max, int *ambient_occlusion, float *vertexVals, float *normalVals, uchar *normalValsC, float *colorVals, uchar *colorValsUC, float *pickColorVals, float *accessibilityVals, bool &has_normals, bool &has_colors, bool &has_accessibility){
+  float *pc = pcarg;
+  int op = 0;
+  float *save_pc = NULL;
+  int idxpl = 0;
+  int pl = 0, plc = 0, vpl = 0;
+  int ok = true;
+  while(ok && (op = (CGO_MASK & CGO_read_int(pc)))) {
+    save_pc = pc;
+    switch (op) {
+    case CGO_BOUNDING_BOX:
+      {
+	float *newpc = pc;
+	if (addtocgo)
+          addtocgo->add_to_cgo(op, newpc);
+      }
+      break;
+    case CGO_DRAW_SPHERE_BUFFERS:
+    case CGO_DRAW_LABELS:
+    case CGO_DRAW_TEXTURES:
+    case CGO_DRAW_SCREEN_TEXTURES_AND_POLYGONS:
+    case CGO_DRAW_CYLINDER_BUFFERS:
+    case CGO_DRAW_BUFFERS_NOT_INDEXED:
+    case CGO_DRAW_BUFFERS_INDEXED:
+    {
+      float * newpc = pc;
+      if (addtocgo)
+        addtocgo->add_to_cgo(op, newpc);
+    }
+      break;
+    case CGO_NORMAL:
+      cgo->normal[0] = *pc; cgo->normal[1] = *(pc + 1); cgo->normal[2] = *(pc + 2);
+      has_normals = true;
+      break;
+    case CGO_COLOR:
+      cgo->color[0] = *pc; cgo->color[1] = *(pc + 1); cgo->color[2] = *(pc + 2);
+      has_colors = true;
+      break;
+    case CGO_ALPHA:
+      cgo->alpha = *pc;
+      break;
+    case CGO_ACCESSIBILITY:
+      cgo->current_accessibility = pc[0];
+      has_accessibility = true;
+      break;
+    case CGO_PICK_COLOR:
+      cgo->current_pick_color_index = CGO_get_uint(pc);
+      cgo->current_pick_color_bond = CGO_get_int(pc + 1);
+      break;
+    case CGO_DRAW_ARRAYS:
+      {
+        cgo::draw::arrays * sp = reinterpret_cast<decltype(sp)>(pc);
+	short shouldCompress = false;
+	switch(sp->mode){
+	case GL_TRIANGLE_FAN:
+	case GL_TRIANGLE_STRIP:
+	case GL_TRIANGLES:
+	  shouldCompress = true;
+	default:
+	  break;
+	}
+	if (shouldCompress){
+	  int cnt, nxtn = 3,incr=0;
+	  float *vertexValsDA = NULL, *nxtVals = NULL, *colorValsDA = NULL, *normalValsDA = NULL, *accessibilityValsDA = NULL;
+	  float *pickColorValsDA = NULL, *pickColorValsTMP;
+	  nxtVals = vertexValsDA = sp->floatdata;
+
+	  for (cnt=0; cnt<sp->nverts*3; cnt+=3){
+	    set_min_max(min, max, &vertexValsDA[cnt]);
+	  }
+	  if (sp->arraybits & CGO_NORMAL_ARRAY){
+	    nxtVals = normalValsDA = vertexValsDA + (nxtn*sp->nverts);
+            has_normals = true;
+	  }
+
+	  if (sp->arraybits & CGO_COLOR_ARRAY){
+	    nxtVals = colorValsDA = nxtVals + (nxtn*sp->nverts);
+	    nxtn = 4;
+            has_colors = true;
+	  }
+	  if (sp->arraybits & CGO_PICK_COLOR_ARRAY){
+	    nxtVals = nxtVals + (nxtn*sp->nverts);
+	    pickColorValsDA = nxtVals + sp->nverts;
+	    nxtn = 3;
+	  }
+	  pickColorValsTMP = pickColorVals + (idxpl * 2);
+	  if (sp->arraybits & CGO_ACCESSIBILITY_ARRAY){
+	    if (!(*ambient_occlusion) && incr){
+	      for (cnt=0; cnt<incr;cnt++){
+		/* if ambient_occlusion, need to fill in the array */
+		accessibilityVals[cnt] = 1.f;
+	      }
+	    }
+	    (*ambient_occlusion) = 1;
+	    accessibilityValsDA = nxtVals + nxtn*sp->nverts;
+            has_accessibility = true;
+	  } else {
+	    if (*ambient_occlusion){
+	      for (cnt=incr; cnt<incr+sp->nverts;cnt++){
+		/* if ambient_occlusion, need to fill in the array */
+		accessibilityVals[cnt] = 1.f;
+	      }
+	    }
+	  }
+	  switch (sp->mode){
+	  case GL_TRIANGLES:
+	    for (cnt = 0; ok && cnt < sp->nverts; cnt++){
+	      SetVertexValuesForVBO(G, cgo, pl, plc, cnt, incr++,
+				    vertexValsDA, normalValsDA, colorValsDA, pickColorValsDA,
+				    vertexVals, normalValsC, normalVals, colorValsUC, colorVals,
+				    pickColorValsTMP, accessibilityVals, accessibilityValsDA);
+              if (incr && (incr % 3) == 0){
+                FixPickColorsForTriangle(pickColorValsTMP + (incr-3) * 2,
+                                         pickColorValsTMP + (incr-2) * 2,
+                                         pickColorValsTMP + (incr-1) * 2);
+              }
+	      idxpl++; pl += 3; plc += 4;
+	      ok &= !G->Interrupt;
+	    }
+	    break;
+	  case GL_TRIANGLE_STRIP:
+	    {
+	      short flip = 0;
+	      for (cnt = 2; ok && cnt < sp->nverts; cnt++){
+		SetVertexValuesForVBO(G, cgo, pl, plc, cnt - (flip ? 0 : 2), incr++,
+				      vertexValsDA, normalValsDA, colorValsDA, pickColorValsDA,
+				      vertexVals, normalValsC, normalVals, colorValsUC, colorVals,
+				      pickColorValsTMP, accessibilityVals, accessibilityValsDA);
+		idxpl++; pl += 3; plc += 4;
+		SetVertexValuesForVBO(G, cgo, pl, plc, cnt-1, incr++,
+				      vertexValsDA, normalValsDA, colorValsDA, pickColorValsDA,
+				      vertexVals, normalValsC, normalVals, colorValsUC, colorVals,
+				      pickColorValsTMP, accessibilityVals, accessibilityValsDA);
+		idxpl++; pl += 3; plc += 4;
+		SetVertexValuesForVBO(G, cgo, pl, plc, cnt - (flip ? 2 : 0) , incr++,
+				      vertexValsDA, normalValsDA, colorValsDA, pickColorValsDA,
+				      vertexVals, normalValsC, normalVals, colorValsUC, colorVals,
+				      pickColorValsTMP, accessibilityVals, accessibilityValsDA);
+                FixPickColorsForTriangle(pickColorValsTMP + (incr-3) * 2,
+                                         pickColorValsTMP + (incr-2) * 2,
+                                         pickColorValsTMP + (incr-1) * 2);
+		idxpl++; pl += 3; plc += 4;
+		ok &= !G->Interrupt;
+		flip = !flip;
+	      }
+	    }
+	    break;
+	  case GL_TRIANGLE_FAN:
+	    for (cnt = 2; ok && cnt < sp->nverts; cnt++){
+	      SetVertexValuesForVBO(G, cgo, pl, plc, 0, incr++,
+				    vertexValsDA, normalValsDA, colorValsDA, pickColorValsDA,
+				    vertexVals, normalValsC, normalVals, colorValsUC, colorVals,
+				    pickColorValsTMP, accessibilityVals, accessibilityValsDA);
+	      idxpl++; pl += 3; plc += 4;
+	      SetVertexValuesForVBO(G, cgo, pl, plc, cnt - 1, incr++,
+				    vertexValsDA, normalValsDA, colorValsDA, pickColorValsDA,
+				    vertexVals, normalValsC, normalVals, colorValsUC, colorVals,
+				    pickColorValsTMP, accessibilityVals, accessibilityValsDA);
+	      idxpl++; pl += 3; plc += 4;
+	      SetVertexValuesForVBO(G, cgo, pl, plc, cnt, incr++,
+				    vertexValsDA, normalValsDA, colorValsDA, pickColorValsDA,
+				    vertexVals, normalValsC, normalVals, colorValsUC, colorVals,
+				    pickColorValsTMP, accessibilityVals, accessibilityValsDA);
+              FixPickColorsForTriangle(pickColorValsTMP + (incr-3) * 2,
+                                       pickColorValsTMP + (incr-2) * 2,
+                                       pickColorValsTMP + (incr-1) * 2);
+	      idxpl++; pl += 3; plc += 4;
+	      ok &= !G->Interrupt;
+	    }
+	    break;
+	  }
+	  vpl += sp->nverts;
+	}
+      }
+      break;
+    default:
+      break;
+    }
+    if (ok){
+      pc = save_pc;
+      pc += CGO_sz[op];
+    }
+    ok &= !G->Interrupt;
+  }
+  ok &= !G->Interrupt;
+  return ok;
+}
+
+static
+int CGOProcessScreenCGOtoArrays(PyMOLGlobals * G, float *pcarg, CGO *cgo, float *vertexVals, float *texcoordVals, float *colorVals, uchar *colorValsUC){
+  float *pc = pcarg;
+  int op = 0;
+  int sz = 0;
+  int ok = true;
+  int pl = 0, skip = false;
+  cgo->alpha = 1.f;
+  while(ok && (op = (CGO_MASK & CGO_read_int(pc)))) {
+    skip = false;
+    switch (op) {
+    case CGO_BOUNDING_BOX:
+    case CGO_DRAW_SPHERE_BUFFERS:
+    case CGO_DRAW_LABELS:
+    case CGO_DRAW_TEXTURES:
+    case CGO_DRAW_SCREEN_TEXTURES_AND_POLYGONS:
+    case CGO_DRAW_CYLINDER_BUFFERS:
+    case CGO_DRAW_BUFFERS_NOT_INDEXED:
+    case CGO_DRAW_BUFFERS_INDEXED:
+    case CGO_DRAW_ARRAYS:
+    case CGO_ACCESSIBILITY:
+      PRINTFB(G, FB_CGO, FB_Warnings) "WARNING: CGOProcessScreenCGOtoArrays() called with bad op=%d in cgo\n", op ENDFB(G);		  
+	ok = false;
+      break;
+    case CGO_NORMAL:
+      cgo->normal[0] = *pc; cgo->normal[1] = *(pc + 1); cgo->normal[2] = *(pc + 2);
+      break;
+    case CGO_TEX_COORD:
+      cgo->texture[0] = *pc; cgo->texture[1] = *(pc + 1);
+      break;
+    case CGO_COLOR:
+      cgo->color[0] = *pc; cgo->color[1] = *(pc + 1); cgo->color[2] = *(pc + 2);
+      break;
+    case CGO_ALPHA:
+      cgo->alpha = *pc;
+      break;
+    case CGO_PICK_COLOR:
+      cgo->current_pick_color_index = CGO_get_uint(pc);
+      cgo->current_pick_color_bond = CGO_get_int(pc + 1);
+      break;
+    case CGO_BEGIN:
+      {
+	int err = 0, end = 0;
+	int mode = CGO_read_int(pc);
+	int nverts = 0, ipl = 0;
+	(void)mode;
+	cgo->texture[0] = cgo->texture[1] = 0.f;
+	while(!err && !end && (op = (CGO_MASK & CGO_read_int(pc)))) {
+	  end = (op == CGO_END);
+	  switch (op) {
+	  case CGO_TEX_COORD:
+	    cgo->texture[0] = *pc; cgo->texture[1] = *(pc + 1);
+	    break;
+	  case CGO_COLOR:
+	    cgo->color[0] = *pc; cgo->color[1] = *(pc + 1); cgo->color[2] = *(pc + 2);
+	    break;
+	  case CGO_ALPHA:
+	    cgo->alpha = *pc;
+	    break;
+	  case CGO_VERTEX:
+	    {
+	      switch (mode){
+	      case GL_TRIANGLES:
+		{
+		  int vpl = pl * 3, tpl = pl * 2, cpl = pl * 4;
+		  vertexVals[vpl] = *pc;
+		  vertexVals[vpl + 1] = *(pc + 1);
+		  vertexVals[vpl + 2] = *(pc + 2);
+		  texcoordVals[tpl] = cgo->texture[0];
+		  texcoordVals[tpl+1] = cgo->texture[1];
+		  if (colorValsUC){
+		    colorValsUC[cpl] = CLIP_COLOR_VALUE(cgo->color[0]);
+		    colorValsUC[cpl+1] = CLIP_COLOR_VALUE(cgo->color[1]);
+		    colorValsUC[cpl+2] = CLIP_COLOR_VALUE(cgo->color[2]);
+		    colorValsUC[cpl+3] = CLIP_COLOR_VALUE(cgo->alpha);
+		  } else {
+		    colorVals[cpl] = cgo->color[0];
+		    colorVals[cpl+1] = cgo->color[1];
+		    colorVals[cpl+2] = cgo->color[2];
+		    colorVals[cpl+3] = cgo->alpha;
+		  }
+		  pl++;
+		}
+		break;
+	      case GL_TRIANGLE_STRIP:
+		{
+		  int vpl = pl * 3, tpl = pl * 2, cpl = pl * 4;
+		  if (ipl < 3){
+		    vertexVals[vpl] = *pc; vertexVals[vpl + 1] = *(pc + 1); vertexVals[vpl + 2] = *(pc + 2);
+		    texcoordVals[tpl] = cgo->texture[0]; texcoordVals[tpl+1] = cgo->texture[1];
+		    if (colorValsUC){
+		      colorValsUC[cpl] = CLIP_COLOR_VALUE(cgo->color[0]); colorValsUC[cpl+1] = CLIP_COLOR_VALUE(cgo->color[1]);
+		      colorValsUC[cpl+2] = CLIP_COLOR_VALUE(cgo->color[2]); colorValsUC[cpl+3] = CLIP_COLOR_VALUE(cgo->alpha);
+		    } else {
+		      colorVals[cpl] = cgo->color[0]; colorVals[cpl+1] = cgo->color[1];
+		      colorVals[cpl+2] = cgo->color[2]; colorVals[cpl+3] = cgo->alpha;
+		    }
+		    pl++; ipl++;
+		  } else {
+		    vertexVals[vpl] = vertexVals[vpl-6]; vertexVals[vpl + 1] = vertexVals[vpl-5]; vertexVals[vpl + 2] = vertexVals[vpl-4];
+		    texcoordVals[tpl] = texcoordVals[tpl-4]; texcoordVals[tpl+1] = texcoordVals[tpl-3];
+		    if (colorValsUC){
+		      colorValsUC[cpl] = colorValsUC[cpl-8]; colorValsUC[cpl+1] = colorValsUC[cpl-7];
+		      colorValsUC[cpl+2] = colorValsUC[cpl-6]; colorValsUC[cpl+3] = colorValsUC[cpl-5];
+		    } else {
+		      colorVals[cpl] = colorVals[cpl-8]; colorVals[cpl+1] = colorVals[cpl-7];
+		      colorVals[cpl+2] = colorVals[cpl-6]; colorVals[cpl+3] = colorVals[cpl-5];
+		    }
+		    pl++; vpl+=3; tpl+=2; cpl+=4; ipl++;
+		    vertexVals[vpl] = vertexVals[vpl-6]; vertexVals[vpl + 1] = vertexVals[vpl-5]; vertexVals[vpl + 2] = vertexVals[vpl-4];
+		    texcoordVals[tpl] = texcoordVals[tpl-4]; texcoordVals[tpl+1] = texcoordVals[tpl-3];
+		    if (colorValsUC){
+		      colorValsUC[cpl] = colorValsUC[cpl-8]; colorValsUC[cpl+1] = colorValsUC[cpl-7];
+		      colorValsUC[cpl+2] = colorValsUC[cpl-6]; colorValsUC[cpl+3] = colorValsUC[cpl-5];
+		    } else {
+		      colorVals[cpl] = colorVals[cpl-8]; colorVals[cpl+1] = colorVals[cpl-7];
+		      colorVals[cpl+2] = colorVals[cpl-6]; colorVals[cpl+3] = colorVals[cpl-5];
+		    }
+		    pl++; vpl+=3; tpl+=2; cpl+=4; ipl++;
+		    vertexVals[vpl] = *pc; vertexVals[vpl + 1] = *(pc + 1); vertexVals[vpl + 2] = *(pc + 2);
+		    texcoordVals[tpl] = cgo->texture[0]; texcoordVals[tpl+1] = cgo->texture[1];
+		    if (colorValsUC){
+		      colorValsUC[cpl] = CLIP_COLOR_VALUE(cgo->color[0]); colorValsUC[cpl+1] = CLIP_COLOR_VALUE(cgo->color[1]);
+		      colorValsUC[cpl+2] = CLIP_COLOR_VALUE(cgo->color[2]); colorValsUC[cpl+3] = CLIP_COLOR_VALUE(cgo->alpha);
+		    } else {
+		      colorVals[cpl] = cgo->color[0]; colorVals[cpl+1] = cgo->color[1];
+		      colorVals[cpl+2] = cgo->color[2]; colorVals[cpl+3] = cgo->alpha;
+		    }
+		    pl++; ipl++;
+		  }
+		}
+		break;
+	      case GL_TRIANGLE_FAN:
+	      default:
+		printf("CGOProcessScreenCGOtoArrays: WARNING: mode=%d not implemented yet GL_LINES=%d GL_LINE_STRIP=%d GL_LINE_LOOP=%d\n", mode, GL_LINES, GL_LINE_STRIP, GL_LINE_LOOP);
+		break;
+	      }
+	      nverts++;
+	    }
+	  }
+	  sz = CGO_sz[op];
+	  pc += sz;
+	}
+      }
+      skip = true;
+      break;
+    default:
+      break;
+    }
+    if (!skip){
+      sz = CGO_sz[op];
+      pc += sz;
+    }
+  }
+  ok &= !G->Interrupt;
+  return ok;
+}
+
+bool CGOOptimizeToVBONotIndexed(CGO ** I) {
+  CGO *cgo = CGOOptimizeToVBONotIndexed(*I, 0, true, NULL);
+  CGOFree(*I);
+  *I = cgo;
+  return (cgo != NULL);
+}
+
+CGO *CGOOptimizeToVBONotIndexed(const CGO * I, int est, bool addshaders, float **returnedData)
+{
+  CGO *cgo;
+  float *pc = I->op;
+  int op;
+  float *save_pc;
+  int num_total_vertices = 0, num_total_indexes = 0, num_total_vertices_lines = 0, num_total_indexes_lines = 0,
+    num_total_vertices_points = 0;
+  short has_draw_buffer = false;
+  float min[3] = { MAXFLOAT, MAXFLOAT, MAXFLOAT }, max[3] = { -MAXFLOAT, -MAXFLOAT, -MAXFLOAT };
+  int ambient_occlusion = 0;
+  int ok = true;
+  cgo = CGONewSized(I->G, 0);
+
+  CGOCountNumVertices(I, &num_total_vertices, &num_total_indexes,
+                         &num_total_vertices_lines, &num_total_indexes_lines,
+                         &num_total_vertices_points);
+  if (num_total_vertices_points>0){
+    if (!OptimizePointsToVBO(I, cgo, num_total_vertices_points, min, max, &has_draw_buffer, addshaders)){
+      CGOFree(cgo);
+      return NULL;
+    }
+  }
+  if (num_total_indexes>0){
+    float *vertexVals = 0, *colorVals = 0, *normalVals;
+    float *pickColorVals, *accessibilityVals = 0;
+    int tot, nxtn;
+    uchar *colorValsUC = 0;
+    uchar *normalValsC = 0;
+    pc = I->op;
+
+    cgo->alpha = 1.f;
+    cgo->color[0] = 1.f; cgo->color[1] = 1.f; cgo->color[2] = 1.f;
+
+    tot = num_total_indexes * (3 * 6) ;
+    //    tot = num_total_indexes * (3 * 3 + 2) ;
+    /* NOTE/TODO: Not sure why 3*5 needs to be used, but 3*3+2, which is the 
+       correct length, crashes in glBufferData */
+    /* before allocating anything, we should check to make sure that we have enough memory on IOS,
+       otherwise we should just fail */
+    vertexVals = Alloc(float, tot);
+    if (!vertexVals){
+      PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeToVBONotIndexed() vertexVals could not be allocated\n" ENDFB(I->G);	
+      CGOFree(cgo);
+      return (NULL);
+    }
+    normalVals = vertexVals + 3 * num_total_indexes;
+    nxtn = 3;
+    if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_normal)){
+      normalValsC = (uchar*) normalVals;
+      nxtn = 1;
+    }
+    colorVals = normalVals + nxtn * num_total_indexes;
+    if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_color)){
+      colorValsUC = (uchar*) colorVals;
+      nxtn = 1;
+    } else {
+      nxtn = 4;
+    }
+    pickColorVals = (colorVals + nxtn * num_total_indexes);
+    nxtn = 3;
+    accessibilityVals = pickColorVals + nxtn * num_total_indexes;
+
+    bool has_normals = false, has_colors = false, has_accessibility = false;
+    ok = CGOProcessCGOtoArrays(I->G, pc, cgo, cgo, min, max,  &ambient_occlusion, vertexVals, normalVals, normalValsC, colorVals, colorValsUC, pickColorVals, accessibilityVals, has_normals, has_colors, has_accessibility);
+    if (!ok){
+      if (!I->G->Interrupt)
+	PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOProcessCGOtoArrays() could not allocate enough memory\n" ENDFB(I->G);	
+      FreeP(vertexVals);      
+      CGOFree(cgo);
+      return (NULL);
+    }
+    if (ok){
+      short nsz = VERTEX_NORMAL_SIZE * 4;
+      GLenum ntp = GL_FLOAT;
+      bool nnorm = GL_FALSE;
+      if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_normal)){
+        nsz = VERTEX_NORMAL_SIZE;
+        ntp = GL_BYTE;
+        nnorm = GL_TRUE;
+      }
+
+      short csz = 4;
+      GLenum ctp = GL_FLOAT;
+      bool cnorm = GL_FALSE;
+      if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_color)){
+        csz = 1;
+        ctp = GL_UNSIGNED_BYTE;
+        cnorm = GL_TRUE;
+      }
+
+      VertexBuffer * vbo = I->G->ShaderMgr->newGPUBuffer<VertexBuffer>(VertexBuffer::SEQUENTIAL);
+      BufferDataDesc bufData =
+        { { "a_Vertex", GL_FLOAT, 3, sizeof(float) * num_total_indexes * 3, vertexVals, GL_FALSE } };
+      if (has_normals){
+        bufData.push_back( { "a_Normal", ntp,      VERTEX_NORMAL_SIZE, (size_t)(num_total_indexes * nsz), normalVals, nnorm } );
+      }
+      if (has_colors){
+        bufData.push_back( { "a_Color",  ctp,      4, sizeof(float) * num_total_indexes * csz, colorVals, cnorm } );
+      }
+      if (has_accessibility){
+        bufData.push_back( { "a_Accessibility", GL_FLOAT, 1, sizeof(float) * num_total_indexes, accessibilityVals, GL_FALSE } );
+      }
+      ok = vbo->bufferData(std::move(bufData));
+
+      size_t vboid = vbo->get_hash_id();
+      // picking VBO: generate a buffer twice the size needed, for each picking pass
+      VertexBuffer * pickvbo = I->G->ShaderMgr->newGPUBuffer<VertexBuffer>(VertexBuffer::SEQUENTIAL, GL_DYNAMIC_DRAW);
+      ok = pickvbo->bufferData({
+          BufferDesc( "a_Color", GL_UNSIGNED_BYTE, 4, sizeof(float) * num_total_indexes, 0, GL_TRUE ),
+          BufferDesc( "a_Color", GL_UNSIGNED_BYTE, 4, sizeof(float) * num_total_indexes, 0, GL_TRUE )
+        });
+      size_t pickvboid = pickvbo->get_hash_id();
+
+      if (ok){
+	float *newPickColorVals ;
+	int arrays = CGO_VERTEX_ARRAY | CGO_NORMAL_ARRAY | CGO_COLOR_ARRAY | CGO_PICK_COLOR_ARRAY;
+	if (ambient_occlusion){
+	  arrays |= CGO_ACCESSIBILITY_ARRAY;
+	}
+	if (addshaders)
+	  CGOEnable(cgo, GL_DEFAULT_SHADER_WITH_SETTINGS);
+	newPickColorVals = cgo->add<cgo::draw::buffers_not_indexed>(GL_TRIANGLES, arrays, num_total_indexes, vboid, pickvboid);
+	if (ok && addshaders)
+	  ok &= CGODisable(cgo, GL_DEFAULT_SHADER);
+	CHECKOK(ok, newPickColorVals);
+	if (!newPickColorVals){
+	  I->G->ShaderMgr->freeGPUBuffer(pickvboid);
+          I->G->ShaderMgr->freeGPUBuffer(vboid);
+	}
+	if (!ok){
+	  PRINTFB(I->G, FB_CGO, FB_Errors) "CGOOptimizeToVBONotIndexedWithReturnedData: ERROR: CGODrawBuffersNotIndexed() could not allocate enough memory\n" ENDFB(I->G);	
+	  FreeP(vertexVals);
+	  CGOFree(cgo);
+	  return (NULL);
+	}
+	memcpy(newPickColorVals + num_total_indexes, pickColorVals, num_total_indexes * 2 * sizeof(float));
+	has_draw_buffer = true;
+      } else {
+        I->G->ShaderMgr->freeGPUBuffer(vboid);
+        I->G->ShaderMgr->freeGPUBuffer(pickvboid);
+      }
+    }
+    if (ok && returnedData){
+      returnedData[0] = vertexVals;
+    } else {
+      FreeP(vertexVals);
+    }
+  }
+  if (ok && num_total_indexes_lines>0){
+    bool has_color = false, has_normals = false;
+    float *vertexVals = 0, *colorVals = 0, *normalVals;
+    float *pickColorVals;
+    int pl = 0, plc = 0, idxpl = 0, vpl = 0, tot, nxtn;
+    uchar *colorValsUC = 0;
+    uchar *normalValsC = 0;
+
+    pc = I->op;
+    cgo->alpha = 1.f;
+    cgo->color[0] = 1.f; cgo->color[1] = 1.f; cgo->color[2] = 1.f;
+
+    tot = num_total_indexes_lines * (3 * 5) ;
+    //    tot = num_total_indexes * (3 * 3 + 2) ;
+    /* NOTE/TODO: Not sure why 3*5 needs to be used, but 3*3+2, which is the 
+       correct length, crashes in glBufferData */
+    vertexVals = Alloc(float, tot);
+    if (!vertexVals){
+      PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeToVBONotIndexed() vertexVals could not be allocated\n" ENDFB(I->G);	
+      CGOFree(cgo);
+      return (NULL);
+    }
+    normalVals = vertexVals + 3 * num_total_indexes_lines;
+    nxtn = 3;
+    if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_normal)){
+      normalValsC = (uchar*) normalVals;
+      nxtn = 1;
+    }
+
+    colorVals = normalVals + nxtn * num_total_indexes_lines;
+    if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_color)){
+      colorValsUC = (uchar*) colorVals;
+      nxtn = 1;
+    } else {
+      nxtn = 4;
+    }
+    pickColorVals = (colorVals + nxtn * num_total_indexes_lines);
+    while((op = (CGO_MASK & CGO_read_int(pc)))) {
+      save_pc = pc;
+      switch (op) {
+      case CGO_SPECIAL:
+      case CGO_RESET_NORMAL:
+	{
+	  float *newpc = pc;
+          cgo->add_to_cgo(op, newpc);
+	}
+	break;
+      case CGO_NORMAL:
+        has_normals = true;
+	cgo->normal[0] = *pc; cgo->normal[1] = *(pc + 1); cgo->normal[2] = *(pc + 2);
+	break;
+      case CGO_COLOR:
+        has_color = true;
+	cgo->color[0] = *pc; cgo->color[1] = *(pc + 1); cgo->color[2] = *(pc + 2);
+	break;
+      case CGO_ACCESSIBILITY:
+	cgo->current_accessibility = pc[0];
+	break;
+      case CGO_ALPHA:
+	cgo->alpha = *pc;
+	break;
+      case CGO_PICK_COLOR:
+	cgo->current_pick_color_index = CGO_get_uint(pc);
+	cgo->current_pick_color_bond = CGO_get_int(pc + 1);
+	break;
+      case CGO_DRAW_ARRAYS:
+      {
+        cgo::draw::arrays * sp = reinterpret_cast<decltype(sp)>(pc);
+	short shouldCompress = false;
+	switch(sp->mode){
+	case GL_LINE_LOOP:
+	case GL_LINE_STRIP:
+	case GL_LINES:
+	  shouldCompress = true;
+	default:
+	  break;
+	}
+
+	if (shouldCompress){
+	  int cnt, nxtn = 3, incr = 0;
+	  float *vertexValsDA = NULL, *nxtVals = NULL, *colorValsDA = NULL, *normalValsDA = NULL;
+	  float *pickColorValsDA = NULL, *pickColorValsTMP;
+
+	  nxtVals = vertexValsDA = sp->floatdata;
+
+	  for (cnt=0; cnt<sp->nverts*3; cnt+=3){
+	    set_min_max(min, max, &vertexValsDA[cnt]);
+	  }
+	  if (sp->arraybits & CGO_NORMAL_ARRAY){
+            has_normals = true;
+	    nxtVals = normalValsDA = vertexValsDA + (nxtn*sp->nverts);
+	  }
+
+	  if (sp->arraybits & CGO_COLOR_ARRAY){
+            has_color = true;
+	    nxtVals = colorValsDA = nxtVals + (nxtn*sp->nverts);
+	    nxtn = 4;
+	  }
+	  if (sp->arraybits & CGO_PICK_COLOR_ARRAY){
+	    nxtVals = nxtVals + (nxtn*sp->nverts);
+	    pickColorValsDA = nxtVals + sp->nverts;
+	    nxtn = 3;
+	  }
+	  pickColorValsTMP = pickColorVals + (idxpl * 2);
+	  switch (sp->mode){
+	  case GL_LINES:
+	    for (cnt = 0; cnt < sp->nverts; cnt++){
+	      SetVertexValuesForVBO(I->G, cgo, pl, plc, cnt, incr++, 
+				    vertexValsDA, normalValsDA, colorValsDA, pickColorValsDA, 
+				    vertexVals, normalValsC, normalVals, colorValsUC, colorVals, 
+				    pickColorValsTMP);
+              if (incr && (incr % 2) == 0){
+                FixPickColorsForLine(pickColorValsTMP + (incr-2) * 2,
+                                     pickColorValsTMP + (incr-1) * 2);
+              }
+	      idxpl++; pl += 3; plc += 4;
+	    }
+	    break;
+	  case GL_LINE_STRIP:
+	    for (cnt = 1; cnt < sp->nverts; cnt++){
+	      SetVertexValuesForVBO(I->G, cgo, pl, plc, cnt-1, incr++, 
+				    vertexValsDA, normalValsDA, colorValsDA, pickColorValsDA, 
+				    vertexVals, normalValsC, normalVals, colorValsUC, colorVals, 
+				    pickColorValsTMP);
+	      idxpl++; pl += 3; plc += 4;
+	      SetVertexValuesForVBO(I->G, cgo, pl, plc, cnt, incr++, 
+				    vertexValsDA, normalValsDA, colorValsDA, pickColorValsDA, 
+				    vertexVals, normalValsC, normalVals, colorValsUC, colorVals, 
+				    pickColorValsTMP);
+              FixPickColorsForLine(pickColorValsTMP + (incr-2) * 2,
+                                   pickColorValsTMP + (incr-1) * 2);
+	      idxpl++; pl += 3; plc += 4;
+	    }
+	    break;
+	  case GL_LINE_LOOP:
+	    for (cnt = 1; cnt < sp->nverts; cnt++){
+	      SetVertexValuesForVBO(I->G, cgo, pl, plc, cnt-1, incr++, 
+				    vertexValsDA, normalValsDA, colorValsDA, pickColorValsDA, 
+				    vertexVals, normalValsC, normalVals, colorValsUC, colorVals, 
+				    pickColorValsTMP);
+	      idxpl++; pl += 3; plc += 4;
+	      SetVertexValuesForVBO(I->G, cgo, pl, plc, cnt, incr++, 
+				    vertexValsDA, normalValsDA, colorValsDA, pickColorValsDA, 
+				    vertexVals, normalValsC, normalVals, colorValsUC, colorVals, 
+				    pickColorValsTMP);
+              FixPickColorsForLine(pickColorValsTMP + (incr-2) * 2,
+                                   pickColorValsTMP + (incr-1) * 2);
+	      idxpl++; pl += 3; plc += 4;
+	    }
+	    SetVertexValuesForVBO(I->G, cgo, pl, plc, 0, incr++, 
+				  vertexValsDA, normalValsDA, colorValsDA, pickColorValsDA, 
+				  vertexVals, normalValsC, normalVals, colorValsUC, colorVals, 
+				  pickColorValsTMP);
+	    idxpl++; pl += 3; plc += 4;
+	    SetVertexValuesForVBO(I->G, cgo, pl, plc, sp->nverts-1, incr++, 
+				  vertexValsDA, normalValsDA, colorValsDA, pickColorValsDA, 
+				  vertexVals, normalValsC, normalVals, colorValsUC, colorVals, 
+				  pickColorValsTMP);
+            FixPickColorsForLine(pickColorValsTMP + (incr-2) * 2,
+                                 pickColorValsTMP + (incr-1) * 2);
+	    idxpl++; pl += 3; plc += 4;
+	    break;
+	  }
+
+	  //	  pl += 3 * nverts;
+	  //	  plc += 4 * nverts;
+	  vpl += sp->nverts;
+	}
+      }
+	break;
+      default:
+	break;
+      }
+      pc = save_pc;
+      pc += CGO_sz[op];
+    }
+    {
+      short nsz = VERTEX_NORMAL_SIZE * 4;
+      GLenum ntp = GL_FLOAT;
+      bool nnorm = GL_FALSE;
+      if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_normal)){
+        nsz = VERTEX_NORMAL_SIZE;
+        ntp = GL_BYTE;
+        nnorm = GL_TRUE;
+      }
+
+      short csz = 4;
+      GLenum ctp = GL_FLOAT;
+      bool cnorm = GL_FALSE;
+      if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_color)){
+        csz = 1;
+        ctp = GL_UNSIGNED_BYTE;
+        cnorm = GL_TRUE;
+      }
+
+      VertexBuffer * vbo = I->G->ShaderMgr->newGPUBuffer<VertexBuffer>(VertexBuffer::SEQUENTIAL);
+      BufferDataDesc bufData =
+        { { "a_Vertex", GL_FLOAT, 3, sizeof(float) * num_total_indexes_lines * 3, vertexVals, GL_FALSE } };
+
+      if (has_normals){
+        bufData.push_back( { "a_Normal", ntp,      VERTEX_NORMAL_SIZE, (size_t)(num_total_indexes_lines * nsz), normalVals, nnorm } );
+      }
+      if (has_color){
+        bufData.push_back( { "a_Color",  ctp,      4, sizeof(float) * num_total_indexes_lines * csz, colorVals, cnorm } );
+      }
+      ok = vbo->bufferData(std::move(bufData));
+      size_t vboid = vbo->get_hash_id();
+
+      // picking VBO: generate a buffer twice the size needed, for each picking pass
+      VertexBuffer * pickvbo = I->G->ShaderMgr->newGPUBuffer<VertexBuffer>(VertexBuffer::SEQUENTIAL, GL_DYNAMIC_DRAW);
+      ok &= pickvbo->bufferData({
+          BufferDesc( "a_Color", GL_UNSIGNED_BYTE, 4, sizeof(float) * num_total_indexes_lines, 0, GL_TRUE ),
+          BufferDesc( "a_Color", GL_UNSIGNED_BYTE, 4, sizeof(float) * num_total_indexes_lines, 0, GL_TRUE )
+        });
+      size_t pickvboid = pickvbo->get_hash_id();
+
+      if (ok){
+	float *newPickColorVals ;
+	if (addshaders)
+	  CGOEnable(cgo, GL_DEFAULT_SHADER_WITH_SETTINGS);
+	CGODisable(cgo, GL_SHADER_LIGHTING);
+	newPickColorVals = cgo->add<cgo::draw::buffers_not_indexed>(GL_LINES, CGO_VERTEX_ARRAY | CGO_NORMAL_ARRAY | CGO_COLOR_ARRAY | CGO_PICK_COLOR_ARRAY, num_total_indexes_lines, vboid, pickvboid);
+	if (ok && addshaders)
+	  ok &= CGODisable(cgo, GL_DEFAULT_SHADER);
+	CHECKOK(ok, newPickColorVals);
+	if (!ok){
+	  PRINTFB(I->G, FB_CGO, FB_Errors) "CGOOptimizeToVBONotIndexedWithReturnedData: ERROR: CGODrawBuffersNotIndexed() could not allocate enough memory\n" ENDFB(I->G);	
+	  FreeP(vertexVals);
+	  CGOFree(cgo);
+	  if (!newPickColorVals) {
+	    I->G->ShaderMgr->freeGPUBuffer(pickvboid);
+            I->G->ShaderMgr->freeGPUBuffer(vboid);
+          }
+	  return (NULL);
+	}
+	memcpy(newPickColorVals + num_total_indexes_lines, pickColorVals, num_total_indexes_lines * 2 * sizeof(float));
+	has_draw_buffer = true;
+      } else {
+        I->G->ShaderMgr->freeGPUBuffer(pickvboid);
+        I->G->ShaderMgr->freeGPUBuffer(vboid);
+      }
+    }
+    if (ok && returnedData){
+      returnedData[1] = vertexVals;
+    } else {
+      FreeP(vertexVals);
+    }
+  }
+
+  if (ok && (num_total_vertices>0 || num_total_vertices_lines>0 || num_total_vertices_points>0)){
+    ok &= CGOBoundingBox(cgo, min, max);
+  }
+
+  if (ok)
+    ok &= CGOStop(cgo);
+  if (has_draw_buffer){
+    cgo->has_draw_buffers = true;
+  }
+  cgo->use_shader = I->use_shader;
+  if (cgo->use_shader){
+    cgo->cgo_shader_ub_color = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_color);
+    cgo->cgo_shader_ub_normal = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_normal);
+  }
+  if (!ok){
+    CGOFree(cgo);
+  }
+  return (cgo);
+}
+
+CGO *CGOOptimizeToVBOIndexed(CGO * I, int est,
+    const float *color, bool addshaders, bool embedTransparencyInfo)
+{
+  CGO *cgo;
+
+  float *pc = I->op;
+  int op;
+  float *save_pc;
+  int num_total_vertices = 0, num_total_indexes = 0, num_total_vertices_lines = 0, num_total_indexes_lines = 0,
+    num_total_vertices_points = 0;
+  short has_draw_buffer = false;
+  float min[3] = { MAXFLOAT, MAXFLOAT, MAXFLOAT }, max[3] = { -MAXFLOAT, -MAXFLOAT, -MAXFLOAT };
+  int ok = true;
+
+  CGOCountNumVertices(I, &num_total_vertices, &num_total_indexes,
+		      &num_total_vertices_lines, &num_total_indexes_lines,
+		      &num_total_vertices_points);
+
+  cgo = CGONewSized(I->G, I->c + est);
+  CHECKOK(ok, cgo);
+  if (ok){
+    if (color){
+      cgo->color[0] = color[0]; cgo->color[1] = color[1]; cgo->color[2] = color[2];
+      cgo->alpha = color[3];
+    } else {
+      cgo->color[0] = 1.f; cgo->color[1] = 1.f; cgo->color[2] = 1.f;
+      cgo->alpha = 1.f;
+    }
+  }
+
+#if defined(_PYMOL_IOS) && !defined(_WEBGL)
+  if (num_total_indexes > MAX_INDICES_FOR_IOS || num_total_indexes_lines > MAX_INDICES_FOR_IOS){
+    PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeToVBOIndexed() VBO Memory Limitation: The requested \n       operation requires a larger buffer than PyMOL currently allows. \n       The operation has not entirely completed successfully.\n" ENDFB(I->G);
+    firePyMOLLimitationWarning();
+    CGOFree(cgo);
+    return NULL;
+  }
+#endif
+
+  if (num_total_vertices_points>0){
+    /* This does not need to be indexed (for now) */
+    if (!OptimizePointsToVBO(I, cgo, num_total_vertices_points, min, max, &has_draw_buffer, addshaders)){
+      CGOFree(cgo);
+      return NULL;
+    }
+  }
+
+  if (num_total_vertices>0){
+    float *vertexVals = 0, *colorVals = 0, *normalVals, *accessibilityVals = 0;
+    float *pickColorVals;
+    GL_C_INT_TYPE *vertexIndices; 
+    short vertexIndicesAllocated = 0;
+    int pl = 0, plc = 0, idxpl = 0, vpl = 0, tot, nxtn;
+    uchar *colorValsUC = 0;
+    uchar *normalValsC = 0;
+    short ambient_occlusion = 0;
+    float *sumarray = NULL;
+    int n_data = 0;
+
+    pc = I->op;
+
+    if (embedTransparencyInfo){
+      int n_tri = num_total_indexes / 3;
+      int bytes_to_allocate = 2 * num_total_indexes * sizeof(GL_C_INT_TYPE) + // vertexIndicesOriginal, vertexIndices
+	3 * num_total_indexes * sizeof(float) +  // 3 * for sum
+	n_tri * sizeof(float) + 2 * n_tri * sizeof(int) + 256 * sizeof(int);    // z_value (float * n_tri), ix (n_tri * int), sort_mem ((n_tri + 256) * int)
+      // round to 4 byte words for the length of the CGO
+      n_data = bytes_to_allocate / 4 + (((bytes_to_allocate % 4) == 0) ? 0 : 1) ;
+    }
+    vertexIndices = Calloc(GL_C_INT_TYPE, num_total_indexes);
+    vertexIndicesAllocated = 1;
+    if (!vertexIndices){
+      PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeToVBOIndexed() vertexIndices could not be allocated\n" ENDFB(I->G);	
+      CGOFree(cgo);
+      return (NULL);
+    }
+    tot = num_total_vertices * (3 * 6) ;
+    //    tot = num_total_vertices * (3 * 3 + 2) ;
+    /* NOTE/TODO: Not sure why 3*5 needs to be used, but 3*3+2, which is the 
+       correct length, crashes in glBufferData */
+    vertexVals = Alloc(float, tot);
+    if (!vertexVals){
+      PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeToVBOIndexed() vertexVals could not be allocated\n" ENDFB(I->G);	
+      CGOFree(cgo);
+      return (NULL);
+    }
+    normalVals = vertexVals + 3 * num_total_vertices;
+    nxtn = 3;
+    if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_normal)){
+      normalValsC = (uchar*) normalVals;
+      nxtn = 1;
+    }
+
+    colorVals = normalVals + nxtn * num_total_vertices;
+    if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_color)){
+      colorValsUC = (uchar*) colorVals;
+      nxtn = 1;
+    } else {
+      nxtn = 4;
+    }
+    pickColorVals = (colorVals + nxtn * num_total_vertices);
+    accessibilityVals = pickColorVals + 3 * num_total_vertices;
+
+    while(ok && (op = (CGO_MASK & CGO_read_int(pc)))) {
+      save_pc = pc;
+      switch (op) {
+      case CGO_NORMAL:
+	cgo->normal[0] = *pc; cgo->normal[1] = *(pc + 1); cgo->normal[2] = *(pc + 2);
+	break;
+      case CGO_COLOR:
+	cgo->color[0] = *pc; cgo->color[1] = *(pc + 1); cgo->color[2] = *(pc + 2);
+	break;
+      case CGO_ALPHA:
+	cgo->alpha = *pc;
+ 	break;
+      case CGO_ACCESSIBILITY:
+	cgo->current_accessibility = *pc;
+	break;
+      case CGO_PICK_COLOR:
+	cgo->current_pick_color_index = CGO_get_uint(pc);
+	cgo->current_pick_color_bond = CGO_get_int(pc + 1);
+	break;
+      case CGO_DRAW_ARRAYS:
+	{
+        cgo::draw::arrays * sp = reinterpret_cast<decltype(sp)>(pc);
+	short shouldCompress = false;
+	switch(sp->mode){
+	case GL_TRIANGLE_FAN:
+	case GL_TRIANGLE_STRIP:
+	case GL_TRIANGLES:
+	  shouldCompress = true;
+	default:
+	  break;
+	}
+	if (shouldCompress){	
+	  int cnt, nxtn = 3;
+	  float *vertexValsDA = 0, *nxtVals = 0, *colorValsDA = 0, *normalValsDA, *accessibilityValsDA;
+	  float *pickColorValsDA, *pickColorValsTMP, *accessibilityValsTMP;
+
+	  nxtVals = vertexValsDA = sp->floatdata;
+	  for (cnt=0; cnt<sp->nverts*3; cnt+=3){
+	    set_min_max(min, max, &vertexValsDA[cnt]);
+	  }
+	  for (cnt=0; cnt<sp->nverts*3; cnt++){
+	    vertexVals[pl + cnt] = vertexValsDA[cnt];
+	  }
+	  if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_normal)){
+	    if (sp->arraybits & CGO_NORMAL_ARRAY){
+	      nxtVals = normalValsDA = vertexValsDA + (nxtn*sp->nverts);
+	      for (cnt=0; cnt<sp->nverts*3; cnt++){
+		normalValsC[VAR_FOR_NORMAL + cnt VAR_FOR_NORMAL_CNT_PLUS] = CLIP_NORMAL_VALUE(normalValsDA[cnt]);
+	      }
+	    } else {
+	      uchar norm[3] = { CLIP_NORMAL_VALUE(cgo->normal[0]), CLIP_NORMAL_VALUE(cgo->normal[1]), CLIP_NORMAL_VALUE(cgo->normal[2]) };
+	      for (cnt=0; cnt<sp->nverts*3; cnt++){
+		normalValsC[VAR_FOR_NORMAL + cnt VAR_FOR_NORMAL_CNT_PLUS] = norm[cnt%3];
+	      }
+	    }
+	  } else {
+	    if (sp->arraybits & CGO_NORMAL_ARRAY){
+	      nxtVals = normalValsDA = vertexValsDA + (nxtn*sp->nverts);
+	      for (cnt=0; cnt<sp->nverts*3; cnt++){
+		normalVals[pl + cnt] = normalValsDA[cnt];
+	      }
+	    } else {
+	      for (cnt=0; cnt<sp->nverts*3; cnt++){
+		normalVals[pl + cnt] = cgo->normal[cnt%3];
+	      }
+	    }
+	  }
+	  nxtn = 3;
+	  if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_color)){
+	    if (sp->arraybits & CGO_COLOR_ARRAY){
+	      nxtVals = colorValsDA = nxtVals + (nxtn*sp->nverts);
+	      for (cnt=0; cnt<sp->nverts*4; cnt+=4){
+		colorValsUC[plc + cnt] = CLIP_COLOR_VALUE(colorValsDA[cnt]);
+		colorValsUC[plc + cnt + 1] = CLIP_COLOR_VALUE(colorValsDA[cnt+1]);
+		colorValsUC[plc + cnt + 2] = CLIP_COLOR_VALUE(colorValsDA[cnt+2]);
+		colorValsUC[plc + cnt + 3] = CLIP_COLOR_VALUE(colorValsDA[cnt+3]);
+	      }
+	      nxtn = 4;
+	    } else {
+	      uchar col[4] = { CLIP_COLOR_VALUE(cgo->color[0]), CLIP_COLOR_VALUE(cgo->color[1]), CLIP_COLOR_VALUE(cgo->color[2]), CLIP_COLOR_VALUE(cgo->alpha) };
+	      for (cnt=0; cnt<sp->nverts*4; cnt++){
+		colorValsUC[plc + cnt] = col[cnt%4];
+	      }
+	    }
+	  } else {
+	    if (sp->arraybits & CGO_COLOR_ARRAY){
+	      nxtVals = colorValsDA = nxtVals + (nxtn*sp->nverts);
+	      for (cnt=0; cnt<sp->nverts*4; cnt+=4){
+		colorVals[plc + cnt] = colorValsDA[cnt];
+		colorVals[plc + cnt + 1] = colorValsDA[cnt+1];
+		colorVals[plc + cnt + 2] = colorValsDA[cnt+2];
+		colorVals[plc + cnt + 3] = colorValsDA[cnt+3];
+	      }
+	      nxtn = 4;
+	    } else {
+	      float col[4] = { cgo->color[0], cgo->color[1], cgo->color[2], cgo->alpha };
+	      for (cnt=0; cnt<sp->nverts*4; cnt++){
+		colorVals[plc + cnt] = col[cnt%4];
+	      }
+	    }
+	  }
+	  if (sp->arraybits & CGO_PICK_COLOR_ARRAY){
+	    nxtVals = nxtVals + (nxtn*sp->nverts);
+	    pickColorValsDA = nxtVals + sp->nverts;
+	    pickColorValsTMP = pickColorVals + (vpl * 2);
+	    for (cnt=0; cnt<sp->nverts; cnt++){
+	      CGO_put_int(pickColorValsTMP++, CGO_get_int(pickColorValsDA++));
+	      CGO_put_int(pickColorValsTMP++, CGO_get_int(pickColorValsDA++));
+	    }
+	    nxtn = 3;
+	  } else {
+	    pickColorValsTMP = pickColorVals + (vpl * 2);
+	    for (cnt=0; cnt<sp->nverts; cnt++){
+	      CGO_put_uint(pickColorValsTMP++, cgo->current_pick_color_index);
+	      CGO_put_int(pickColorValsTMP++, cgo->current_pick_color_bond);
+	    }
+	  }
+	  if (sp->arraybits & CGO_ACCESSIBILITY_ARRAY){
+	    if (!ambient_occlusion){
+	      for (cnt=0; cnt<vpl; cnt++){
+		accessibilityVals[cnt] = 1.f;
+	      }
+	    }
+	    ambient_occlusion = 1;
+	    nxtVals = nxtVals + (nxtn*sp->nverts);
+	    accessibilityValsDA = nxtVals;
+	    accessibilityValsTMP = accessibilityVals + vpl;
+	    for (cnt=0; cnt<sp->nverts; cnt++){
+	      accessibilityValsTMP[cnt] = accessibilityValsDA[cnt];
+	    }
+	  } else {
+	    if (ambient_occlusion){
+	      accessibilityValsTMP = accessibilityVals + vpl;
+	      for (cnt=0; cnt<sp->nverts; cnt++){
+		accessibilityValsTMP[cnt] = 1.f;
+	      }
+	    }
+	  }
+	  switch (sp->mode){
+	  case GL_TRIANGLES:
+	    for (cnt = 0; cnt < sp->nverts; cnt++){
+	      vertexIndices[idxpl++] = vpl + cnt;
+	    }
+	    break;
+	  case GL_TRIANGLE_STRIP:
+	    {
+	      short flip = 0;
+	      for (cnt = 2; cnt < sp->nverts; cnt++){
+		vertexIndices[idxpl++] = vpl + cnt - (flip ? 0 : 2);
+		vertexIndices[idxpl++] = vpl + cnt - 1;
+		vertexIndices[idxpl++] = vpl + cnt - (flip ? 2 : 0);
+		flip = !flip;
+	      }
+	    }
+	    break;
+	  case GL_TRIANGLE_FAN:
+	    for (cnt = 2; cnt < sp->nverts; cnt++){
+	      vertexIndices[idxpl++] = vpl;
+	      vertexIndices[idxpl++] = vpl + cnt - 1;
+	      vertexIndices[idxpl++] = vpl + cnt;
+	    }
+	    break;
+	  }
+	  pl += 3 * sp->nverts;
+	  plc += 4 * sp->nverts;
+	  vpl += sp->nverts;
+	}
+	}
+	break;
+      default:
+	break;
+      }
+      pc = save_pc;
+      pc += CGO_sz[op];
+      ok &= !I->G->Interrupt;
+    }
+    if (sumarray){
+      for (idxpl = 0; idxpl < num_total_indexes; idxpl+=3){
+	add3f(&vertexVals[3 * vertexIndices[idxpl]], &vertexVals[3 * vertexIndices[idxpl+1]], sumarray);
+	add3f(&vertexVals[3 * vertexIndices[idxpl+2]], sumarray, sumarray);
+	sumarray += 3;
+      }
+    }
+    if (ok) {
+      short nsz = VERTEX_NORMAL_SIZE * 4;
+      GLenum ntp = GL_FLOAT;
+      if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_normal)){
+        nsz = VERTEX_NORMAL_SIZE;
+        ntp = GL_BYTE;
+      }
+
+      short csz = 4;
+      GLenum ctp = GL_FLOAT;
+      if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_color)){
+        csz = 1;
+        ctp = GL_UNSIGNED_BYTE;
+      }
+
+      VertexBuffer * vbo = I->G->ShaderMgr->newGPUBuffer<VertexBuffer>();
+      ok &= vbo->bufferData({
+          BufferDesc( "a_Vertex",        GL_FLOAT, 3, sizeof(float) * num_total_vertices * 3, vertexVals, GL_FALSE ),
+          BufferDesc( "a_Normal",        ntp,      VERTEX_NORMAL_SIZE, num_total_vertices * nsz, normalVals, GL_FALSE ),
+          BufferDesc( "a_Color",         ctp,      4, sizeof(float) * num_total_vertices * csz, colorVals, GL_TRUE ),
+          BufferDesc( "a_Accessibility", GL_FLOAT, 1, sizeof(float) * num_total_vertices, accessibilityVals, GL_FALSE )
+        });
+
+      IndexBuffer * ibo = I->G->ShaderMgr->newGPUBuffer<IndexBuffer>();
+      ok &= ibo->bufferData({
+          BufferDesc( GL_UNSIGNED_INT, sizeof(GL_C_INT_TYPE) * num_total_indexes, vertexIndices )
+        });
+
+      size_t vboid = vbo->get_hash_id();
+      size_t iboid = ibo->get_hash_id();
+
+      VertexBuffer * pickvbo = I->G->ShaderMgr->newGPUBuffer<VertexBuffer>(VertexBuffer::SEQUENTIAL, GL_DYNAMIC_DRAW);
+      ok &= pickvbo->bufferData({
+          BufferDesc( "a_Color", GL_UNSIGNED_BYTE, 4, sizeof(float) * num_total_indexes, 0, GL_TRUE ),
+          BufferDesc( "a_Color", GL_UNSIGNED_BYTE, 4, sizeof(float) * num_total_indexes, 0, GL_TRUE )
+        });
+      size_t pickvboid = pickvbo->get_hash_id();
+
+      if (ok) {
+	float *newPickColorVals ;
+	int arrays = CGO_VERTEX_ARRAY | CGO_NORMAL_ARRAY | CGO_COLOR_ARRAY | CGO_PICK_COLOR_ARRAY;
+	if (ambient_occlusion){
+	  arrays |= CGO_ACCESSIBILITY_ARRAY;
+	}
+	if (addshaders)
+	  CGOEnable(cgo, GL_DEFAULT_SHADER);
+	newPickColorVals = cgo->add<cgo::draw::buffers_indexed>(GL_TRIANGLES, arrays, num_total_indexes, num_total_vertices, vboid, iboid, n_data, pickvboid);
+	if (embedTransparencyInfo){
+	  int n_tri = num_total_indexes/3;
+	  float *sumarray;
+	  float *sum = sumarray = newPickColorVals + num_total_vertices*3;
+	  float *z_value = sum + (num_total_indexes*3);
+	  int *ix = (int *)z_value + n_tri;
+	  int *sort_mem = ix + n_tri;
+	  GL_C_INT_TYPE *vertexIndicesOriginalTI = (GL_C_INT_TYPE *)(sort_mem + n_tri + 256);
+	  
+	  for (idxpl = 0; idxpl < num_total_indexes; idxpl+=3){
+	    add3f(&vertexVals[3 * vertexIndices[idxpl]], &vertexVals[3 * vertexIndices[idxpl+1]], sumarray);
+	    add3f(&vertexVals[3 * vertexIndices[idxpl+2]], sumarray, sumarray);
+	    sumarray += 3;
+	  }
+	  memcpy(vertexIndicesOriginalTI, vertexIndices, sizeof(GL_C_INT_TYPE) * num_total_indexes);
+	}
+
+	if (addshaders && ok)
+	  ok &= CGODisable(cgo, GL_DEFAULT_SHADER);
+	CHECKOK(ok, newPickColorVals);
+	if (!newPickColorVals){
+          I->G->ShaderMgr->freeGPUBuffer(pickvboid);
+          I->G->ShaderMgr->freeGPUBuffer(vboid);
+          I->G->ShaderMgr->freeGPUBuffer(iboid);
+	}
+	if (ok)
+	  memcpy(newPickColorVals + num_total_vertices, pickColorVals, num_total_vertices * 2 * sizeof(float));
+	has_draw_buffer = true;
+      } else {
+        I->G->ShaderMgr->freeGPUBuffer(pickvboid);
+        I->G->ShaderMgr->freeGPUBuffer(vboid);
+        I->G->ShaderMgr->freeGPUBuffer(iboid);
+      }
+    }
+    if (vertexIndicesAllocated)
+      FreeP(vertexIndices);
+    FreeP(vertexVals);
+  }
+  if (ok && num_total_vertices_lines>0){
+    float *vertexVals = 0, *colorVals = 0, *normalVals = NULL, *nxtVals;
+    float *pickColorVals;
+    GL_C_INT_TYPE *vertexIndexes; 
+    uchar *colorValsUC = 0;
+    uchar *normalValsC = 0;
+    int pl = 0, plc = 0, idxpl = 0, vpl = 0, tot, sz;
+    bool hasNormals = 0;
+
+    pc = I->op;
+    hasNormals = !CGOHasAnyLineVerticesWithoutNormals(I);
+    vertexIndexes = Alloc(GL_C_INT_TYPE, num_total_indexes_lines);
+    if (!vertexIndexes){
+      PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeToVBOIndexed() vertexIndexes could not be allocated\n" ENDFB(I->G);	
+      CGOFree(cgo);
+      return (NULL);
+    }
+    tot = num_total_vertices_lines * (3 * 5) ;
+    //    tot = num_total_vertices * (3 * 3 + 2) ;
+    /* NOTE/TODO: Not sure why 3*5 needs to be used, but 3*3+2, which is the 
+       correct length, crashes in glBufferData */
+    vertexVals = Alloc(float, tot);
+    if (!vertexVals){
+      PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeToVBOIndexed() vertexVals could not be allocated\n" ENDFB(I->G);	
+      CGOFree(cgo);
+      return (NULL);
+    }
+    nxtVals = vertexVals + 3 * num_total_vertices_lines;
+    sz = 3;
+    if (hasNormals){
+      normalVals = nxtVals;
+      if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_normal)){
+	normalValsC = (uchar*) normalVals;
+	sz = 1;
+      }
+    }
+    colorVals = nxtVals + sz * num_total_vertices_lines;
+    if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_color)){
+      colorValsUC = (uchar*) colorVals;
+      sz = 1;
+    } else {
+      sz = 4;
+    }
+    pickColorVals = (colorVals + sz * num_total_vertices_lines);
+    while(ok && (op = (CGO_MASK & CGO_read_int(pc)))) {
+      save_pc = pc;
+      switch (op) {
+      case CGO_NORMAL:
+	cgo->normal[0] = *pc; cgo->normal[1] = *(pc + 1); cgo->normal[2] = *(pc + 2);
+	break;
+      case CGO_COLOR:
+	cgo->color[0] = *pc; cgo->color[1] = *(pc + 1); cgo->color[2] = *(pc + 2);
+	break;
+      case CGO_ACCESSIBILITY:
+	cgo->current_accessibility = *pc;
+	break;
+      case CGO_ALPHA:
+	cgo->alpha = *pc;
+	break;
+      case CGO_PICK_COLOR:
+	cgo->current_pick_color_index = CGO_get_uint(pc);
+	cgo->current_pick_color_bond = CGO_get_int(pc + 1);
+	break;
+      case CGO_DRAW_ARRAYS:
+	{
+        cgo::draw::arrays * sp = reinterpret_cast<decltype(sp)>(pc);
+	short shouldCompress = false;
+	switch(sp->mode){
+	case GL_LINE_LOOP:
+	case GL_LINE_STRIP:
+	case GL_LINES:
+	  shouldCompress = true;
+	default:
+	  break;
+	}
+	if (shouldCompress){	
+	  int cnt, nxtn = 3;
+	  float *vertexValsDA = 0, *nxtVals2 = 0, *colorValsDA = 0, *normalValsDA = 0;
+	  float *pickColorValsDA = 0, *pickColorValsTMP;
+
+	  nxtVals2 = vertexValsDA = sp->floatdata;
+	  for (cnt=0; cnt<sp->nverts*3; cnt+=3){
+	    set_min_max(min, max, &vertexValsDA[cnt]);
+	  }
+	  for (cnt=0; cnt<sp->nverts*3; cnt++){
+	    vertexVals[pl + cnt] = vertexValsDA[cnt];
+	  }
+	  if (normalVals){
+	    if (sp->arraybits & CGO_NORMAL_ARRAY){
+	      if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_normal)){
+		nxtVals2 = normalValsDA = nxtVals2 + (nxtn*sp->nverts);
+		for (cnt=0; cnt<sp->nverts*3; cnt++){
+		  normalValsC[VAR_FOR_NORMAL + cnt VAR_FOR_NORMAL_CNT_PLUS] = CLIP_NORMAL_VALUE(normalValsDA[cnt]);
+		}
+	      } else {
+		nxtVals2 = normalValsDA = nxtVals2 + (nxtn*sp->nverts);
+		for (cnt=0; cnt<sp->nverts*3; cnt++){
+		  normalVals[VAR_FOR_NORMAL + cnt] = normalValsDA[cnt];
+		}
+	      }
+	    }
+	  }
+	  if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_color)){
+	    if (sp->arraybits & CGO_COLOR_ARRAY){
+	      nxtVals2 = colorValsDA = nxtVals2 + (nxtn*sp->nverts);
+	      for (cnt=0; cnt<sp->nverts*4; cnt++){
+		colorValsUC[plc + cnt] = CLIP_COLOR_VALUE(colorValsDA[cnt]);
+	      }
+	      nxtn = 4;
+	    } else {
+	      uchar col[4] = { CLIP_COLOR_VALUE(cgo->color[0]), CLIP_COLOR_VALUE(cgo->color[1]), CLIP_COLOR_VALUE(cgo->color[2]), CLIP_COLOR_VALUE(cgo->alpha) };
+	      for (cnt=0; cnt<sp->nverts*4; cnt++){
+		colorValsUC[plc + cnt] = col[cnt%4];
+	      }
+	    }
+	  } else {
+	    if (sp->arraybits & CGO_COLOR_ARRAY){
+	      nxtVals2 = colorValsDA = nxtVals2 + (nxtn*sp->nverts);
+	      for (cnt=0; cnt<sp->nverts*4; cnt++){
+		colorVals[plc + cnt] = colorValsDA[cnt];
+	      }
+	      nxtn = 4;
+	    } else {
+	      float col[4] = { cgo->color[0], cgo->color[1], cgo->color[2], cgo->alpha };
+	      for (cnt=0; cnt<sp->nverts*4; cnt++){
+		colorVals[plc + cnt] = col[cnt%4];
+	      }
+	    }
+	  }
+	  if (sp->arraybits & CGO_PICK_COLOR_ARRAY){
+	    nxtVals2 = nxtVals2 + (nxtn*sp->nverts);
+	    pickColorValsDA = nxtVals2 + sp->nverts;
+	    pickColorValsTMP = pickColorVals + (vpl * 2);
+	    for (cnt=0; cnt<sp->nverts; cnt++){
+	      CGO_put_int(pickColorValsTMP++, CGO_get_int(pickColorValsDA++));
+	      CGO_put_int(pickColorValsTMP++, CGO_get_int(pickColorValsDA++));
+	    }
+	    nxtn = 3;
+	  } else {
+	    pickColorValsTMP = pickColorVals + (vpl * 2);
+	    for (cnt=0; cnt<sp->nverts; cnt++){
+	      CGO_put_uint(pickColorValsTMP++, cgo->current_pick_color_index);
+	      CGO_put_int(pickColorValsTMP++, cgo->current_pick_color_bond);
+	    }
+	  }
+	  if (idxpl + sp->nverts > num_total_indexes_lines){
+	    PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeToVBOIndexed() num_total_indexes_lines=%d mode=%d nverts=%d idxpl=%d\n", num_total_indexes_lines, sp->mode, sp->nverts, idxpl ENDFB(I->G);
+	  }
+	  switch (sp->mode){
+	  case GL_LINES:
+	    for (cnt = 0; cnt < sp->nverts; cnt++){
+	      vertexIndexes[idxpl++] = vpl + cnt;
+	    }
+	    break;
+	  case GL_LINE_STRIP:
+	    for (cnt = 1; cnt < sp->nverts; cnt++){
+	      vertexIndexes[idxpl++] = vpl + cnt - 1;
+	      vertexIndexes[idxpl++] = vpl + cnt;
+	    }
+	    break;
+	  case GL_LINE_LOOP:
+	    for (cnt = 1; cnt < sp->nverts; cnt++){
+	      vertexIndexes[idxpl++] = vpl + cnt - 1;
+	      vertexIndexes[idxpl++] = vpl + cnt;
+	    }
+	    vertexIndexes[idxpl++] = vpl;
+	    vertexIndexes[idxpl++] = vpl + sp->nverts - 1;
+	    break;
+	  }
+
+	  pl += 3 * sp->nverts;
+	  plc += 4 * sp->nverts;
+	  vpl += sp->nverts;
+	}
+	}
+	break;
+      case CGO_SPECIAL:
+	CGOSpecial(cgo, CGO_get_int(pc));
+      default:
+	break;
+      }
+      pc = save_pc;
+      pc += CGO_sz[op];
+      ok &= !I->G->Interrupt;
+    }
+    if (ok) {
+      short nsz = VERTEX_NORMAL_SIZE * 4;
+      GLenum ntp = GL_FLOAT;
+      if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_normal)){
+        nsz = VERTEX_NORMAL_SIZE;
+        ntp = GL_BYTE;
+      }
+
+      short csz = 4;
+      GLenum ctp = GL_FLOAT;
+      if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_color)){
+        csz = 1;
+        ctp = GL_UNSIGNED_BYTE;
+      }
+
+      VertexBuffer * vbo = I->G->ShaderMgr->newGPUBuffer<VertexBuffer>();
+      ok &= vbo->bufferData({
+          BufferDesc( "a_Vertex",        GL_FLOAT, 3, sizeof(float) * num_total_vertices_lines * 3, vertexVals, GL_FALSE ),
+          BufferDesc( "a_Normal",        ntp,      VERTEX_NORMAL_SIZE, num_total_vertices_lines * nsz, normalVals, GL_FALSE ),
+          BufferDesc( "a_Color",         ctp,      4, sizeof(float) * num_total_vertices_lines * csz, colorVals, GL_TRUE )
+        });
+
+      IndexBuffer * ibo = I->G->ShaderMgr->newGPUBuffer<IndexBuffer>();
+      ok &= ibo->bufferData({
+          BufferDesc( GL_UNSIGNED_INT, sizeof(GL_C_INT_TYPE) * num_total_indexes_lines, vertexIndexes )
+        });
+
+      size_t vboid = vbo->get_hash_id();
+      size_t iboid = ibo->get_hash_id();
+
+      VertexBuffer * pickvbo = I->G->ShaderMgr->newGPUBuffer<VertexBuffer>(VertexBuffer::SEQUENTIAL, GL_DYNAMIC_DRAW);
+      ok &= pickvbo->bufferData({
+          BufferDesc( "a_Color", GL_UNSIGNED_BYTE, 4, sizeof(float) * num_total_indexes, 0, GL_TRUE ),
+          BufferDesc( "a_Color", GL_UNSIGNED_BYTE, 4, sizeof(float) * num_total_indexes, 0, GL_TRUE )
+        });
+      size_t pickvboid = pickvbo->get_hash_id();
+
+      if (ok){
+	float *newPickColorVals ;
+	if (addshaders){
+	  CGOEnable(cgo, GL_DEFAULT_SHADER);
+	  CGODisable(cgo, GL_SHADER_LIGHTING);
+	}
+	newPickColorVals = cgo->add<cgo::draw::buffers_indexed>(GL_LINES,
+                                                                CGO_VERTEX_ARRAY | CGO_NORMAL_ARRAY |
+                                                                CGO_COLOR_ARRAY | CGO_PICK_COLOR_ARRAY,
+                                                                num_total_indexes_lines,
+                                                                num_total_vertices_lines, vboid, iboid, 0, pickvboid);
+	CHECKOK(ok, newPickColorVals);
+	if (addshaders && ok)
+	  ok &= CGODisable(cgo, GL_DEFAULT_SHADER);
+	if (!newPickColorVals) {
+          I->G->ShaderMgr->freeGPUBuffer(pickvboid);
+          I->G->ShaderMgr->freeGPUBuffer(vboid);
+          I->G->ShaderMgr->freeGPUBuffer(iboid);
+        }
+	if (ok)
+	  memcpy(newPickColorVals + num_total_vertices_lines, 
+		 pickColorVals, num_total_vertices_lines * 2 * sizeof(float));
+	has_draw_buffer = true;
+      } else {
+        I->G->ShaderMgr->freeGPUBuffer(pickvboid);
+        I->G->ShaderMgr->freeGPUBuffer(vboid);
+        I->G->ShaderMgr->freeGPUBuffer(iboid);
+      }
+    }
+    FreeP(vertexIndexes);
+    FreeP(vertexVals);
+  }
+  if (ok && (num_total_vertices>0 || num_total_vertices_lines>0)){
+    ok &= CGOBoundingBox(cgo, min, max);
+  }
+
+  if (ok)
+    ok &= CGOStop(cgo);
+  if (ok){
+    if (has_draw_buffer){
+      cgo->has_draw_buffers = true;
+    }
+    cgo->use_shader = I->use_shader;
+    if (cgo->use_shader){
+      cgo->cgo_shader_ub_color = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_color); 
+      cgo->cgo_shader_ub_normal = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_normal);
+    }
+  }
+  if (!ok){
+    CGOFree(cgo);
+  }
+  return (cgo);
+}
+
+CGO *CGOOptimizeSpheresToVBONonIndexed(const CGO * I, int est, bool addshaders, CGO *leftOverCGO)
+{
+  CGO *cgo = NULL;
+  float *pc = I->op;
+  int op;
+  int sz;
+
+  int rightup_flags[4] = { 0, 1, 3, 2 };
+  float *save_pc;
+  int num_total_spheres = 0;
+  short has_draw_buffer = false;
+  float min[3] = { MAXFLOAT, MAXFLOAT, MAXFLOAT }, max[3] = { -MAXFLOAT, -MAXFLOAT, -MAXFLOAT };
+  int vv, total_vert = 0, total_spheres = 0;
+  int ok = true;
+
+  num_total_spheres = CGOCountNumberOfOperationsOfType(I, CGO_SPHERE);
+  if (num_total_spheres>0) {
+    float *vertVals = 0;
+    GLubyte *rightUpFlagValsUB = 0;
+    float *rightUpFlagVals = 0;
+    GLubyte *colorValsUB = 0;
+    int tot = VERTICES_PER_SPHERE * 4 * num_total_spheres;
+    float *org_vertVals = NULL;
+    GLubyte *org_colorValsUB = NULL;
+    int *org_pickcolorVals = NULL, *pickcolorVals = NULL;
+    GLubyte *org_rightUpFlagValsUB = NULL;
+    float *org_rightUpFlagVals = NULL;
+    float min_alpha;
+    short cgo_shader_ub_flags;
+    bool copyToLeftOver, copyNormalToLeftOver, copyColorToLeftOver, copyPickColorToLeftOver, copyAlphaToLeftOver ;
+    bool has_picking = CGOHasOperationsOfType(I, CGO_PICK_COLOR);
+
+    cgo = CGONewSized(I->G, I->c + est);
+
+    cgo_shader_ub_flags = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_flags);
+  
+    org_vertVals = vertVals = Alloc(float, tot);
+    if (!org_vertVals){
+      PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeSpheresToVBONonIndexed() org_vertVals could not be allocated\n" ENDFB(I->G);	
+      CGOFree(cgo);
+      return (NULL);
+    }
+
+    org_colorValsUB = colorValsUB = Alloc(GLubyte, tot);
+    if (!org_colorValsUB){
+      PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeSpheresToVBONonIndexed() org_colorValsUB could not be allocated\n" ENDFB(I->G);	
+      FreeP(org_vertVals);
+      CGOFree(cgo);
+      return (NULL);
+    }
+
+    if (cgo_shader_ub_flags){
+      org_rightUpFlagValsUB = rightUpFlagValsUB = Alloc(GLubyte, VALUES_PER_IMPOSTER_SPACE_COORD * VERTICES_PER_SPHERE * num_total_spheres);
+      if (!org_rightUpFlagValsUB){
+	PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeSpheresToVBONonIndexed() org_rightUpFlagValsUB could not be allocated\n" ENDFB(I->G);	
+	FreeP(org_colorValsUB);	FreeP(org_vertVals);
+	CGOFree(cgo);
+	return (NULL);
+      }
+    } else {
+      org_rightUpFlagVals = rightUpFlagVals = Alloc(float, VALUES_PER_IMPOSTER_SPACE_COORD * VERTICES_PER_SPHERE * num_total_spheres);
+      if (!org_rightUpFlagVals){
+	PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeSpheresToVBONonIndexed() org_rightUpFlagVals could not be allocated\n" ENDFB(I->G);	
+	FreeP(org_colorValsUB);	FreeP(org_vertVals);
+	CGOFree(cgo);
+	return (NULL);
+      }
+    }
+    if (has_picking){
+      // atom/bond info for picking, 2 ints for each sphere
+      org_pickcolorVals = pickcolorVals = Alloc(int, num_total_spheres * 2 * 4);
+    }
+
+    pc = I->op;
+    cgo->alpha = 1.f;
+    min_alpha = 1.f;
+    copyToLeftOver = copyNormalToLeftOver = copyColorToLeftOver = copyPickColorToLeftOver = copyAlphaToLeftOver = 0;
+    while(ok && (op = (CGO_MASK & CGO_read_int(pc)))) {
+      copyToLeftOver = false;
+      save_pc = pc;
+      sz = -1;
+      switch (op) {
+      case CGO_NORMAL:
+        cgo->normal[0] = *pc; cgo->normal[1] = *(pc + 1); cgo->normal[2] = *(pc + 2);
+	copyNormalToLeftOver = true;
+      break;
+      case CGO_COLOR:
+        cgo->color[0] = *pc; cgo->color[1] = *(pc + 1); cgo->color[2] = *(pc + 2);
+	copyColorToLeftOver = true;
+      break;
+      case CGO_ALPHA:
+        cgo->alpha = *pc;
+        if (cgo->alpha < min_alpha) min_alpha = cgo->alpha;
+	copyAlphaToLeftOver = true;
+	break;
+      case CGO_PICK_COLOR:
+	cgo->current_pick_color_index = CGO_get_uint(pc);
+	cgo->current_pick_color_bond = CGO_get_int(pc + 1);
+	copyPickColorToLeftOver = true;
+	break;
+      case CGO_SPHERE:
+	for (vv=0; vv<VERTICES_PER_SPHERE; vv++) { // generate eight vertices of a bounding box for each cylinder
+	  vertVals[0] = *(pc);
+	  vertVals[1] = *(pc+1);
+	  vertVals[2] = *(pc+2);
+	  vertVals[3] = *(pc+3);
+	  set_min_max(min, max, vertVals);
+	  if (cgo_shader_ub_flags){
+	    rightUpFlagValsUB[0] = rightup_flags[vv];
+	    rightUpFlagValsUB++;
+	  } else {
+	    rightUpFlagVals[0] = rightup_flags[vv];
+	    rightUpFlagVals++;
+	  }
+          colorValsUB[0] = CLIP_COLOR_VALUE(cgo->color[0]);
+          colorValsUB[1] = CLIP_COLOR_VALUE(cgo->color[1]);
+          colorValsUB[2] = CLIP_COLOR_VALUE(cgo->color[2]);
+          colorValsUB[3] = CLIP_COLOR_VALUE(cgo->alpha);
+          colorValsUB += 4;
+	  vertVals += 4;
+	  total_vert++;
+	}
+        if (has_picking){
+          *(pickcolorVals++) = cgo->current_pick_color_index;
+          *(pickcolorVals++) = cgo->current_pick_color_bond;
+        }
+	total_spheres++;
+	break;
+      case CGO_DRAW_BUFFERS_INDEXED:
+      case CGO_DRAW_BUFFERS_NOT_INDEXED:
+	PRINTFB(I->G, FB_CGO, FB_Warnings) "WARNING: CGOOptimizeSpheresToVBONonIndexed() CGO_DRAW_BUFFERS_INDEXED or CGO_DRAW_BUFFERS_INDEXED encountered op=%d\n", op ENDFB(I->G);	
+	break;
+      case CGO_DRAW_SCREEN_TEXTURES_AND_POLYGONS:
+	PRINTFB(I->G, FB_CGO, FB_Warnings) "WARNING: CGOOptimizeCylindersToVBO() CGO_DRAW_SCREEN_TEXTURES_AND_POLYGONS encountered op=0x%X\n", op ENDFB(I->G);	
+	break;
+      case CGO_DRAW_LABELS:
+	PRINTFB(I->G, FB_CGO, FB_Warnings) "WARNING: CGOOptimizeCylindersToVBO() CGO_DRAW_LABELS encountered op=0x%X\n", op ENDFB(I->G);	
+	break;
+      case CGO_DRAW_TEXTURES:
+	PRINTFB(I->G, FB_CGO, FB_Warnings) "WARNING: CGOOptimizeCylindersToVBO() CGO_DRAW_TEXTURES encountered op=0x%X\n", op ENDFB(I->G);	
+	break;
+      case CGO_DRAW_ARRAYS:
+      default:
+	copyToLeftOver = true;
+	sz = CGO_sz[op];
+	pc += sz;
+      }
+      if (leftOverCGO && copyToLeftOver){
+	float *npc = pc;
+	if (copyAlphaToLeftOver){
+	  CGOAlpha(leftOverCGO, cgo->alpha);
+	}
+	if (copyColorToLeftOver){
+	  CGOColor(leftOverCGO, cgo->color[0],  cgo->color[1],  cgo->color[2] );
+	}
+	if (copyNormalToLeftOver){
+	  CGONormalv(leftOverCGO, cgo->normal );
+	}
+	if (copyPickColorToLeftOver){
+	  CGOPickColor(leftOverCGO, cgo->current_pick_color_index, cgo->current_pick_color_bond);
+	}
+	if (sz < 0){
+	  sz = CGO_sz[op];
+	} else {
+	  npc -= sz;
+	}
+        leftOverCGO->add_to_cgo(op, npc);
+	copyToLeftOver = copyColorToLeftOver = copyPickColorToLeftOver = copyAlphaToLeftOver = 0;
+      }
+      pc = save_pc;
+      pc += CGO_sz[op];
+#ifndef _WEBGL
+      ok &= !I->G->Interrupt;
+#endif
+    }
+    if (ok && total_spheres > 0) {
+      GLenum rtp = GL_FLOAT;
+      short rsz  = sizeof(float);
+      void * radiusptr = (void *)org_rightUpFlagVals;
+      if (cgo_shader_ub_flags) {
+        rtp = GL_UNSIGNED_BYTE;
+        rsz = sizeof(GLubyte);
+        radiusptr = (void *)org_rightUpFlagValsUB;
+      }
+
+      VertexBuffer * vbo = I->G->ShaderMgr->newGPUBuffer<VertexBuffer>();
+      ok &= vbo->bufferData({
+          BufferDesc( "a_vertex_radius", GL_FLOAT, 4, sizeof(float) * total_vert * 4, org_vertVals, GL_FALSE ),
+          BufferDesc( "a_Color", GL_UNSIGNED_BYTE, 4, sizeof(float) * total_vert, org_colorValsUB, GL_TRUE ),
+          BufferDesc( "a_rightUpFlags", rtp, VALUES_PER_IMPOSTER_SPACE_COORD, rsz * total_vert * VALUES_PER_IMPOSTER_SPACE_COORD, radiusptr, GL_FALSE )
+        });
+      size_t vboid = vbo->get_hash_id();
+
+      VertexBuffer * pickvbo = I->G->ShaderMgr->newGPUBuffer<VertexBuffer>(VertexBuffer::SEQUENTIAL, GL_DYNAMIC_DRAW);
+      ok &= pickvbo->bufferData({
+          BufferDesc( "a_Color", GL_UNSIGNED_BYTE, 4, 0, GL_TRUE ),
+          BufferDesc( "a_Color", GL_UNSIGNED_BYTE, 4, sizeof(float) * total_vert, GL_TRUE )
+        }, 0, sizeof(float) * total_vert * 2, 0);
+      size_t pickvboid = pickvbo->get_hash_id();
+
+      has_draw_buffer = true;
+
+      auto freebuffers = [vboid, pickvboid, I]() {
+        I->G->ShaderMgr->freeGPUBuffer(vboid);
+        I->G->ShaderMgr->freeGPUBuffer(pickvboid);
+      };
+      if (ok){
+        int *pickcolor_data;
+	if (addshaders)
+	  CGOEnable(cgo, GL_SPHERE_SHADER);
+	pickcolor_data = (int*)cgo->add<cgo::draw::sphere_buffers>(total_spheres, (cgo_shader_ub_flags ? 3 : 1), vboid, pickvboid); // always cgo_shader_ub_color
+        CHECKOK(ok, pickcolor_data);
+        if (ok && has_picking){
+          memcpy(pickcolor_data, org_pickcolorVals, num_total_spheres * 2 * 4);
+        }
+	if (ok && addshaders)
+	  ok &= CGODisable(cgo, GL_SPHERE_SHADER);
+	if (!ok){
+	  freebuffers();
+	}
+      } else {
+        freebuffers();
+      }
+    }
+
+    FreeP(org_pickcolorVals);
+    FreeP(org_vertVals);
+    FreeP(org_colorValsUB);
+    if (cgo_shader_ub_flags){
+      FreeP(org_rightUpFlagValsUB);
+    } else {
+      FreeP(org_rightUpFlagVals);
+    }
+
+    if (ok && num_total_spheres>0){
+      ok &= CGOBoundingBox(cgo, min, max);
+    }
+    
+    if (ok)
+      ok &= CGOStop(cgo);
+
+    if (ok){
+      if (has_draw_buffer){
+	cgo->has_draw_buffers = true;
+	cgo->has_draw_sphere_buffers = true;
+      }
+      cgo->use_shader = I->use_shader;
+      if (cgo->use_shader){
+	cgo->cgo_shader_ub_color = true;
+	cgo->cgo_shader_ub_normal = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_normal);
+      }
+    }
+  }
+  if (!ok){
+    CGOFree(cgo);
+  }
+  return (cgo);
+}
+
+/*
+ * converts a CGO that has primitives into pure geometry,
+ *    and converts CGO_BEGIN/CGO_END blocks into CGO_DRAW_ARRAYS
+ *    operations, similar to what CGOCombineBeginEnd() does.
+ *
+ * I:               input CGO
+ * est:             initial size of the newly allocated CGO array
+ *                     that is returned by this function
+ * sphere_quality:  the quality of the spheres generated by this function
+ *                     (if -1, defaults to cgo_sphere_quality)
+ * stick_round_nub: if true, a round cap is generated, otherwise, it generates
+ *                  the old "pointed" caps
+ */
+CGO *CGOSimplify(const CGO * I, int est, short sphere_quality, bool stick_round_nub)
+{
+  CGO *cgo;
+  float *pc = I->op;
+  int op = 0;
+  float *save_pc = NULL;
+  int sz = 0;
+  int ok = true;
+  if (sphere_quality < 0){
+    sphere_quality = SettingGet_i(I->G, NULL, NULL, cSetting_cgo_sphere_quality);
+  }
+  cgo = CGONewSized(I->G, I->c + est);
+  CHECKOK(ok, cgo);
+
+  while(ok && (op = (CGO_MASK & CGO_read_int(pc)))) {
+    save_pc = pc;
+    switch (op) {
+    case CGO_COLOR:
+      copy3f(pc, cgo->color);
+      CGOColorv(cgo, pc);
+      break;
+    case CGO_PICK_COLOR:
+      CGOPickColor(cgo, CGO_get_uint(pc), CGO_get_int(pc + 1));
+      break;
+    case CGO_SHADER_CYLINDER:
+      {
+	float v2[3];
+        int cap = CGO_get_int(pc + 7);
+        int fcap = (cap & 1) ? ((cap & cCylShaderCap1RoundBit) ? 2 : 1) : 0;
+        int bcap = (cap & 2) ? ((cap & cCylShaderCap2RoundBit) ? 2 : 1) : 0;
+	add3f(pc, pc + 3, v2);
+        ok &= CGOSimpleCylinder(cgo, pc, v2, *(pc + 6), 0, 0, cgo->alpha, cgo->alpha, (cap & cCylShaderInterpColor),
+                                fcap, bcap, nullptr, stick_round_nub);
+      }
+      break;
+    case CGO_SHADER_CYLINDER_WITH_2ND_COLOR:
+      {
+        auto cyl = reinterpret_cast<cgo::draw::shadercylinder2ndcolor*>(pc);
+	float v1[3];
+        int cap = cyl->cap;
+        int fcap = (cap & 1) ? ((cap & cCylShaderCap1RoundBit) ? 2 : 1) : 0;
+        int bcap = (cap & 2) ? ((cap & cCylShaderCap2RoundBit) ? 2 : 1) : 0;
+        Pickable pickcolor2 = { cyl->pick_color_index, cyl->pick_color_bond };
+        float color1[3] = { cgo->color[0], cgo->color[1], cgo->color[2] };
+	add3f(pc, pc + 3, v1);
+        float mid[3];
+        mult3f(cyl->axis, .5f, mid);
+        add3f(cyl->origin, mid, mid);
+        float alpha2 = cyl->alpha >= 0.f ? cyl->alpha : cgo->alpha;
+        if (cap & cCylShaderInterpColor){
+          ok &= CGOSimpleCylinder(cgo, cyl->origin, v1, cyl->tube_size, color1, cyl->color2, cgo->alpha, alpha2, true, bcap, fcap, &pickcolor2, stick_round_nub);
+        } else {
+          ok &= CGOColorv(cgo, color1);
+          ok &= CGOSimpleCylinder(cgo, cyl->origin, mid, cyl->tube_size, color1, NULL, cgo->alpha, alpha2, false, fcap, 0, nullptr, stick_round_nub);
+          ok &= CGOColorv(cgo, cyl->color2);
+          ok &= CGOPickColor(cgo, pickcolor2.index, pickcolor2.bond);
+          ok &= CGOSimpleCylinder(cgo, mid, v1, cyl->tube_size, cyl->color2, NULL, cgo->alpha, alpha2, false, 0, bcap, nullptr, stick_round_nub);
+        }
+      }
+      break;
+    case CGO_CYLINDER:
+      {
+        auto cyl = reinterpret_cast<cgo::draw::cylinder*>(pc);
+        ok &= CGOSimpleCylinder(cgo, *cyl, cgo->alpha, cgo->alpha, true, 1, 1, nullptr, stick_round_nub);
+      }
+      break;
+    case CGO_CONE:
+      ok &= CGOSimpleCone(cgo, pc, pc + 3, *(pc + 6), *(pc + 7), pc + 8, pc + 11,
+                    (int) *(pc + 14), (int) *(pc + 15));
+      break;
+    case CGO_SAUSAGE:
+      ok &= CGOSimpleCylinder(cgo, pc, pc + 3, *(pc + 6), pc + 7, pc + 10, cgo->alpha, cgo->alpha, true, 2, 2, nullptr, stick_round_nub);
+      break;
+    case CGO_CUSTOM_CYLINDER:
+      {
+        auto cyl = reinterpret_cast<cgo::draw::custom_cylinder*>(pc);
+        ok &= CGOSimpleCylinder(cgo, *cyl, cgo->alpha, cgo->alpha, true, cyl->cap1, cyl->cap2, nullptr, stick_round_nub);
+      }
+      break;
+    case CGO_CUSTOM_CYLINDER_ALPHA:
+      {
+        auto cyl = reinterpret_cast<cgo::draw::custom_cylinder_alpha*>(pc);
+        ok &= CGOSimpleCylinder(cgo, *cyl, cyl->color1[3], cyl->color2[3], true, cyl->cap1, cyl->cap2, nullptr, stick_round_nub);
+      }
+      break;
+    case CGO_SPHERE:
+      ok &= CGOSimpleSphere(cgo, pc, *(pc + 3), sphere_quality);
+      break;
+    case CGO_ELLIPSOID:
+      ok &= CGOSimpleEllipsoid(cgo, pc, *(pc + 3), pc + 4, pc + 7, pc + 10);
+      break;
+    case CGO_QUADRIC:
+      ok &= CGOSimpleQuadric(cgo, pc, *(pc + 3), pc + 4);
+      break;
+    case CGO_DRAW_BUFFERS_INDEXED:
+	PRINTFB(I->G, FB_CGO, FB_Errors) "CGOSimplify-Error: CGO_DRAW_BUFFERS_INDEXED encountered\n" ENDFB(I->G);
+      break;
+    case CGO_DRAW_BUFFERS_NOT_INDEXED:
+	PRINTFB(I->G, FB_CGO, FB_Errors) "CGOSimplify-Error: CGO_DRAW_BUFFERS_NOT_INDEXED encountered\n" ENDFB(I->G);
+      break;
+    case CGO_DRAW_SPHERE_BUFFERS:
+        PRINTFB(I->G, FB_CGO, FB_Errors) "CGOSimplify-Error: CGO_DRAW_SPHERE_BUFFERS encountered\n" ENDFB(I->G);
+      break;
+    case CGO_DRAW_CYLINDER_BUFFERS:
+        PRINTFB(I->G, FB_CGO, FB_Errors) "CGOSimplify-Error: CGO_DRAW_CYLINDER_BUFFERS encountered\n" ENDFB(I->G);
+      break;
+    case CGO_DRAW_LABELS:
+	PRINTFB(I->G, FB_CGO, FB_Errors) "CGOSimplify-Error: CGO_DRAW_LABELS encountered\n" ENDFB(I->G);
+      break;
+    case CGO_DRAW_TEXTURES:
+	PRINTFB(I->G, FB_CGO, FB_Errors) "CGOSimplify-Error: CGO_DRAW_TEXTURES encountered \n" ENDFB(I->G);
+      break;
+    case CGO_END:
+      PRINTFB(I->G, FB_CGO, FB_Warnings) "CGOSimplify-Warning: CGO_END encountered without CGO_BEGIN but skipped for OpenGLES\n" ENDFB(I->G);      
+      break;
+    case CGO_VERTEX:
+      PRINTFB(I->G, FB_CGO, FB_Warnings) "CGOSimplify-Warning: CGO_VERTEX encountered without CGO_BEGIN but skipped for OpenGLES\n" ENDFB(I->G);      
+      break;
+    case CGO_BEGIN:
+      {
+	float *origpc = pc, firstColor[3], firstAlpha;
+	char hasFirstColor = 0, hasFirstAlpha = 0;
+	int nverts = 0, damode = CGO_VERTEX_ARRAY, err = 0, end = 0;
+	int mode = CGO_read_int(pc);
+
+	while(ok && !err && !end && (op = (CGO_MASK & CGO_read_int(pc)))) {
+	  switch (op) {
+	  case CGO_DRAW_ARRAYS:
+	    PRINTFB(I->G, FB_CGO, FB_Warnings) " CGOSimplify-Warning: CGO_DRAW_ARRAYS encountered inside CGO_BEGIN/CGO_END\n" ENDFB(I->G);
+	    err = true;
+	    continue;
+	  case CGO_NORMAL:
+	    damode |= CGO_NORMAL_ARRAY;
+	    break;
+	  case CGO_COLOR:
+	    if (!nverts){
+	      hasFirstColor = 1;
+	      firstColor[0] = pc[0]; firstColor[1] = pc[1]; firstColor[2] = pc[2];
+	    } else {
+	      hasFirstColor = 0;
+	      damode |= CGO_COLOR_ARRAY;
+	    } 
+	    break;
+	  case CGO_PICK_COLOR:
+	    damode |= CGO_PICK_COLOR_ARRAY;
+	    break;
+	  case CGO_ACCESSIBILITY:
+	    damode |= CGO_ACCESSIBILITY_ARRAY;
+	    break;
+	  case CGO_VERTEX:
+	    nverts++;
+	    break;
+	  case CGO_END:
+	    end = 1;
+	    break;
+	  case CGO_ALPHA:
+	    cgo->alpha = *pc;
+	    if (!nverts){
+	      hasFirstAlpha = 1;
+	      firstAlpha = cgo->alpha;
+	    } else {
+	      hasFirstAlpha = 0;
+	      damode |= CGO_COLOR_ARRAY;
+	    }
+	  default:
+	    break;
+	  }
+	  sz = CGO_sz[op];
+	  pc += sz;
+	}
+	if (nverts>0 && !err){
+	  int pl = 0, plc = 0, pla = 0;
+	  float *vertexVals, *tmp_ptr;
+	  float *normalVals = 0, *colorVals = 0, *nxtVals = 0, *pickColorVals = 0, *accessibilityVals = 0;
+	  short notHaveValue = 0, nxtn = 3;
+	  if (hasFirstAlpha || hasFirstColor){
+	    if (hasFirstAlpha){
+	      CGOAlpha(cgo, firstAlpha);
+	    }
+	    if (hasFirstColor){
+	      CGOColorv(cgo, firstColor);
+	    }
+	  }
+	  nxtVals = vertexVals = cgo->add<cgo::draw::arrays>(mode, damode, nverts);
+      CHECKOK(ok, vertexVals);
+	  if (!ok){
+	    break;
+	  }
+	  if (damode & CGO_NORMAL_ARRAY){
+	    nxtVals = normalVals = vertexVals + (nxtn*nverts);
+	  }
+	  if (damode & CGO_COLOR_ARRAY){
+	    nxtVals = colorVals = nxtVals + (nxtn*nverts);
+	    nxtn = 4;
+	  }
+	  if (damode & CGO_PICK_COLOR_ARRAY){
+	    nxtVals = nxtVals + (nxtn*nverts);
+	    pickColorVals = nxtVals + nverts;
+	    nxtn = 3;
+	  }
+	  if (damode & CGO_ACCESSIBILITY_ARRAY){
+	    nxtVals = nxtVals + (nxtn*nverts);
+	    accessibilityVals = nxtVals;
+	    nxtn = 1;
+	  }
+	  pc = origpc + 1;
+	  notHaveValue = damode;
+	  end = 0;
+	  bool skiptoend = false;
+	  while(!err && !end && (op = (CGO_MASK & CGO_read_int(pc)))) {
+	    if (skiptoend && op!=CGO_END){
+	      sz = CGO_sz[op];
+	      pc += sz;
+	      continue;
+	    }
+	    switch (op) {
+	    case CGO_NORMAL:
+	      normalVals[pl] = pc[0]; normalVals[pl+1] = pc[1]; normalVals[pl+2] = pc[2];
+	      notHaveValue &= ~CGO_NORMAL_ARRAY;
+	      break;
+	    case CGO_COLOR:
+	      if (colorVals){
+		colorVals[plc] = pc[0]; colorVals[plc+1] = pc[1]; 
+		colorVals[plc+2] = pc[2]; colorVals[plc+3] = cgo->alpha;
+		notHaveValue &= ~CGO_COLOR_ARRAY;
+	      }
+	      break;
+	    case CGO_PICK_COLOR:
+              CGOPickColor(cgo, CGO_get_uint(pc), CGO_get_int(pc + 1));
+	      notHaveValue &= ~CGO_PICK_COLOR_ARRAY;
+	      break;
+	    case CGO_ACCESSIBILITY:
+	      cgo->current_accessibility = pc[0];
+	      break;
+	    case CGO_VERTEX:
+	      if (notHaveValue & CGO_NORMAL_ARRAY){
+		if (pl){
+		  tmp_ptr = &normalVals[pl-3];
+		  normalVals[pl] = tmp_ptr[0]; normalVals[pl+1] = tmp_ptr[1]; normalVals[pl+2] = tmp_ptr[2];		
+		} else {
+		  copy3f(cgo->normal, &normalVals[pl]);
+		}
+	      }
+	      if (notHaveValue & CGO_COLOR_ARRAY){
+		if (plc){
+		  tmp_ptr = &colorVals[plc-4];
+		  colorVals[plc] = tmp_ptr[0]; colorVals[plc+1] = tmp_ptr[1]; 
+		  colorVals[plc+2] = tmp_ptr[2];	colorVals[plc+3] = tmp_ptr[3];
+		} else {
+		  copy3f(cgo->color, &colorVals[plc]);
+		  colorVals[plc+3] = cgo->alpha;
+		}
+	      }
+	      if (pickColorVals){
+		CGO_put_uint(pickColorVals + pla * 2, cgo->current_pick_color_index);
+		CGO_put_int(pickColorVals + pla * 2 + 1, cgo->current_pick_color_bond);
+	      }
+	      if (accessibilityVals){
+		accessibilityVals[pla] = cgo->current_accessibility;
+	      }
+	      vertexVals[pl++] = pc[0]; vertexVals[pl++] = pc[1]; vertexVals[pl++] = pc[2];
+	      plc += 4;
+	      pla++;
+	      if (pla >= nverts) // anything past the last vertex is ignored
+		skiptoend = true;
+	      notHaveValue = damode;
+	      break;
+	    case CGO_END:
+	      end = 1;
+	      break;
+	    case CGO_ALPHA:
+	      // in case we're before CGO_COLOR
+	      cgo->alpha = *pc;
+	      if (colorVals) {
+		// in case we're after CGO_COLOR
+		colorVals[plc + 3] = *pc;
+	      }
+	      break;
+	    default:
+	      break;
+	    }
+	    sz = CGO_sz[op];
+	    pc += sz;
+	  }
+	  save_pc = pc;
+	} else {
+	  save_pc = origpc;
+	}
+	op = CGO_NULL;
+      }
+      break;
+    case CGO_ALPHA:
+      cgo->alpha = *pc;
+    default:
+      cgo->add_to_cgo(op, pc);
+    }
+    pc = save_pc;
+    pc += CGO_sz[op];
+    ok &= !I->G->Interrupt;
+  }
+  if (ok){
+    ok &= CGOStop(cgo);
+  } 
+  if (!ok){
+    CGOFree(cgo);
+  }
+  return (cgo);
+}
+
+/*
+ * converts a CGO that has primitives into pure geomtry, just like CGOSimplify
+ *    but without converting the CGO_BEGIN/CGO_END blocks.
+ *
+ */
+CGO *CGOSimplifyNoCompress(const CGO * I, int est, short sphere_quality, bool stick_round_nub)
+{
+  CGO *cgo;
+
+  float *pc = I->op;
+  int op = 0;
+  float *save_pc = NULL;
+  int ok = true;
+  if (sphere_quality < 0){
+    sphere_quality = SettingGet_i(I->G, NULL, NULL, cSetting_cgo_sphere_quality);
+  }
+
+  cgo = CGONewSized(I->G, I->c + est);
+  CHECKOK(ok, cgo);
+  while(ok && (op = (CGO_MASK & CGO_read_int(pc)))) {
+    save_pc = pc;
+    switch (op) {
+    case CGO_PICK_COLOR:
+      CGOPickColor(cgo, CGO_get_uint(pc), CGO_get_int(pc + 1));
+      break;
+    case CGO_SHADER_CYLINDER:
+      {
+	float v2[3];
+        int cap = CGO_get_int(pc + 7);
+        int fcap = (cap & 1) ? ((cap & cCylShaderCap1RoundBit) ? 2 : 1) : 0;
+        int bcap = (cap & 2) ? ((cap & cCylShaderCap2RoundBit) ? 2 : 1) : 0;
+	add3f(pc, pc + 3, v2);
+        ok &= CGOSimpleCylinder(cgo, pc, v2, *(pc + 6), 0, 0, cgo->alpha, cgo->alpha, (cap & cCylShaderInterpColor),
+                                fcap, bcap, nullptr, stick_round_nub);
+      }
+      break;
+    case CGO_SHADER_CYLINDER_WITH_2ND_COLOR:
+      {
+        auto cyl = reinterpret_cast<cgo::draw::shadercylinder2ndcolor*>(pc);
+	float v1[3];
+        int cap = cyl->cap;
+        int fcap = (cap & 1) ? ((cap & cCylShaderCap1RoundBit) ? 2 : 1) : 0;
+        int bcap = (cap & 2) ? ((cap & cCylShaderCap2RoundBit) ? 2 : 1) : 0;
+        Pickable pickcolor2 = { cyl->pick_color_index, cyl->pick_color_bond };
+        float color1[3] = { cgo->color[0], cgo->color[1], cgo->color[2] };
+	add3f(cyl->origin, cyl->axis, v1);
+        float mid[3];
+        mult3f(cyl->axis, .5f, mid);
+        add3f(cyl->origin, mid, mid);
+        float alpha2 = cyl->alpha >= 0.f ? cyl->alpha : cgo->alpha;
+        if (cap & cCylShaderInterpColor){
+          ok &= CGOSimpleCylinder(cgo, cyl->origin, v1, cyl->tube_size, color1, cyl->color2, cgo->alpha, alpha2, true, bcap, fcap, &pickcolor2, stick_round_nub);
+        } else {
+          ok &= CGOColorv(cgo, color1);
+          ok &= CGOSimpleCylinder(cgo, cyl->origin, mid, cyl->tube_size, color1, NULL, cgo->alpha, alpha2, false, fcap, 0, NULL, stick_round_nub);
+          ok &= CGOColorv(cgo, cyl->color2);
+          ok &= CGOPickColor(cgo, pickcolor2.index, pickcolor2.bond);
+          ok &= CGOSimpleCylinder(cgo, mid, v1, cyl->tube_size, cyl->color2, NULL, cgo->alpha, alpha2, false, 0, bcap, NULL, stick_round_nub);
+        }
+      }
+      break;
+    case CGO_CYLINDER:
+      {
+        auto cyl = reinterpret_cast<cgo::draw::cylinder*>(pc);
+        ok &= CGOSimpleCylinder(cgo, *cyl, cgo->alpha, cgo->alpha, true, 1, 1, nullptr, stick_round_nub);
+      }
+      break;
+    case CGO_CONE:
+      ok &= CGOSimpleCone(cgo, pc, pc + 3, *(pc + 6), *(pc + 7), pc + 8, pc + 11,
+                    (int) *(pc + 14), (int) *(pc + 15));
+      break;
+    case CGO_SAUSAGE:
+      ok &= CGOSimpleCylinder(cgo, pc, pc + 3, *(pc + 6), pc + 7, pc + 10, cgo->alpha, cgo->alpha, true, 2, 2, nullptr, stick_round_nub);
+      break;
+    case CGO_CUSTOM_CYLINDER:
+      {
+        auto cyl = reinterpret_cast<cgo::draw::custom_cylinder*>(pc);
+        ok &= CGOSimpleCylinder(cgo, *cyl, cgo->alpha, cgo->alpha, true, cyl->cap1, cyl->cap2, nullptr, stick_round_nub);
+      }
+      break;
+    case CGO_CUSTOM_CYLINDER_ALPHA:
+      {
+        auto cyl = reinterpret_cast<cgo::draw::custom_cylinder_alpha*>(pc);
+        ok &= CGOSimpleCylinder(cgo, *cyl, cyl->color1[3], cyl->color2[3], true, cyl->cap1, cyl->cap2, nullptr, stick_round_nub);
+      }
+      break;
+    case CGO_SPHERE:
+      ok &= CGOSimpleSphere(cgo, pc, *(pc + 3), sphere_quality);
+      break;
+    case CGO_ELLIPSOID:
+      ok &= CGOSimpleEllipsoid(cgo, pc, *(pc + 3), pc + 4, pc + 7, pc + 10);
+      break;
+    case CGO_QUADRIC:
+      ok &= CGOSimpleQuadric(cgo, pc, *(pc + 3), pc + 4);
+      break;
+    case CGO_DRAW_BUFFERS_INDEXED:
+	PRINTFB(I->G, FB_CGO, FB_Errors) "CGOSimplifyNoCompress-Error: CGO_DRAW_BUFFERS_INDEXED encountered\n" ENDFB(I->G);
+      break;
+    case CGO_DRAW_BUFFERS_NOT_INDEXED:
+	PRINTFB(I->G, FB_CGO, FB_Errors) "CGOSimplifyNoCompress-Error: CGO_DRAW_BUFFERS_NOT_INDEXED encountered\n" ENDFB(I->G);
+      break;
+    case CGO_DRAW_SPHERE_BUFFERS:
+        PRINTFB(I->G, FB_CGO, FB_Errors) "CGOSimplifyNoCompress-Error: CGO_DRAW_SPHERE_BUFFERS encountered\n" ENDFB(I->G);
+      break;
+    case CGO_DRAW_CYLINDER_BUFFERS:
+        PRINTFB(I->G, FB_CGO, FB_Errors) "CGOSimplifyNoCompress-Error: CGO_DRAW_CYLINDER_BUFFERS encountered\n" ENDFB(I->G);
+      break;
+    case CGO_DRAW_LABELS:
+	PRINTFB(I->G, FB_CGO, FB_Errors) "CGOSimplifyNoCompress-Error: CGO_DRAW_LABELS encountered\n" ENDFB(I->G);
+      break;
+    case CGO_DRAW_TEXTURES:
+	PRINTFB(I->G, FB_CGO, FB_Errors) "CGOSimplifyNoCompress-Error: CGO_DRAW_TEXTURES encountered\n" ENDFB(I->G);
+      break;
+    case CGO_BEGIN:
+      cgo->has_begin_end = true;
+    default:
+      cgo->add_to_cgo(op, pc);
+    }
+    pc = save_pc;
+    pc += CGO_sz[op];
+    ok &= !I->G->Interrupt;
+  }
+  if (ok){
+    ok &= CGOStop(cgo);
+  } 
+  if (!ok){
+    CGOFree(cgo);
+  }
+  return (cgo);
+}
+
+
+CGO *CGOOptimizeTextures(CGO * I, int est)
+{
+  CGO *cgo = NULL;
+  float *pc = I->op;
+  int op;
+  int num_total_textures;
+  int ok = true;
+  num_total_textures = CGOCountNumberOfOperationsOfType(I, CGO_DRAW_TEXTURE);
+  //  printf("CGOOptimizeTextures: num_total_textures=%d\n", num_total_textures);
+  if (num_total_textures){
+    float *worldPos, *screenValues, *textExtents, *pickColorVals;
+    int place3 = 0, place2 = 0;
+    worldPos = Alloc(float, num_total_textures * 18);
+    if (!worldPos){
+      PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeTextures() worldPos could not be allocated\n" ENDFB(I->G);
+      return NULL;
+    }
+    screenValues = Alloc(float, num_total_textures * 18);
+    if (!screenValues){
+      PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeTextures() screenValues could not be allocated\n" ENDFB(I->G);
+      FreeP(worldPos);
+      return NULL;
+    }
+    textExtents = Alloc(float, num_total_textures * 12);
+    if (!textExtents){
+      PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeTextures() textExtents could not be allocated\n" ENDFB(I->G);
+      FreeP(screenValues);
+      FreeP(worldPos);
+      return NULL;
+    }
+    pickColorVals = Alloc(float, num_total_textures * 12); /* pick index and bond */
+    if (!pickColorVals){
+      PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeTextures() pickColorVals could not be allocated\n" ENDFB(I->G);
+      FreeP(textExtents);
+      FreeP(screenValues);
+      FreeP(worldPos);
+      return NULL;
+    }
+
+    cgo = CGONewSized(I->G, 0);
+    while(ok && (op = (CGO_MASK & CGO_read_int(pc)))) {
+      switch (op) {
+      case CGO_PICK_COLOR:
+	cgo->current_pick_color_index = CGO_get_uint(pc);
+	cgo->current_pick_color_bond = CGO_get_int(pc + 1);
+	break;
+      case CGO_DRAW_BUFFERS_INDEXED:
+      case CGO_DRAW_BUFFERS_NOT_INDEXED:
+	PRINTFB(I->G, FB_CGO, FB_Warnings) "WARNING: CGOOptimizeTextures() CGO_DRAW_BUFFERS_INDEXED or CGO_DRAW_BUFFERS_INDEXED encountered op=%d\n", op ENDFB(I->G);	
+	break;
+      case CGO_DRAW_TEXTURE:
+	{
+	  float screenMin[3], screenMax[3], textExtent[4];
+	  copy3f(pc, &worldPos[place3]);
+	  copy3f(pc, &worldPos[place3+3]);
+	  copy3f(pc, &worldPos[place3+6]);
+	  copy3f(pc, &worldPos[place3+9]);
+	  copy3f(pc, &worldPos[place3+12]);
+	  copy3f(pc, &worldPos[place3+15]);
+	  copy3f(pc + 3, screenMin);
+	  copy3f(pc + 6, screenMax);
+	  copy4f(pc + 9, textExtent);
+	  copy3f(screenMin, &screenValues[place3]);
+	  copy3f(screenMin, &screenValues[place3+3]);
+	  copy3f(screenMin, &screenValues[place3+6]);
+	  copy3f(screenMin, &screenValues[place3+9]);
+	  copy3f(screenMin, &screenValues[place3+12]);
+	  copy3f(screenMax, &screenValues[place3+15]);
+	  screenValues[place3+4] = screenMax[1];
+	  screenValues[place3+6] = screenMax[0];
+	  screenValues[place3+10] = screenMax[1];
+	  screenValues[place3+12] = screenMax[0];
+	  screenValues[place3+17] = screenMin[2];
+	  place3 += 18;
+	  CGO_put_uint(pickColorVals + place2, cgo->current_pick_color_index);
+	  CGO_put_int(pickColorVals + place2 + 1, cgo->current_pick_color_bond);
+	  textExtents[place2++] = textExtent[0]; textExtents[place2++] = textExtent[1];
+	  CGO_put_uint(pickColorVals + place2, cgo->current_pick_color_index);
+	  CGO_put_int(pickColorVals + place2 + 1, cgo->current_pick_color_bond);
+	  textExtents[place2++] = textExtent[0]; textExtents[place2++] = textExtent[3];
+	  CGO_put_uint(pickColorVals + place2, cgo->current_pick_color_index);
+	  CGO_put_int(pickColorVals + place2 + 1, cgo->current_pick_color_bond);
+	  textExtents[place2++] = textExtent[2]; textExtents[place2++] = textExtent[1];
+	  CGO_put_int(pickColorVals + place2, cgo->current_pick_color_index);
+	  CGO_put_uint(pickColorVals + place2 + 1, cgo->current_pick_color_bond);
+	  textExtents[place2++] = textExtent[0]; textExtents[place2++] = textExtent[3];
+	  CGO_put_uint(pickColorVals + place2, cgo->current_pick_color_index);
+	  CGO_put_int(pickColorVals + place2 + 1, cgo->current_pick_color_bond);
+	  textExtents[place2++] = textExtent[2]; textExtents[place2++] = textExtent[1];
+	  CGO_put_uint(pickColorVals + place2, cgo->current_pick_color_index);
+	  CGO_put_int(pickColorVals + place2 + 1, cgo->current_pick_color_bond);
+	  textExtents[place2++] = textExtent[2]; textExtents[place2++] = textExtent[3];
+	}
+	break;
+      }
+      pc += CGO_sz[op];
+      ok &= !I->G->Interrupt;
+    }
+    if (ok) {
+      VertexBuffer * vbo = I->G->ShaderMgr->newGPUBuffer<VertexBuffer>(VertexBuffer::SEQUENTIAL);
+      ok &= vbo->bufferData({
+          BufferDesc( "attr_worldpos", GL_FLOAT, 3, sizeof(float) * num_total_textures * 18, worldPos, GL_FALSE ),
+          BufferDesc( "attr_screenoffset", GL_FLOAT, 3, sizeof(float) * num_total_textures * 18, screenValues, GL_FALSE ),
+          BufferDesc( "attr_texcoords", GL_FLOAT, 3, sizeof(float) * num_total_textures * 18, textExtents, GL_FALSE )
+        });
+      size_t vboid = vbo->get_hash_id();
+
+      if (ok) {
+	float *pickArray = cgo->add<cgo::draw::textures>(num_total_textures, vboid);
+	CHECKOK(ok, pickArray);
+	if (!pickArray)
+	  I->G->ShaderMgr->freeGPUBuffer(vboid);
+	if (ok)
+	  memcpy(pickArray + num_total_textures * 6, pickColorVals, num_total_textures * 12 * sizeof(float));
+	if (ok)
+	  ok &= CGOStop(cgo);
+      } else {
+	I->G->ShaderMgr->freeGPUBuffer(vboid);
+      }
+      if (!ok){
+	CGOFree(cgo);
+      }
+    }
+    FreeP(worldPos);
+    FreeP(screenValues);
+    FreeP(textExtents);
+    FreeP(pickColorVals);
+  }
+  return cgo;
+}
+
+CGO *CGOConvertToLabelShader(const CGO *I, CGO * addTo){
+  /* Lines that pass in two vertices per line */
+  PyMOLGlobals *G = I->G;
+
+  AttribDataOp world_pos_op =
+    { { CGO_DRAW_LABEL,       1, FLOAT3_TO_FLOAT3, offsetof(cgo::draw::label, world_pos),           0 } };
+  AttribDataOp screen_offset_op =
+    { { CGO_DRAW_LABEL,       2, FLOAT3_TO_FLOAT3, offsetof(cgo::draw::label, screen_world_offset), 0 } };
+  AttribDataOp screen_min_op =
+    { { CGO_DRAW_LABEL,       3, FLOAT3_TO_FLOAT3, offsetof(cgo::draw::label, screen_min),          0 } };
+  AttribDataOp screen_max_op =
+    { { CGO_DRAW_LABEL,       4, FLOAT3_TO_FLOAT3, offsetof(cgo::draw::label, screen_max),          0 } };
+  AttribDataOp text_extent_op =
+    { { CGO_DRAW_LABEL,       5, FLOAT2_TO_FLOAT2, offsetof(cgo::draw::label, text_extent),         0 } };
+  AttribDataOp relative_mode_op =
+    { { CGO_DRAW_LABEL,       6, FLOAT_TO_FLOAT,   offsetof(cgo::draw::label, relative_mode),       0 } };
+  AttribDataOp target_pos_op =
+    { { CGO_DRAW_LABEL,       7, FLOAT3_TO_FLOAT3, offsetof(cgo::draw::label, target_pos),          6 } };
+
+  AttribDataDesc attrDesc = { { "attr_worldpos",          GL_FLOAT, 3, GL_FALSE, world_pos_op },
+                              { "attr_targetpos",         GL_FLOAT, 3, GL_FALSE, target_pos_op },
+                              { "attr_screenoffset",      GL_FLOAT, 3, GL_FALSE, screen_min_op },
+                              { "attr_texcoords",         GL_FLOAT, 2, GL_FALSE, text_extent_op },
+                              { "attr_screenworldoffset", GL_FLOAT, 3, GL_FALSE, screen_offset_op },
+                              { "attr_relative_mode",     GL_FLOAT, 1, GL_FALSE, relative_mode_op } };
+
+  auto ComputeScreenValues = [](void * varData, const float * pc, void * screenData, int idx) {
+    auto sp = reinterpret_cast<const cgo::draw::label *>(pc);
+    const vec3 & smin = sp->screen_min;
+    const vec3 & smax = sp->screen_max;
+    float * v = reinterpret_cast<float *>(varData);
+    switch (idx) {
+    case 0:
+    v[0] = smin[0]; v[1] = smin[1]; v[2] = smin[2];
+    break;
+    case 1:
+    v[0] = smin[0]; v[1] = smax[1]; v[2] = smin[2];
+    break;
+    case 2:
+    v[0] = smax[0]; v[1] = smin[1]; v[2] = smin[2];
+    break;
+    case 3:
+    v[0] = smin[0]; v[1] = smax[1]; v[2] = smin[2];
+    break;
+    case 4:
+    v[0] = smax[0]; v[1] = smin[1]; v[2] = smin[2];
+    break;
+    case 5:
+    v[0] = smax[0]; v[1] = smax[1]; v[2] = smin[2];
+    break;
+    };
+  };
+
+  auto ComputeTexCoords = [](void * varData, const float * pc, void * discard, int idx) {
+    auto sp = reinterpret_cast<const cgo::draw::label *>(pc);
+    float * v = reinterpret_cast<float *>(varData);
+    const vec4 & te = sp->text_extent;
+    static ivec2 idxs[6] = {
+      { 0, 1 },
+      { 0, 3 },
+      { 2, 1 },
+      { 0, 3 },
+      { 2, 1 },
+      { 2, 3 }
+    };
+    v[0] = te[idxs[idx].x];
+    v[1] = te[idxs[idx].y];
+  };
+
+  attrDesc[1].attrOps[0].funcDataConversions.push_back({ ComputeScreenValues, nullptr, "attr_screenoffset" });
+  attrDesc[1].attrOps[0].funcDataConversions.push_back({ ComputeTexCoords, nullptr, "attr_texcoords" });
+
+  uchar pickdata[4] = { 0, 0, 0, 0 };
+  addTo->add<cgo::draw::vertex_attribute_4ub>(G->ShaderMgr->GetAttributeUID("attr_pickcolor"), pickdata);
+
+  AttribDataOp pickOp = { { CGO_PICK_COLOR, 1, UINT_INT_TO_PICK_DATA, 0, 0 } };
+  AttribDataDesc pickDesc = { { "attr_pickcolor", GL_UNSIGNED_BYTE, 4, GL_TRUE, pickOp } };
+  return CGOConvertToShader(I, attrDesc, pickDesc, GL_TRIANGLES, VertexBuffer::INTERLEAVED, true);
+}
+
+CGO *CGOOptimizeLabels(CGO * I, int est, bool addshaders)
+{
+  CGO *cgo = NULL;
+  float *pc = I->op;
+  int op;
+  int num_total_labels;
+  int ok = true;
+  num_total_labels = CGOCountNumberOfOperationsOfType(I, CGO_DRAW_LABEL);
+  if (num_total_labels){
+    float *targetPos, *worldPos, *screenValues, *screenWorldValues, *textExtents, *pickColorVals;
+    float *relativeMode;
+    int place3 = 0, place2 = 0, place = 0;
+    worldPos = Alloc(float, num_total_labels * 6 * 17); 
+    if (!worldPos){
+      PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeLabels() worldPos could not be allocated\n" ENDFB(I->G);
+      return NULL;
+    }
+    screenValues = worldPos + (num_total_labels * 18);
+    targetPos = screenValues + (num_total_labels * 18);
+    screenWorldValues = targetPos + (num_total_labels * 18);
+    textExtents = screenWorldValues + (num_total_labels * 18);
+    pickColorVals = textExtents + (num_total_labels * 12); /* pick index and bond */
+    relativeMode = (float *)(pickColorVals + (num_total_labels * 12));
+    cgo = CGONewSized(I->G, 0);
+    while(ok && (op = (CGO_MASK & CGO_read_int(pc)))) {
+      switch (op) {
+      case CGO_PICK_COLOR:
+	cgo->current_pick_color_index = CGO_get_uint(pc);
+	cgo->current_pick_color_bond = CGO_get_int(pc + 1);
+	break;
+      case CGO_DRAW_BUFFERS_INDEXED:
+      case CGO_DRAW_BUFFERS_NOT_INDEXED:
+	PRINTFB(I->G, FB_CGO, FB_Warnings) "WARNING: CGOOptimizeLabels() CGO_DRAW_BUFFERS_INDEXED or CGO_DRAW_BUFFERS_INDEXED encountered op=%d\n", op ENDFB(I->G);	
+	break;
+      case CGO_DRAW_LABEL:
+	{
+	  float screenWorldOffset[3], screenMin[3], screenMax[3], textExtent[4];
+	  copy3f(pc, &worldPos[place3]);
+	  copy3f(pc, &worldPos[place3+3]);
+	  copy3f(pc, &worldPos[place3+6]);
+	  copy3f(pc, &worldPos[place3+9]);
+	  copy3f(pc, &worldPos[place3+12]);
+	  copy3f(pc, &worldPos[place3+15]);
+	  copy3f(pc + 3, screenWorldOffset);
+	  copy3f(pc + 6, screenMin);
+	  copy3f(pc + 9, screenMax);
+	  copy4f(pc + 12, textExtent);
+	  copy3f(screenWorldOffset, &screenWorldValues[place3]);
+	  copy3f(&screenWorldValues[place3], &screenWorldValues[place3+3]);
+	  copy3f(&screenWorldValues[place3], &screenWorldValues[place3+6]);
+	  copy3f(&screenWorldValues[place3], &screenWorldValues[place3+9]);
+	  copy3f(&screenWorldValues[place3], &screenWorldValues[place3+12]);
+	  copy3f(&screenWorldValues[place3], &screenWorldValues[place3+15]);
+	  copy3f(screenMin, &screenValues[place3]);
+	  copy3f(screenMin, &screenValues[place3+3]);
+	  copy3f(screenMin, &screenValues[place3+6]);
+	  copy3f(screenMin, &screenValues[place3+9]);
+	  copy3f(screenMin, &screenValues[place3+12]);
+	  copy3f(screenMax, &screenValues[place3+15]);
+	  screenValues[place3+4] = screenMax[1];
+	  screenValues[place3+6] = screenMax[0];
+	  screenValues[place3+10] = screenMax[1];
+	  screenValues[place3+12] = screenMax[0];
+	  screenValues[place3+17] = screenMin[2];
+	  copy3f(pc + 17, &targetPos[place3]);
+	  copy3f(pc + 17, &targetPos[place3+3]);
+	  copy3f(pc + 17, &targetPos[place3+6]);
+	  copy3f(pc + 17, &targetPos[place3+9]);
+	  copy3f(pc + 17, &targetPos[place3+12]);
+	  copy3f(pc + 17, &targetPos[place3+15]);
+	  place3 += 18;
+	  CGO_put_uint(pickColorVals + place2, cgo->current_pick_color_index);
+	  CGO_put_int(pickColorVals + place2 + 1, cgo->current_pick_color_bond);
+	  textExtents[place2++] = textExtent[0]; textExtents[place2++] = textExtent[1];
+	  CGO_put_uint(pickColorVals + place2, cgo->current_pick_color_index);
+	  CGO_put_int(pickColorVals + place2 + 1, cgo->current_pick_color_bond);
+	  textExtents[place2++] = textExtent[0]; textExtents[place2++] = textExtent[3];
+	  CGO_put_uint(pickColorVals + place2, cgo->current_pick_color_index);
+	  CGO_put_int(pickColorVals + place2 + 1, cgo->current_pick_color_bond);
+	  textExtents[place2++] = textExtent[2]; textExtents[place2++] = textExtent[1];
+	  CGO_put_uint(pickColorVals + place2, cgo->current_pick_color_index);
+	  CGO_put_int(pickColorVals + place2 + 1, cgo->current_pick_color_bond);
+	  textExtents[place2++] = textExtent[0]; textExtents[place2++] = textExtent[3];
+	  CGO_put_uint(pickColorVals + place2, cgo->current_pick_color_index);
+	  CGO_put_int(pickColorVals + place2 + 1, cgo->current_pick_color_bond);
+	  textExtents[place2++] = textExtent[2]; textExtents[place2++] = textExtent[1];
+	  CGO_put_uint(pickColorVals + place2, cgo->current_pick_color_index);
+	  CGO_put_int(pickColorVals + place2 + 1, cgo->current_pick_color_bond);
+	  textExtents[place2++] = textExtent[2]; textExtents[place2++] = textExtent[3];
+	  {
+	    uchar rM = (uchar)*(pc + 16);
+	    relativeMode[place++] = rM;
+	    relativeMode[place++] = rM;
+	    relativeMode[place++] = rM;
+	    relativeMode[place++] = rM;
+	    relativeMode[place++] = rM;
+	    relativeMode[place++] = rM;
+	  }
+	}
+	break;
+      }
+      pc += CGO_sz[op];
+      ok &= !I->G->Interrupt;
+    }
+    if (ok) {
+      // Static Vertex Data
+      VertexBuffer * vbo = I->G->ShaderMgr->newGPUBuffer<VertexBuffer>(VertexBuffer::SEQUENTIAL);
+      ok &= vbo->bufferData({
+          BufferDesc( "attr_worldpos", GL_FLOAT, 3, sizeof(float)*18*num_total_labels, worldPos,          GL_FALSE ),
+          BufferDesc( "attr_targetpos", GL_FLOAT, 3, sizeof(float)*18*num_total_labels, targetPos,         GL_FALSE ),
+          BufferDesc( "attr_screenoffset", GL_FLOAT, 3, sizeof(float)*18*num_total_labels, screenValues,      GL_FALSE ),
+          BufferDesc( "attr_texcoords", GL_FLOAT, 2, sizeof(float)*12*num_total_labels, textExtents,       GL_FALSE ),
+          BufferDesc( "attr_screenworldoffset", GL_FLOAT, 3, sizeof(float)*18*num_total_labels, screenWorldValues, GL_FALSE ),
+          BufferDesc( "attr_relative_mode", GL_FLOAT, 1, sizeof(float)*6*num_total_labels,  relativeMode,      GL_FALSE )
+        });
+      size_t vboid = vbo->get_hash_id();
+
+      VertexBuffer * pickvbo = I->G->ShaderMgr->newGPUBuffer<VertexBuffer>(VertexBuffer::SEQUENTIAL, GL_DYNAMIC_DRAW);
+      ok &= pickvbo->bufferData({
+          BufferDesc( "attr_pickcolor", GL_UNSIGNED_BYTE, VERTEX_COLOR_SIZE, 0, GL_TRUE ),
+          BufferDesc( "attr_pickcolor", GL_UNSIGNED_BYTE, VERTEX_COLOR_SIZE, sizeof(float) * num_total_labels * 6, GL_TRUE )
+        }, 0, sizeof(float) * num_total_labels * 12, 0);
+      size_t pickvboid = pickvbo->get_hash_id();
+
+      auto freebuffers = [vboid, pickvboid, I]() {
+        I->G->ShaderMgr->freeGPUBuffer(vboid);
+        I->G->ShaderMgr->freeGPUBuffer(pickvboid);
+      };
+
+      if (ok) {
+	float *pickArray = NULL;
+	if (addshaders){
+	  CGOEnable(cgo, GL_LABEL_SHADER);
+	}
+	pickArray = cgo->add<cgo::draw::labels>(num_total_labels, vboid, pickvboid);
+	if (addshaders){
+	  CGODisable(cgo, GL_LABEL_SHADER);
+	}
+	CHECKOK(ok, pickArray);
+	if (!pickArray) {
+          freebuffers();
+        }
+	if (ok)
+	  memcpy(pickArray + num_total_labels * 6, pickColorVals, num_total_labels * 12 * sizeof(float));
+	if (ok)
+	  ok &= CGOStop(cgo);
+      } else {
+        freebuffers();
+      }
+      if (!ok){
+	CGOFree(cgo);
+      }
+    }
+    FreeP(worldPos);
+  }
+  return cgo;
+}
+
+CGO *CGOOptimizeConnectors(CGO * I, int est)
+{
+  CGO *cgo = NULL;
+  float *pc = I->op;
+  int op;
+  int num_total_connectors;
+  int ok = true;
+  int use_geometry_shaders = SettingGetGlobal_b(I->G, cSetting_use_geometry_shaders);
+  int factor = (use_geometry_shaders ? 1 : 4);
+  num_total_connectors = CGOCountNumberOfOperationsOfType(I, CGO_DRAW_CONNECTOR);
+
+  if (num_total_connectors){
+    float *targetPt3d, *labelCenterPt3d, *indentFactor, *screenWorldOffset, *connectorColor, *textSize;
+    float *bkgrdColor, *relExtLength, *connectorWidth;
+    uchar *relativeMode, *drawBkgrd;
+    uchar *isCenterPt = NULL;
+    int place3 = 0, place2 = 0, place = 0;
+    targetPt3d = Calloc(float, num_total_connectors * 20 * factor); /* too much, relativeMode only needs 1 byte per vertex, instead of 1 float */
+    if (!targetPt3d){
+      PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeConnectors() could not be allocated\n" ENDFB(I->G);
+      return NULL;
+    }
+    labelCenterPt3d = targetPt3d + (num_total_connectors*3 * factor);
+    indentFactor = labelCenterPt3d + (num_total_connectors*3 * factor);
+    screenWorldOffset = indentFactor + (num_total_connectors*2 * factor);
+    connectorColor = screenWorldOffset + (num_total_connectors*3 * factor);
+    textSize = connectorColor + (num_total_connectors*factor);
+    relativeMode = (uchar *)(textSize + (num_total_connectors*2*factor));
+    drawBkgrd = (uchar *)(relativeMode + (num_total_connectors*factor));
+    bkgrdColor = (float*)(drawBkgrd + (num_total_connectors*factor));
+    relExtLength = (float*)(bkgrdColor + (num_total_connectors*factor));
+    connectorWidth = (float*)(relExtLength + (num_total_connectors*factor));
+    if (!use_geometry_shaders)
+      isCenterPt = (uchar *)(connectorWidth + (num_total_connectors*factor));
+    else
+      isCenterPt = nullptr;
+    cgo = CGONewSized(I->G, 0);
+
+    while(ok && (op = (CGO_MASK & CGO_read_int(pc)))) {
+      switch (op) {
+      case CGO_PICK_COLOR:
+	cgo->current_pick_color_index = CGO_get_uint(pc);
+	cgo->current_pick_color_bond = CGO_get_int(pc + 1);
+	break;
+      case CGO_DRAW_BUFFERS_INDEXED:
+      case CGO_DRAW_BUFFERS_NOT_INDEXED:
+	PRINTFB(I->G, FB_CGO, FB_Warnings) "WARNING: CGOOptimizeConnectors() CGO_DRAW_BUFFERS_INDEXED or CGO_DRAW_BUFFERS_INDEXED encountered op=%d\n", op ENDFB(I->G);	
+	break;
+      case CGO_DRAW_CONNECTOR:
+	{
+	  uchar *uc;
+	  int f;
+	  if (!use_geometry_shaders){
+	      isCenterPt[place] = 0; isCenterPt[place+1] = 2; isCenterPt[place+2] = 2; isCenterPt[place+3] = 1;
+	  }
+	  copy3f(pc, &targetPt3d[place3]);
+	  copy3f(pc + 3, &labelCenterPt3d[place3]);
+	  copy2f(pc + 6, &indentFactor[place2]);
+	  copy3f(pc + 9, &screenWorldOffset[place3]);
+	  copy2f(pc + 12, &textSize[place2]);
+	  relativeMode[place] = (uchar)(int)pc[17];
+	  drawBkgrd[place] = (uchar)(int)pc[18];
+	  uc = (uchar *)&bkgrdColor[place];
+	  uc[0] = CLIP_COLOR_VALUE(*(pc+19));
+	  uc[1] = CLIP_COLOR_VALUE(*(pc+20));
+	  uc[2] = CLIP_COLOR_VALUE(*(pc+21));
+	  uc[3] = CLIP_COLOR_VALUE(*(pc+22));
+	  uc = (uchar *)&connectorColor[place];
+	  uc[0] = CLIP_COLOR_VALUE(*(pc+14));
+	  uc[1] = CLIP_COLOR_VALUE(*(pc+15));
+	  uc[2] = CLIP_COLOR_VALUE(*(pc+16));
+	  uc[3] = 255;
+	  relExtLength[place] = *(pc + 8);
+	  connectorWidth[place] = *(pc + 23);
+	  place3 += 3; place2 += 2; place += 1;
+	  for (f=1;f<factor; f++){
+	    copy3f(pc, &targetPt3d[place3]);
+	    copy3f(pc + 3, &labelCenterPt3d[place3]);
+	    copy2f(pc + 6, &indentFactor[place2]);
+	    copy3f(pc + 9, &screenWorldOffset[place3]);
+	    copy2f(pc + 12, &textSize[place2]);
+	    relativeMode[place] = (uchar)(int)pc[17];
+	    drawBkgrd[place] = (uchar)(int)pc[18];
+	    relExtLength[place] = *(pc + 8);
+	    connectorWidth[place] = *(pc + 23);
+	    uc = (uchar *)&bkgrdColor[place];
+	    uc[0] = uc[-4];
+	    uc[1] = uc[-3];
+	    uc[2] = uc[-2];
+	    uc[3] = uc[-1];
+	    uc = (uchar *)&connectorColor[place];
+	    uc[0] = uc[-4];
+	    uc[1] = uc[-3];
+	    uc[2] = uc[-2];
+	    uc[3] = uc[-1];
+	    place3 += 3; place2 += 2; place += 1;
+	  }
+	}
+	break;
+      }
+      pc += CGO_sz[op];
+      ok &= !I->G->Interrupt;
+    }
+    if (ok) {
+      const size_t quant = factor * num_total_connectors;
+      VertexBuffer * vbo = I->G->ShaderMgr->newGPUBuffer<VertexBuffer>();
+      ok = vbo->bufferData({
+          BufferDesc( "a_target_pt3d",       GL_FLOAT, 3, sizeof(float) * 3 * quant,     targetPt3d,        GL_FALSE ),
+          BufferDesc( "a_center_pt3d",       GL_FLOAT, 3, sizeof(float) * 3 * quant,     labelCenterPt3d,   GL_FALSE ),
+          BufferDesc( "a_indentFactor",      GL_FLOAT, 2, sizeof(float) * 2 * quant,     indentFactor,      GL_FALSE ),
+          BufferDesc( "a_screenWorldOffset", GL_FLOAT, 3, sizeof(float) * 3 * quant,     screenWorldOffset, GL_FALSE ),
+          BufferDesc( "a_textSize",          GL_FLOAT, 2, sizeof(float) * 2 * quant,     textSize,          GL_FALSE ),
+          BufferDesc( "a_Color",             GL_UNSIGNED_BYTE, 4, sizeof(float) * quant, connectorColor,    GL_TRUE  ),
+          BufferDesc( "a_relative_mode",     GL_UNSIGNED_BYTE, 1, sizeof(uchar) * quant, relativeMode,      GL_FALSE ),
+          BufferDesc( "a_draw_flags",        GL_UNSIGNED_BYTE, 1, sizeof(uchar) * quant, drawBkgrd,         GL_FALSE ),
+          BufferDesc( "a_bkgrd_color",       GL_UNSIGNED_BYTE, 4, sizeof(float) * quant, bkgrdColor,        GL_TRUE  ),
+          BufferDesc( "a_rel_ext_length",    GL_FLOAT, 1, sizeof(float) * quant,         relExtLength,      GL_FALSE ),
+          BufferDesc( "a_con_width",         GL_FLOAT, 1, sizeof(float) * quant,         connectorWidth,    GL_FALSE ),
+          BufferDesc( "a_isCenterPt",        GL_UNSIGNED_BYTE, 1, sizeof(uchar) * quant, isCenterPt,        GL_FALSE )
+        });
+      size_t vboid = vbo->get_hash_id();
+      if (ok) {
+	cgo->add<cgo::draw::connectors>(num_total_connectors, vboid);
+	if (ok)
+	  ok &= CGOStop(cgo);
+      }
+      if (!ok){
+        I->G->ShaderMgr->freeGPUBuffer(vboid);
+	CGOFree(cgo);
+      }
+    }
+    FreeP(targetPt3d);
+  }
+  {
+    GLenum err ;
+    CHECK_GL_ERROR_OK("ERROR: CGOOptimizeConnectors() end returns err=%d\n");
+  }
+  return cgo;
+}
+
+
+CGO *CGOExpandDrawTextures(const CGO * I, int est)
+{
+  CGO *cgo = CGONew(I->G);
+  int ok = true;
+
+  for (auto it = I->begin(); ok && !it.is_stop(); ++it) {
+    auto pc = it.data();
+    int op = it.op_code();
+
+    switch (op) {
+    case CGO_PICK_COLOR:
+      cgo->current_pick_color_index = CGO_get_uint(pc);
+      cgo->current_pick_color_bond = CGO_get_int(pc + 1);
+      break;
+    case CGO_DRAW_BUFFERS_INDEXED:
+    case CGO_DRAW_BUFFERS_NOT_INDEXED:
+      PRINTFB(I->G, FB_CGO, FB_Warnings) "WARNING: CGOOptimizeTextures() CGO_DRAW_BUFFERS_INDEXED or CGO_DRAW_BUFFERS_INDEXED encountered op=%d\n", op ENDFB(I->G);	
+      break;
+    case CGO_DRAW_TEXTURE:
+      {
+	float screenMin[3], screenMax[3], textExtent[4];
+	float alpha = cgo->alpha;
+	CGOAlpha(cgo, 0.f);
+	CGOColor(cgo, 0.f,0.f,0.f);
+	copy3f(pc + 3, screenMin);
+	copy3f(pc + 6, screenMax);
+	copy4f(pc + 9, textExtent);
+	CGOBegin(cgo, GL_TRIANGLES);
+	CGOTexCoord2f(cgo, textExtent[0], textExtent[1]);
+	CGOVertexv(cgo, screenMin);
+	CGOTexCoord2f(cgo, textExtent[0], textExtent[3]);
+	CGOVertex(cgo, screenMin[0], screenMax[1], screenMin[2]);
+	CGOTexCoord2f(cgo, textExtent[2], textExtent[1]);
+	CGOVertex(cgo, screenMax[0], screenMin[1], screenMin[2]);
+	CGOTexCoord2f(cgo, textExtent[0], textExtent[3]);
+	CGOVertex(cgo, screenMin[0], screenMax[1], screenMin[2]);
+	CGOTexCoord2f(cgo, textExtent[2], textExtent[1]);
+	CGOVertex(cgo, screenMax[0], screenMin[1], screenMin[2]);
+	CGOTexCoord2f(cgo, textExtent[2], textExtent[3]);
+	CGOVertex(cgo, screenMax[0], screenMax[1], screenMin[2]);
+	CGOEnd(cgo);
+	CGOAlpha(cgo, alpha);
+      }
+      break;
+    default:
+      cgo->add_to_cgo(op, pc);
+    }
+    ok &= !I->G->Interrupt;
+  }
+  CGOStop(cgo);
+  return cgo;
+}
+
+/* ======== Raytrace Renderer ======== */
+
+int CGOGetExtent(CGO * I, float *mn, float *mx)
+{
+  float *pc = I->op;
+  int op;
+  int result = false;
+
+#define check_extent(v,r) {\
+    if(!result) {\
+      mn[0]=((*(v  ))-r); \
+      mx[0]=((*(v  ))+r);  \
+      mn[1]=((*(v+1))-r); \
+      mx[1]=((*(v+1))+r); \
+      mn[2]=((*(v+2))-r); \
+      mx[2]=((*(v+2))+r); \
+      result=true; \
+  } else {\
+       if(mn[0]>((*(v    ))-r)) mn[0]=((*(v    ))-r); \
+       if(mx[0]<((*(v    ))+r)) mx[0]=((*(v    ))+r); \
+       if(mn[1]>((*((v)+1))-r)) mn[1]=((*((v)+1))-r); \
+       if(mx[1]<((*((v)+1))+r)) mx[1]=((*((v)+1))+r); \
+       if(mn[2]>((*((v)+2))-r)) mn[2]=((*((v)+2))-r); \
+       if(mx[2]<((*((v)+2))+r)) mx[2]=((*((v)+2))+r); }}
+
+#define check_extent4(v,r) {\
+    if(!result) {\
+      mn[0]=((*(v  ))-r); \
+      mx[0]=((*(v  ))+r);  \
+      mn[1]=((*(v+1))-r); \
+      mx[1]=((*(v+1))+r); \
+      mn[2]=((*(v+2))-r); \
+      mx[2]=((*(v+2))+r); \
+      mn[3]=((*(v+3))-r); \
+      mx[3]=((*(v+3))+r); \
+      result=true; \
+  } else {\
+       if(mn[0]>((*(v    ))-r)) mn[0]=((*(v    ))-r); \
+       if(mx[0]<((*(v    ))+r)) mx[0]=((*(v    ))+r); \
+       if(mn[1]>((*((v)+1))-r)) mn[1]=((*((v)+1))-r); \
+       if(mx[1]<((*((v)+1))+r)) mx[1]=((*((v)+1))+r); \
+       if(mn[2]>((*((v)+2))-r)) mn[2]=((*((v)+2))-r); \
+       if(mx[2]<((*((v)+2))+r)) mx[2]=((*((v)+2))+r); \
+       if(mn[3]>((*((v)+3))-r)) mn[3]=((*((v)+3))-r); \
+       if(mx[3]<((*((v)+3))+r)) mx[3]=((*((v)+3))+r); }}
+
+  while((op = (CGO_MASK & CGO_read_int(pc)))) {
+    switch (op) {
+    case CGO_VERTEX:
+      check_extent(pc, 0);
+      break;
+    case CGO_SPHERE:
+    case CGO_ELLIPSOID:
+      check_extent(pc, *(pc + 3));
+      break;
+    case CGO_CYLINDER:
+    case CGO_CONE:
+    case CGO_SAUSAGE:
+    case CGO_CUSTOM_CYLINDER:
+    case CGO_CUSTOM_CYLINDER_ALPHA:
+      check_extent(pc, *(pc + 6));
+      check_extent(pc + 3, *(pc + 6));
+      break;
+    case CGO_TRIANGLE:
+      check_extent(pc, 0);
+      check_extent(pc + 3, 0);
+      check_extent(pc + 6, 0);
+      break;
+    case CGO_DRAW_ARRAYS:
+      {
+        cgo::draw::arrays * sp = reinterpret_cast<decltype(sp)>(pc);
+	float *pct = sp->floatdata;
+	int pl;
+
+	if (sp->arraybits & CGO_VERTEX_ARRAY){
+	  for (pl = 0; pl < sp->nverts; pl++){
+	    check_extent(pct, 0);
+	    pct += 3;
+	  }
+	}
+	if (sp->arraybits & CGO_NORMAL_ARRAY){
+	  for (pl = 0; pl < sp->nverts; pl++){
+	    pct += 3;
+	  }
+	}
+	if (sp->arraybits & CGO_COLOR_ARRAY){
+	  for (pl = 0; pl < sp->nverts; pl++){
+	    pct += 4;
+	  }
+	}
+	if (sp->arraybits & CGO_PICK_COLOR_ARRAY){
+	  for (pl = 0; pl < sp->nverts; pl++){
+	    pct += 3;
+	  }
+	}
+      }
+      break;
+    case CGO_BOUNDING_BOX:
+      {
+	if (!result){
+	  mn[0]=(*pc);
+	  mn[1]=*(pc+1);
+	  mn[2]=*(pc+2);
+	  mx[0]=*(pc+3);
+	  mx[1]=*(pc+4);
+	  mx[2]=*(pc+5);
+	  result = true;
+	} else {
+	  if(mn[0]>*pc) mn[0]=(*pc);
+	  if(mn[1]>*(pc+1)) mn[1]=*(pc+1);
+	  if(mn[2]>*(pc+2)) mn[2]=*(pc+2);
+	  if(mx[0]<*(pc+3)) mx[0]=*(pc+3);
+	  if(mx[1]<*(pc+4)) mx[1]=*(pc+4);
+	  if(mx[2]<*(pc+5)) mx[2]=*(pc+5);
+	}
+      }
+    }
+    pc += CGO_sz[op];
+  }
+  return (result);
+}
+
+int CGOHasNormals(CGO * I)
+{
+  float *pc = I->op;
+  int op = 0;
+  int result = false;
+
+  while((op = (CGO_MASK & CGO_read_int(pc)))) {
+    switch (op) {
+    case CGO_NORMAL:
+    case CGO_SPHERE:
+    case CGO_ELLIPSOID:
+    case CGO_CYLINDER:
+    case CGO_CONE:
+    case CGO_SAUSAGE:
+    case CGO_CUSTOM_CYLINDER:
+    case CGO_CUSTOM_CYLINDER_ALPHA:
+      result |= 1;
+      break;
+    case CGO_DRAW_ARRAYS:
+      {
+        cgo::draw::arrays * sp = reinterpret_cast<decltype(sp)>(pc);
+	if (sp->arraybits & CGO_NORMAL_ARRAY){
+	  result |= 1;
+	}
+      }
+      break;
+    }
+    pc += CGO_sz[op];
+  }
+  return (result);
+}
+
+static int CGOQuadricToEllipsoid(float *v, float r, float *q,
+                                 float *r_el, float *n0, float *n1, float *n2)
+{
+  int ok = false;
+  double inp_matrix[16];
+  double e_val[4];
+  double e_vec[16];
+  double inverse[16];
+
+  inp_matrix[0] = q[0];
+  inp_matrix[1] = q[3];
+  inp_matrix[2] = q[5];
+  inp_matrix[3] = q[6];
+  inp_matrix[4] = q[3];
+  inp_matrix[5] = q[1];
+  inp_matrix[6] = q[4];
+  inp_matrix[7] = q[7];
+  inp_matrix[8] = q[5];
+  inp_matrix[9] = q[4];
+  inp_matrix[10] = q[2];
+  inp_matrix[11] = q[8];
+  inp_matrix[12] = q[6];
+  inp_matrix[13] = q[7];
+  inp_matrix[14] = q[8];
+  inp_matrix[15] = q[9];
+
+  if(xx_matrix_invert(inverse, inp_matrix, 4)) {
+
+    /* inverse now contains Uij coefficients */
+    float pradius = sqrt1f(-1 / inverse[15]);
+    int n_rot;
+
+    if(xx_matrix_jacobi_solve(e_vec, e_val, &n_rot, inverse, 4)) {
+      float mag[3];
+      float scale[3];
+      float mx;
+      n0[0] = e_vec[0];
+      n0[1] = e_vec[4];
+      n0[2] = e_vec[8];
+      n1[0] = e_vec[1];
+      n1[1] = e_vec[5];
+      n1[2] = e_vec[9];
+      n2[0] = e_vec[2];
+      n2[1] = e_vec[6];
+      n2[2] = e_vec[10];
+
+      normalize3f(n0);
+      normalize3f(n1);
+      normalize3f(n2);
+      mag[0] = sqrt1f(e_val[0]);
+      mag[1] = sqrt1f(e_val[1]);
+      mag[2] = sqrt1f(e_val[2]);
+
+      mx = mag[0];
+      if(mx < mag[1])
+        mx = mag[1];
+      if(mx < mag[2])
+        mx = mag[2];
+
+      scale[0] = mag[0] / mx;
+      scale[1] = mag[1] / mx;
+      scale[2] = mag[2] / mx;
+
+      scale3f(n0, scale[0], n0);
+      scale3f(n1, scale[1], n1);
+      scale3f(n2, scale[2], n2);
+
+      *r_el = mx * pradius;
+      ok = true;
+    }
+  }
+  return ok;
+}
+
+static int CGORenderQuadricRay(CRay * ray, float *v, float r, float *q)
+{
+  float r_el, n0[3], n1[3], n2[3];
+  int ok = true;
+  if(CGOQuadricToEllipsoid(v, r, q, &r_el, n0, n1, n2))
+    ok &= ray->ellipsoid3fv(v, r_el, n0, n1, n2);
+  return ok;
+}
+
+
+/* ======== Raytrace Renderer ======== */
+
+int CGORenderRay(CGO * I, CRay * ray, RenderInfo * info, const float *color, ObjectGadgetRamp *ramp, CSetting * set1, CSetting * set2)
+{
+#ifdef _PYMOL_NO_RAY
+  return 0;
+#else
+  float *pc;
+  int op;
+  int vc = 0;
+  float linewidth = 1.0F;
+  float widthscale = 0.15F;
+  float lineradius, dotradius, dotwidth;
+  float white[] = { 1.0, 1.0, 1.0 };
+  float zee[] = { 0.0, 0.0, 1.0 };
+  int ok = true;
+  const float *n0 = NULL, *n1 = NULL, *n2 = NULL, *v0 = NULL, *v1 = NULL, *v2 = NULL, *c0 =
+    NULL, *c1 = NULL, *c2 = NULL;
+  float rampc0[3], rampc1[3], rampc2[3];
+  int mode = -1;
+  /* workaround; multi-state ray-trace bug */
+  if (I)
+    pc = I->op;
+  else return 0; /* not sure if it should return 0 or 1, 0 - fails, but is it a memory issue? might not be since the arg is NULL */ 
+
+  I->G->CGORenderer->alpha =
+    1.0F - SettingGet_f(I->G, set1, set2, cSetting_cgo_transparency);
+
+  widthscale = SettingGet_f(I->G, set1, set2, cSetting_cgo_ray_width_scale);
+
+  /*  printf("debug %8.9f\n",SceneGetScreenVertexScale(I->G,zee)); */
+  linewidth = SettingGet_f(I->G, set1, set2, cSetting_cgo_line_width);
+  if(linewidth < 0.0F)
+    linewidth = 1.0F;
+  lineradius = SettingGet_f(I->G, set1, set2, cSetting_cgo_line_radius);
+  dotwidth = SettingGet_f(I->G, set1, set2, cSetting_cgo_dot_width);
+  dotradius = SettingGet_f(I->G, set1, set2, cSetting_cgo_dot_radius);
+  if(lineradius < 0.0F)
+    lineradius = linewidth * ray->PixelRadius / 2.0F;
+  if(dotradius < 0.0F)
+    dotradius = dotwidth * ray->PixelRadius / 2.0F;
+  if(widthscale < 0.0F)
+    widthscale = ray->PixelRadius / 2.0F;
+  if(color)
+    c0 = color;
+  else
+    c0 = white;
+  ray->transparentf(1.0F - I->G->CGORenderer->alpha);
+
+  while(ok && (op = (CGO_MASK & CGO_read_int(pc)))) {
+    switch (op) {
+    case CGO_BEGIN:
+      mode = CGO_get_int(pc);
+      vc = 0;
+      n0 = zee;
+      break;
+    case CGO_END:
+      switch (mode) {
+      case GL_LINE_LOOP:
+        if(vc > 1)
+          ok &= ray->sausage3fv(v0, v2, lineradius, c0, c2);
+        break;
+      }
+      mode = -1;
+      break;
+    case CGO_WIDTHSCALE:
+      widthscale = *pc;
+      lineradius = widthscale * linewidth;
+      dotradius = widthscale * dotwidth;
+      break;
+    case CGO_DOTWIDTH:
+      dotwidth = *pc;
+      dotradius = widthscale * dotwidth;
+      break;
+    case CGO_LINEWIDTH:
+      linewidth = *pc;
+      lineradius = widthscale * linewidth;
+      break;
+    case CGO_NORMAL:
+      n0 = pc;
+      break;
+    case CGO_SPECIAL_WITH_ARG:
+      {
+        float argval = *(pc + 1);
+        switch (*(int*)pc){
+        case LINEWIDTH_FOR_LINES:
+          linewidth = argval;
+          lineradius = widthscale * linewidth;
+        }
+      }
+      break;
+    case CGO_SPECIAL:
+      {
+        switch ((*(int*)pc)){
+        case LINEWIDTH_DYNAMIC_WITH_SCALE_RIBBON:
+          {
+            float radius = SettingGet_f(I->G, set1, set2, cSetting_ribbon_radius);
+            if(radius == 0.0F) {
+              float ribbon_width = SettingGet_f(I->G, set1, set2, cSetting_ribbon_width);
+              float line_width = SceneGetDynamicLineWidth(info, ribbon_width);
+              SceneGetDynamicLineWidth(info, line_width);
+              radius = ray->PixelRadius * line_width / 2.0F;
+            }
+            lineradius = radius;
+          }
+          break;
+        case LINEWIDTH_FOR_LINES:
+          {
+            float radius = SettingGet_f(I->G, set1, set2, cSetting_line_radius);
+            if(radius <= 0.0F) {
+              float line_width = SettingGet_f(I->G, set1, set2, cSetting_line_width);
+              line_width = SceneGetDynamicLineWidth(info, line_width);
+              radius = ray->PixelRadius * line_width / 2.0F;
+            }
+            lineradius = radius;
+          }
+          break;
+        case CYLINDER_WIDTH_FOR_NONBONDED:
+        case LINEWIDTH_WITH_SCALE:
+          {
+            float line_width = SettingGet_f(I->G, set1, set2, cSetting_line_width);
+            line_width = SceneGetDynamicLineWidth(info, line_width);
+            lineradius = widthscale * line_width / 2.f;
+          }
+          break;
+        }
+      }
+      break;
+    case CGO_COLOR:
+      c0 = pc;
+      ray->color3fv(c0);
+      break;
+    case CGO_ALPHA:
+      I->G->CGORenderer->alpha = *pc;
+      ray->transparentf(1.0F - *pc);
+      break;
+    case CGO_LINE:
+      {
+        auto line = reinterpret_cast<cgo::draw::line *>(pc);
+        ok &= ray->sausage3fv(line->vertex1, line->vertex2, lineradius, c0, c0);
+      }
+      break;
+    case CGO_SPLITLINE:
+      {
+        auto splitline = reinterpret_cast<cgo::draw::splitline *>(pc);
+        float color2[] = { CONVERT_COLOR_VALUE(splitline->color2[0]),
+                           CONVERT_COLOR_VALUE(splitline->color2[1]),
+                           CONVERT_COLOR_VALUE(splitline->color2[2]) };
+        if (splitline->flags & cgo::draw::splitline::interpolation){
+          ok &= ray->sausage3fv(splitline->vertex1, splitline->vertex2, lineradius, c0, color2);
+        } else {
+          float mid[3];
+          add3f(splitline->vertex1, splitline->vertex2, mid);
+          mult3f(mid, .5f, mid);
+          ok &= ray->customCylinder3fv(splitline->vertex1, mid, 
+                                       lineradius, c0, c0, 2, 0);
+          ok &= ray->customCylinder3fv(mid, splitline->vertex2, 
+                                       lineradius, color2, color2, 0, 2);
+        }
+      }
+      break;
+    case CGO_VERTEX_CROSS:
+      {
+        float pt1[3], pt2[3];
+        float nonbonded_size =
+          SettingGet_f(I->G, set1, set2, cSetting_nonbonded_size);
+        copy3f(pc, pt1);
+        copy3f(pc, pt2);
+        pt1[0] -= nonbonded_size;
+        pt2[0] += nonbonded_size;
+        ok &= ray->sausage3fv(pt1, pt2, lineradius, c0, c0);
+
+        copy3f(pc, pt1);
+        copy3f(pc, pt2);
+        pt1[1] -= nonbonded_size;
+        pt2[1] += nonbonded_size;
+        ok &= ray->sausage3fv(pt1, pt2, lineradius, c0, c0);
+
+        copy3f(pc, pt1);
+        copy3f(pc, pt2);
+        pt1[2] -= nonbonded_size;
+        pt2[2] += nonbonded_size;
+        ok &= ray->sausage3fv(pt1, pt2, lineradius, c0, c0);
+      }
+      break;
+    case CGO_VERTEX_BEGIN_LINE_STRIP:
+    case CGO_VERTEX:
+      v0 = pc;
+
+      if (ramp){
+	if (!ObjectGadgetRampInterVertex(ramp, v0, rampc0, -1)){
+	  copy3f(white, rampc0);
+	}
+	c0 = rampc0;
+      }
+      switch (mode) {
+      case GL_POINTS:
+        ok &= ray->sphere3fv(v0, dotradius);
+        break;
+      case GL_LINES:
+        if(vc & 0x1)
+          ok &= ray->sausage3fv(v0, v1, lineradius, c0, c1);
+        v1 = v0;
+	if (!ramp){
+	  c1 = c0;
+	}
+        break;
+      case GL_LINE_STRIP:
+        if(vc){
+          ok &= ray->sausage3fv(v0, v1, lineradius, c0, c1);
+        }
+        v1 = v0;
+	if (!ramp){
+	  c1 = c0;
+	}
+        break;
+      case GL_LINE_LOOP:
+        if(vc)
+          ok &= ray->sausage3fv(v0, v1, lineradius, c0, c1);
+        else {
+          v2 = v0;
+          c2 = c0;
+        }
+        v1 = v0;
+	if (!ramp)
+	  c1 = c0;
+        break;
+      case GL_TRIANGLES:
+	if( ((vc + 1) % 3) == 0)
+          ok &= ray->triangle3fv(v0, v1, v2, n0, n1, n2, c0, c1, c2);
+        v2 = v1;
+        n2 = n1;
+        v1 = v0;
+        n1 = n0;
+	if (!ramp){
+	  c2 = c1;
+	  c1 = c0;
+	}
+        break;
+      case GL_TRIANGLE_STRIP:
+        if(vc > 1)
+          ok &= ray->triangle3fv(v0, v1, v2, n0, n1, n2, c0, c1, c2);
+        v2 = v1;
+        n2 = n1;
+        v1 = v0;
+        n1 = n0;
+	if (!ramp){
+	  c2 = c1;
+	  c1 = c0;
+	}
+        break;
+      case GL_TRIANGLE_FAN:
+        if(vc > 1)
+          ok &= ray->triangle3fv(v0, v1, v2, n0, n1, n2, c0, c1, c2);
+        else if(!vc) {
+          n2 = n0;
+          v2 = v0;
+	  if (!ramp)
+	    c2 = c0;
+        }
+        v1 = v0;
+        n1 = n0;
+	if (!ramp)
+	  c1 = c0;
+        break;
+      }
+      if (ramp){
+	switch (mode){
+	case GL_TRIANGLES:
+	case GL_TRIANGLE_STRIP:
+	case GL_TRIANGLE_FAN:
+	  copy3f(rampc1, rampc2);
+	  c2 = rampc2;
+	case GL_LINES:
+	case GL_LINE_STRIP:
+	case GL_LINE_LOOP:
+	  copy3f(rampc0, rampc1);
+	  c1 = rampc1;
+	  break;
+	}
+      }
+      vc++;
+      break;
+    case CGO_SPHERE:
+      ray->color3fv(c0);
+      ok &= ray->sphere3fv(pc, *(pc + 3));
+      break;
+    case CGO_ELLIPSOID:
+      ray->color3fv(c0);
+      ok &= ray->ellipsoid3fv(pc, *(pc + 3), pc + 4, pc + 7, pc + 10);
+      break;
+    case CGO_QUADRIC:
+      ray->color3fv(c0);
+      ok &= CGORenderQuadricRay(ray, pc, *(pc + 3), pc + 4);
+      break;
+    case CGO_CONE:
+      ok &= ray->cone3fv(pc, pc + 3, *(pc + 6), *(pc + 7), pc + 8, pc + 11,
+			  (int) *(pc + 14), (int) *(pc + 15));
+      break;
+    case CGO_CUSTOM_CYLINDER:
+      {
+        auto cyl = reinterpret_cast<cgo::draw::custom_cylinder*>(pc);
+        ok &= ray->customCylinder3fv(*cyl);
+      }
+      break;
+    case CGO_CUSTOM_CYLINDER_ALPHA:
+      {
+        auto cyl = reinterpret_cast<cgo::draw::custom_cylinder_alpha*>(pc);
+        ok &= ray->customCylinderAlpha3fv(*cyl);
+      }
+      break;
+    case CGO_SHADER_CYLINDER:
+      {
+        float p2[3];
+        int cap = CGO_get_int(pc + 7);
+        int cap1 = cap & 1 ? ( (cap & cCylShaderCap1RoundBit) ? 2 : 1 ) : 0;
+        int cap2 = cap & 2 ? ( (cap & cCylShaderCap2RoundBit) ? 2 : 1 ) : 0;
+        add3f(pc, pc + 3, p2);
+        ok &= ray->customCylinder3fv(pc, p2, *(pc + 6), ray->CurColor, ray->CurColor,
+                                     cap1, cap2);
+      }
+      break;
+    case CGO_SHADER_CYLINDER_WITH_2ND_COLOR:
+      {
+        auto cyl = reinterpret_cast<cgo::draw::shadercylinder2ndcolor*>(pc);
+        float v1[3];
+        int cap = cyl->cap;
+        int fcap = (cap & 1) ? ((cap & cCylShaderCap1RoundBit) ? 2 : 1) : 0;
+        int bcap = (cap & 2) ? ((cap & cCylShaderCap2RoundBit) ? 2 : 1) : 0;
+        int colorinterp = cap & cCylShaderInterpColor;
+        const float *color1 = c0;
+        const float *color2 = cyl->color2;
+        add3f(cyl->origin, cyl->axis, v1);
+        float alpha1 = I->G->CGORenderer->alpha;
+        float alpha2 = cyl->alpha >= 0.f ? cyl->alpha : alpha1;
+        if (colorinterp || equal3f(color1, color2)) {
+          ok &= ray->customCylinder3fv(pc, v1, cyl->tube_size, color1, color2, fcap, bcap, alpha1, alpha2);
+        } else {
+          float mid[3];
+          mult3f(cyl->axis, .5f, mid);
+          add3f(cyl->origin, mid, mid);
+
+          ray->color3fv(c0);
+          ok &= ray->customCylinder3fv(cyl->origin, mid, cyl->tube_size, color1, color1, fcap, 0, alpha1, alpha2);
+          ray->color3fv(cyl->color2);
+          ok &= ray->customCylinder3fv(mid, v1, cyl->tube_size, color2, color2, 0, bcap, alpha1, alpha2);
+        }
+      }
+      break;
+    case CGO_CYLINDER:
+      {
+        auto *cyl = reinterpret_cast<cgo::draw::cylinder*>(pc);
+        ok &= ray->cylinder3fv(*cyl);
+      }
+      break;
+    case CGO_SAUSAGE:
+      ok &= ray->sausage3fv(pc, pc + 3, *(pc + 6), pc + 7, pc + 10);
+      break;
+    case CGO_TRIANGLE:
+      ok &= ray->triangle3fv(pc, pc + 3, pc + 6, pc + 9, pc + 12, pc + 15, pc + 18,
+			      pc + 21, pc + 24);
+      break;
+    case CGO_DRAW_ARRAYS:
+      {
+        cgo::draw::arrays * sp = reinterpret_cast<decltype(sp)>(pc);
+	int mode = sp->mode, arrays = sp->arraybits, narrays = sp->narrays, nverts = sp->nverts, v, pl, plc;
+	float *vertexVals = sp->floatdata;
+	float *normalVals = 0, *colorVals = 0;
+        int offset = 0;
+	(void)narrays;
+	if (arrays & CGO_VERTEX_ARRAY){
+	  vertexVals = sp->floatdata;
+          offset += nverts * 3;
+	}
+	if (arrays & CGO_NORMAL_ARRAY){
+	  normalVals = sp->floatdata + offset;
+          offset += nverts * 3;
+	}
+	if (arrays & CGO_COLOR_ARRAY){
+	  colorVals = sp->floatdata + offset;
+          offset += nverts * 4;
+	}
+	if (arrays & CGO_PICK_COLOR_ARRAY){
+          offset += nverts * 3;
+	}
+	vc = 0;
+	for (v=0, pl=0, plc=0; ok && v<nverts; v++, pl+=3, plc+=4){
+	  if (normalVals){
+	    n0 = &normalVals[pl];
+	  }
+	  if (colorVals){
+	    c0 = &colorVals[plc];
+	    ray->color3fv(c0);
+	    ray->transparentf(1.0f - c0[3]);
+	  }
+	  if (vertexVals){
+	    v0 = &vertexVals[pl];
+	  }
+	  switch (mode){
+	  case GL_POINTS:
+	    ok &= ray->sphere3fv(v0, dotradius);
+	    break;
+	  case GL_LINES:
+	    if(vc & 0x1)
+	      ok &= ray->sausage3fv(v0, v1, lineradius, c0, c1);
+	    v1 = v0;
+	    c1 = c0;
+	    break;
+	  case GL_LINE_STRIP:
+	    if(vc)
+	      ok &= ray->sausage3fv(v0, v1, lineradius, c0, c1);
+	    v1 = v0;
+	    c1 = c0;
+	    break;
+	  case GL_LINE_LOOP:
+	    if(vc)
+	      ok &= ray->sausage3fv(v0, v1, lineradius, c0, c1);
+	    else {
+	      v2 = v0;
+	      c2 = c0;
+	    }
+	    v1 = v0;
+	    c1 = c0;
+	    break;
+	  case GL_TRIANGLES:
+	    if( ((vc + 1) % 3) == 0)
+	      ok &= ray->triangle3fv(v0, v1, v2, n0, n1, n2, c0, c1, c2);
+	    v2 = v1;
+	    c2 = c1;
+	    n2 = n1;
+	    v1 = v0;
+	    c1 = c0;
+	    n1 = n0;
+	    break;
+	  case GL_TRIANGLE_STRIP:
+	    if(vc > 1)
+	      ok &= ray->triangle3fv(v0, v1, v2, n0, n1, n2, c0, c1, c2);
+	    v2 = v1;
+	    c2 = c1;
+	    n2 = n1;
+	    v1 = v0;
+	    c1 = c0;
+	    n1 = n0;
+	    break;
+	  case GL_TRIANGLE_FAN:
+	    if(vc > 1)
+	      ok &= ray->triangle3fv(v0, v1, v2, n0, n1, n2, c0, c1, c2);
+	    else if(!vc) {
+	      n2 = n0;
+	      v2 = v0;
+	      c2 = c0;
+	    }
+	    v1 = v0;
+	    c1 = c0;
+	    n1 = n0;
+	    break;
+	  }
+	  vc++;
+	}
+      }
+      break;
+    default:
+      break;
+    }
+    pc += CGO_sz[op];
+  }
+
+  if (ok)
+    ray->transparentf(0.0F);
+  return ok;
+#endif
+}
+
+
+/* ======== GL Rendering ======== */
+
+static int CGO_gl_begin_WARNING_CALLED = false, CGO_gl_end_WARNING_CALLED = false, CGO_gl_vertex_WARNING_CALLED = false;
+static void CGO_gl_begin(CCGORenderer * I, float **pc){ 
+  if (I->use_shader){
+    if (!CGO_gl_begin_WARNING_CALLED) { 
+      PRINTFB(I->G, FB_CGO, FB_Warnings) " CGO_gl_begin() is called but not implemented in OpenGLES\n" ENDFB(I->G);
+      CGO_gl_begin_WARNING_CALLED = true; 
+    }
+  } else {
+    int mode = CGO_get_int(*pc);
+    if (I->debug)
+      mode = CGOConvertDebugMode(I->debug, mode);
+    glBegin(mode);
+  }
+}
+static void CGO_gl_end(CCGORenderer * I, float **pc){ 
+  if (I->use_shader){
+    if (!CGO_gl_end_WARNING_CALLED) {
+      PRINTFB(I->G, FB_CGO, FB_Warnings) " CGO_gl_end() is called but not implemented in OpenGLES\n" ENDFB(I->G);
+      CGO_gl_end_WARNING_CALLED = true; 
+    }
+  } else {
+    glEnd();
+  }
+}
+static void CGO_gl_vertex(CCGORenderer * I, float **v){
+  if (I->use_shader){
+  if (!CGO_gl_vertex_WARNING_CALLED) {
+    PRINTFB(I->G, FB_CGO, FB_Warnings) " CGO_gl_vertex() is called but not implemented in OpenGLES\n" ENDFB(I->G);
+    CGO_gl_vertex_WARNING_CALLED = true;
+  }
+  } else {
+    glVertex3fv(*v);
+  }
+}
+
+static void CGO_gl_vertex_cross(CCGORenderer * I, float **v){
+#ifndef PURE_OPENGL_ES_2
+  if (I->use_shader){
+#endif
+  if (!CGO_gl_vertex_WARNING_CALLED) {
+    PRINTFB(I->G, FB_CGO, FB_Warnings) " CGO_gl_vertex() is called but not implemented in OpenGLES\n" ENDFB(I->G);
+    CGO_gl_vertex_WARNING_CALLED = true;
+  }
+#ifndef PURE_OPENGL_ES_2
+  } else {
+    CSetting * set1 = NULL, * set2 = NULL;
+    if (I->rep&&I->rep->cs) set1 = I->rep->cs->Setting;
+    if (I->rep&&I->rep->obj) set2 = I->rep->obj->Setting;
+    float nonbonded_size =
+      SettingGet_f(I->G, set1, set2, cSetting_nonbonded_size);
+    float pt[3];
+    copy3f(*v, pt);
+    pt[0] -= nonbonded_size;
+    glVertex3fv(pt);
+    pt[0] += 2 * nonbonded_size;
+    glVertex3fv(pt);
+    copy3f(*v, pt);
+    pt[1] -= nonbonded_size;
+    glVertex3fv(pt);
+    pt[1] += 2 * nonbonded_size;
+    glVertex3fv(pt);
+    copy3f(*v, pt);
+    pt[2] -= nonbonded_size;
+    glVertex3fv(pt);
+    pt[2] += 2 * nonbonded_size;
+    glVertex3fv(pt);
+  }
+#endif
+}
+
+static void CGO_gl_line(CCGORenderer * I, float **v){
+#ifndef PURE_OPENGL_ES_2
+  if (!I->use_shader){
+    auto line = reinterpret_cast<cgo::draw::line *>(*v);
+    glVertex3fv(line->vertex1);
+    glVertex3fv(line->vertex2);
+  }
+#endif
+}
+
+static void CGO_gl_splitline(CCGORenderer * I, float **v){
+#ifndef PURE_OPENGL_ES_2
+  if (!I->use_shader){
+    auto splitline = reinterpret_cast<cgo::draw::splitline *>(*v);
+    bool interpolation = splitline->flags & cgo::draw::splitline::interpolation;
+    bool equal_colors = splitline->flags & cgo::draw::splitline::equal_colors;
+    bool no_split_for_pick = splitline->flags & cgo::draw::splitline::no_split_for_pick;
+
+    if (I->isPicking){
+      if (no_split_for_pick){
+        glVertex3fv(splitline->vertex1);
+        glVertex3fv(splitline->vertex2);
+      } else {
+        float h[3];
+        average3f(splitline->vertex1, splitline->vertex2, h);
+        glVertex3fv(splitline->vertex1);
+        glVertex3fv(h);
+        unsigned char col[4];
+        auto pick = I->info->pick;
+        AssignNewPickColor(NULL, (*pick)[0].src.index, pick, &I->rep->context, col,
+                           splitline->index, splitline->bond);
+        glColor4ubv(col);
+        glVertex3fv(h);
+        glVertex3fv(splitline->vertex2);
+      }
+    } else if (interpolation || equal_colors){
+      glVertex3fv(splitline->vertex1);
+      if (!equal_colors)
+        glColor4ub(splitline->color2[0], splitline->color2[1], splitline->color2[2], CLIP_COLOR_VALUE(I->alpha));
+      glVertex3fv(splitline->vertex2);
+    } else {
+      float h[3];
+      average3f(splitline->vertex1, splitline->vertex2, h);
+      glVertex3fv(splitline->vertex1);
+      glVertex3fv(h);
+      glColor4ub(splitline->color2[0], splitline->color2[1], splitline->color2[2], CLIP_COLOR_VALUE(I->alpha));
+      glVertex3fv(h);
+      glVertex3fv(splitline->vertex2);
+    }
+  }
+#endif
+}
+
+
+static void CGO_gl_normal(CCGORenderer * I, float **varg){
+  float *v = *varg;
+  if (I->use_shader){
+    glVertexAttrib3fv(VERTEX_NORMAL, v);
+  } else {
+    glNormal3f(v[0],v[1],v[2]);
+  }
+}
+
+static void CGO_gl_draw_arrays(CCGORenderer * I, float **pc){
+  cgo::draw::arrays * sp = reinterpret_cast<decltype(sp)>(*pc);
+  int mode = sp->mode, arrays = sp->arraybits, narrays = sp->narrays, nverts = sp->nverts;
+  float * data = sp->floatdata;
+  (void) narrays;
+#ifndef PURE_OPENGL_ES_2
+  if (I->use_shader){
+#endif
+
+  if (arrays & CGO_VERTEX_ARRAY) glEnableVertexAttribArray(VERTEX_POS);
+  if (arrays & CGO_NORMAL_ARRAY) glEnableVertexAttribArray(VERTEX_NORMAL);
+  if (I->isPicking){
+    if (arrays & CGO_PICK_COLOR_ARRAY){
+      glEnableVertexAttribArray(VERTEX_COLOR);
+    }
+  } else {
+    if (arrays & CGO_COLOR_ARRAY)
+      glEnableVertexAttribArray(VERTEX_COLOR);
+  }
+
+  if (arrays & CGO_VERTEX_ARRAY){
+#ifdef _WEBGL
+#else
+    glVertexAttribPointer(VERTEX_POS, VERTEX_POS_SIZE, GL_FLOAT, GL_FALSE, 0, data);
+#endif
+    data += nverts*3;
+  }
+  if (arrays & CGO_NORMAL_ARRAY){
+#ifdef _WEBGL
+#else
+    glVertexAttribPointer(VERTEX_NORMAL, VERTEX_NORMAL_SIZE, GL_FLOAT, GL_FALSE, 0, data);
+#endif
+    data += nverts*3;
+  }
+  if (I->isPicking){
+    if (arrays & CGO_COLOR_ARRAY){
+      data += nverts*4;
+    }
+    if (arrays & CGO_PICK_COLOR_ARRAY){
+#ifdef _WEBGL
+    glBindBuffer(GL_ARRAY_BUFFER, buffers[2]);
+    glBufferData(GL_ARRAY_BUFFER, nverts * 4, data, GL_STATIC_DRAW);
+    glVertexAttribPointer(VERTEX_COLOR, VERTEX_COLOR_SIZE, GL_UNSIGNED_BYTE, GL_FALSE, 0, 0);
+#else
+      glVertexAttribPointer(VERTEX_COLOR, VERTEX_COLOR_SIZE, GL_UNSIGNED_BYTE, GL_FALSE, 0, data);     
+#endif
+      data += nverts*3;
+    }
+  } else {
+    if (arrays & CGO_COLOR_ARRAY){
+#ifdef _WEBGL
+#else
+      glVertexAttribPointer(VERTEX_COLOR, VERTEX_COLOR_SIZE, GL_FLOAT, GL_FALSE, 0, data);
+#endif
+      data += nverts*4;
+    }
+    if (arrays & CGO_PICK_COLOR_ARRAY){
+      data += nverts*3;
+    }
+  }
+  if (I->debug){
+    mode = CGOConvertDebugMode(I->debug, mode);
+  }
+  glDrawArrays(mode, 0, nverts);
+
+  if (I->isPicking){
+    if (arrays & CGO_PICK_COLOR_ARRAY){
+      glDisableVertexAttribArray(VERTEX_COLOR);
+    }
+  } else {
+    if (arrays & CGO_COLOR_ARRAY)
+      glDisableVertexAttribArray(VERTEX_COLOR);
+  }
+  if (arrays & CGO_VERTEX_ARRAY) glDisableVertexAttribArray(VERTEX_POS);
+  if (arrays & CGO_NORMAL_ARRAY) glDisableVertexAttribArray(VERTEX_NORMAL);
+
+#ifndef PURE_OPENGL_ES_2
+  } else {
+
+    int pl, pla, plc;
+    float *vertexVals = nullptr;
+    float *colorVals = 0, *normalVals = 0, *tmp_ptr, alpha ;
+    uchar *pickColorVals = 0, *tmp_pc_ptr;
+    alpha = I->alpha;
+    if (arrays & CGO_VERTEX_ARRAY){
+      vertexVals = data;
+      data += nverts*3;
+    }
+    if (arrays & CGO_NORMAL_ARRAY){
+      normalVals = data;
+      data += nverts*3;
+    }
+    if (I->isPicking){
+      alpha = 1.f;
+      if (arrays & CGO_COLOR_ARRAY){
+	data += nverts*4;
+      }
+      if (arrays & CGO_PICK_COLOR_ARRAY){
+	pickColorVals = (uchar*)data;
+	data += nverts*3;
+      }
+    } else {
+      if (arrays & CGO_COLOR_ARRAY){
+	colorVals = data;
+	data += nverts*4;
+      }
+      if (arrays & CGO_PICK_COLOR_ARRAY){
+	data += nverts*3;
+      }
+    }
+    if (arrays & CGO_ACCESSIBILITY_ARRAY) data += nverts;
+
+    if (I->debug){
+      mode = CGOConvertDebugMode(I->debug, mode);
+    }
+
+    glBegin(mode);
+    for (pl = 0, pla = 0, plc = 0; pl<nverts; pl++, pla+=3, plc+=4){
+      if (pickColorVals){
+        tmp_pc_ptr = &pickColorVals[plc]; /* the pick colors are saved with rgba */
+        glColor4ub(tmp_pc_ptr[0], tmp_pc_ptr[1], tmp_pc_ptr[2], tmp_pc_ptr[3]);
+      } else {
+        if (colorVals){
+          tmp_ptr = &colorVals[plc];
+          glColor4f(tmp_ptr[0], tmp_ptr[1], tmp_ptr[2], alpha);	
+        }
+        if (normalVals){
+          tmp_ptr = &normalVals[pla];
+          glNormal3fv(&normalVals[pla]);
+        }
+      }
+      if (vertexVals){
+	tmp_ptr = &vertexVals[pla];
+	glVertex3fv(&vertexVals[pla]);
+      }
+    }
+    glEnd();
+  }
+#endif
+}
+
+static
+void TransparentInfoSortIX(PyMOLGlobals * G, float *sum, float *z_value, 
+			   int *ix, int n_tri, int *sort_mem, int t_mode);
+static
+void CGOReorderIndicesWithTransparentInfo(PyMOLGlobals * G, int nindices, 
+					  size_t vbuf, int n_tri, int *ix, 
+					  GL_C_INT_TYPE *vertexIndicesOriginal, 
+					  GL_C_INT_TYPE *vertexIndices);
+
+static void CGO_gl_draw_buffers_indexed(CCGORenderer * I, float **pc){
+  cgo::draw::buffers_indexed * sp = reinterpret_cast<decltype(sp)>(*pc);
+  int mode = sp->mode, nindices = sp->nindices,
+    nverts = sp->nverts, n_data = sp->n_data;
+  size_t vboid = sp->vboid, iboid = sp->iboid;
+  VertexBuffer * vbo = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(vboid);
+  IndexBuffer * ibo  = I->G->ShaderMgr->getGPUBuffer<IndexBuffer>(iboid);
+  GLenum err ;
+  CHECK_GL_ERROR_OK("beginning of CGO_gl_draw_buffers_indexed err=%d\n");
+
+  auto shaderPrg = I->G->ShaderMgr->Get_Current_Shader();
+
+  if (!shaderPrg){
+    *pc += fsizeof<cgo::draw::buffers_not_indexed>();
+    return;
+  }
+
+  if (I->isPicking){
+    int attr_a_Color = shaderPrg->GetAttribLocation("a_Color");
+    vbo->maskAttributes({ attr_a_Color });
+    shaderPrg->Set1i("fog_enabled", 0);
+    shaderPrg->Set1i("lighting_enabled", 0);
+    if (I->use_shader){
+      if (sp->pickvboid){
+        VertexBuffer * pickvbo = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(sp->pickvboid);
+        if (I->pick_mode){
+          // second pass
+          pickvbo->bind(shaderPrg->id, 1);
+        } else {
+          // first pass
+          pickvbo->bind(shaderPrg->id, 0);
+        }
+      } else {
+        glEnableVertexAttribArray(attr_a_Color);
+        glVertexAttribPointer(attr_a_Color, VERTEX_COLOR_SIZE, GL_UNSIGNED_BYTE, GL_TRUE, 0, sp->floatdata);
+      }
+    }
+  }
+  if (n_data){
+    // if transparency data, then sort it
+    int n_tri = nindices/3;
+    float *sum = sp->floatdata + nverts*3;
+    float *z_value = sum + (nindices*3);
+    int *ix = (int *)(z_value + n_tri);
+    int *sort_mem = ix + n_tri;
+    int t_mode;
+    CSetting * set1 = NULL, * set2 = NULL;
+    if (I->rep&&I->rep->cs) set1 = I->rep->cs->Setting;
+    if (I->rep&&I->rep->obj) set2 = I->rep->obj->Setting;
+    t_mode = SettingGet_i(I->G, set1, set2, cSetting_transparency_mode);
+    if (t_mode!=3){
+      GL_C_INT_TYPE *vertexIndicesOriginalTI = (GL_C_INT_TYPE *)(sort_mem + n_tri + 256);
+      GL_C_INT_TYPE *vertexIndicesTI = vertexIndicesOriginalTI + nindices;
+      TransparentInfoSortIX(I->G, sum, z_value, ix, n_tri, sort_mem, t_mode);
+      CGOReorderIndicesWithTransparentInfo(I->G, nindices, iboid, n_tri, ix,
+                                           vertexIndicesOriginalTI, vertexIndicesTI);
+    }
+  }
+
+  if (I->debug){
+    mode = CGOConvertDebugMode(I->debug, mode);
+  }
+  vbo->bind(shaderPrg->id);
+  ibo->bind();
+
+  CHECK_GL_ERROR_OK("CGO_gl_draw_buffers_indexed: before glDrawElements err=%d\n");
+  glDrawElements(mode, nindices, GL_C_INT_ENUM, 0);
+  CHECK_GL_ERROR_OK("CGO_gl_draw_buffers_indexed: after glDrawElements err=%d\n");
+
+  vbo->unbind();
+  ibo->unbind();
+
+  if (I->isPicking) {
+    VertexBuffer * pickvbo = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(sp->pickvboid);
+    if (pickvbo)
+      pickvbo->unbind();
+  }
+
+  CHECK_GL_ERROR_OK("CGO_gl_draw_buffers_indexed: end err=%d\n");
+}
+
+static void CGO_gl_draw_buffers_not_indexed(CCGORenderer * I, float **pc){
+  cgo::draw::buffers_not_indexed * sp = reinterpret_cast<decltype(sp)>(*pc);
+  int mode = sp->mode;
+
+  auto shaderPrg = I->G->ShaderMgr->Get_Current_Shader();
+  if (!shaderPrg){
+    return;
+  }
+  VertexBuffer * vbo = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(sp->vboid);
+  if (!vbo)
+    return;
+  if (I->isPicking){
+    int attr_a_Color = shaderPrg->GetAttribLocation("a_Color");
+    vbo->maskAttributes({ attr_a_Color });
+    shaderPrg->Set1i("fog_enabled", 0);
+    shaderPrg->Set1i("lighting_enabled", 0);
+    if (I->use_shader){
+      if (sp->pickvboid){
+        VertexBuffer * pickvbo = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(sp->pickvboid);
+        if (I->pick_mode){
+          // second pass
+          pickvbo->bind(shaderPrg->id, 1);
+        } else {
+          // first pass
+          pickvbo->bind(shaderPrg->id, 0);
+        }
+      } else {
+        glEnableVertexAttribArray(attr_a_Color);
+        glVertexAttribPointer(attr_a_Color, VERTEX_COLOR_SIZE, GL_UNSIGNED_BYTE, GL_TRUE, 0, sp->floatdata);
+      }
+    }
+  }
+
+  if (I->debug){
+    mode = CGOConvertDebugMode(I->debug, mode);
+  }
+
+  vbo->bind(shaderPrg->id);
+  glDrawArrays(mode, 0, sp->nverts);
+  vbo->unbind();
+
+  if (I->isPicking) {
+    VertexBuffer * pickvbo = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(sp->pickvboid);
+    if (pickvbo)
+      pickvbo->unbind();
+  }
+}
+
+static void CGO_gl_mask_attribute_if_picking(CCGORenderer * I, float **pc){
+  if (I->isPicking){
+    cgo::draw::mask_attribute_if_picking * sp = reinterpret_cast<decltype(sp)>(*pc);
+    auto shaderPrg = I->G->ShaderMgr->Get_Current_Shader();
+    if (!shaderPrg){
+      return;
+    }
+    VertexBuffer * vbo = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(sp->vboid);
+    if (!vbo)
+      return;
+    int loc = shaderPrg->GetAttribLocation(I->G->ShaderMgr->GetAttributeName(sp->attr_lookup_idx));
+    vbo->maskAttribute(loc);
+  }
+}
+
+static void CGO_gl_bind_vbo_for_picking(CCGORenderer * I, float **pc){
+  if (I->isPicking){
+    cgo::draw::bind_vbo_for_picking * sp = reinterpret_cast<decltype(sp)>(*pc);
+    auto shaderPrg = I->G->ShaderMgr->Get_Current_Shader();
+    if (!shaderPrg){
+      return;
+    }
+    VertexBuffer * vbo = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(sp->vboid);
+    if (!vbo)
+      return;
+    if (I->pick_mode){
+        // second pass
+        vbo->bind(shaderPrg->id, sp->which_attr_idx + sp->npickattrs);
+    } else {
+        // first pass
+        vbo->bind(shaderPrg->id, sp->which_attr_idx);
+    }
+  }
+}
+
+static void CGO_gl_draw_custom(CCGORenderer * I, float **pc){
+  cgo::draw::custom * sp = reinterpret_cast<decltype(sp)>(*pc);
+
+  auto shaderPrg = I->G->ShaderMgr->Get_Current_Shader();
+  if (!shaderPrg){
+    return;
+  }
+  VertexBuffer * vbo = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(sp->vboid);
+  if (!vbo)
+    return;
+  IndexBuffer * ibo = NULL;
+  if (sp->iboid){
+    ibo = I->G->ShaderMgr->getGPUBuffer<IndexBuffer>(sp->iboid);
+  }
+  vbo->bind(shaderPrg->id);
+  if (ibo){
+    ibo->bind();
+    glDrawElements(sp->mode, sp->nindices, GL_C_INT_ENUM, 0);
+  } else {
+    glDrawArrays(sp->mode, 0, sp->nverts);
+  }
+  vbo->unbind();
+  if (sp->pickvboid) {
+    VertexBuffer * pickvbo = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(sp->pickvboid);
+    if (pickvbo)
+      pickvbo->unbind();
+  }
+  if (ibo)
+    ibo->unbind();
+
+}
+
+static void CGO_gl_color_impl(CCGORenderer * I, float *v);
+
+static void CGO_gl_draw_sphere_buffers(CCGORenderer * I, float **pc) {
+  cgo::draw::sphere_buffers * sp = reinterpret_cast<decltype(sp)>(*pc);
+  int num_spheres = sp->num_spheres;
+  int attr_color;
+  VertexBuffer * vbo = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(sp->vboid);
+  VertexBuffer * pickvbo = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(sp->pickvboid);
+  CShaderPrg *shaderPrg;
+  int pickable = 0;
+
+  shaderPrg = I->G->ShaderMgr->Get_DefaultSphereShader(I->info ? I->info->pass : 0);
+  if (!shaderPrg){
+    return;
+  }
+
+  attr_color = shaderPrg->GetAttribLocation("a_Color");
+
+  if (I->isPicking){
+    vbo->maskAttributes({ attr_color });
+    pickable = SettingGet_i(I->G, I->set1, I->set2, cSetting_pickable);
+    shaderPrg->Set1i("lighting_enabled", 0);
+    if (pickable){
+      if (I->pick_mode){
+        // second pass
+        pickvbo->bind(shaderPrg->id, 1);
+      } else {
+        // first pass
+        pickvbo->bind(shaderPrg->id, 0);
+      }
+    } else {
+      glVertexAttrib4f(attr_color, 0.f, 0.f, 0.f, 1.f);
+    }
+  }
+
+  vbo->bind(shaderPrg->id);
+  glDrawArrays(GL_QUADS, 0, num_spheres * 4);
+
+  vbo->unbind();
+}
+
+static void CGO_gl_draw_cylinder_buffers(CCGORenderer * I, float **pc) {
+  cgo::draw::cylinder_buffers * sp = reinterpret_cast<decltype(sp)>(*pc);
+  int  num_cyl = sp->num_cyl;
+  int min_alpha = sp->alpha;
+  int attr_colors, attr_colors2;
+  CShaderPrg *shaderPrg;
+  int pickable = 0;
+  VertexBuffer * vbo = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(sp->vboid);
+  IndexBuffer * ibo = I->G->ShaderMgr->getGPUBuffer<IndexBuffer>(sp->iboid);
+  VertexBuffer * pickvbo = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(sp->pickvboid);
+
+  shaderPrg = I->G->ShaderMgr->Get_CylinderShader(I->info ? I->info->pass : 0);
+
+  if (!shaderPrg){
+    return;
+  }
+  attr_colors = shaderPrg->GetAttribLocation("a_Color");
+  attr_colors2 = shaderPrg->GetAttribLocation("a_Color2");
+
+  if (I->isPicking){
+    pickable = SettingGet_i(I->G, I->set1, I->set2, cSetting_pickable);
+    shaderPrg->Set1i("lighting_enabled", 0);
+  }
+  if (I->isPicking){
+    vbo->maskAttributes({ attr_colors, attr_colors2 });
+    if (pickable){
+      if (I->pick_mode){
+        // first color (offset 0), second pass (2nd half of vbo)
+        pickvbo->bind( shaderPrg->id, 1 );
+        // second color (offset 4), second pass (2nd half of vbo)
+        pickvbo->bind( shaderPrg->id, 3 );
+      } else {
+        // first color (offset 0), first pass (1st half of vbo)
+        pickvbo->bind( shaderPrg->id, 0 );
+        // second color (offset 4), first pass (1st half of vbo)
+        pickvbo->bind( shaderPrg->id, 2 );
+      }
+    } else {
+      glVertexAttrib4f(attr_colors, 0.f, 0.f, 0.f, I->picking_32bit ? 0.f : 1.f);
+      glVertexAttrib4f(attr_colors2, 0.f, 0.f, 0.f, I->picking_32bit ? 0.f : 1.f);
+    }
+  }
+
+  vbo->bind(shaderPrg->id);
+  ibo->bind();
+
+  if (min_alpha < 255) {
+    glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
+    glDrawElements(GL_TRIANGLES, num_cyl * NUM_TOTAL_VERTICES_PER_CYLINDER, GL_C_INT_ENUM, 0);
+    glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
+    glDepthFunc(GL_LEQUAL);
+  }
+  glDrawElements(GL_TRIANGLES, num_cyl * NUM_TOTAL_VERTICES_PER_CYLINDER, GL_C_INT_ENUM, 0);
+
+  if (min_alpha < 255) {
+    glDepthFunc(GL_LESS);
+  }
+
+  ibo->unbind();
+  vbo->unbind();
+  if (I->isPicking)
+    pickvbo->unbind();
+}
+#include "Texture.h"
+
+static void CGO_gl_draw_labels(CCGORenderer * I, float **pc) {
+  cgo::draw::labels * sp = reinterpret_cast<decltype(sp)>(*pc);
+
+  CShaderPrg * shaderPrg;
+  int t_mode = SettingGetGlobal_i(I->G, cSetting_transparency_mode);
+
+  if (t_mode==3 && I->info && !(I->info->pass<0)){
+    // in transparency_mode=3, labels are drawn in the transparency pass=-1
+    return;
+  }
+  shaderPrg = I->G->ShaderMgr->Get_LabelShader(I->info ? I->info->pass : 0);
+  if (I->rep){
+    float label_size;
+    CSetting * set1 = NULL, * set2 = NULL;
+    if (I->rep->cs) set1 = I->rep->cs->Setting;
+    if (I->rep->obj) set2 = I->rep->obj->Setting;
+    label_size = SettingGet_f(I->G, set1, set2, cSetting_label_size);
+    shaderPrg->Set1f("scaleByVertexScale", label_size < 0.f ? 1.f : 0.f);
+    if (label_size<0.f){
+      shaderPrg->Set1f("labelTextureSize", (float)-2.f* I->info->texture_font_size/label_size);
+    }
+  }
+
+  if (!shaderPrg){
+    return;
+  }
+
+  VertexBuffer * vbo     = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(sp->vboid);
+  VertexBuffer * pickvbo = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(sp->pickvboid);
+
+  int attr_pickcolor = shaderPrg->GetAttribLocation("attr_pickcolor");
+
+  if (I->isPicking){
+    if (I->pick_mode){
+      // second pass
+      pickvbo->bind(shaderPrg->id, 1);
+    } else {
+      pickvbo->bind(shaderPrg->id, 0);
+    }
+  } else {
+    glVertexAttrib4f(attr_pickcolor, 0.f, 0.f, 0.f, 0.f);
+  }
+
+  if (!vbo)
+    return;
+  vbo->bind(shaderPrg->id);
+
+  glDrawArrays(GL_TRIANGLES, 0, sp->ntextures*6);
+
+  vbo->unbind();
+  pickvbo->unbind();
+}
+
+static void CGO_gl_draw_connectors(CCGORenderer * I, float **pc) {
+  int use_geometry_shaders = SettingGetGlobal_b(I->G, cSetting_use_geometry_shaders);
+
+  cgo::draw::connectors * sp = reinterpret_cast<decltype(sp)>(*pc);
+
+  GLenum mode = GL_LINES;
+  int factor = 2;
+  float lineWidth;
+  if (I->isPicking){
+    return;
+  }
+  {
+    GLenum err ;
+    CHECK_GL_ERROR_OK("ERROR: CGO_gl_draw_connectors begin returns err=%d\n");
+  }
+
+  if (use_geometry_shaders){
+    mode = GL_POINTS;
+    factor = 1;
+  } else {
+    factor = 4;
+  }
+  auto shaderPrg = I->G->ShaderMgr->Get_Current_Shader();
+  if (!shaderPrg){
+    return;
+  }
+  if (I->rep){
+    float label_size;
+    CSetting * set1 = NULL, * set2 = NULL;
+    float v_scale = SceneGetScreenVertexScale(I->G, NULL);
+    if (I->rep->cs) set1 = I->rep->cs->Setting;
+    if (I->rep->obj) set2 = I->rep->obj->Setting;
+    label_size = SettingGet_f(I->G, set1, set2, cSetting_label_size);
+    shaderPrg->Set1f("scaleByVertexScale", label_size < 0.f ? 1.f : 0.f);
+    lineWidth = SettingGet_f(I->G, set1, set2, cSetting_label_connector_width);
+    if (label_size<0.f){
+      shaderPrg->Set1f("textureToLabelSize", v_scale * (float)I->info->texture_font_size/label_size);
+    } else {
+      shaderPrg->Set1f("textureToLabelSize", 1.f);
+    }
+  } else {
+    lineWidth = SettingGetGlobal_f(I->G, cSetting_label_connector_width);
+  }
+#ifndef _WEBGL
+  if (!use_geometry_shaders)
+    glLineWidth(lineWidth);
+#endif
+
+  VertexBuffer * vbo = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(sp->vboid);
+  if (!vbo)
+    return;
+  vbo->bind(shaderPrg->id);
+  glDrawArrays(mode, 0, sp->nconnectors*factor);
+  vbo->unbind();
+  {
+    GLenum err ;
+    CHECK_GL_ERROR_OK("ERROR: CGO_gl_draw_connectors end returns err=%d\n");
+  }
+}
+
+static void CGO_gl_draw_textures(CCGORenderer * I, float **pc) {
+  cgo::draw::textures * sp = reinterpret_cast<decltype(sp)>(*pc);
+  int ntextures = sp->ntextures;
+  VertexBuffer * vbo = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(sp->vboid);
+  CShaderPrg * shaderPrg;
+  int attr_pickcolor = 0;
+  shaderPrg = I->G->ShaderMgr->Get_LabelShader(I->info ? I->info->pass : 0);
+  if (!shaderPrg){
+    return;
+  }
+  if (I->isPicking){
+    attr_pickcolor = shaderPrg->GetAttribLocation("attr_pickcolor");    
+  }
+  if (attr_pickcolor){
+    glBindBuffer(GL_ARRAY_BUFFER, 0);
+    glEnableVertexAttribArray(attr_pickcolor);
+    glVertexAttribPointer(attr_pickcolor, VERTEX_COLOR_SIZE, GL_UNSIGNED_BYTE, GL_TRUE, 0, sp->floatdata);
+  }
+  vbo->bind(shaderPrg->id);
+  glDrawArrays(GL_TRIANGLES, 0, ntextures*6);
+  vbo->unbind();
+  if (attr_pickcolor){
+    glDisableVertexAttribArray(attr_pickcolor);
+  }
+}
+
+static void CGO_gl_draw_screen_textures_and_polygons(CCGORenderer * I, float **pc) {
+  cgo::draw::screen_textures * sp = reinterpret_cast<decltype(sp)>(*pc);
+  int nverts = sp->nverts;
+  CShaderPrg * shaderPrg;
+
+  shaderPrg = I->G->ShaderMgr->Get_ScreenShader();
+  if (!shaderPrg){
+    return;
+  }
+
+  VertexBuffer * vb = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(sp->vboid);
+  if (!vb)
+    return;
+  vb->bind(shaderPrg->id);
+
+  glDrawArrays(GL_TRIANGLES, 0, nverts);
+
+  vb->unbind();
+}
+
+static void CGO_gl_draw_trilines(CCGORenderer * I, float **pc) {
+  int nverts = CGO_get_int(*pc);
+  int buffer = CGO_get_int(*pc+1);
+  int a_vertex, a_othervertex, a_uv, a_color, a_color2;
+  auto shaderPrg = I->G->ShaderMgr->Get_Current_Shader();
+  if (!shaderPrg){
+    return;
+  }
+  a_vertex = 0; // a_Vertex is bound to 0 (see ShaderMgr) CShaderPrg_GetAttribLocation(shaderPrg, "a_Vertex");
+  a_othervertex = shaderPrg->GetAttribLocation("a_OtherVertex");
+  a_uv = shaderPrg->GetAttribLocation("a_UV");
+  a_color = shaderPrg->GetAttribLocation("a_Color");
+  a_color2 = shaderPrg->GetAttribLocation("a_Color2");
+
+  glEnableVertexAttribArray(a_vertex);
+  glEnableVertexAttribArray(a_othervertex);
+  glEnableVertexAttribArray(a_uv);
+  glEnableVertexAttribArray(a_color);
+  glEnableVertexAttribArray(a_color2);
+
+  glBindBuffer(GL_ARRAY_BUFFER, buffer);
+
+  glVertexAttribPointer(a_vertex, 3, GL_FLOAT, GL_FALSE, 32, (const void *)0);
+  glVertexAttribPointer(a_othervertex, 3, GL_FLOAT, GL_FALSE, 32, (const void *)12);
+  glVertexAttribPointer(a_uv, 1, GL_FLOAT, GL_FALSE, 32, (const void *)24);
+  glVertexAttribPointer(a_color, 4, GL_UNSIGNED_BYTE, GL_TRUE, 32, (const void *)28);
+  glVertexAttribPointer(a_color2, 4, GL_UNSIGNED_BYTE, GL_TRUE, 32, (const void *)28);
+  glDrawArrays(GL_TRIANGLES, 0, nverts);
+
+  glDisableVertexAttribArray(a_vertex);
+  glDisableVertexAttribArray(a_othervertex);
+  glDisableVertexAttribArray(a_uv);
+  glDisableVertexAttribArray(a_color);
+  glDisableVertexAttribArray(a_color2);
+}
+
+/* CGO_gl_uniform3f - this is the implementation for the 
+ * CGOUniform3f/CGO_UNIFORM3F operation. From the uniform_id
+ * it looks up the uniform location from the current shader,
+ * and sets it to the values in this op.
+ *
+ */
+static void CGO_gl_uniform3f(CCGORenderer * I, float **pc) {
+  int uniform_id = CGO_get_int(*pc);
+  auto shaderPrg = I->G->ShaderMgr->Get_Current_Shader();
+  if (!shaderPrg){
+    return;
+  }
+  int loc = shaderPrg->GetUniformLocation(
+      shaderPrg->uniformLocations[uniform_id].c_str());
+  float *pcp = *pc + 1;
+  glUniform3f(loc, pcp[0], pcp[1], pcp[2]);
+}
+
+static void CGO_gl_linewidth(CCGORenderer * I, float **pc)
+{
+#ifndef _WEBGL
+  glLineWidth(**pc);
+#endif
+}
+
+/*
+ * call glLineWidth and set the "line_width" uniform
+ */
+static void glLineWidthAndUniform(float line_width,
+    CShaderPrg * shaderPrg=NULL) {
+#ifndef _WEBGL
+  glLineWidth(line_width);
+#endif
+
+  if (shaderPrg && shaderPrg->name == "trilines")
+    shaderPrg->Set1f("line_width", line_width);
+}
+
+/* CGO_gl_special - this is the implementation function for 
+   CGOSpecial/CGO_SPECIAL.  Each op has its own implementation.
+ */
+static void CGO_gl_special(CCGORenderer * I, float **pc)
+{
+  int mode = CGO_get_int(*pc);
+  char varwidth = 0;
+  float vScale = (I->info ? I->info->vertex_scale : SceneGetScreenVertexScale(I->G, NULL));
+
+  CSetting *csSetting = NULL, *objSetting = NULL;
+  auto shaderPrg = I->G->ShaderMgr->Get_Current_Shader();
+  if (I->rep && I->rep->cs){
+    csSetting = I->rep->cs->Setting;
+  }
+  if (I->rep && I->rep->obj){
+    objSetting = I->rep->obj->Setting;
+  }
+  switch (mode){
+  case LINEWIDTH_DYNAMIC_WITH_SCALE_RIBBON:
+    {
+      float line_width = SceneGetDynamicLineWidth(I->info, SettingGet_f(I->G, NULL, NULL, cSetting_ribbon_width));
+      if (I->info && I->info->width_scale_flag){
+        line_width *= I->info->width_scale;
+      }
+      glLineWidthAndUniform(line_width, shaderPrg);
+    }
+    break;
+  case LINEWIDTH_DYNAMIC_WITH_SCALE_DASH:
+    {
+      float line_width = SceneGetDynamicLineWidth(I->info, SettingGet_f(I->G, NULL, NULL, cSetting_dash_width));
+      if (I->info && I->info->width_scale_flag){
+        line_width *= I->info->width_scale;
+      }
+      glLineWidthAndUniform(line_width, shaderPrg);
+    }
+    break;
+  case LINEWIDTH_DYNAMIC_WITH_SCALE:
+    {
+      float line_width = SceneGetDynamicLineWidth(I->info, SettingGet_f(I->G, NULL, NULL, cSetting_line_width));
+      if (I->info && I->info->width_scale_flag){
+        line_width *= I->info->width_scale;
+      }
+      glLineWidthAndUniform(line_width, shaderPrg);
+    }
+    break;
+  case LINEWIDTH_WITH_SCALE:
+    {
+      float line_width = SettingGet_f(I->G, NULL, NULL, cSetting_line_width);
+      if (I->info && I->info->width_scale_flag){
+        line_width *= I->info->width_scale;
+      }
+      glLineWidthAndUniform(line_width, shaderPrg);
+    }
+    break;
+  case LINEWIDTH_DYNAMIC_MESH:
+    {
+      float line_width;
+      if (I->rep){
+        line_width = SettingGet_f(I->G, I->rep->cs->Setting, I->rep->obj->Setting, cSetting_mesh_width);
+      } else {
+        line_width = SettingGet_f(I->G, NULL, NULL, cSetting_mesh_width);
+      }
+      line_width = SceneGetDynamicLineWidth(I->info, line_width);
+      glLineWidthAndUniform(line_width, shaderPrg);
+    }
+    break;
+  case POINTSIZE_DYNAMIC_DOT_WIDTH:
+    {
+      float ps;
+      if(I->info && I->info->width_scale_flag){
+        ps = SettingGet_f
+          (I->G, csSetting, objSetting,
+           cSetting_dot_width) * I->info->width_scale;
+      }
+      else {
+        ps = SettingGet_f
+          (I->G, csSetting, objSetting, cSetting_dot_width);
+      }
+      glPointSize(ps);
+      break;
+    }
+  case CYLINDERWIDTH_DYNAMIC_MESH:
+    {
+      CSetting *setting = NULL;
+      float mesh_width;
+      if (I && I->rep && I->rep->obj){
+        setting = I->rep->obj->Setting;
+      }
+      mesh_width = SettingGet_f(I->G, setting, NULL, cSetting_mesh_width);
+      if (shaderPrg) {
+        const float * color = I->color ? I->color : g_ones4f;
+	shaderPrg->Set1f("uni_radius", SceneGetLineWidthForCylinders(I->G, I->info, mesh_width));
+        shaderPrg->SetAttrib4fLocation("a_Color", color[0], color[1], color[2], I->alpha);
+        shaderPrg->SetAttrib4fLocation("a_Color2", color[0], color[1], color[2], I->alpha);
+      }
+    }
+    break;
+  case DOTSIZE_WITH_SPHERESCALE:
+    {
+      float radius = SettingGet_f(I->G, csSetting, objSetting, cSetting_dot_width);
+      radius *= vScale;
+      if (shaderPrg)
+	shaderPrg->Set1f("sphere_size_scale", fabs(radius));
+    }
+    break;
+  case MESH_WIDTH_FOR_SURFACES:
+    {
+      float mesh_width = SettingGet_f(I->G, csSetting, objSetting, cSetting_mesh_width);
+      if (shaderPrg)
+	shaderPrg->Set1f("uni_radius", SceneGetLineWidthForCylinders(I->G, I->info, mesh_width));
+    }
+    break;
+  case CYLINDER_WIDTH_FOR_DISTANCES:
+    {
+      float pixel_scale_value = SettingGetGlobal_f(I->G, cSetting_ray_pixel_scale);
+      float line_width, radius;
+      int round_ends;
+      round_ends =
+        SettingGet_b(I->G, csSetting, objSetting, cSetting_dash_round_ends);
+      line_width = 
+        SettingGet_f(I->G, csSetting, objSetting, cSetting_dash_width);
+      radius =
+        SettingGet_f(I->G, csSetting, objSetting, cSetting_dash_radius);
+      
+      line_width = SceneGetDynamicLineWidth(I->info, line_width);
+
+      if(pixel_scale_value < 0)
+        pixel_scale_value = 1.0F;
+      if (shaderPrg) {
+	if(radius == 0.0F) {
+	  shaderPrg->Set1f("uni_radius", vScale * pixel_scale_value * line_width/ 2.f);
+	} else {
+	  shaderPrg->Set1f("uni_radius", radius);
+	}
+	if (!round_ends){
+	  shaderPrg->Set1i("no_flat_caps", 0);
+	}
+      }
+    }
+    break;
+  case CYLINDER_WIDTH_FOR_RIBBONS:
+    {
+      float pixel_scale_value = SettingGetGlobal_f(I->G, cSetting_ray_pixel_scale);
+      float line_width, radius;
+      line_width = 
+        SettingGet_f(I->G, csSetting, objSetting, cSetting_ribbon_width);
+      radius =
+        SettingGet_f(I->G, csSetting, objSetting, cSetting_ribbon_radius);
+      
+      line_width = SceneGetDynamicLineWidth(I->info, line_width);
+      if(pixel_scale_value < 0)
+        pixel_scale_value = 1.0F;
+      if (shaderPrg) {
+	if(radius == 0.0F) {
+	  shaderPrg->Set1f("uni_radius", vScale * pixel_scale_value * line_width/ 2.f);
+	} else {
+	  shaderPrg->Set1f("uni_radius", radius);
+	}
+      }
+    }
+    break;
+  case DOT_WIDTH_FOR_DOTS:
+    {
+      float dot_width = SettingGet_f(I->G, csSetting, objSetting, cSetting_dot_width);
+      float radius;
+      if(I->info && I->info->width_scale_flag)
+        radius = (dot_width * I->info->width_scale);
+      else
+        radius= dot_width;
+      if (shaderPrg)
+	shaderPrg->Set1f("g_PointSize", radius);
+#ifndef _PYMOL_IOS
+      glPointSize(radius);
+#endif
+    }
+    break;
+  case DOT_WIDTH_FOR_DOT_SPHERES:
+    {
+      float dotSize = SettingGet_f(I->G, csSetting, objSetting, cSetting_dot_radius);
+      float dot_width = SettingGet_f(I->G, csSetting, objSetting, cSetting_dot_width);
+      float radius;
+      if(I->info && dotSize <= 0.0F) {
+        if(I->info->width_scale_flag)
+          radius = dot_width * I->info->width_scale * I->info->vertex_scale / 1.4142F;
+        else
+          radius = dot_width * I->info->vertex_scale;
+      } else {
+        radius = dotSize;
+      }
+      if (shaderPrg)
+	shaderPrg->Set1f("sphere_size_scale", fabs(radius));
+    }
+    break;
+  case CYLINDER_WIDTH_FOR_NONBONDED:
+    {
+      float line_width = SettingGet_f(I->G, csSetting, objSetting, cSetting_line_width);
+      float pixel_scale_value = SettingGetGlobal_f(I->G, cSetting_ray_pixel_scale);
+      /*
+      float scale_bound = SettingGetGlobal_f(I->G, cSetting_field_of_view)  * cPI / 180.0f * 0.018f;
+      if (I->info && I->info->vertex_scale < scale_bound) {
+        I->info->vertex_scale = scale_bound;
+        }*/ // should this be here???
+      if(pixel_scale_value < 0)
+        pixel_scale_value = 1.0F;
+      if (shaderPrg){
+        shaderPrg->Set1f("uni_radius", vScale * pixel_scale_value * line_width/ 2.f);
+      }
+    }
+    break;
+  case CYLINDER_WIDTH_FOR_REPWIRE_VARWIDTH:
+    varwidth = 1;
+  case CYLINDER_WIDTH_FOR_REPWIRE:
+    {
+      float radius = SettingGet_f(I->G, csSetting, objSetting, cSetting_line_radius);
+      if (radius < R_SMALL8) {
+        float line_width = SettingGet_f(I->G, csSetting, objSetting, cSetting_line_width);
+        float pixel_scale_value = SettingGetGlobal_f(I->G, cSetting_ray_pixel_scale);
+        float vertex_scale = vScale;
+        float scale_bound = SettingGetGlobal_f(I->G, cSetting_field_of_view)  * cPI / 180.0f * 0.018f;
+        if (!varwidth){
+          line_width = SceneGetDynamicLineWidth(I->info, line_width);
+        }
+        if (vertex_scale < scale_bound) {
+          vertex_scale = scale_bound;
+        }
+        if(pixel_scale_value < 0)
+          pixel_scale_value = 1.0F;
+        radius = vertex_scale * pixel_scale_value * line_width / 2.f;
+      }
+      if (shaderPrg){
+	shaderPrg->Set1f("uni_radius", radius);
+      }
+    }
+    break;
+  case ENABLE_BACK_FACES_IF_NOT_TWO_SIDED:
+    {
+      int two_sided_lighting = SettingGet_i(I->G, csSetting, objSetting, cSetting_two_sided_lighting) > 0;
+      if (!two_sided_lighting){
+        glCullFace(GL_BACK);
+        glEnable(GL_CULL_FACE);
+      }
+    }
+    break;
+  case DISABLE_BACK_FACES_IF_NOT_TWO_SIDED:
+    {
+      int two_sided_lighting = SettingGet_i(I->G, csSetting, objSetting, cSetting_two_sided_lighting) > 0;
+      if (!two_sided_lighting){
+        glDisable(GL_CULL_FACE);
+      }
+    }
+    break;
+  case SET_SURFACE_UNIFORMS:
+    {
+      float ambient_occlusion_scale = 0.f;
+      int ambient_occlusion_mode = SettingGet_i(I->G, csSetting, objSetting, cSetting_ambient_occlusion_mode);
+      
+      if (ambient_occlusion_mode){
+        ambient_occlusion_scale = SettingGet_f(I->G, csSetting, objSetting, cSetting_ambient_occlusion_scale);
+      }
+      if (shaderPrg)
+	shaderPrg->Set1f("ambient_occlusion_scale", ambient_occlusion_scale);
+    }
+    break;
+  case SET_ALIGNMENT_UNIFORMS_ATTRIBS:
+    {
+      float linewidth = SettingGet_f(I->G, csSetting, objSetting, cSetting_cgo_line_width);
+      float lineradius = SettingGet_f(I->G, csSetting, objSetting, cSetting_cgo_line_radius);
+      float pixel_scale_value = SettingGetGlobal_f(I->G, cSetting_ray_pixel_scale);
+      if (linewidth < 0.f){
+        linewidth = 1.f;
+      }
+      if(pixel_scale_value < 0)
+        pixel_scale_value = 1.0F;
+      if (lineradius < 0.f){
+        lineradius = linewidth * vScale * pixel_scale_value / 2.f;
+      }
+      shaderPrg->Set1f("uni_radius", lineradius);
+      if (I->color){
+        shaderPrg->SetAttrib4fLocation("a_Color", I->color[0], I->color[1], I->color[2], 1.f);
+        shaderPrg->SetAttrib4fLocation("a_Color2", I->color[0], I->color[1], I->color[2], 1.f);
+      }
+      glLineWidthAndUniform(lineradius*2.f / vScale, shaderPrg);
+    }
+    break;
+  case LINEWIDTH_FOR_LINES:
+    {
+      float line_width = SceneGetDynamicLineWidth(I->info,
+          SettingGet_f(I->G, NULL, NULL, cSetting_line_width));
+      if (I->info && I->info->width_scale_flag){
+        line_width *= I->info->width_scale;
+      }
+      glLineWidthAndUniform(line_width, shaderPrg);
+    }
+    break;
+  case SET_LABEL_SCALE_UNIFORMS:
+  {
+    if (I->rep){
+      float label_size;
+      CSetting * set1 = NULL, * set2 = NULL;
+      if (I->rep->cs) set1 = I->rep->cs->Setting;
+      if (I->rep->obj) set2 = I->rep->obj->Setting;
+      label_size = SettingGet_f(I->G, set1, set2, cSetting_label_size);
+      shaderPrg->Set1f("scaleByVertexScale", label_size < 0.f ? 1.f : 0.f);
+      if (label_size<0.f){
+        shaderPrg->Set1f("labelTextureSize", (float)-2.f* I->info->texture_font_size/label_size);
+      }
+    }
+
+
+  }
+  break;
+  default:
+    PRINTFB(I->G, FB_CGO, FB_Warnings) " CGO_gl_special(): bad mode=%d\n", mode ENDFB(I->G);
+  }
+}
+
+/* CGO_gl_special_with_arg - this is the implementation function for 
+   CGOSpecialWithArg/CGO_SPECIAL_WITH_ARG.  Each op has its own implementation.
+ */
+static void CGO_gl_special_with_arg(CCGORenderer * I, float **pc)
+{
+#ifndef PURE_OPENGL_ES_2
+  int mode = CGO_get_int(*pc);
+  float argval = *((*pc) + 1);
+  bool use_shaders = SettingGetGlobal_b(I->G, cSetting_use_shaders);
+  bool sphere_use_shaders = use_shaders && SettingGetGlobal_b(I->G, cSetting_use_shaders);
+  switch(mode){
+  case LINEWIDTH_FOR_LINES:
+    {
+      if (!use_shaders){
+        glEnd();
+        glLineWidth(argval);
+        glBegin(GL_LINES);
+      }
+    }
+    break;
+  case LINE_LIGHTING:
+    if (!I->isPicking && !SettingGetGlobal_b(I->G, cSetting_use_shaders)) {
+      if (!I->info->line_lighting){
+        bool enableLighting = (int)argval;
+        if (enableLighting)
+          glEnable(GL_LIGHTING);
+        else
+          glDisable(GL_LIGHTING);
+      }
+    }
+    break;
+  case SPHERE_MODE_OPS:
+    {
+      float pixel_scale = 1.0F / I->info->vertex_scale;
+      int sphere_mode = (int)fabs(argval);
+      bool enable = argval > 0.f;
+      if (enable){
+        float pointSize;
+        if((sphere_mode == 1) || (sphere_mode == 6)) {
+          pointSize = SettingGet_f(I->G, I->set1, I->set2, cSetting_sphere_point_size);
+          glDisable(GL_POINT_SMOOTH);
+          glDisable(GL_ALPHA_TEST);
+          if (!I->isPicking && !sphere_use_shaders){
+            glEnable(GL_LIGHTING);
+            glHint(GL_POINT_SMOOTH_HINT, GL_FASTEST);
+          }
+        } else {
+          float sphere_scale = SettingGet_f(I->G, I->set1, I->set2, cSetting_sphere_scale);
+          if((sphere_mode == 3) || (sphere_mode == 8)) {
+            glEnable(GL_POINT_SMOOTH);
+            glAlphaFunc(GL_GREATER, 0.5F);
+            glEnable(GL_ALPHA_TEST);
+            glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);
+            pointSize = sphere_scale * pixel_scale * 2.0F;
+          } else {
+            glHint(GL_POINT_SMOOTH_HINT, GL_FASTEST);
+            glDisable(GL_POINT_SMOOTH);
+            glDisable(GL_ALPHA_TEST);
+            pointSize = sphere_scale * pixel_scale * 1.4F;
+          }
+        }
+        if(!I->isPicking && ((sphere_mode == 7) || (sphere_mode == 8)))
+          glEnable(GL_LIGHTING);
+        glPointSize(pointSize);
+      } else {
+        if(sphere_mode == 3) {
+          glDisable(GL_POINT_SMOOTH);
+          glAlphaFunc(GL_GREATER, 0.05F);
+        } else {
+          glEnable(GL_ALPHA_TEST);
+        }
+      }
+    }
+  }
+#endif
+}
+
+static void CGO_gl_dotwidth(CCGORenderer * I, float **pc)
+{
+  glPointSize(**pc);
+}
+
+static void CGO_gl_enable(CCGORenderer * I, float **pc)
+{
+  GLenum mode = CGO_get_int(*pc);
+  CShaderMgr *shaderMgr = I->G->ShaderMgr;
+  CShaderPrg *shaderPrg = shaderMgr->Get_Current_Shader();
+  if (I->use_shader){
+    if (true){
+      switch(mode){
+      case CGO_GL_LIGHTING:
+        {
+          if (shaderPrg){
+            shaderPrg->SetLightingEnabled(1);
+          }
+        }
+        break;
+      case GL_SHADER_LIGHTING:
+        if (!I->isPicking){
+          if (shaderPrg){
+            shaderPrg->SetLightingEnabled(1);
+          }
+        }
+        break;
+      case GL_TWO_SIDED_LIGHTING:
+        {
+          if (shaderPrg){
+            shaderPrg->Set1i("two_sided_lighting_enabled", 1);
+          }
+        }
+        break;
+      case GL_MESH_LIGHTING:
+        {
+          int lighting =
+            SettingGet_i(I->G, I->set1, I->set2, cSetting_mesh_lighting);
+          if (shaderPrg){
+            shaderPrg->SetLightingEnabled(lighting);
+          }
+        }
+        break;
+      case GL_DOT_LIGHTING:
+        {
+          int lighting =
+            SettingGet_i(I->G, I->set1, I->set2, cSetting_dot_lighting);
+          if (shaderPrg && !I->isPicking){
+            shaderPrg->SetLightingEnabled(lighting);
+            shaderPrg->Set1i("two_sided_lighting_enabled", 0);
+          }
+        }
+        break;
+      case GL_LABEL_FLOAT_TEXT:
+        {
+          int float_text =
+            SettingGet_i(I->G, I->set1, I->set2, cSetting_float_labels);
+          if (float_text){
+            glDisable(GL_DEPTH_TEST);
+          }
+        }
+        break;
+      case GL_DASH_TRANSPARENCY_DEPTH_TEST:
+        {
+          float dash_transparency =
+            SettingGet_f(I->G, I->set1, I->set2, cSetting_dash_transparency);
+          short dash_transparency_enabled;
+          bool t_mode_3 =
+            SettingGet_i(I->G, I->set1, I->set2, cSetting_transparency_mode) == 3;
+          dash_transparency = (dash_transparency < 0.f ? 0.f : (dash_transparency > 1.f ? 1.f : dash_transparency));
+          dash_transparency_enabled = (dash_transparency > 0.f);
+          if (dash_transparency_enabled && !t_mode_3 && !I->isPicking){
+            glDisable(GL_DEPTH_TEST);
+          }
+        }
+        break;
+      case GL_DEFAULT_SHADER:
+        shaderMgr->Enable_DefaultShader(I->info ? I->info->pass : 0);
+        break;
+      case GL_LINE_SHADER:
+        shaderMgr->Enable_LineShader(I->info ? I->info->pass : 0);
+        break;
+      case GL_SURFACE_SHADER:
+        shaderMgr->Enable_SurfaceShader(I->info ? I->info->pass : 0);
+        break;
+      case GL_CYLINDER_SHADER:
+        shaderMgr->Enable_CylinderShader(I->info ? I->info->pass : 0);
+        break;
+      case GL_SPHERE_SHADER:
+        shaderMgr->Enable_DefaultSphereShader(I->info ? I->info->pass : 0);
+        break;
+      case GL_RAMP_SHADER:
+        shaderMgr->Enable_RampShader();
+        break;
+      case GL_DEFAULT_SHADER_WITH_SETTINGS:
+        shaderMgr->Enable_DefaultShaderWithSettings(I->set1, I->set2, I->info ? I->info->pass : 0);
+        break;
+      case GL_BACKGROUND_SHADER:
+        shaderMgr->Enable_BackgroundShader();
+        break;
+      case GL_LABEL_SHADER:
+        shaderMgr->Enable_LabelShader(I->info ? I->info->pass : 0);
+        break;
+      case GL_CONNECTOR_SHADER:
+        shaderMgr->Enable_ConnectorShader(I->info ? I->info->pass : 0);
+        break;
+      case GL_SCREEN_SHADER:
+        shaderMgr->Enable_ScreenShader();
+        break;
+      case GL_TRILINES_SHADER:
+        shaderMgr->Enable_TriLinesShader();
+        break;
+#ifndef _PYMOL_NO_AA_SHADERS
+#endif
+      case GL_OIT_SHADER:
+        shaderMgr->Enable_OITShader();
+        break;
+      case GL_OIT_COPY_SHADER:
+        shaderMgr->Enable_OITCopyShader();
+        break;
+      case GL_BACK_FACE_CULLING:
+        glCullFace(GL_BACK);
+        glEnable(GL_CULL_FACE);
+        break;
+      case GL_DEPTH_TEST:
+        glEnable(mode);
+        break;
+      case GL_DEPTH_TEST_IF_FLOATING:
+        {
+          int float_text = SettingGet_i(I->G, I->set1, I->set2, cSetting_float_labels);
+          if(float_text)
+            glEnable(GL_DEPTH_TEST);
+        }
+        break;
+      }
+    }
+  } else {
+    if (!I->isPicking){
+      if (mode==CGO_GL_LIGHTING){
+        glEnable(GL_LIGHTING);
+      }
+    }
+  }
+}
+
+static void CGO_gl_disable(CCGORenderer * I, float **pc)
+{
+  GLenum mode = CGO_get_int(*pc);
+  auto shaderPrg = I->G->ShaderMgr->Get_Current_Shader();
+  if (I->use_shader){
+      switch(mode){
+      case GL_SHADER_LIGHTING:
+        {
+          if (shaderPrg){
+            shaderPrg->SetLightingEnabled(0);
+          }
+        }
+        break;
+      case GL_CYLINDER_SHADER:
+        glDisable(GL_CULL_FACE);
+      case GL_RAMP_SHADER:
+      case GL_SCREEN_SHADER:
+      case GL_LABEL_SHADER:
+      case GL_CONNECTOR_SHADER:
+      case GL_DEFAULT_SHADER:
+      case GL_SURFACE_SHADER:
+      case GL_SPHERE_SHADER:
+      case GL_TRILINES_SHADER:
+      case GL_OIT_COPY_SHADER:
+      case GL_LINE_SHADER:
+        {
+          if (shaderPrg){
+	    shaderPrg->Disable();
+          }
+        }
+        break;
+      case GL_LABEL_FLOAT_TEXT:
+        {
+          int float_text =
+            SettingGet_i(I->G, I->set1, I->set2, cSetting_float_labels);
+          if (float_text){
+            glEnable(GL_DEPTH_TEST);
+          }
+        }
+        break;
+      case GL_DASH_TRANSPARENCY_DEPTH_TEST:
+        {
+          float dash_transparency =
+            SettingGet_f(I->G, I->set1, I->set2, cSetting_dash_transparency);
+          short dash_transparency_enabled;
+          bool t_mode_3 =
+            SettingGet_i(I->G, I->set1, I->set2, cSetting_transparency_mode) == 3;
+          dash_transparency = (dash_transparency < 0.f ? 0.f : (dash_transparency > 1.f ? 1.f : dash_transparency));
+          dash_transparency_enabled = (dash_transparency > 0.f);
+          if (dash_transparency_enabled && !t_mode_3 && !I->isPicking){
+            glEnable(GL_DEPTH_TEST);
+          }
+        }
+        break;
+      case CGO_GL_LIGHTING:
+        {
+          if (shaderPrg){
+            shaderPrg->SetLightingEnabled(0);
+          }
+        }
+        break;
+      case GL_TWO_SIDED_LIGHTING:
+        {
+          if (shaderPrg){
+            shaderPrg->Set1i("two_sided_lighting_enabled", 0);
+          }
+        }
+        break;
+#if !defined(PURE_OPENGL_ES_2) || defined(_WEBGL)
+      case GL_OIT_SHADER:
+      case GL_SMAA1_SHADER:
+      case GL_SMAA2_SHADER:
+        glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, I->G->ShaderMgr->default_framebuffer_id);
+        break;
+#endif
+      case GL_BACK_FACE_CULLING:
+        glDisable(GL_CULL_FACE);
+        break;
+      case GL_DEPTH_TEST:
+        glDisable(mode);
+        break;
+      case GL_DEPTH_TEST_IF_FLOATING:
+        {
+          int float_text = SettingGet_i(I->G, I->set1, I->set2, cSetting_float_labels);
+          if(float_text)
+            glDisable(GL_DEPTH_TEST);
+        }
+        break;
+      }
+  } else {
+    if (mode!=CGO_GL_LIGHTING || !I->isPicking){
+        if (mode==CGO_GL_LIGHTING)
+            mode = GL_LIGHTING;
+      glDisable(mode);
+    }
+  }
+}
+
+static void CGO_gl_alpha(CCGORenderer * I, float **pc)
+{
+  I->alpha = **pc;
+}
+
+static void CGO_gl_reset_normal(CCGORenderer * I, float **pc)
+{
+  SceneResetNormalUseShader(I->G, CGO_get_int(*pc), I->use_shader);
+}
+
+static void CGO_gl_null(CCGORenderer * I, float **pc)
+{
+}
+
+static void CGO_gl_error(CCGORenderer * I, float **pc)
+{
+  PRINTFB(I->G, FB_CGO, FB_Warnings) " CGO_gl_error() is not suppose to be called op=%d with mask=%d\n", CGO_get_int((*pc)-1), CGO_MASK & CGO_get_int((*pc)-1) ENDFB(I->G);
+}
+
+static void CGO_gl_color_impl(CCGORenderer * I, float *v){
+  if (I->use_shader){
+    auto shaderPrg = I->G->ShaderMgr->Get_Current_Shader();
+    if (shaderPrg){
+      int attr_a_Color = shaderPrg->GetAttribLocation("a_Color");
+      glVertexAttrib4f(attr_a_Color, v[0], v[1], v[2], I->alpha);
+    }
+  } else {
+    glColor4f(v[0], v[1], v[2], I->alpha);
+  }
+}
+
+static void CGO_gl_color(CCGORenderer * I, float **varg)
+{
+  float *v = *varg;
+  CGO_gl_color_impl(I, v);
+}
+
+static void CGO_gl_sphere(CCGORenderer * I, float **varg)
+{
+  float *v = *varg;
+  if (I->isPicking){
+    SphereRender(I->G, 0, v, I->color, I->alpha, v[3]);
+  } else {
+    SphereRender(I->G, I->sphere_quality, v, NULL, I->alpha, v[3]);
+  }
+}
+
+static void CGO_gl_vertex_attribute_3f(CCGORenderer * I, float **varg)
+{
+    auto vertex_attr = reinterpret_cast<cgo::draw::vertex_attribute_3f *>(*varg);
+    auto shaderPrg = I->G->ShaderMgr->Get_Current_Shader();
+    int loc = shaderPrg->GetAttribLocation(I->G->ShaderMgr->GetAttributeName(vertex_attr->attr_lookup_idx));
+    if (loc >= 0)
+      glVertexAttrib3fv(loc, vertex_attr->values);
+}
+
+static void CGO_gl_vertex_attribute_4ub(CCGORenderer * I, float **varg)
+{
+    auto vertex_attr = reinterpret_cast<cgo::draw::vertex_attribute_4ub *>(*varg);
+    auto shaderPrg = I->G->ShaderMgr->Get_Current_Shader();
+    int loc = shaderPrg->GetAttribLocation(I->G->ShaderMgr->GetAttributeName(vertex_attr->attr_lookup_idx));
+    if (loc >= 0)
+      glVertexAttrib4ubv(loc, vertex_attr->ubdata);
+}
+
+static void CGO_gl_vertex_attribute_4ub_if_picking(CCGORenderer * I, float **varg)
+{
+  if (I->isPicking){
+    auto vertex_attr = reinterpret_cast<cgo::draw::vertex_attribute_4ub_if_picking *>(*varg);
+    auto shaderPrg = I->G->ShaderMgr->Get_Current_Shader();
+    int loc = shaderPrg->GetAttribLocation(I->G->ShaderMgr->GetAttributeName(vertex_attr->attr_lookup_idx));
+    if (loc >= 0)
+      glVertexAttrib4ubv(loc, vertex_attr->ubdata);
+  }
+}
+
+static void CGO_gl_vertex_attribute_1f(CCGORenderer * I, float **varg)
+{
+    auto vertex_attr = reinterpret_cast<cgo::draw::vertex_attribute_1f *>(*varg);
+    auto shaderPrg = I->G->ShaderMgr->Get_Current_Shader();
+    const char *name = I->G->ShaderMgr->GetAttributeName(vertex_attr->attr_lookup_idx);
+    int loc = shaderPrg->GetAttribLocation(name);
+    if (loc >= 0)
+      glVertexAttrib1f(loc, vertex_attr->value);
+}
+
+/* dispatch table for OpenGL */
+
+CGO_op_fn CGO_gl[] = {
+  CGO_gl_null,                  /* 0x00 */
+  CGO_gl_null,                  /* 0x01 */
+  CGO_gl_begin,                 /* 0x02 */
+  CGO_gl_end,                   /* 0x03 */
+  CGO_gl_vertex,                /* 0x04 */
+  CGO_gl_normal,                /* 0x05 */
+  CGO_gl_color,                 /* 0x06 */
+  CGO_gl_sphere,                /* 0x07 */
+  CGO_gl_null,                  /* 0x08 */
+  CGO_gl_null,                  /* 0x09 */
+
+  CGO_gl_linewidth,             /* 0x0A */
+  CGO_gl_null,                  /* 0x0B */
+  CGO_gl_enable,                /* 0x0C */
+  CGO_gl_disable,               /* 0x0D */
+  CGO_gl_null,                  /* 0x0E */
+  CGO_gl_null,                  /* 0x0F */
+
+  CGO_gl_dotwidth,              /* 0X10 */
+  CGO_gl_null,                  /* 0x11 */
+  CGO_gl_null,                  /* 0x12 */
+  CGO_gl_null,                  /* 0X13 */
+
+  CGO_gl_null,                  /* 0X14 */
+  CGO_gl_null,                  /* 0x15 */
+  CGO_gl_null,                  /* 0x16 */
+  CGO_gl_null,                  /* 0X17 */
+
+  CGO_gl_null,                  /* 0X18 */
+  CGO_gl_alpha,                 /* 0x19 */
+  CGO_gl_null,                  /* 0x1A */
+  CGO_gl_null,                  /* 0X1B */
+  CGO_gl_draw_arrays,           /* 0x1C DrawArrays() */
+  CGO_gl_null,                  /* 0x1D */
+  CGO_gl_reset_normal,          /* 0x1E */
+  CGO_gl_null,                  /* pick color  0X1F */
+  CGO_gl_null,                  /* 0x20 draw buffers REMOVED */
+  CGO_gl_draw_buffers_indexed,          /* 0x21 draw buffers indexed */
+  CGO_gl_null,                  /* 0x22 bounding box */
+  CGO_gl_draw_buffers_not_indexed,          /* 0x23 draw buffers not indexed */
+  CGO_gl_special,                /* 0x24 special */
+  CGO_gl_draw_cylinder_buffers,  /* 0x25 draw GLSL cylinders */
+  CGO_gl_null,                  /* 0x26 shader cylinder */
+  CGO_gl_null,                  /* 0x27 shader cylinder with 2nd color */
+  CGO_gl_draw_sphere_buffers,   /* 0x28 draw sphere buffers */
+  CGO_gl_null,                  /* 0x29 accessibility used for ambient occlusion */
+  CGO_gl_error,          /* 0x2A draw texture */
+  CGO_gl_draw_textures,          /* 0x2B draw textures */
+  CGO_gl_draw_screen_textures_and_polygons,          /* 0x2C draw screen textures and polygons */
+  CGO_gl_error,
+  CGO_gl_error,  CGO_gl_draw_labels,
+  CGO_gl_error,  CGO_gl_draw_connectors,  CGO_gl_draw_trilines,  CGO_gl_uniform3f,  CGO_gl_special_with_arg,
+  CGO_gl_line,  CGO_gl_splitline,  CGO_gl_draw_custom,
+  CGO_gl_vertex_attribute_3f, CGO_gl_vertex_attribute_4ub,
+  CGO_gl_vertex_attribute_1f, 
+  CGO_gl_mask_attribute_if_picking, CGO_gl_bind_vbo_for_picking,
+  CGO_gl_vertex, 
+  CGO_gl_null, // interpolated
+  CGO_gl_vertex_cross, // CGO_VERTEX_CROSS
+  CGO_gl_vertex_attribute_4ub_if_picking,
+  CGO_gl_error
+};
+
+void SetUCColorFromIndex_32bit(uchar *color, unsigned int idx){
+  color[0] = (idx & 0xFF);
+  color[1] = (idx & 0xFF00) >> 8;
+  color[2] = ((idx & 0xFF0000) >> 16);
+  color[3] = ((idx & 0xFF000000) >> 24);
+}
+
+void SetUCColorFromIndex_16bit(uchar *color, unsigned int idx){
+  color[0] = ((idx & 0xF) << 4);// | 0x8;
+  color[1] = ((idx & 0xF0) | 0x8);
+  color[2] = ((idx & 0xF00) >> 4);// | 0x8;
+  color[3] = 255;
+}
+
+void SetUCColorToZero_32bit(uchar *color){
+  color[0] = 0;
+  color[1] = 0;
+  color[2] = 0;
+  color[3] = 0;
+}
+
+void SetUCColorToZero_16bit(uchar *color){
+  color[0] = 0;
+  color[1] = 0;
+  color[2] = 0;
+  color[3] = 255;
+}
+
+#if 0
+static
+void SetUCColorToPrev(uchar *color){
+  color[0] = color[-4];
+  color[1] = color[-3];
+  color[2] = color[-2];
+  color[3] = color[-1];
+}
+
+static
+void SetUCColorToPrev8(uchar *color){
+  color[0] = color[-8];
+  color[1] = color[-7];
+  color[2] = color[-6];
+  color[3] = color[-5];
+}
+#endif
+
+static
+void SetUCColorToPrevN(int n, uchar *color){
+  color[0] = color[-n*4];
+  color[1] = color[-n*4+1];
+  color[2] = color[-n*4+2];
+  color[3] = color[-n*4+3];
+}
+
+static
+int * get_pickcolorsset_ptr(int op, float * pc) {
+#define RETURN_PICKCOLORSETPTR_CASE(cls) \
+  case cgo::draw::cls::op_code: \
+    return &(reinterpret_cast<cgo::draw::cls*>(pc)->pickcolorsset)
+  switch (op) {
+    RETURN_PICKCOLORSETPTR_CASE(buffers_indexed);
+    RETURN_PICKCOLORSETPTR_CASE(buffers_not_indexed);
+    RETURN_PICKCOLORSETPTR_CASE(labels);
+    RETURN_PICKCOLORSETPTR_CASE(sphere_buffers);
+    RETURN_PICKCOLORSETPTR_CASE(cylinder_buffers);
+    RETURN_PICKCOLORSETPTR_CASE(custom);
+  }
+  return NULL;
+}
+
+void CGORenderGLPicking(CGO * I, RenderInfo *info, PickContext * context, CSetting * set1,
+                        CSetting * set2, Rep *rep)
+{
+  PyMOLGlobals *G = I->G;
+
+  if (!G->ValidContext)
+    return;
+
+  if (!I->c)
+    return;
+
+  int op;
+  CCGORenderer *R = G->CGORenderer;
+  unsigned int i, j;
+  bool pickable = (!I->no_pick) &&
+    SettingGet_b(G, set1, set2, cSetting_pickable);
+  auto pick = info->pick;
+  bool use_shaders = SettingGetGlobal_b(G, cSetting_use_shaders);
+  bool reset_colors = !use_shaders || (pick->begin()->src.bond & 2);
+
+  R->use_shader = I->use_shader;
+  R->isPicking = true;
+  R->picking_32bit = info->picking_32bit;
+  R->pick_mode = pick->begin()->src.bond & 1;
+  R->set1 = set1;
+  R->set2 = set2;
+  R->info = info;
+  R->rep = rep;
+
+  i = pick->begin()->src.index;
+
+#ifndef _WEBGL
+      glLineWidth(SettingGet_f(G, set1, set2, cSetting_cgo_line_width));
+#endif
+
+  for (float *pc = I->op;
+      (op = (CGO_MASK & CGO_read_int(pc)));
+      pc += CGO_sz[op]) {
+
+    switch (op) {
+      case CGO_COLOR:
+        continue;
+
+      case CGO_PICK_COLOR:
+
+        if (reset_colors){ // only if picking info is invalid
+          unsigned char col[4];
+          AssignNewPickColor(I, i, pick, context, col, CGO_get_uint(pc), 
+              pickable ? CGO_get_int(pc + 1) : cPickableNoPick);
+          pick->begin()->src.index = i;
+#ifndef PURE_OPENGL_ES_2
+          if (!I->use_shader){
+            glColor4ubv(col);
+          }
+#endif
+        }
+        continue;
+
+      case CGO_DRAW_ARRAYS:
+        {
+          cgo::draw::arrays * sp = reinterpret_cast<decltype(sp)>(pc);
+          int arrays = sp->arraybits;
+          if (reset_colors && arrays & CGO_PICK_COLOR_ARRAY){ // only if picking info is invalid
+            int nverts = sp->nverts, v, idx = -1, bnd = -1;
+            float *pca = sp->floatdata;
+
+            if (arrays & CGO_VERTEX_ARRAY){ pca += nverts * 3; }
+            if (arrays & CGO_NORMAL_ARRAY){ pca += nverts * 3; }
+            if (arrays & CGO_COLOR_ARRAY){ pca += nverts * 4; }
+
+            auto pickColorValsUC = (uchar*)pca;
+            auto pickColorVals = (int*)(pca + nverts);
+
+            for (v=0;v<nverts; v++) {
+              bnd = pickable ? pickColorVals[v * 2 + 1] : cPickableNoPick;
+
+              if (bnd == cPickableNoPick){
+                info->setUCColorToZero(pickColorValsUC + (v * 4));
+                continue;
+              }
+
+              i++;
+
+              if(!R->pick_mode) {
+                idx = pickColorVals[v * 2];
+                if (pick->size() <= i) {
+                  pick->resize((i + 1) * 3 / 2); // grow by 50%
+                }
+                set_current_pick_color(I, pick->data() + i, context, idx, bnd);
+                j = i;
+              } else {
+                j = i >> 12;
+              }
+
+              info->setUCColorFromIndex(pickColorValsUC + (v * 4), j);
+            }
+          }
+        }
+        break;
+
+      case CGO_DRAW_BUFFERS_INDEXED:
+      case CGO_DRAW_BUFFERS_NOT_INDEXED:
+      case CGO_DRAW_TEXTURES:
+      case CGO_DRAW_LABELS:
+      case CGO_DRAW_SPHERE_BUFFERS:
+      case CGO_DRAW_CYLINDER_BUFFERS:
+      case CGO_DRAW_CUSTOM:
+        {
+          int pickcolors_are_set = true;
+          int *pickcolors_are_set_ptr = get_pickcolorsset_ptr(op, pc);
+          if (!pickcolors_are_set_ptr)
+            pickcolors_are_set_ptr = &pickcolors_are_set;
+
+          if (reset_colors || !*pickcolors_are_set_ptr){ // only if picking info is invalid
+            int nverts = 0;
+            int nvertsperfrag = 1;
+            int v, pl;
+            int bnd = cPickableNoPick, pbnd = cPickableNoPick;
+            int chg = 0;
+            unsigned int idx = 0, pidx = 0;
+            int srcp;
+            float *pca = nullptr;
+            int *pickDataSrc ;
+            uchar *pickColorDestUC = NULL;
+            bool free_pick_color_dest = false;
+            int destOffset = 0, bufsizemult = 1;
+            size_t pickvbo = 0;
+            switch (op){
+              case CGO_DRAW_CUSTOM:
+              {
+                cgo::draw::custom * sp = reinterpret_cast<decltype(sp)>(pc);
+                nverts = sp->nverts;
+                pickvbo = sp->pickvboid;
+                if (!pickvbo)
+                  continue;
+                pca = sp->floatdata;
+                nvertsperfrag = sp->vertsperpickinfo;
+                bufsizemult = sp->npickbufs;
+
+                pickColorDestUC = new uchar[bufsizemult * nverts * 4];
+              }
+                break;
+              case CGO_DRAW_BUFFERS_INDEXED:
+              {
+                cgo::draw::buffers_indexed * sp = reinterpret_cast<decltype(sp)>(pc);
+                nverts = sp->nverts;
+                pickvbo = sp->pickvboid;
+                pca = sp->floatdata;
+              }
+                break;
+              case CGO_DRAW_BUFFERS_NOT_INDEXED:
+              {
+                cgo::draw::buffers_not_indexed * sp = reinterpret_cast<decltype(sp)>(pc);
+                nverts = sp->nverts;
+                pickvbo = sp->pickvboid;
+                pca = sp->floatdata;
+              }
+                break;
+              case CGO_DRAW_SPHERE_BUFFERS:
+              {
+                cgo::draw::sphere_buffers * sp = reinterpret_cast<decltype(sp)>(pc);
+                nverts = sp->num_spheres * VERTICES_PER_SPHERE;
+                nvertsperfrag = VERTICES_PER_SPHERE;
+                pickvbo = sp->pickvboid;
+                pca = sp->floatdata;
+
+                pickColorDestUC = new uchar[nverts * 4];
+              }
+              break;
+              case CGO_DRAW_CYLINDER_BUFFERS:
+              {
+                cgo::draw::cylinder_buffers * sp = reinterpret_cast<decltype(sp)>(pc);
+                nverts = sp->num_cyl * NUM_VERTICES_PER_CYLINDER;
+                nvertsperfrag = NUM_VERTICES_PER_CYLINDER;
+                pickvbo = sp->pickvboid;
+                pca = sp->floatdata;
+                bufsizemult = 2;
+
+                pickColorDestUC = new uchar[bufsizemult * nverts * 4];
+              }
+              break;
+              case CGO_DRAW_TEXTURES:
+              {
+                cgo::draw::textures * sp = reinterpret_cast<decltype(sp)>(pc);
+                nverts = sp->ntextures * 6;
+                pca = sp->floatdata;
+              }
+              break;
+              case CGO_DRAW_LABELS:
+              {
+                cgo::draw::labels * sp;
+                sp = reinterpret_cast<decltype(sp)>(pc);
+                nverts = sp->ntextures * 6;
+                pca = sp->floatdata;
+                pickvbo = sp->pickvboid;
+              }
+                break;
+              }
+
+            if (pickColorDestUC) {
+              free_pick_color_dest = true;
+              pickDataSrc = (int*)(pca);
+            } else {
+              pickColorDestUC = (uchar*)pca;
+              pickDataSrc = (int*)(pca + nverts);
+            }
+
+            if(!R->pick_mode) {
+              destOffset = 0;
+            } else {
+              destOffset = sizeof(float) * nverts * bufsizemult;
+            }
+
+            if (!pickable){
+              memset(pickColorDestUC, 0, 4 * nverts * bufsizemult);
+            } else {
+              int npickbufs = bufsizemult;
+              int ploffsetforbuf = 0;
+              if (op == CGO_DRAW_CYLINDER_BUFFERS){
+                  // disabled 2016-07-19 TH: code looks almost identical to
+                  // else branch and CGO_DRAW_CYLINDER_BUFFERS seem to be
+                  // not used anymore.
+                  PRINTFB(I->G, FB_CGO, FB_Errors)
+                    " FIXME: SUPPOSEDLY UNUSED CODE EXECUTED in CGORenderGLPicking!\n"
+                    ENDFB(I->G);
+              } else {
+                if (op == CGO_DRAW_CUSTOM){
+                  ploffsetforbuf = sizeof(float) * nverts; // for multiple picking attributes
+                }
+                for (v=0, pl = 0;v<nverts; v++, pl += 4){
+                  if (v % nvertsperfrag){
+                    // if same fragment, same color
+                    for (int pi = 0; pi < npickbufs; ++pi){
+                      int ploffset = ploffsetforbuf * pi;
+                      SetUCColorToPrevN(1, &pickColorDestUC[pl+ploffset]);
+                    }
+                    continue;
+                  }
+
+                  int frag = (int)(v / nvertsperfrag);
+                  for (int pi = 0; pi < npickbufs; ++pi){
+                    int ploffset = ploffsetforbuf * pi;
+                    srcp = 2* ((npickbufs * frag) + pi);
+                    pidx = idx;
+                    pbnd = bnd;
+                    idx = pickDataSrc[srcp];
+                    bnd = pickDataSrc[srcp + 1];
+                    if (bnd == cPickableNoPick){
+                      info->setUCColorToZero(&pickColorDestUC[pl+ploffset]);
+                      continue;
+                    }
+                    chg = idx != pidx || bnd != pbnd;
+                    if (chg)
+                      i++;
+                    if(!R->pick_mode) {
+                      j = i;
+                      if (chg){
+                        if (pick->size() <= i) {
+                          pick->resize((i + 1) * 3 / 2);
+                        }
+                        set_current_pick_color(I, pick->data() + i, context, idx, bnd);
+                      }
+                    } else {
+                      j = i >> 12;
+                    }
+                    info->setUCColorFromIndex(&pickColorDestUC[pl+ploffset], j);
+                  }
+                }
+              }
+            }
+
+            if (pickvbo) {
+              // reload entire vbo
+              VertexBuffer * vbo = I->G->ShaderMgr->getGPUBuffer<VertexBuffer>(pickvbo);
+              vbo->bufferReplaceData(destOffset, sizeof(float) * nverts * bufsizemult, pickColorDestUC);
+              (*pickcolors_are_set_ptr) = true;
+            }
+
+            if (free_pick_color_dest){
+              delete[] pickColorDestUC;
+              pickColorDestUC = NULL;
+              free_pick_color_dest = false;
+            }
+          }
+        }
+        break;
+    }
+
+    CGO_gl[op] (R, &pc);
+
+    if(!use_shaders && op == CGO_SPLITLINE) {
+      i = (*pick)[0].src.index;
+    }
+  }
+
+  (*pick)[0].src.index = i; /* pass the count */
+
+  R->isPicking = false;
+}
+
+/* This DEBUG_PRINT_OPS preprocessor, if defined, will print all OPS of every CGO rendered
+   by CGORenderGL().  This is only to be used in debugging */
+//#define DEBUG_PRINT_OPS
+
+void CGORenderGL(CGO * I, const float *color, CSetting * set1, CSetting * set2,
+                 RenderInfo * info, Rep *rep)
+/* this should be as fast as you can make it...
+
+ * the ASM loop is about 2X long as raw looped GL calls,
+
+ * but hopefully superscaler processors won't care */
+{
+  PyMOLGlobals *G = I->G;
+
+  if (I->render_alpha){
+    // for now, the render_alpha_only flag calls CGOSetZVector/CGORenderGLAlpha
+    float *ModMatrix = SceneGetModMatrix(G);
+    CGOSetZVector(I, ModMatrix[2], ModMatrix[6], ModMatrix[10]);
+    CGORenderGLAlpha(I, info, 1);
+    if (I->render_alpha == 1) // right now, render_alpha 1: renders alpha only, 2: renders both alpha and rest
+      return;
+  }
+
+  if(G->ValidContext) {
+    float *pc = I->op;
+    int op;
+    CCGORenderer *R = G->CGORenderer;
+    float _1 = 1.0F;
+    auto shaderPrg = I->G->ShaderMgr->Get_Current_Shader();
+#ifdef DEBUG_PRINT_OPS
+    CGOCountNumberOfOperationsOfType(I, 0);
+#endif
+    R->info = info;
+    R->use_shader = I->use_shader;
+    R->debug = I->debug;
+    R->sphere_quality = I->sphere_quality;
+    R->rep = rep;
+    R->color = color;
+    R->set1 = set1;
+    R->set2 = set2;
+    // normals should be initialized to the view vector
+    // (changed BB 9/14 from SceneResetNormalUseShader(), to CScene->LinesNormal, which was arbitrary, I believe)
+    SceneResetNormalToViewVector(I->G, I->use_shader);  
+
+    if(I->c) {
+      R->alpha = 1.0F - SettingGet_f(I->G, set1, set2, cSetting_cgo_transparency);
+      if (shaderPrg && I->use_shader) {
+        if (color){
+          shaderPrg->SetAttrib4fLocation("a_Color", color[0], color[1], color[2], R->alpha);
+        } else {
+          shaderPrg->SetAttrib4fLocation("a_Color", 1.f, 1.f, 1.f, R->alpha);
+        }
+      } else {
+        if(color)
+          glColor4f(color[0], color[1], color[2], R->alpha);
+        else
+          glColor4f(1.0, 1.0, 1.0, R->alpha);
+      }
+      if(info && info->width_scale_flag) {
+        glLineWidth(SettingGet_f(I->G, set1, set2, cSetting_cgo_line_width) *
+                    info->width_scale);
+        glPointSize(SettingGet_f(I->G, set1, set2, cSetting_cgo_dot_width) *
+                    info->width_scale);
+
+      } else {
+        glLineWidth(SettingGet_f(I->G, set1, set2, cSetting_cgo_line_width));
+        glPointSize(SettingGet_f(I->G, set1, set2, cSetting_cgo_dot_width));
+      }
+      if(info && info->alpha_cgo) {     /* we're sorting transparent triangles globally */
+        int mode = -1;
+        float *n0 = NULL, *n1 = NULL, *n2 = NULL, *v0 = NULL, *v1 = NULL, *v2 =
+          NULL, *c0 = NULL, *c1 = NULL, *c2 = NULL;
+        float zee[] = { 0.0, 0.0, 1.0 }, color_tmp[] = { 1., 1., 1. };
+        int vc = 0;
+	if (color){
+	  I->color[0] = color[0]; I->color[1] = color[1]; I->color[2] = color[2];
+	  c0 = I->color;
+	} else {
+	  c0 = color_tmp;
+	}
+        while((op = (CGO_MASK & CGO_read_int(pc)))) {
+          if((R->alpha != _1)) {
+            switch (op) {       /* transparency */
+            case CGO_BEGIN:
+              mode = CGO_get_int(pc);
+              CGO_gl_begin(R, &pc);
+              vc = 0;
+              n0 = zee;
+              break;
+            case CGO_END:
+              CGO_gl_end(R, &pc);
+              mode = -1;
+              break;
+            case CGO_NORMAL:
+              switch (mode) {
+              case GL_TRIANGLES:
+              case GL_TRIANGLE_STRIP:
+              case GL_TRIANGLE_FAN:
+                n0 = pc;
+                break;
+              default:
+                CGO_gl_normal(R, &pc);
+              }
+              break;
+            case CGO_COLOR:
+              c0 = pc;
+              CGO_gl_color(R, &pc);
+              break;
+            case CGO_TRIANGLE:
+              CGOAlphaTriangle(info->alpha_cgo,
+                               pc, pc + 3, pc + 6, pc + 9, pc + 12, pc + 15, pc + 18,
+                               pc + 21, pc + 24, R->alpha, R->alpha, R->alpha, false);
+              break;
+	    case CGO_DRAW_ARRAYS:
+	      {
+                cgo::draw::arrays * sp = reinterpret_cast<decltype(sp)>(pc);
+		int mode = sp->mode, arrays = sp->arraybits, nverts = sp->nverts;
+		float *vertexVals = 0, *nxtVals = 0, *colorVals = 0, *normalVals;
+		float *vertexVals_tmp = 0, *colorVals_tmp = 0, *normalVals_tmp = 0;
+		int step;
+		short nxtn = 3;
+		nxtVals = vertexVals = vertexVals_tmp = sp->floatdata;
+		if (arrays & CGO_NORMAL_ARRAY){
+		  nxtVals = normalVals = normalVals_tmp = vertexVals + (nxtn*nverts);
+		}
+		if (arrays & CGO_COLOR_ARRAY){
+		  nxtVals = colorVals = colorVals_tmp = nxtVals + (nxtn*nverts);
+		  nxtn = 4;
+		}
+		switch (mode){
+		case GL_TRIANGLES:
+		  {
+		    for (step = 0; step < nverts; step += 3){
+		      if (colorVals_tmp){
+			c0 = colorVals_tmp; c1 = colorVals_tmp+4; c2 = colorVals_tmp+8;
+		      } else {
+			c1 = c2 = c0;
+		      }
+		      if (normalVals_tmp){
+			n0 = normalVals_tmp; n1 = normalVals_tmp+3; n2 = normalVals_tmp+6; 
+		      } else {
+			n1 = n2 = n0;
+		      }
+		      CGOAlphaTriangle(info->alpha_cgo,
+				       vertexVals_tmp, vertexVals_tmp+3, vertexVals_tmp+6,
+				       n0, n1, n2,
+				       c0, c1, c2,
+				       R->alpha, R->alpha, R->alpha, false);
+		      vertexVals_tmp += 9;
+		      if (normalVals_tmp){
+			normalVals_tmp += 9;
+		      }
+		      if (colorVals_tmp){
+			colorVals_tmp += 12;
+		      }
+		    }
+		  }
+		  break;
+		case GL_TRIANGLE_STRIP:
+		  {
+		    if (colorVals_tmp){
+		      c1 = colorVals_tmp; c2 = colorVals_tmp+4;
+		      colorVals_tmp += 8;
+		    } else {
+		      c1 = c2 = c0;
+		    }
+		    if (normalVals_tmp){
+		      n1 = normalVals_tmp; n2 = normalVals_tmp+3;
+		      normalVals_tmp+= 6;
+		    } else {
+		      n1 = n2 = n0;
+		    }
+		    vertexVals_tmp += 6;
+		    for (step = 2; step < nverts; step++){
+		      if (colorVals_tmp){
+			c0 = c1; c1 = c2; c2 = colorVals_tmp;
+		      }
+		      if (normalVals_tmp){
+			n0 = n1; n1 = n2; n2 = normalVals_tmp;
+		      }
+		      CGOAlphaTriangle(info->alpha_cgo,
+				       vertexVals_tmp-6, vertexVals_tmp-3, vertexVals_tmp,
+				       n0, n1, n2,
+				       c0, c1, c2,
+				       R->alpha, R->alpha, R->alpha, false);
+		      vertexVals_tmp += 3;
+		      if (normalVals_tmp){
+			normalVals_tmp += 3;
+		      }
+		      if (colorVals_tmp){
+			colorVals_tmp += 4;
+		      }
+		    }
+		  }
+		  break;
+		case GL_TRIANGLE_FAN:
+		  {
+		    float *firstVertex = vertexVals_tmp;
+		    if (colorVals_tmp){
+		      c0 = colorVals_tmp;
+		      c2 = colorVals_tmp + 4;
+		      colorVals_tmp += 8;
+		    } else {
+		      c1 = c2 = c0;
+		    }
+		    if (normalVals_tmp){
+		      n0 = normalVals_tmp; 
+		      n2 = normalVals_tmp + 3;
+		      normalVals_tmp += 6;
+		    }
+		    vertexVals_tmp += 6;
+		    for (step = 2; step < nverts; step++){
+		      if (colorVals_tmp){
+			c1 = c2; c2 = colorVals_tmp;
+		      }
+		      if (normalVals_tmp){
+			n1 = n2; n2 = normalVals_tmp;
+		      }
+		      CGOAlphaTriangle(info->alpha_cgo,
+				       firstVertex, vertexVals_tmp-3, vertexVals_tmp,
+				       n0, n1, n2,
+				       c0, c1, c2,
+				       R->alpha, R->alpha, R->alpha, false);
+		      vertexVals_tmp += 3;
+		      if (normalVals_tmp){
+			normalVals_tmp += 3;
+		      }
+		      if (colorVals_tmp){
+			colorVals_tmp += 4;
+		      }
+		    }
+		  }
+		  break;
+		}
+	      }
+	      break;
+            case CGO_VERTEX:
+              v0 = pc;
+              switch (mode) {
+              case GL_TRIANGLES:
+                if(3 * ((vc + 1) / 3) == vc + 1) {
+                  CGOAlphaTriangle(info->alpha_cgo,
+                                   v0, v1, v2, n0, n1, n2, c0, c1, c2,
+                                   R->alpha, R->alpha, R->alpha, true);
+                }
+                v2 = v1;
+                c2 = c1;
+                n2 = n1;
+                v1 = v0;
+                c1 = c0;
+                n1 = n0;
+                vc++;
+                break;
+              case GL_TRIANGLE_STRIP:
+                if(vc > 1) {
+                  CGOAlphaTriangle(info->alpha_cgo,
+                                   v0, v1, v2, n0, n1, n2, c0, c1, c2,
+                                   R->alpha, R->alpha, R->alpha, !(vc & 0x1));
+                }
+                v2 = v1;
+                c2 = c1;
+                n2 = n1;
+                v1 = v0;
+                c1 = c0;
+                n1 = n0;
+                vc++;
+                break;
+              case GL_TRIANGLE_FAN:
+                if(vc > 1) {
+                  CGOAlphaTriangle(info->alpha_cgo,
+                                   v0, v1, v2, n0, n1, n2, c0, c1, c2,
+                                   R->alpha, R->alpha, R->alpha, false);
+                } else if(!vc) {
+                  n2 = n0;
+                  v2 = v0;
+                  c2 = c0;
+                }
+                v1 = v0;
+                c1 = c0;
+                n1 = n0;
+                vc++;
+                break;
+              default:
+                CGO_gl_vertex(R, &pc);
+                break;
+              }
+              break;
+            default:
+              CGO_gl[op] (R, &pc);
+              break;
+            }
+          } else {              /* opaque */
+	    switch(op){
+	    case CGO_COLOR:
+	      /* Since CGO operations are done in sequence, alpha could happen 
+		 after color is set.  In this case, we still need to keep track of the color 
+		 in case there is a transparent object */
+	      c0 = pc;
+	      break;
+	    default:
+	      break;
+	    }
+            CGO_gl[op] (R, &pc);
+          }
+          pc += CGO_sz[op];
+        }
+      } else {
+	int nops = 0;
+        while((op = (CGO_MASK & CGO_read_int(pc)))) {
+          CGO_gl[op] (R, &pc);
+          pc += CGO_sz[op];
+	  nops++;
+	}
+      }
+    }
+  }
+}
+
+void CGORenderGLAlpha(CGO * I, RenderInfo * info, bool calcDepth)
+{
+  PyMOLGlobals *G = I->G;
+  if(G->ValidContext && I->c) {
+    int mode = GL_TRIANGLES;
+    if (I->debug){
+      mode = CGOConvertDebugMode(I->debug, GL_TRIANGLES);
+    }
+#ifndef PURE_OPENGL_ES_2
+    // not sure why shader is set, but disable it for now,
+    // since we are doing immediate mode rendering for global transparency
+    auto shaderPrg = G->ShaderMgr->Get_Current_Shader();
+    if (shaderPrg){
+      shaderPrg->Disable();
+#ifdef _DEAD_CODE_DIE
+      PRINTFB(I->G, FB_CGO, FB_Warnings) "CGORenderGLAlpha: Current Shader should not be still set for global transparency sorting\n" ENDFB(I->G);
+#endif
+    }
+#endif
+    /* 1. transform and measure range (if not already known) 
+       2. bin into linked lists based on Z-centers
+       3. render by layer */
+
+    if(I->z_flag) {
+      if(!I->i_start) {
+        I->i_size = 256;
+        I->i_start = Calloc(int, I->i_size);
+      } else {
+        UtilZeroMem(I->i_start, sizeof(int) * I->i_size);
+      }
+      {
+        int i_size = I->i_size;
+        float range_factor;
+        float *base = I->op;
+        float *pc = base;
+        int op, i;
+        int *start = I->i_start;
+        int delta = 1, ntris = 0;
+        /* bin the triangles */
+	if (calcDepth){
+	  float *zv = I->z_vector, z;
+	  while((op = (CGO_MASK & CGO_read_int(pc)))) {
+	    switch (op) {
+	    case CGO_ALPHA_TRIANGLE:
+	      z = pc[1] * zv[0] + pc[2] * zv[1] + pc[3] * zv[2];
+	      if(z > I->z_max)
+		I->z_max = z;
+	      if(z < I->z_min)
+		I->z_min = z;
+	      pc[4] = z;
+	      ntris++;
+	    }
+	    pc += CGO_sz[op];
+          }
+	}
+	pc = base;
+	range_factor = (0.9999F * i_size) / (I->z_max - I->z_min);
+        while((op = (CGO_MASK & CGO_read_int(pc)))) {
+          switch (op) {
+          case CGO_ALPHA_TRIANGLE:
+            i = (int) ((pc[4] - I->z_min) * range_factor);
+            if(i < 0)
+              i = 0;
+            if(i >= i_size)
+              i = i_size;
+            CGO_put_int(pc, start[i]);
+            start[i] = (pc - base);     /* NOTE: will always be > 0 since we have CGO_read_int'd */
+          }
+          pc += CGO_sz[op];
+        }
+        if(SettingGetGlobal_i(G, cSetting_transparency_mode) == 2) {
+          delta = -1;
+          start += (i_size - 1);
+        }
+
+        /* now render by bin */
+#ifndef PURE_OPENGL_ES_2
+        glBegin(mode);
+        for(i = 0; i < i_size; i++) {
+          int ii = *start;
+          start += delta;
+          while(ii) {
+            pc = base + ii;
+            glColor4fv(pc + 23);
+            glNormal3fv(pc + 14);
+            glVertex3fv(pc + 5);
+            glColor4fv(pc + 27);
+            glNormal3fv(pc + 17);
+            glVertex3fv(pc + 8);
+            glColor4fv(pc + 31);
+            glNormal3fv(pc + 20);
+            glVertex3fv(pc + 11);
+
+            ii = CGO_get_int(pc);
+          }
+        }
+        glEnd();
+#endif
+      }
+    } else {
+      float *pc = I->op;
+      int op = 0;
+#ifndef PURE_OPENGL_ES_2
+      glBegin(mode);
+      while((op = (CGO_MASK & CGO_read_int(pc)))) {
+        switch (op) {
+        case CGO_ALPHA_TRIANGLE:
+          glColor4fv(pc + 23);
+          glNormal3fv(pc + 14);
+          glVertex3fv(pc + 5);
+          glColor4fv(pc + 27);
+          glNormal3fv(pc + 17);
+          glVertex3fv(pc + 8);
+          glColor4fv(pc + 31);
+          glNormal3fv(pc + 20);
+          glVertex3fv(pc + 11);
+          break;
+        }
+        pc += CGO_sz[op];
+      }
+      glEnd();
+#endif
+    }
+  }
+}
+
+
+/* translation function which turns cylinders and spheres into triangles */
+
+static int CGOSimpleSphere(CGO * I, float *v, float vdw, short sphere_quality)
+{
+  SphereRec *sp;
+  int *q, *s;
+  int b, c;
+  int ok = true;
+  /* cgo_sphere_quality is between 0 and (NUMBER_OF_SPHERE_LEVELS-1) */
+
+  sp = I->G->Sphere->Sphere[CLAMPVALUE<short>(sphere_quality, 0, (NUMBER_OF_SPHERE_LEVELS-1)) ];
+
+  q = sp->Sequence;
+  s = sp->StripLen;
+
+  for(b = 0; b < sp->NStrip; b++) {
+    if (ok)
+      ok &= CGOBegin(I, GL_TRIANGLE_STRIP);
+    for(c = 0; ok && c < (*s); c++) {
+      ok &= CGONormalv(I, sp->dot[*q]);
+      if (ok)
+	ok &= CGOVertex(I, v[0] + vdw * sp->dot[*q][0],
+			v[1] + vdw * sp->dot[*q][1], v[2] + vdw * sp->dot[*q][2]);
+      q++;
+    }
+    if (ok)
+      ok &= CGOEnd(I);
+    s++;
+  }
+  return ok;
+}
+
+static int CGOSimpleQuadric(CGO * I, float *v, float r, float *q)
+{
+  float r_el, n0[3], n1[3], n2[3];
+  int ok = true;
+  if(CGOQuadricToEllipsoid(v, r, q, &r_el, n0, n1, n2))
+    ok &= CGOSimpleEllipsoid(I, v, r_el, n0, n1, n2);
+  return ok;
+}
+
+static int CGOSimpleEllipsoid(CGO * I, float *v, float vdw, float *n0, float *n1,
+			      float *n2)
+{
+  SphereRec *sp;
+  int *q, *s;
+  int b, c;
+  int ds;
+  float nn0[3], nn1[3], nn2[3];
+  float scale[3], scale_sq[3];
+  int ok = true;
+
+  normalize23f(n0, nn0);
+  normalize23f(n1, nn1);
+  normalize23f(n2, nn2);
+
+  scale[0] = (float) length3f(n0);
+  scale[1] = (float) length3f(n1);
+  scale[2] = (float) length3f(n2);
+
+  scale_sq[0] = scale[0] * scale[0];
+  scale_sq[1] = scale[1] * scale[1];
+  scale_sq[2] = scale[2] * scale[2];
+
+  ds = SettingGet_i(I->G, NULL, NULL, cSetting_cgo_ellipsoid_quality);
+  if(ds < 0)
+    ds = SettingGet_i(I->G, NULL, NULL, cSetting_ellipsoid_quality);
+  if(ds < 0)
+    ds = 0;
+  if(ds > 3)
+    ds = 3;
+  sp = I->G->Sphere->Sphere[ds];
+
+  q = sp->Sequence;
+  s = sp->StripLen;
+
+  for(b = 0; b < sp->NStrip; b++) {
+    ok &= CGOBegin(I, GL_TRIANGLE_STRIP);
+    for(c = 0; ok && c < (*s); c++) {
+      float *sp_dot_q = sp->dot[*q];
+      float s0 = vdw * sp_dot_q[0];
+      float s1 = vdw * sp_dot_q[1];
+      float s2 = vdw * sp_dot_q[2];
+      float d0[3], d1[3], d2[3], vv[3], direction[3];
+      float dd0, dd1, dd2, ss0, ss1, ss2;
+      float comp0[3], comp1[3], comp2[3];
+      float surfnormal[3];
+      int i;
+      
+      scale3f(n0, s0, d0);
+      scale3f(n1, s1, d1);
+      scale3f(n2, s2, d2);
+      
+      for(i = 0; i < 3; i++) {
+	vv[i] = d0[i] + d1[i] + d2[i];
+      }
+      normalize23f(vv, direction);
+      add3f(v, vv, vv);
+      
+      dd0 = dot_product3f(direction, nn0);
+      dd1 = dot_product3f(direction, nn1);
+      dd2 = dot_product3f(direction, nn2);
+      
+      if(scale[0] > R_SMALL8) {
+	ss0 = dd0 / scale_sq[0];
+      } else {
+	ss0 = 0.0F;
+      }
+      if(scale[1] > R_SMALL8) {
+	ss1 = dd1 / scale_sq[1];
+      } else {
+	ss1 = 0.0F;
+      }
+      
+      if(scale[2] > R_SMALL8) {
+	ss2 = dd2 / scale_sq[2];
+      } else {
+	ss2 = 0.0F;
+      }
+      
+      scale3f(nn0, ss0, comp0);
+      scale3f(nn1, ss1, comp1);
+      scale3f(nn2, ss2, comp2);
+      
+      for(i = 0; i < 3; i++) {
+	surfnormal[i] = comp0[i] + comp1[i] + comp2[i];
+      }
+      normalize3f(surfnormal);
+      
+      ok &= CGONormalv(I, surfnormal);
+      if (ok)
+	ok &= CGOVertexv(I, vv);
+      q++;
+    }
+    if (ok)
+      ok &= CGOEnd(I);
+    s++;
+  }
+  return ok;
+}
+
+/*
+ * Triangulated round cap (half-globe)
+ */
+void CGORoundNub(CGO * I,
+    const float *v1,    // cap center
+    const float *p0,    // normal along axis
+    const float *p1,    // x coord in cap space
+    const float *p2,    // y coord in cap space
+    int direction,      // 1 or -1
+    int nEdge,          // "quality"
+    float size)
+{
+  const int cmax = (nEdge + 3) / 2;
+  const float PI_over_cmax = PI / ((cmax - 1) * 2);
+  const float PI_over_nEdge = (PI * 2) / nEdge;
+  float z2 = 1.f;
+
+  // z coord in cap space
+  float p3[3];
+  scale3f(p0, direction, p3);
+
+  CGOBegin(I, GL_TRIANGLE_STRIP);
+
+  // from equator to pole (latitudinal)
+  for (int c = 1; c < cmax; c += 1){
+    float z1 = z2;
+    z2 = cos(c * PI_over_cmax);
+
+    // around cylinder axis (longitudinal)
+    for (int d = (nEdge + 1) * (-direction); d; d += direction){
+      float z3 = z1;
+
+      // 2 vertices
+      for (int e = -1; e < 1; ++e) {
+        float x = cos(d * PI_over_nEdge) * sin((c + e) * PI_over_cmax);
+        float y = sin(d * PI_over_nEdge) * sin((c + e) * PI_over_cmax);
+        float normal[3], vertex[3];
+
+        normal[0] = p1[0] * x + p2[0] * y + p3[0] * z3;
+        normal[1] = p1[1] * x + p2[1] * y + p3[1] * z3;
+        normal[2] = p1[2] * x + p2[2] * y + p3[2] * z3;
+
+        vertex[0] = v1[0] + normal[0] * size;
+        vertex[1] = v1[1] + normal[1] * size;
+        vertex[2] = v1[2] + normal[2] * size;
+
+        normalize3f(normal);
+        CGONormalv(I, normal);
+        CGOVertexv(I, vertex);
+
+        z3 = z2;
+      }
+    }
+  }
+
+  CGOEnd(I);
+}
+
+static int CGOSimpleCylinder(CGO * I, const float *v1, const float *v2, const float tube_size,
+                             const float *c1, const float *c2, const float alpha1,
+                             const float alpha2, const bool interp, const int cap1, const int cap2,
+                             const Pickable *pickcolor2, const bool stick_round_nub)
+{
+#define MAX_EDGE 50
+
+  float d[3], t[3], p0[3], p1[3], p2[3], vv1[3], vv2[3], v_buf[9], *v;
+  float x[MAX_EDGE + 1], y[MAX_EDGE + 1];
+  float overlap;
+  float nub;
+  bool colorFlag, interpColorFlag;
+  int nEdge;
+  int c;
+  int ok = true;
+  float midcolor[3];
+  float midalpha{alpha1};
+  Pickable pickcolor[2];
+    pickcolor[0].index = I->current_pick_color_index;
+    pickcolor[0].bond = I->current_pick_color_bond;
+  if (pickcolor2){
+    pickcolor[1].index = pickcolor2->index;
+    pickcolor[1].bond = pickcolor2->bond;
+  } else {
+    pickcolor[1].index = pickcolor[0].index;
+    pickcolor[1].bond = pickcolor[0].bond;
+  }
+  v = v_buf;
+  nEdge = SettingGetGlobal_i(I->G, cSetting_stick_quality);
+  overlap = tube_size * SettingGetGlobal_f(I->G, cSetting_stick_overlap);
+  nub = tube_size * SettingGetGlobal_f(I->G, cSetting_stick_nub);
+
+  if(nEdge > MAX_EDGE)
+    nEdge = MAX_EDGE;
+  subdivide(nEdge, x, y);
+
+  colorFlag = (c1 != c2) && c2;
+  colorFlag |= alpha1 != alpha2;
+
+  interpColorFlag = c2 && interp && pickcolor2;
+  if (interpColorFlag){
+    average3f(c1, c2, midcolor);
+    midalpha = (alpha1 + alpha2) / 2.0f;
+  }
+  /* direction vector */
+
+  p0[0] = (v2[0] - v1[0]);
+  p0[1] = (v2[1] - v1[1]);
+  p0[2] = (v2[2] - v1[2]);
+
+  normalize3f(p0);
+
+  if(cap1 == cCylCapRound && !stick_round_nub) {
+    vv1[0] = v1[0] - p0[0] * overlap;
+    vv1[1] = v1[1] - p0[1] * overlap;
+    vv1[2] = v1[2] - p0[2] * overlap;
+  } else {
+    vv1[0] = v1[0];
+    vv1[1] = v1[1];
+    vv1[2] = v1[2];
+  }
+  if(cap2 == cCylCapRound && !stick_round_nub) {
+    vv2[0] = v2[0] + p0[0] * overlap;
+    vv2[1] = v2[1] + p0[1] * overlap;
+    vv2[2] = v2[2] + p0[2] * overlap;
+  } else {
+    vv2[0] = v2[0];
+    vv2[1] = v2[1];
+    vv2[2] = v2[2];
+  }
+
+  d[0] = (vv2[0] - vv1[0]);
+  d[1] = (vv2[1] - vv1[1]);
+  d[2] = (vv2[2] - vv1[2]);
+  if (pickcolor2){
+    mult3f(d, .5f, d);
+  }
+  get_divergent3f(d, t);
+  cross_product3f(d, t, p1);
+  normalize3f(p1);
+
+  cross_product3f(d, p1, p2);
+
+  normalize3f(p2);
+
+  /* now we have a coordinate system */
+
+  if (ok)
+    ok &= CGOBegin(I, GL_TRIANGLE_STRIP);
+  for(c = nEdge; ok && c >= 0; c--) {
+    v[0] = p1[0] * x[c] + p2[0] * y[c];
+    v[1] = p1[1] * x[c] + p2[1] * y[c];
+    v[2] = p1[2] * x[c] + p2[2] * y[c];
+
+    v[3] = vv1[0] + v[0] * tube_size;
+    v[4] = vv1[1] + v[1] * tube_size;
+    v[5] = vv1[2] + v[2] * tube_size;
+
+    v[6] = v[3] + d[0];
+    v[7] = v[4] + d[1];
+    v[8] = v[5] + d[2];
+
+    ok &= CGONormalv(I, v);
+    if(ok && (colorFlag || interpColorFlag) ){
+      ok &= CGOColorv(I, c1);
+      ok &= CGOAlpha(I, alpha1);
+    }
+    if (ok)
+      ok &= CGOVertexv(I, v + 3);
+    if (ok && interpColorFlag){
+      ok &= CGOColorv(I, midcolor);
+      ok &= CGOAlpha(I, midalpha);
+    } else if(ok && colorFlag && !pickcolor2){
+      ok &= CGOColorv(I, c2);
+      ok &= CGOAlpha(I, alpha2);
+    }
+    if (ok)
+      ok &= CGOVertexv(I, v + 6);
+  }
+  if (ok)
+    ok &= CGOEnd(I);
+  if (pickcolor2){
+    ok &= CGOColorv(I, c2);
+    ok &= CGOAlpha(I, alpha2);
+    CGOPickColor(I, pickcolor2->index, pickcolor2->bond);
+    if (ok)
+      ok &= CGOBegin(I, GL_TRIANGLE_STRIP);
+    for(c = nEdge; ok && c >= 0; c--) {
+      v[0] = p1[0] * x[c] + p2[0] * y[c];
+      v[1] = p1[1] * x[c] + p2[1] * y[c];
+      v[2] = p1[2] * x[c] + p2[2] * y[c];
+
+      v[3] = vv1[0] + v[0] * tube_size + d[0];
+      v[4] = vv1[1] + v[1] * tube_size + d[1];
+      v[5] = vv1[2] + v[2] * tube_size + d[2];
+
+      v[6] = v[3] + d[0];
+      v[7] = v[4] + d[1];
+      v[8] = v[5] + d[2];
+
+      ok &= CGONormalv(I, v);
+      if (ok && interpColorFlag){
+        ok &= CGOColorv(I, midcolor);
+        ok &= CGOAlpha(I, midalpha);
+      }
+      if (ok)
+        ok &= CGOVertexv(I, v + 3);
+      if (ok && interpColorFlag){
+        ok &= CGOColorv(I, c2);
+        ok &= CGOAlpha(I, alpha2);
+      }
+      if (ok)
+        ok &= CGOVertexv(I, v + 6);
+    }
+    if (ok)
+      ok &= CGOEnd(I);
+  }
+
+  if(ok && cap1) {
+    if(ok && colorFlag && c1){
+      ok &= CGOColorv(I, c1);
+      ok &= CGOAlpha(I, alpha1);
+    }
+    if (pickcolor2)
+      CGOPickColor(I, pickcolor[0].index, pickcolor[0].bond);
+
+    if(stick_round_nub && cap1 == cCylCapRound) {
+      CGORoundNub(I, v1, p0, p1, p2, -1, nEdge, tube_size);
+    } else {
+      v[0] = -p0[0];
+      v[1] = -p0[1];
+      v[2] = -p0[2];
+
+      if(cap1 == cCylCapRound) {
+        v[3] = vv1[0] - p0[0] * nub;
+        v[4] = vv1[1] - p0[1] * nub;
+        v[5] = vv1[2] - p0[2] * nub;
+      } else {
+        v[3] = vv1[0];
+        v[4] = vv1[1];
+        v[5] = vv1[2];
+      }
+
+      if (ok)  ok &= CGOBegin(I, GL_TRIANGLE_FAN);
+      if (ok)  ok &= CGONormalv(I, v);
+      if (ok)  ok &= CGOVertexv(I, v + 3);
+
+      for(c = nEdge; ok && c >= 0; c--) {
+        v[0] = p1[0] * x[c] + p2[0] * y[c];
+        v[1] = p1[1] * x[c] + p2[1] * y[c];
+        v[2] = p1[2] * x[c] + p2[2] * y[c];
+
+        v[3] = vv1[0] + v[0] * tube_size;
+        v[4] = vv1[1] + v[1] * tube_size;
+        v[5] = vv1[2] + v[2] * tube_size;
+
+        if(cap1 == cCylCapRound)
+          ok &= CGONormalv(I, v);
+        if (ok)
+          ok &= CGOVertexv(I, v + 3);
+      }
+      if (ok)
+        ok &= CGOEnd(I);
+    }
+  }
+
+  if(ok && cap2) {
+    if(ok && colorFlag && c2){
+      ok &= CGOColorv(I, c2);
+      ok &= CGOAlpha(I, alpha2);
+    }
+    if (pickcolor2)
+      CGOPickColor(I, pickcolor2->index, pickcolor2->bond);
+
+    if(stick_round_nub && cap2 == cCylCapRound) {
+      CGORoundNub(I, v2, p0, p1, p2, 1, nEdge, tube_size);
+    } else {
+      v[0] = p0[0];
+      v[1] = p0[1];
+      v[2] = p0[2];
+
+      if(cap2 == cCylCapRound) {
+        v[3] = vv2[0] + p0[0] * nub;
+        v[4] = vv2[1] + p0[1] * nub;
+        v[5] = vv2[2] + p0[2] * nub;
+      } else {
+        v[3] = vv2[0];
+        v[4] = vv2[1];
+        v[5] = vv2[2];
+      }
+
+      if (ok) ok &= CGOBegin(I, GL_TRIANGLE_FAN);
+      if (ok) ok &= CGONormalv(I, v);
+      if (ok) ok &= CGOVertexv(I, v + 3);
+
+      for(c = 0; ok && c <= nEdge; c++) {
+        v[0] = p1[0] * x[c] + p2[0] * y[c];
+        v[1] = p1[1] * x[c] + p2[1] * y[c];
+        v[2] = p1[2] * x[c] + p2[2] * y[c];
+
+        v[3] = vv2[0] + v[0] * tube_size;
+        v[4] = vv2[1] + v[1] * tube_size;
+        v[5] = vv2[2] + v[2] * tube_size;
+
+        if(cap2 == cCylCapRound)
+          ok &= CGONormalv(I, v);
+        if (ok)
+          ok &= CGOVertexv(I, v + 3);
+      }
+      if (ok) ok &= CGOEnd(I);
+    }
+  }
+  return ok;
+}
+
+template <typename CylinderT>
+static int CGOSimpleCylinder(CGO* I, const CylinderT& cyl, const float a1,
+    const float a2, const bool interp, const int cap1, const int cap2,
+    const Pickable* pickcolor2, const bool stick_round_nub)
+{
+  return CGOSimpleCylinder(I, cyl.vertex1, cyl.vertex2, cyl.radius, cyl.color1,
+      cyl.color2, a1, a2, interp, cap1, cap2, pickcolor2, stick_round_nub);
+}
+
+static int CGOSimpleCone(CGO * I, float *v1, float *v2, float r1, float r2,
+			 float *c1, float *c2, int cap1, int cap2)
+{
+#define MAX_EDGE 50
+
+  float d[3], t[3], p0[3], p1[3], p2[3], vv1[3], vv2[3], v_buf[9], *v;
+  float x[MAX_EDGE + 1], y[MAX_EDGE + 1], edge_normal[3 * (MAX_EDGE + 1)];
+  int colorFlag;
+  int nEdge;
+  int c;
+  int ok = true;
+
+  v = v_buf;
+  nEdge = SettingGetGlobal_i(I->G, cSetting_cone_quality);
+
+  if(nEdge > MAX_EDGE)
+    nEdge = MAX_EDGE;
+  subdivide(nEdge, x, y);
+
+  colorFlag = (c1 != c2) && c2;
+
+  ok &= CGOColorv(I, c1);
+
+  /* direction vector */
+
+  p0[0] = (v2[0] - v1[0]);
+  p0[1] = (v2[1] - v1[1]);
+  p0[2] = (v2[2] - v1[2]);
+
+  normalize3f(p0);
+
+  {
+    vv1[0] = v1[0];
+    vv1[1] = v1[1];
+    vv1[2] = v1[2];
+  }
+
+  {
+    vv2[0] = v2[0];
+    vv2[1] = v2[1];
+    vv2[2] = v2[2];
+  }
+
+  d[0] = (vv2[0] - vv1[0]);
+  d[1] = (vv2[1] - vv1[1]);
+  d[2] = (vv2[2] - vv1[2]);
+
+  get_divergent3f(d, t);
+
+  cross_product3f(d, t, p1);
+
+  normalize3f(p1);
+
+  cross_product3f(d, p1, p2);
+
+  normalize3f(p2);
+
+  /* now we have a coordinate system */
+
+  {
+    float len = diff3f(v1, v2);
+    float vt[3], nt[3];
+    float slope = 0.0F;
+
+    if(len) {
+      slope = (r1 - r2) / len;
+    }
+    for(c = nEdge; c >= 0; c--) {
+      vt[0] = p1[0] * x[c] + p2[0] * y[c];
+      vt[1] = p1[1] * x[c] + p2[1] * y[c];
+      vt[2] = p1[2] * x[c] + p2[2] * y[c];
+
+      scale3f(p0, slope, nt);
+      add3f(nt, vt, vt);
+      normalize3f(vt);
+      copy3f(vt, edge_normal + 3 * c);
+    }
+  }
+
+  /* now we have normals */
+  if (ok)
+    ok &= CGOBegin(I, GL_TRIANGLE_STRIP);
+  for(c = nEdge; ok && c >= 0; c--) {
+    v[0] = p1[0] * x[c] + p2[0] * y[c];
+    v[1] = p1[1] * x[c] + p2[1] * y[c];
+    v[2] = p1[2] * x[c] + p2[2] * y[c];
+
+    v[3] = vv1[0] + v[0] * r1;
+    v[4] = vv1[1] + v[1] * r1;
+    v[5] = vv1[2] + v[2] * r1;
+
+    v[6] = vv1[0] + v[0] * r2 + d[0];
+    v[7] = vv1[1] + v[1] * r2 + d[1];
+    v[8] = vv1[2] + v[2] * r2 + d[2];
+
+    ok &= CGONormalv(I, edge_normal + 3 * c);
+    if(ok && colorFlag)
+      CGOColorv(I, c1);
+    if (ok)
+      CGOVertexv(I, v + 3);
+    if(ok && colorFlag)
+      CGOColorv(I, c2);
+    if (ok)
+      CGOVertexv(I, v + 6);
+  }
+  if (ok)
+    ok &= CGOEnd(I);
+
+  if(ok && cap1) {
+    v[0] = -p0[0];
+    v[1] = -p0[1];
+    v[2] = -p0[2];
+
+    {
+      v[3] = vv1[0];
+      v[4] = vv1[1];
+      v[5] = vv1[2];
+    }
+
+    if(colorFlag)
+      ok &= CGOColorv(I, c1);
+    if (ok)
+      ok &= CGOBegin(I, GL_TRIANGLE_FAN);
+    if (ok)
+      ok &= CGONormalv(I, v);
+    if (ok)
+      ok &= CGOVertexv(I, v + 3);
+
+    for(c = nEdge; ok && c >= 0; c--) {
+      v[0] = p1[0] * x[c] + p2[0] * y[c];
+      v[1] = p1[1] * x[c] + p2[1] * y[c];
+      v[2] = p1[2] * x[c] + p2[2] * y[c];
+
+      v[3] = vv1[0] + v[0] * r1;
+      v[4] = vv1[1] + v[1] * r1;
+      v[5] = vv1[2] + v[2] * r1;
+
+      if(cap1 == cCylCapRound)
+        ok &= CGONormalv(I, v);
+      if (ok)
+	ok &= CGOVertexv(I, v + 3);
+    }
+    if (ok)
+      ok &= CGOEnd(I);
+  }
+
+  if(ok && cap2) {
+
+    v[0] = p0[0];
+    v[1] = p0[1];
+    v[2] = p0[2];
+
+    {
+      v[3] = vv2[0];
+      v[4] = vv2[1];
+      v[5] = vv2[2];
+    }
+
+    if(colorFlag)
+      ok &= CGOColorv(I, c2);
+    if (ok)
+      ok &= CGOBegin(I, GL_TRIANGLE_FAN);
+    if (ok)
+      ok &= CGONormalv(I, v);
+    if (ok)
+      ok &= CGOVertexv(I, v + 3);
+
+    for(c = 0; ok && c <= nEdge; c++) {
+      v[0] = p1[0] * x[c] + p2[0] * y[c];
+      v[1] = p1[1] * x[c] + p2[1] * y[c];
+      v[2] = p1[2] * x[c] + p2[2] * y[c];
+
+      v[3] = vv2[0] + v[0] * r2;
+      v[4] = vv2[1] + v[1] * r2;
+      v[5] = vv2[2] + v[2] * r2;
+
+      if(cap2 == cCylCapRound)
+        ok &= CGONormalv(I, v);
+      if (ok)
+	ok &= CGOVertexv(I, v + 3);
+    }
+    if (ok)
+      ok &= CGOEnd(I);
+  }
+  return ok;
+}
+
+/* CGOGetNextDrawBufferedIndex: This is used by RepSurface to */
+/* get the data from the CGO_DRAW_BUFFERS_INDEXED operation so */
+/* that it can update the indices for semi-transparent surfaces. */
+float *CGOGetNextDrawBufferedIndex(float *cgo_op, int optype)
+{
+  return CGOGetNextOp(cgo_op, optype);
+}
+
+float *CGOGetNextOp(float *cgo_op, int optype)
+{
+  float *pc = cgo_op;
+  int op = 0;
+
+  while((op = (CGO_MASK & CGO_read_int(pc)))) {
+    if (op==optype)
+      return pc;
+    pc += CGO_sz[op];
+  }
+  return (0);
+}
+
+int CGO::append(const CGO * source, bool stopAtEnd) {
+  int ok = 1;
+
+  for (auto it = source->begin(); !it.is_stop(); ++it) {
+    add_to_cgo(it.op_code(), it.data());
+  }
+
+  if (stopAtEnd)
+    ok &= CGOStop(this);
+  has_draw_buffers |= source->has_draw_buffers;
+  has_draw_cylinder_buffers |= source->has_draw_cylinder_buffers;
+  return ok;
+}
+
+/*
+ * Appends `src` to the end of this CGO. Takes ownership of data
+ * (incl. VBOs) and leaves `src` as a valid but empty CGO.
+ */
+void CGO::move_append(CGO * src) {
+  if (!src->c)
+    return;
+
+  // copy buffer
+  VLACheck(op, float, c + src->c);
+  memcpy(op + c, src->op, src->c * sizeof(float));
+
+  // update sizes
+  c += src->c;
+  src->c = 0;
+
+  // null terminators (CGO_STOP)
+  *(op + c) = 0;
+  *(src->op) = 0;
+
+  // move heap data
+  for (auto& ref : src->_data_heap) {
+    _data_heap.emplace_back(std::move(ref));
+  }
+  src->_data_heap.clear();
+
+  // copy boolean flags
+  has_draw_buffers            |= src->has_draw_buffers;
+  has_draw_cylinder_buffers   |= src->has_draw_cylinder_buffers;
+  has_draw_sphere_buffers     |= src->has_draw_sphere_buffers;
+  has_begin_end               |= src->has_begin_end;
+  use_shader                  |= src->use_shader;
+  render_alpha                |= src->render_alpha;
+}
+
+/*
+ * Appends `src` to the end of this CGO and then free's `src`
+ * and sets the pointer to NULL.
+ */
+void CGO::free_append(CGO * &src) {
+  move_append(src);
+  CGOFreeWithoutVBOs(src);
+}
+
+int CGOAppend(CGO *dest, const CGO *source, bool stopAtEnd){
+  int ok = dest->append(source, stopAtEnd);
+  return ok;
+}
+
+//#define DEBUG_PRINT_BEGIN_MODES
+
+int CGOCountNumberOfOperationsOfTypeDEBUG(const CGO *I, int optype){
+  float *pc = I->op;
+  int op, numops = 0, totops = 0;
+  if (!optype){
+#ifdef DEBUG_PRINT_BEGIN_MODES
+    printf("GL_POINTS=%d GL_LINES=%d GL_LINE_LOOP=%d GL_LINE_STRIP=%d GL_TRIANGLES=%d GL_TRIANGLE_STRIP=%d GL_TRIANGLE_FAN=%d\n", GL_POINTS, GL_LINES, GL_LINE_LOOP, GL_LINE_STRIP, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN);
+#endif
+    printf("CGOCountNumberOfOperationsOfType: ");
+  }
+  while((op = (CGO_MASK & CGO_read_int(pc)))) {
+    if (!optype){
+#ifdef DEBUG_PRINT_BEGIN_MODES
+      if (op == CGO_BEGIN || op == CGO_DRAW_ARRAYS){
+	printf(" %02X:%d ", op, CGO_get_int(pc));
+      } else {
+	printf(" %02X ", op);
+      }
+#else
+      printf(" %02X ", op);
+#endif
+    }
+    totops++;
+    if (op == optype)
+      numops++;
+    pc += CGO_sz[op];
+  }
+  if (!optype){
+    printf("\n");
+  }
+  if(optype){
+    return (numops);
+  } else {
+    return (totops);
+  }
+}
+
+int CGOCountNumberOfOperationsOfType(const CGO *I, int optype){
+  std::set<int> ops = { optype };
+  return CGOCountNumberOfOperationsOfTypeN(I, ops, optype == 0);
+}
+
+int CGOCountNumberOfOperationsOfTypeN(const CGO *I, const std::set<int> &optype, bool debug){
+  float *pc = I->op;
+  int op, numops = 0, totops = 0;
+#ifdef DEBUG_PRINT_OPS
+  if (debug){
+    printf("CGOCountNumberOfOperationsOfType: ");
+  }
+#endif
+  while((op = (CGO_MASK & CGO_read_int(pc)))) {
+#ifdef DEBUG_PRINT_OPS
+    if (debug){
+      printf(" 0x%02X ", op);
+    }
+#endif
+    totops++;
+    if (optype.find(op) != optype.end())
+      numops++;
+    pc += CGO_sz[op];
+  }
+#ifdef DEBUG_PRINT_OPS
+  if (debug){
+    printf("\n");
+  }
+#endif
+  //  printf("\n\ttotops=%d\n", totops);
+  if(!debug){
+    return (numops);
+  } else {
+    return (totops);
+  }
+}
+
+int CGOCountNumberOfOperationsOfTypeN(const CGO *I, const std::map<int, int> &optype){
+  float *pc = I->op;
+  int op, numops = 0;
+  std::map<int, int>::const_iterator it;
+  while((op = (CGO_MASK & CGO_read_int(pc)))) {
+    it = optype.find(op);
+    if (it != optype.end())
+      numops += it->second;
+    pc += CGO_sz[op];
+  }
+  return (numops);
+}
+
+bool CGOHasOperationsOfType(const CGO *I, int optype){
+  std::set<int> ops = { optype };
+  return CGOHasOperationsOfTypeN(I, ops);
+}
+
+bool CGOHasOperations(const CGO *I) {
+  return (I->op && 0 != (CGO_MASK & CGO_get_int(I->op)));
+}
+
+bool CGOHasOperationsOfTypeN(const CGO *I, const std::set<int> &optype){
+  if (!I->op)
+    return false;
+
+  for (auto it = I->begin(); !it.is_stop(); ++it) {
+    if (optype.count(it.op_code()))
+      return 1;
+  }
+  return (0);
+}
+
+static
+bool CGOFilterOutOperationsOfTypeN(const CGO *I, CGO *cgo, const std::set<int> &optype){
+  if (!I->op)
+    return false;
+
+  bool ret = false;
+  for (auto it = I->begin(); !it.is_stop(); ++it) {
+    auto op = it.op_code();
+    if (optype.find(op) == optype.end()){
+      auto pc = it.data();
+      cgo->add_to_cgo(op, pc);
+    } else {
+      ret = true; // returns if filtered anything
+    }
+  }
+  return ret;
+}
+
+bool CGOFilterOutCylinderOperationsInto(const CGO *I, CGO *cgo){
+  static std::set<int> optypes = { CGO_SHADER_CYLINDER, 
+                                   CGO_SHADER_CYLINDER_WITH_2ND_COLOR,
+                                   CGO_SAUSAGE,
+                                   CGO_CYLINDER,
+                                   CGO_CUSTOM_CYLINDER,
+                                   CGO_CUSTOM_CYLINDER_ALPHA };
+  return CGOFilterOutOperationsOfTypeN(I, cgo, optypes);
+}
+
+bool CGOHasCylinderOperations(const CGO *I){
+  static std::set<int> optypes = { CGO_SHADER_CYLINDER, 
+                                   CGO_SHADER_CYLINDER_WITH_2ND_COLOR,
+                                   CGO_SAUSAGE,
+                                   CGO_CYLINDER,
+                                   CGO_CUSTOM_CYLINDER,
+                                   CGO_CUSTOM_CYLINDER_ALPHA };
+  return CGOHasOperationsOfTypeN(I, optypes);
+}
+
+bool CGOHasSphereOperations(const CGO *I){
+  static std::set<int> optypes = { CGO_SPHERE };
+  return CGOHasOperationsOfTypeN(I, optypes);
+}
+
+bool CGOCheckWhetherToFree(PyMOLGlobals * G, CGO *I){
+  if (I->use_shader){
+    if (I->cgo_shader_ub_color != SettingGetGlobal_i(G, cSetting_cgo_shader_ub_color) || 
+	I->cgo_shader_ub_normal != SettingGetGlobal_i(G, cSetting_cgo_shader_ub_normal)){
+      return true;
+    }
+  }
+  return false;
+}
+
+CGO *CGOConvertLinesToShaderCylinders(const CGO * I, int est){
+
+  int tot_nverts = 0, tot_ncyls = 0;
+
+  CGO *cgo = CGONewSized(I->G, I->c + est);
+
+  for (auto it = I->begin(); !it.is_stop(); ++it) {
+    auto pc = it.data();
+    int op = it.op_code();
+
+    switch (op) {
+    case CGO_DRAW_ARRAYS:
+      {
+        const cgo::draw::arrays * sp = reinterpret_cast<decltype(sp)>(pc);
+	float *vals = cgo->add<cgo::draw::arrays>(sp->mode, sp->arraybits, sp->nverts);
+	int nvals = sp->narrays*sp->nverts;
+        memcpy(vals, sp->floatdata, nvals);
+      }
+      break;
+    case CGO_END:
+      PRINTFB(I->G, FB_CGO, FB_Warnings) " CGOConvertLinesToShaderCylinders: CGO_END encountered without CGO_BEGIN but skipped for OpenGLES\n" ENDFB(I->G);      
+      break;
+    case CGO_VERTEX:
+      PRINTFB(I->G, FB_CGO, FB_Warnings) " CGOConvertLinesToShaderCylinders: CGO_VERTEX encountered without CGO_BEGIN but skipped for OpenGLES\n" ENDFB(I->G);      
+      break;
+    case CGO_BEGIN:
+      {
+	const float *last_vertex = NULL, *last_color = NULL, *current_color = NULL, *color = NULL ;
+        unsigned int last_pick_color_idx = 0;
+	int last_pick_color_bnd = cPickableNoPick ;
+	int nverts = 0, err = 0;
+	int mode = CGO_get_int(pc);
+
+        for (++it; !err && it != CGO_END; ++it) {
+          auto pc = it.data();
+          int op = it.op_code();
+
+	  switch (op) {
+	  case CGO_VERTEX:
+	    if (last_vertex){
+	      switch (mode){
+	      case GL_LINES:
+	      case GL_LINE_STRIP:
+		{
+		  float axis[3];
+                  bool pick_color_diff = false;
+		  axis[0] = pc[0] - last_vertex[0];
+		  axis[1] = pc[1] - last_vertex[1];
+		  axis[2] = pc[2] - last_vertex[2];
+                  pick_color_diff = (cgo->current_pick_color_index != last_pick_color_idx ||
+                                     cgo->current_pick_color_bond != last_pick_color_bnd);
+		  if (last_color && current_color &&
+                      (!equal3f(last_color, current_color) || pick_color_diff)){
+		    CGOColorv(cgo, last_color);
+                    if (pick_color_diff){
+                      Pickable pickcolor2 = { cgo->current_pick_color_index, cgo->current_pick_color_bond };
+                      CGOPickColor(cgo, last_pick_color_idx, last_pick_color_bnd);
+                      cgo->add<cgo::draw::shadercylinder2ndcolor>(cgo, last_vertex, axis, 1.f, cCylShaderBothCapsRound, current_color, &pickcolor2);
+                      CGOPickColor(cgo, pickcolor2.index, pickcolor2.bond);
+                    } else {
+                      cgo->add<cgo::draw::shadercylinder2ndcolor>(cgo, last_vertex, axis, 1.f, cCylShaderBothCapsRound, current_color);
+                    }
+		    CGOColorv(cgo, current_color);
+		  } else {
+		    cgo->add<cgo::draw::shadercylinder>(last_vertex, axis, 1.f, cCylShaderBothCapsRound);
+		  }
+		  last_vertex = pc;
+                  last_pick_color_idx = cgo->current_pick_color_index;
+                  last_pick_color_bnd = cgo->current_pick_color_bond;
+		  tot_ncyls++;
+		}
+		if (mode==GL_LINES){
+		  last_vertex = NULL;
+		  last_color = NULL;
+		}
+	      }
+	    } else {
+	      last_vertex = pc;
+	      current_color = color;
+              last_pick_color_idx = cgo->current_pick_color_index;
+              last_pick_color_bnd = cgo->current_pick_color_bond;
+	    }
+	    nverts++;
+            break;
+          case CGO_LINE:
+	    {
+              float axis[3];
+              auto line = reinterpret_cast<const cgo::draw::line *>(pc);
+              subtract3f(line->vertex2, line->vertex1, axis);
+              cgo->add<cgo::draw::shadercylinder>(line->vertex1, axis, 1.f, cCylShaderBothCapsRound);
+              tot_ncyls++;
+            }
+            break;
+          case CGO_SPLITLINE:
+	    {
+              float axis[3];
+              auto splitline = reinterpret_cast<const cgo::draw::splitline *>(pc);
+              Pickable pickcolor2 = { splitline->index, splitline->bond };
+              float color2[] = { CONVERT_COLOR_VALUE(splitline->color2[0]),
+                                 CONVERT_COLOR_VALUE(splitline->color2[1]),
+                                 CONVERT_COLOR_VALUE(splitline->color2[2]) };
+              unsigned char flags = splitline->flags;
+              subtract3f(splitline->vertex2, splitline->vertex1, axis);
+              if ((flags & cgo::draw::splitline::equal_colors) &&
+                  (flags & cgo::draw::splitline::no_split_for_pick)){
+                cgo->add<cgo::draw::shadercylinder>(splitline->vertex1, axis, 1., cCylShaderBothCapsRound);
+              } else {
+                int cap = cCylShaderBothCapsRound;
+                if (flags & splitline->flags & cgo::draw::splitline::interpolation){
+                  cap |= cCylShaderInterpColor;
+                }
+                cgo->add<cgo::draw::shadercylinder2ndcolor>(cgo, splitline->vertex1, axis, 1., cap, color2, &pickcolor2);
+                last_pick_color_idx = splitline->index;
+                last_pick_color_bnd = splitline->bond;
+              }
+              tot_ncyls++;
+            }
+            break;
+	  case CGO_COLOR:
+	    if (op == CGO_COLOR){
+	      last_color = current_color;
+	      current_color = pc;
+	      color = pc;
+	    }
+          case CGO_PICK_COLOR:
+            if (op == CGO_PICK_COLOR){
+              cgo->current_pick_color_index = CGO_get_uint(pc);
+              cgo->current_pick_color_bond = CGO_get_int(pc + 1);
+            }
+	  default:
+            cgo->add_to_cgo(op, pc);
+	  }
+	}
+
+	tot_nverts += nverts;
+      }
+      break;
+    default:
+      cgo->add_to_cgo(op, pc);
+    }
+  }
+  CGOStop(cgo);
+  cgo->use_shader = I->use_shader;
+  if (cgo->use_shader){
+    cgo->cgo_shader_ub_color = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_color);
+    cgo->cgo_shader_ub_normal = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_normal);
+  }
+  if (tot_ncyls){
+    return (cgo);
+  } else {
+    CGOFree(cgo);
+    return NULL;
+  }
+}
+/* CGOSplitUpLinesForPicking: This operation goes through */
+/* a CGO and returns a new CGO that has the same lines but */
+/* a line that has two different pick colors will get split */
+/* at its midpoint into two separate lines so that it can */
+/* be used for picking */
+CGO *CGOSplitUpLinesForPicking(const CGO * I){
+  CGO *cgo;
+
+  float *pc = I->op;
+  int op;
+  float *save_pc;
+  int sz, tot_nverts = 0;
+
+  cgo = CGONew(I->G);
+  CGOBegin(cgo, GL_LINES);
+  while((op = (CGO_MASK & CGO_read_int(pc)))) {
+    save_pc = pc;
+    switch (op) {
+    case CGO_PICK_COLOR:
+      if (op == CGO_PICK_COLOR){
+        cgo->current_pick_color_index = CGO_get_uint(pc);
+        cgo->current_pick_color_bond = CGO_get_int(pc + 1);
+      }
+      break;
+    case CGO_END:
+      PRINTFB(I->G, FB_CGO, FB_Warnings) " CGOSplitUpLinesForPicking: CGO_END encountered without CGO_BEGIN but skipped for OpenGLES\n" ENDFB(I->G);      
+      break;
+    case CGO_VERTEX:
+      PRINTFB(I->G, FB_CGO, FB_Warnings) " CGOSplitUpLinesForPicking: CGO_VERTEX encountered without CGO_BEGIN but skipped for OpenGLES\n" ENDFB(I->G);      
+      break;
+    case CGO_BEGIN:
+      {
+	float *last_vertex = NULL, *last_color = NULL, *current_color = NULL, *color = NULL ;
+        unsigned int last_pick_color_idx = 0;
+	int last_pick_color_bnd = cPickableNoPick ;
+	int nverts = 0, err = 0, end = 0;
+	int mode = CGO_read_int(pc);
+	while(!err && !end && (op = (CGO_MASK & CGO_read_int(pc)))) {
+	  end = (op == CGO_END);
+	  switch (op) {
+	  case CGO_VERTEX:
+	    if (last_vertex){
+	      switch (mode){
+	      case GL_LINES:
+	      case GL_LINE_STRIP:
+		{
+                  bool pick_color_diff = false;
+                  pick_color_diff = (cgo->current_pick_color_index != last_pick_color_idx ||
+                                     cgo->current_pick_color_bond != last_pick_color_bnd);
+		  if (pick_color_diff || 
+                      (last_color && current_color &&
+                       (!equal3f(last_color, current_color)))){
+                    if (pick_color_diff){
+                      float haxis[3];
+                      float mid[3];
+                      uint curp_idx = cgo->current_pick_color_index;
+                      int curp_bnd = cgo->current_pick_color_bond;
+                      haxis[0] = .5f * (pc[0] - last_vertex[0]);
+                      haxis[1] = .5f * (pc[1] - last_vertex[1]);
+                      haxis[2] = .5f * (pc[2] - last_vertex[2]);
+                      add3f(last_vertex, haxis, mid);
+                      CGOPickColor(cgo, last_pick_color_idx, last_pick_color_bnd);
+                      CGOVertexv(cgo, last_vertex);
+                      CGOVertexv(cgo, mid);
+                      CGOPickColor(cgo, curp_idx, curp_bnd);
+                      CGOVertexv(cgo, mid);
+                      CGOVertexv(cgo, pc);
+                    } else {
+                      CGOVertexv(cgo, last_vertex);
+                      CGOVertexv(cgo, pc);
+                    }
+		  } else {
+                    CGOVertexv(cgo, last_vertex);
+                    CGOVertexv(cgo, pc);
+		  }
+		  last_vertex = pc;
+                  last_pick_color_idx = cgo->current_pick_color_index;
+                  last_pick_color_bnd = cgo->current_pick_color_bond;
+		}
+		if (mode==GL_LINES){
+		  last_vertex = NULL;
+		  last_color = NULL;
+		}
+	      }
+	    } else {
+	      last_vertex = pc;
+	      current_color = color;
+              last_pick_color_idx = cgo->current_pick_color_index;
+              last_pick_color_bnd = cgo->current_pick_color_bond;
+	    }
+	    nverts++;
+	  case CGO_COLOR:
+	    if (op == CGO_COLOR){
+	      last_color = current_color;
+	      current_color = pc;
+	      color = pc;
+	    }
+          case CGO_PICK_COLOR:
+            if (op == CGO_PICK_COLOR){
+              cgo->current_pick_color_index = CGO_get_uint(pc);
+              cgo->current_pick_color_bond = CGO_get_int(pc + 1);
+            }
+	  default:
+	    sz = CGO_sz[op];
+	      pc += sz;
+	  }
+	  if (end){
+	    break;
+	  }
+	}
+	tot_nverts += nverts;
+	save_pc = pc;
+      }
+      break;
+    default:
+      sz = CGO_sz[op];
+    }
+    pc = save_pc;
+    pc += CGO_sz[op];
+  }
+  CGOEnd(cgo);
+  CGOStop(cgo);
+  cgo->use_shader = I->use_shader;
+  if (cgo->use_shader){
+    cgo->cgo_shader_ub_color = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_color);
+    cgo->cgo_shader_ub_normal = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_normal);
+  }
+  if (tot_nverts){
+    return (cgo);
+  } else {
+    CGOFree(cgo);
+    return NULL;
+  }
+}
+
+static void trilinesBufferAddVertex(float * &buffer,
+    const float * v1,           // vertex
+    const float * v2,           // vertex other end of line
+    const float * color,        // RGB color
+    float alpha,                // alpha
+    signed char uv)              // uv
+{
+  // vertex
+  (*buffer++) = v1[0];
+  (*buffer++) = v1[1];
+  (*buffer++) = v1[2];
+
+  // othervertex
+  (*buffer++) = v2[0];
+  (*buffer++) = v2[1];
+  (*buffer++) = v2[2];
+
+  (*buffer++) = (float) uv;
+
+  // RGBA
+  unsigned char *byte_view = (unsigned char *)(buffer++);
+  (*byte_view++) = CLIP_COLOR_VALUE(color[0]);
+  (*byte_view++) = CLIP_COLOR_VALUE(color[1]);
+  (*byte_view++) = CLIP_COLOR_VALUE(color[2]);
+  (*byte_view++) = CLIP_COLOR_VALUE(alpha);
+}
+
+static void trilinesBufferAddVertices(float * &buffer,
+    const float * v1,           // vertex
+    const float * v2,           // vertex other end of line
+    const float * color,        // RGB color
+    float alpha)                // alpha
+{
+  // Vertex 1
+  trilinesBufferAddVertex(buffer, v1, v2, color, alpha, 1); //-1, 1);
+  // Vertex 3
+  trilinesBufferAddVertex(buffer, v1, v2, color, alpha, 3); //1, 1);
+  // Vertex 2
+  trilinesBufferAddVertex(buffer, v1, v2, color, alpha, 0); //-1, -1);
+  // Vertex 4
+  trilinesBufferAddVertex(buffer, v1, v2, color, alpha, 3); //1, 1);
+  // Vertex 3
+  trilinesBufferAddVertex(buffer, v1, v2, color, alpha, 2); //1, -1);
+  // Vertex 1
+  trilinesBufferAddVertex(buffer, v1, v2, color, alpha, 1); //-1, 1);
+}
+
+static
+void CGOTrilines_GetCurrentColor(float *&current_color, float *colorv, float *last_color, float *cc){
+  if (!current_color) {
+    if (colorv) {
+      current_color = colorv;
+    } else if (last_color) {
+      current_color = last_color;
+    } else {
+      current_color = cc;
+    }
+  }
+}
+
+int CGOChangeShadersTo(CGO *I, int frommode, int tomode){
+  float *pc = I->op;
+  int op = 0, totops = 0;
+  while((op = (CGO_MASK & CGO_read_int(pc))) != 0) {
+    totops++;
+    switch (op) {
+    case CGO_ENABLE:
+      {
+	int mode = CGO_get_int(pc);
+	if (mode == frommode){
+	  CGO_put_int(pc, tomode);
+	}
+      }
+      break;
+    }
+    pc += CGO_sz[op];
+  }
+  return (totops);
+}
+
+CGO *CGOOptimizeScreenTexturesAndPolygons(CGO * I, int est)
+{
+  CGO *cgo = NULL;
+  float *pc = I->op;
+  int num_total_vertices = 0, num_total_indices = 0;
+  int ok = true;
+
+  CGOCountNumVerticesForScreen(I, &num_total_vertices, &num_total_indices);
+  if (num_total_indices>0){
+    float *vertexVals = 0, *colorVals = 0, *texcoordVals;
+    int tot, nxtn;
+    uchar *colorValsUC = 0;
+    pc = I->op;
+    cgo = CGONew(I->G);
+    CGOAlpha(cgo, 1.f);
+    cgo->alpha = 1.f;
+    cgo->color[0] = 1.f; cgo->color[1] = 1.f; cgo->color[2] = 1.f;
+
+    {
+      int mul = 6; // 3 - screenoffset/vertex, 2 - texture coordinates, 1 - color
+      /*
+      if (SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_color)){
+	mul++;
+      } else {
+	mul += 4;
+	}*/
+      tot = num_total_indices * mul ;
+    }
+    vertexVals = Alloc(float, tot);
+    if (!vertexVals){
+      PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeScreenTexturesAndPolygons() vertexVals could not be allocated\n" ENDFB(I->G);	
+      CGOFree(cgo);
+      return (NULL);
+    }
+    texcoordVals = vertexVals + 3 * num_total_indices;
+    nxtn = 2;
+    colorVals = texcoordVals + nxtn * num_total_indices;
+    colorValsUC = (uchar*) colorVals;
+    nxtn = 1;
+      /*    if (true) { //SettingGetGlobal_i(I->G, cSetting_cgo_shader_ub_color)){
+    } else {
+      nxtn = 4;
+      }*/
+    ok = CGOProcessScreenCGOtoArrays(I->G, pc, I, vertexVals, texcoordVals, colorVals, colorValsUC);
+    if (!ok){
+      if (!I->G->Interrupt)
+	PRINTFB(I->G, FB_CGO, FB_Errors) "ERROR: CGOOptimizeScreenTexturesAndPolygons() could not allocate enough memory\n" ENDFB(I->G);	
+      FreeP(vertexVals);      
+      CGOFree(cgo);
+      return (NULL);
+    }
+    if (ok){
+      VertexBuffer * vbo = I->G->ShaderMgr->newGPUBuffer<VertexBuffer>();
+      ok = vbo->bufferData({
+          BufferDesc( "attr_screenoffset", GL_FLOAT,         3, sizeof(float) * num_total_indices * 3, vertexVals,   GL_FALSE ),
+          BufferDesc( "attr_texcoords", GL_FLOAT,         2, sizeof(float) * num_total_indices * 2, texcoordVals, GL_FALSE ),
+          BufferDesc( "attr_backgroundcolor", GL_UNSIGNED_BYTE, 4, sizeof(uchar) * num_total_indices * 4, colorValsUC,  GL_TRUE )
+        });
+      size_t vboid = vbo->get_hash_id();
+      if (ok){
+	CGOEnable(cgo, GL_SCREEN_SHADER);
+	cgo->add<cgo::draw::screen_textures>(num_total_indices, vboid);
+	if (ok)
+	  ok &= CGODisable(cgo, GL_SCREEN_SHADER);
+	if (!ok){
+	  PRINTFB(I->G, FB_CGO, FB_Errors) "CGOOptimizeScreenTexturesAndPolygons: ERROR: CGODrawBuffersNotIndexed() could not allocate enough memory\n" ENDFB(I->G);	
+	  FreeP(vertexVals);
+	  CGOFree(cgo);
+	  return (NULL);
+	}
+      } else {
+        I->G->ShaderMgr->freeGPUBuffer(vboid);
+      }
+    }
+    FreeP(vertexVals);
+  }
+  cgo->use_shader = true;
+  return cgo;
+}
+
+CGO *CGOColorByRamp(PyMOLGlobals * G, CGO *I, ObjectGadgetRamp *ramp, int state, CSetting * set1){
+  CGO *cgo;
+
+  float *pc;
+  int op;
+  float *save_pc;
+  int ok = true;
+  short skipCopy = false;
+  float white[3] = { 1.f, 1.f, 1.f};
+  float probe_radius = SettingGet_f(G, set1, NULL, cSetting_solvent_radius);
+  float v_above[3], n0[3] = { 0.f, 0.f, 0.f };
+  int ramp_above = SettingGet_i(G, set1, NULL, cSetting_surface_ramp_above_mode) == 1;
+  if (!I)
+      return NULL;
+  pc = I->op;
+  cgo = CGONewSized(I->G, 0);
+  ok &= cgo ? true : false;
+  while(ok && (op = (CGO_MASK & CGO_read_int(pc)))) {
+    save_pc = pc;
+    skipCopy = false;
+    switch (op) {
+    case CGO_DRAW_ARRAYS:
+      {
+        cgo::draw::arrays * sp = reinterpret_cast<decltype(sp)>(pc);
+	float *vals = cgo->add<cgo::draw::arrays>(sp->mode, sp->arraybits, sp->nverts);
+	int nvals = sp->narrays*sp->nverts;
+	ok &= vals ? true : false;
+	if (ok)
+          memcpy(vals, sp->floatdata, nvals);
+	skipCopy = true;
+      }
+      break;
+    case CGO_NORMAL:
+      copy3f(pc, n0);
+      break;
+    case CGO_VERTEX:
+      {
+	float color[3];
+	copy3f(white, color);
+	if (ramp_above){
+	  copy3f(n0, v_above);
+	  scale3f(v_above, probe_radius, v_above);
+	  add3f(pc, v_above, v_above);
+	} else {
+	  copy3f(pc, v_above);
+	}
+	if (ObjectGadgetRampInterVertex(ramp, v_above, color, state)){
+	  CGOColorv(cgo, color);
+	} else {
+	  CGOColorv(cgo, white);
+	}
+      }
+      break;
+    }
+    if (!skipCopy){
+      cgo->add_to_cgo(op, pc);
+    }
+    pc = save_pc;
+    pc += CGO_sz[op];
+  }
+  if (ok){
+    ok &= CGOStop(cgo);
+    if (ok){
+      cgo->use_shader = I->use_shader;
+      if (cgo->use_shader){
+	cgo->cgo_shader_ub_color = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_color);
+	cgo->cgo_shader_ub_normal = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_normal);
+      }
+    }
+  }
+  if (!ok){
+    CGOFree(cgo);
+  }
+  return (cgo);
+}
+
+int CGOHasTransparency(const CGO *I, bool checkTransp, bool checkOpaque){
+  float *pc = I->op;
+  int op;
+
+  while((op = (CGO_MASK & CGO_read_int(pc)))) {
+    switch (op) {
+    case CGO_ALPHA:
+      if (checkTransp && *pc < 1.f)
+	return 1;
+      if (checkOpaque && *pc == 1.f)
+        return 1;
+      break;
+    }
+    pc += CGO_sz[op];
+  }
+
+  return checkOpaque;
+}
+
+/* TransparentInfoSortIX - This function sorts all n_tri triangle 
+ * centroids in the array sum by:
+ * 1) computing z-value in array z_value
+ * 2) bin sorting z_values and placing indices in ix array (using Util.cpp)
+ *
+ * - uses sort_mem as pre-allocated memory to sort
+ * - t_mode - either forward (1) or backwards (0) sort
+ */
+void TransparentInfoSortIX(PyMOLGlobals * G, 
+			   float *sum, float *z_value, int *ix,
+			   int n_tri, int *sort_mem, int t_mode){
+  float *zv;
+  float *sv;
+  float matrix[16];
+  int idx;
+  
+#ifdef PURE_OPENGL_ES_2
+  copy44f(SceneGetModelViewMatrix(G), matrix);
+#else
+  glGetFloatv(GL_MODELVIEW_MATRIX, matrix);
+#endif
+  zv = z_value;
+  sv = sum;
+  
+  /* for each triangle, computes the z */
+  for (idx = 0; idx<n_tri; ++idx){
+    *(zv++) = matrix[2] * sv[0] + matrix[6] * sv[1] + matrix[10] * sv[2];
+    sv += 3;
+  }
+
+  UtilZeroMem(sort_mem, sizeof(int) * (n_tri + 256));
+
+  switch (t_mode) {
+  case 1:
+    UtilSemiSortFloatIndexWithNBinsImpl(sort_mem, n_tri, 256, z_value, ix, true); // front to back
+    /* UtilSortIndex(n_tri,z_value,ix,(UtilOrderFn*)ZOrderFn); */
+    break;
+  default:
+    UtilSemiSortFloatIndexWithNBinsImpl(sort_mem, n_tri, 256, z_value, ix, false); // back to front
+    /* UtilSortIndex(n_tri,z_value,ix,(UtilOrderFn*)ZRevOrderFn); */
+    break;
+  }
+}
+
+CGO *CGOConvertTrianglesToAlpha(const CGO * I){
+  int tot_nverts = 0;
+
+  CGO *cgo = CGONewSized(I->G, I->c);
+
+  for (auto it = I->begin(); !it.is_stop(); ++it) {
+    auto pc = it.data();
+    int op = it.op_code();
+
+    switch (op) {
+    case CGO_DRAW_ARRAYS:
+      {
+        const cgo::draw::arrays * sp = reinterpret_cast<decltype(sp)>(pc);
+        int mode = sp->mode, arrays = sp->arraybits, nverts = sp->nverts;
+        int nxtn = 3;
+        float *vertexValsDA = 0, *nxtVals = 0, *colorValsDA = 0, *normalValsDA = 0;
+        float *vertexVals0, *normalVals0, *colorVals0;
+        
+        nxtVals = vertexValsDA = sp->floatdata;
+        if (arrays & CGO_NORMAL_ARRAY){
+          nxtVals = normalValsDA = vertexValsDA + (nxtn*nverts);
+        }
+        if (arrays & CGO_COLOR_ARRAY){
+          nxtVals = colorValsDA = nxtVals + (nxtn*nverts);
+          nxtn = 4;
+        }
+        if (arrays & CGO_PICK_COLOR_ARRAY){
+          nxtVals = nxtVals + (nxtn*nverts);
+          nxtn = 3;
+        }
+        vertexVals0 = vertexValsDA;
+        normalVals0 = normalValsDA;
+        colorVals0 = colorValsDA;
+        switch (mode){
+        case GL_TRIANGLES:
+          {
+            for (int cnt = 0; cnt < nverts; cnt+=3){
+              if (colorVals0){
+                CGOAlphaTriangle(cgo, vertexValsDA, vertexValsDA+3, vertexValsDA+6,
+                                 normalValsDA, normalValsDA+3, normalValsDA+6,
+                                 colorValsDA, colorValsDA+4, colorValsDA+8,
+                                 *(colorValsDA + 3), *(colorValsDA + 7), *(colorValsDA + 11), 0);
+              } else {
+                CGOAlphaTriangle(cgo, vertexValsDA, vertexValsDA+3, vertexValsDA+6,
+                                 normalValsDA, normalValsDA+3, normalValsDA+6,
+                                 cgo->color, cgo->color, cgo->color,
+                                 cgo->alpha, cgo->alpha, cgo->alpha, 0);
+              }
+              vertexValsDA += 9;
+              normalValsDA += 9;
+              if (colorVals0)
+                colorValsDA += 12;
+            }
+          }
+          tot_nverts += nverts;
+          break;
+        case GL_TRIANGLE_STRIP:
+          {
+            short flip = 0;
+            vertexValsDA += 6;
+            normalValsDA += 6;
+            if (colorVals0)
+              colorValsDA += 8;
+
+            for (int cnt = 2; cnt < nverts; cnt++){
+              if (colorVals0){
+                CGOAlphaTriangle(cgo, vertexValsDA-6, vertexValsDA-3, vertexValsDA,
+                                 normalValsDA-6, normalValsDA-3, normalValsDA,
+                                 colorValsDA-8, colorValsDA-4, colorValsDA,
+                                 *(colorValsDA - 5), *(colorValsDA - 1), *(colorValsDA + 3), flip);
+              } else {
+                CGOAlphaTriangle(cgo, vertexValsDA-6, vertexValsDA-3, vertexValsDA,
+                                 normalValsDA-6, normalValsDA-3, normalValsDA,
+                                 cgo->color, cgo->color, cgo->color,
+                                 cgo->alpha, cgo->alpha, cgo->alpha, flip);
+              }
+              vertexValsDA += 3;
+              normalValsDA += 3;
+              if (colorVals0)
+                colorValsDA += 4;
+              flip = !flip;
+            }
+          }
+          tot_nverts += nverts;
+          break;
+        case GL_TRIANGLE_FAN:
+          {
+            vertexValsDA += 6;
+            normalValsDA += 6;
+            if (colorVals0)
+              colorValsDA += 8;
+            for (int cnt = 2; cnt < nverts; cnt++){
+              if (colorVals0){
+                CGOAlphaTriangle(cgo, vertexVals0, vertexValsDA-3, vertexValsDA,
+                                 normalVals0, normalValsDA-3, normalValsDA,
+                                 colorVals0, colorValsDA-4, colorValsDA,
+                                 *(colorVals0 + 3), *(colorValsDA - 1), *(colorValsDA + 3), 0);
+              } else {
+                CGOAlphaTriangle(cgo, vertexVals0, vertexValsDA-3, vertexValsDA,
+                                 normalVals0, normalValsDA-3, normalValsDA,
+                                 cgo->color, cgo->color, cgo->color,
+                                 cgo->alpha, cgo->alpha, cgo->alpha, 0);
+              }
+              vertexValsDA += 3;
+              normalValsDA += 3;
+              if (colorVals0)
+                colorValsDA += 4;
+            }
+            }
+          tot_nverts += nverts;
+          break;
+        }
+      }
+      //save_pc += cgo::draw::arrays_sz;
+      break;
+    case CGO_END:
+      PRINTFB(I->G, FB_CGO, FB_Warnings) " CGOConvertTrianglesToAlpha: CGO_END encountered without CGO_BEGIN but skipped for OpenGLES\n" ENDFB(I->G);      
+      break;
+    case CGO_VERTEX:
+      PRINTFB(I->G, FB_CGO, FB_Warnings) " CGOConvertTrianglesToAlpha: CGO_VERTEX encountered without CGO_BEGIN but skipped for OpenGLES\n" ENDFB(I->G);      
+      break;
+    case CGO_BEGIN:
+      {
+        float vertices[3][3], colors[4][3], normals[4][3], alpha[4] ;
+        short verticespl = 2, colorspl = 2, normalspl = 2, alphapl = 2;
+        short hasShifted = 0;
+        int nverts = 0, err = 0;
+        int mode = CGO_get_int(pc);
+        short mode_is_triangles = 0, flip = 0, mode_is_fan = 0;
+        copy3f(cgo->color, colors[3]);
+        copy3f(cgo->normal, normals[3]);
+        alpha[3] = cgo->alpha;
+        switch (mode){
+        case GL_TRIANGLE_FAN:
+          mode_is_fan = 1;
+        case GL_TRIANGLES:
+        case GL_TRIANGLE_STRIP:
+          mode_is_triangles = 1;
+        }
+        if (!mode_is_triangles){
+          CGOBegin(cgo, mode);
+        }
+
+        for (++it; !err && it != CGO_END; ++it) {
+          auto pc = it.data();
+          int op = it.op_code();
+          short add_to_cgo = 1;
+          switch (op) {
+          case CGO_VERTEX:
+            if (mode_is_triangles){
+              if (!(hasShifted & 1)){ // colors
+                if (colorspl>=0){
+                  copy3f(colors[colorspl+1], colors[colorspl]);
+                  colorspl--;
+                } else {
+                  if (!mode_is_fan)
+                    copy3f(colors[1], colors[2]);
+                  copy3f(colors[0], colors[1]);
+                }
+              }
+              if (!(hasShifted & 2)){ // normals
+                if (normalspl>=0){
+                  copy3f(normals[normalspl+1], normals[normalspl]);
+                  normalspl--;
+                } else {
+                  if (!mode_is_fan)
+                    copy3f(normals[1], normals[2]);
+                  copy3f(normals[0], normals[1]);
+                }
+              }
+              if (!(hasShifted & 4)){ // alphas
+                if (alphapl>=0){
+                  alpha[alphapl] = alpha[alphapl+1];
+                  alphapl--;
+                } else {
+                  if (!mode_is_fan)
+                    alpha[2] = alpha[1];
+                  alpha[1] = alpha[0];
+                }
+              }
+              if (verticespl>=0){
+                copy3f(pc, vertices[verticespl]) ;
+                verticespl--;
+              } else {
+                if (!mode_is_fan)
+                  copy3f(vertices[1], vertices[2]);
+                copy3f(vertices[0], vertices[1]);
+                copy3f(pc, vertices[0]);
+              }
+
+              nverts++;
+              switch (mode){
+              case GL_TRIANGLES:
+                if (!(nverts % 3)){
+                  CGOAlphaTriangle(cgo, vertices[2], vertices[1], vertices[0],
+                                   normals[2], normals[1], normals[0],
+                                   colors[2], colors[1], colors[0], 
+                                   alpha[2], alpha[1], alpha[0], 0);
+                }
+                break;
+              case GL_TRIANGLE_STRIP:
+                if (verticespl<0){
+                  int off0, off2;
+                  if (flip){ off0 = 0; off2 = 2; } else { off0 = 2; off2 = 0; }
+                  flip = !flip;
+                  CGOAlphaTriangle(cgo, vertices[off0], vertices[1], vertices[off2],
+                                   normals[off0], normals[1], normals[off2],
+                                   colors[off0], colors[1], colors[off2], 
+                                   alpha[off0], alpha[1], alpha[off2], 0);
+                }
+                break;
+              case GL_TRIANGLE_FAN:
+                if (verticespl<0){
+                  CGOAlphaTriangle(cgo, vertices[2], vertices[1], vertices[0],
+                                   normals[2], normals[1], normals[0],
+                                   colors[2], colors[1], colors[0], 
+                                   alpha[2], alpha[1], alpha[0], 0);
+                }
+              }
+              add_to_cgo = !mode_is_triangles;
+              hasShifted = 0;
+            } else {
+              add_to_cgo = 1;
+            }
+          case CGO_COLOR:
+            if (op == CGO_COLOR){
+              add_to_cgo = !mode_is_triangles;
+              if (mode_is_triangles){
+                if (colorspl>=0){
+                  copy3f(pc, colors[colorspl]);
+                  colorspl--;
+                } else {
+                  if (!mode_is_fan)
+                    copy3f(colors[1], colors[2]);
+                  copy3f(colors[0], colors[1]);
+                  copy3f(pc, colors[0]);
+                  
+                }
+                hasShifted |= 1;
+              }
+            }
+          case CGO_NORMAL:
+            if (op == CGO_NORMAL){
+              add_to_cgo = !mode_is_triangles;
+              if (mode_is_triangles){
+                if (normalspl>=0){
+                  copy3f(pc, normals[normalspl]);
+                  normalspl--;
+                } else {
+                  if (!mode_is_fan)
+                    copy3f(normals[1], normals[2]);
+                  copy3f(normals[0], normals[1]);
+                  copy3f(pc, normals[0]);
+                }
+                hasShifted |= 2;
+              }
+            }
+          case CGO_ALPHA:
+            if (op == CGO_ALPHA){
+              add_to_cgo = !mode_is_triangles;
+              if (mode_is_triangles){
+                if (alphapl>=0)
+                  alpha[alphapl--] = *pc;
+                else {
+                  if (!mode_is_fan)
+                    alpha[2] = alpha[1];
+                  alpha[1] = alpha[0];
+                  alpha[0] = *pc;
+                }
+                hasShifted |= 4;
+              }
+            }
+          default:
+            if (add_to_cgo){
+              cgo->add_to_cgo(op, pc);
+            }
+          }
+        }
+
+        if (!mode_is_triangles) {
+          CGOEnd(cgo);
+        }
+
+        tot_nverts += nverts;
+      }
+      break;
+    case CGO_COLOR:
+      if (op==CGO_COLOR){
+        copy3f(pc, cgo->color);
+      }
+    case CGO_NORMAL:
+      if (op==CGO_NORMAL){
+        copy3f(pc, cgo->normal);
+      }
+    case CGO_ALPHA:
+      if (op==CGO_ALPHA){
+        cgo->alpha = *pc;
+      }
+    default:
+      cgo->add_to_cgo(op, pc);
+    }
+  }
+  CGOStop(cgo);
+  cgo->use_shader = I->use_shader;
+  if (cgo->use_shader){
+    cgo->cgo_shader_ub_color = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_color);
+    cgo->cgo_shader_ub_normal = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_normal);
+  }
+  if (tot_nverts){
+    return (cgo);
+  } else {
+    CGOFree(cgo);
+    return NULL;
+  }
+}
+
+/*
+ * Converts TRIANGLE(_STRIP|_FAN) to TRIANGLES and generates
+ * normals for all triangles. Discards any existing normals for
+ * triangles.
+ *
+ * I: primitive CGO
+ * return: new primitive CGO with normals on triangles
+ */
+CGO *CGOGenerateNormalsForTriangles(const CGO * I){
+  auto G = I->G;
+  auto cgo = CGONewSized(G, I->c);
+
+  float vertices[3][3];
+  float current_color[3] = {0.f, 0.f, 0.f}, colors[3][3];
+  float current_normal[3];
+  float current_alpha = 0, alphas[3];
+
+  bool has_alpha = false;
+  bool has_color = false;
+
+  int mode = 0;
+  bool inside_begin_triangles = false;
+  int current_i = 0;
+  int vertex_count = 0;
+  bool flip = false;
+  bool emit;
+
+  const int indices_regular[] = {0, 1, 2};
+  const int indices_flipped[] = {0, 2, 1};
+
+  for (auto it = I->begin(); !it.is_stop(); ++it) {
+    auto pc = it.data();
+    auto op = it.op_code();
+
+    if (op == CGO_BEGIN) {
+      mode = *reinterpret_cast<const int*>(pc);
+
+      switch (mode) {
+        case GL_TRIANGLE_STRIP:
+        case GL_TRIANGLE_FAN:
+        case GL_TRIANGLES:
+          current_i = 0;
+          vertex_count = 0;
+          flip = false;
+          inside_begin_triangles = true;
+
+          CGOBegin(cgo, GL_TRIANGLES);
+          continue; // for-loop, no add_to_cgo
+      }
+
+      inside_begin_triangles = false;
+    } else if (op == CGO_END) {
+      inside_begin_triangles = false;
+    }
+
+    if (!inside_begin_triangles) {
+      cgo->add_to_cgo(op, pc);
+      continue;
+    }
+
+    // handle operations inside BEGIN/END TRIANGLE(S|_STRIP|_FAN)
+    switch (op) {
+      case CGO_VERTEX:
+        copy3(reinterpret_cast<const float*>(pc), vertices[current_i]);
+        copy3(current_color, colors[current_i]);
+        alphas[current_i] = current_alpha;
+
+        ++vertex_count;
+
+        switch (mode) {
+          case GL_TRIANGLE_STRIP:
+            current_i = vertex_count % 3;
+            emit = (vertex_count > 2);
+            break;
+          case GL_TRIANGLE_FAN:
+            current_i = ((vertex_count + 1) % 2) + 1;
+            emit = (vertex_count > 2);
+            break;
+          default:
+            current_i = vertex_count % 3;
+            emit = (current_i == 0);
+        }
+
+        if (emit) {
+          auto * indices = flip ? indices_flipped : indices_regular;
+
+          if (mode != GL_TRIANGLES) {
+            flip = !flip;
+          }
+
+          CalculateTriangleNormal(vertices[0],
+              vertices[indices[1]],
+              vertices[indices[2]], current_normal);
+
+          CGONormalv(cgo, current_normal);
+
+          for (int j = 0; j < 3; ++j) {
+            int k = indices[j];
+            if (has_color) CGOColorv(cgo, colors[k]);
+            if (has_alpha) CGOAlpha(cgo, alphas[k]);
+            CGOVertexv(cgo, vertices[k]);
+          }
+        }
+
+        break;
+      case CGO_COLOR:
+        copy3(reinterpret_cast<const float*>(pc), current_color);
+        has_color = true;
+        break;
+      case CGO_ALPHA:
+        current_alpha = *reinterpret_cast<const float*>(pc);
+        has_alpha = true;
+        break;
+      case CGO_NORMAL:
+        // discard, we will generate new normals
+        break;
+      default:
+        PRINTFB(G, FB_CGO, FB_Warnings)
+          " CGO-Warning: CGOGenerateNormalsForTriangles: unhandled op=0x%02x inside BEGIN/END\n",
+          op ENDFB(G);
+        cgo->add_to_cgo(op, pc);
+    }
+  }
+
+  CGOStop(cgo);
+  cgo->use_shader = I->use_shader;
+  if (cgo->use_shader){
+    cgo->cgo_shader_ub_color = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_color);
+    cgo->cgo_shader_ub_normal = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_normal);
+  }
+  return (cgo);
+}
+
+CGO *CGOTurnLightingOnLinesOff(CGO * I){
+  CGO *cgo;
+
+  float *pc = I->op;
+  int op;
+  float *save_pc;
+  int cur_mode_is_lines = 0;
+  cgo = CGONewSized(I->G, I->c);
+  while((op = (CGO_MASK & CGO_read_int(pc)))) {
+    save_pc = pc;
+    switch (op) {
+    case CGO_DRAW_ARRAYS:
+      {
+        cgo::draw::arrays * sp = reinterpret_cast<decltype(sp)>(pc);
+        float *vals;
+        int nvals = sp->narrays*sp->nverts;
+        switch (sp->mode){
+        case GL_LINES:
+        case GL_LINE_STRIP:
+          CGODisable(cgo, CGO_GL_LIGHTING);
+          cur_mode_is_lines = true;
+        }
+        vals = cgo->add<cgo::draw::arrays>(sp->mode, sp->arraybits, sp->nverts);
+        memcpy(vals, sp->floatdata, nvals);
+        if (cur_mode_is_lines){
+          CGOEnable(cgo, CGO_GL_LIGHTING);
+          cur_mode_is_lines = false;
+        }
+      }
+      break;
+    case CGO_DRAW_BUFFERS_INDEXED:
+      {
+        cgo::draw::buffers_indexed * sp = reinterpret_cast<decltype(sp)>(pc);
+        int mode = sp->mode, mode_is_lines = 0;
+        switch (mode){
+        case GL_LINES:
+        case GL_LINE_STRIP:
+          mode_is_lines = true;
+        }
+        if (mode_is_lines){
+          CGODisable(cgo, CGO_GL_LIGHTING);
+        }
+        cgo->copy_op_from<cgo::draw::buffers_indexed>(pc);
+        if (mode_is_lines){
+          CGOEnable(cgo, CGO_GL_LIGHTING);
+        }
+      }
+      break;
+    case CGO_DRAW_BUFFERS_NOT_INDEXED:
+      {
+        cgo::draw::buffers_not_indexed * sp = reinterpret_cast<decltype(sp)>(pc);
+        int mode = sp->mode, mode_is_lines = 0;
+        switch (mode){
+        case GL_LINES:
+        case GL_LINE_STRIP:
+          mode_is_lines = true;
+        }
+        if (mode_is_lines){
+          CGODisable(cgo, CGO_GL_LIGHTING);
+        }
+        cgo->copy_op_from<cgo::draw::buffers_not_indexed>(pc);
+        if (mode_is_lines){
+          CGOEnable(cgo, CGO_GL_LIGHTING);
+        }
+      }
+    case CGO_END:
+      {
+        CGOEnd(cgo);
+        if (cur_mode_is_lines){
+          CGOEnable(cgo, CGO_GL_LIGHTING);
+          cur_mode_is_lines = 0;
+        }
+      }
+      break;
+    case CGO_BEGIN:
+      {
+        int mode = CGO_get_int(pc);
+        switch (mode){
+        case GL_LINES:
+        case GL_LINE_STRIP:
+          CGODisable(cgo, CGO_GL_LIGHTING);
+          cur_mode_is_lines = true;
+          break;
+        default:
+          if (!I->use_shader){  // no shaders, not lines, turn lighting on
+            CGOEnable(cgo, CGO_GL_LIGHTING);
+          }
+        }
+        CGOBegin(cgo, mode);
+      }
+      break;
+    default:
+      cgo->add_to_cgo(op, pc);
+    }
+    pc = save_pc;
+    pc += CGO_sz[op];
+  }
+  cgo->use_shader = I->use_shader;
+  if (cgo->use_shader){
+    cgo->cgo_shader_ub_color = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_color);
+    cgo->cgo_shader_ub_normal = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_normal);
+  }
+  return (cgo);
+}
+
+bool CGOHasAnyTriangleVerticesWithoutNormals(CGO *I, bool checkTriangles){
+  float *pc = I->op;
+  int op;
+  short inside = 0, hasNormal = 0;
+  while((op = (CGO_MASK & CGO_read_int(pc)))) {
+    switch (op) {
+    case CGO_BEGIN:
+      switch (CGO_get_int(pc)){
+      case GL_TRIANGLE_FAN:
+      case GL_TRIANGLES:
+      case GL_TRIANGLE_STRIP:
+        if (checkTriangles)
+          inside = 1;
+        break;
+      case GL_LINE_STRIP:
+      case GL_LINES:
+        if (!checkTriangles)
+          inside = 1;
+        break;
+      }
+      break;
+    case CGO_END:
+      inside = 0;
+      break;
+    case CGO_NORMAL:
+      hasNormal = 1;
+      break;
+    case CGO_VERTEX:
+      if (inside && !hasNormal)
+        return 1;
+      break;
+    case CGO_DRAW_ARRAYS:
+      {
+        cgo::draw::arrays * sp = reinterpret_cast<decltype(sp)>(pc);
+        switch (sp->mode){
+        case GL_TRIANGLE_FAN:
+        case GL_TRIANGLES:
+        case GL_TRIANGLE_STRIP:
+          if (checkTriangles){
+            if (!(sp->arraybits & CGO_NORMAL_ARRAY)){
+              return 1;
+            }
+          }
+          break;
+        case GL_LINE_STRIP:
+        case GL_LINES:
+          if (!checkTriangles){
+            if (!(sp->arraybits & CGO_NORMAL_ARRAY)){
+              return 1;
+            }
+          }
+          break;
+        }
+      }
+      break;
+    }
+    pc += CGO_sz[op];
+  }
+  return 0;
+}
+
+/*
+ * CGOReorderIndicesWithTransparentInfo : This function
+ * takes the triangle index array ix (result from TransparentInfoSortIX)
+ * and sets the vertices (vertexIndices) for each triangle from the original
+ * indices (vertexIndicesOriginal), then uses glBufferData to set the 
+ * GL_ELEMENT_ARRAY_BUFFER to these indices.
+ *
+ */
+void CGOReorderIndicesWithTransparentInfo(PyMOLGlobals * G, 
+					  int nindices, size_t vbuf, 
+					  int n_tri, int *ix, 
+					  GL_C_INT_TYPE *vertexIndicesOriginal,
+					  GL_C_INT_TYPE *vertexIndices){
+  int c, pl, idx;
+  IndexBuffer * ibo = G->ShaderMgr->getGPUBuffer<IndexBuffer>( vbuf );
+  if (!vertexIndices){
+    PRINTFB(G, FB_RepSurface, FB_Errors) "ERROR: RepSurfaceRender() vertexIndices is not set, nindices=%d\n", nindices ENDFB(G);
+  }
+  /* updates the vertexIndices from the ix array */
+  for(c = 0, pl=0; c < n_tri; c++) {
+    idx = ix[c] * 3;
+    vertexIndices[pl++] = vertexIndicesOriginal[idx];
+    vertexIndices[pl++] = vertexIndicesOriginal[idx + 1];
+    vertexIndices[pl++] = vertexIndicesOriginal[idx + 2];
+  }
+  ibo->bufferSubData(0, sizeof(GL_C_INT_TYPE) * nindices, vertexIndices);
+}
+
+void CGO::add_to_cgo(int op, const float * pc) {
+  switch (op) {
+  case CGO_STOP:
+    // only append to buffer, don't increment size
+    CGOStop(this);
+    break;
+  case CGO_DRAW_ARRAYS:
+    copy_op_from<cgo::draw::arrays>(pc);
+    break;
+  case CGO_DRAW_BUFFERS_INDEXED:
+    copy_op_from<cgo::draw::buffers_indexed>(pc);
+    break;
+  case CGO_DRAW_TEXTURES:
+    copy_op_from<cgo::draw::textures>(pc);
+    break;
+  case CGO_DRAW_SCREEN_TEXTURES_AND_POLYGONS:
+    copy_op_from<cgo::draw::screen_textures>(pc);
+    break;
+  case CGO_DRAW_LABELS:
+    copy_op_from<cgo::draw::labels>(pc);
+    break;
+  case CGO_DRAW_CONNECTORS:
+    copy_op_from<cgo::draw::connectors>(pc);
+    break;
+  case CGO_DRAW_BUFFERS_NOT_INDEXED:
+    copy_op_from<cgo::draw::buffers_not_indexed>(pc);
+    break;
+  case CGO_DRAW_SPHERE_BUFFERS:
+    copy_op_from<cgo::draw::sphere_buffers>(pc);
+    break;
+  case CGO_DRAW_CYLINDER_BUFFERS:
+    copy_op_from<cgo::draw::cylinder_buffers>(pc);
+    break;
+  case CGO_DRAW_CUSTOM:
+    copy_op_from<cgo::draw::custom>(pc);
+    break;
+  default:
+    int sz = CGO_sz[op];
+    std::copy_n(pc - 1, sz + 1, add_to_buffer(sz + 1));
+  };
+}
+
+void CGO::print_table() const {
+}
+
+CGO *CGOConvertSpheresToPoints(CGO *I){
+  CGO *cgo;
+
+  float *pc = I->op;
+  int op = 0;
+  float *save_pc = NULL;
+  int ok = true;
+  cgo = CGONew(I->G);
+  CHECKOK(ok, cgo);
+  CGOBegin(cgo, GL_POINTS);
+  while(ok && (op = (CGO_MASK & CGO_read_int(pc)))) {
+    save_pc = pc;
+    switch (op) {
+    case CGO_PICK_COLOR:
+      cgo->current_pick_color_index = CGO_get_uint(pc);
+      cgo->current_pick_color_bond = CGO_get_int(pc + 1);
+      CGOPickColor(cgo, cgo->current_pick_color_index, cgo->current_pick_color_bond);
+      break;
+    case CGO_SHADER_CYLINDER:
+    case CGO_SHADER_CYLINDER_WITH_2ND_COLOR:
+    case CGO_CYLINDER:
+    case CGO_CONE:
+    case CGO_SAUSAGE:
+    case CGO_CUSTOM_CYLINDER:
+    case CGO_CUSTOM_CYLINDER_ALPHA:
+    case CGO_END:
+    case CGO_VERTEX:
+    case CGO_BEGIN:
+    case CGO_ELLIPSOID:
+    case CGO_QUADRIC:
+    case CGO_DRAW_BUFFERS_INDEXED:
+    case CGO_DRAW_BUFFERS_NOT_INDEXED:
+    case CGO_DRAW_SPHERE_BUFFERS:
+    case CGO_DRAW_CYLINDER_BUFFERS:
+    case CGO_DRAW_LABELS:
+      break;
+    case CGO_SPHERE:
+      CGOVertexv(cgo, pc);
+      break;
+    case CGO_ALPHA:
+      I->alpha = *pc;
+    default:
+      cgo->add_to_cgo(op, pc);
+    }
+    pc = save_pc;
+    pc += CGO_sz[op];
+    ok &= !I->G->Interrupt;
+  }
+  CGOEnd(cgo);
+  if (ok){
+    ok &= CGOStop(cgo);
+  } 
+  if (!ok){
+    CGOFree(cgo);
+  }
+  return (cgo);
+}
+
+#ifdef _PYMOL_ARB_SHADERS
+void CGORenderSpheresARB(RenderInfo *info, CGO *I, float *fog_info){
+  static const float _00[2] = { 0.0F, 0.0F };
+  static const float _01[2] = { 0.0F, 1.0F };
+  static const float _11[2] = { 1.0F, 1.0F };
+  static const float _10[2] = { 1.0F, 0.0F };
+  if(I->c) {
+    int op;
+    float *pc = I->op;
+    float last_radius;
+    last_radius = -1.f;
+    glNormal3fv(info->view_normal);
+    glBegin(GL_QUADS);
+    while((op = (CGO_MASK & CGO_read_int(pc)))) {
+      switch (op) {
+      case CGO_SPHERE:
+        {
+          float sphereCenter[] = { *(pc), *(pc+1), *(pc+2) };
+          float sphereRadius = *(pc+3);
+          if(last_radius != sphereRadius) {
+            glEnd();
+            glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,
+                                       0, 0.0F, 0.0F, sphereRadius, 0.0F);
+            glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB,
+                                       0, fog_info[0], fog_info[1], 0.0F, 0.0F);
+            glBegin(GL_QUADS);
+            last_radius = sphereRadius;
+          }
+          glTexCoord2fv(_00);
+          glVertex3fv(sphereCenter);
+          glTexCoord2fv(_10);
+          glVertex3fv(sphereCenter);
+          glTexCoord2fv(_11);
+          glVertex3fv(sphereCenter);
+          glTexCoord2fv(_01);
+          glVertex3fv(sphereCenter);
+        }
+        break;
+      case CGO_COLOR:
+        glColor3f(*pc, *(pc + 1), *(pc + 2));
+        break;
+      }
+      pc += CGO_sz[op];
+    }
+    glEnd();
+  }
+}
+#endif
+
+// Will create an interleaved VBO with { vertex, otherVertex, uv, and texcoord info }
+// Currently, this function does not support/parse lines inside CGODrawArrays, i.e.,
+// a CGO that CGOCombineBeginEnd was used on
+CGO *CGOConvertLinesToTrilines(const CGO * I, bool addshaders){
+  CGO *cgo;
+  float *pc = I->op;
+  int op;
+  float *save_pc;
+  static std::set<int> lineops = { CGO_VERTEX, CGO_LINE, CGO_SPLITLINE };
+  int sz, nLines = CGOCountNumberOfOperationsOfTypeN(I, lineops ) + 1;
+  int line_counter = 0;
+  GLuint glbuff = 0;
+  float *colorv = NULL;
+  unsigned int buff_size = nLines * 6 * (8 * sizeof(float));
+  
+  // VBO memory -- number of lines x 4 vertices per line x (vertex + otherVertex + normal + texCoord + color)
+  float *buffer = (float *)malloc(buff_size);
+  float *buffer_start = buffer;
+
+  cgo = CGONew(I->G);
+  while((op = (CGO_MASK & CGO_read_int(pc)))) {
+    save_pc = pc;
+    switch (op) {
+    case CGO_DRAW_ARRAYS:
+    {
+        cgo::draw::arrays * sp = reinterpret_cast<decltype(sp)>(pc);
+	float *vals = cgo->add<cgo::draw::arrays>(sp->mode, sp->arraybits, sp->nverts);
+	int nvals = sp->narrays*sp->nverts;
+        memcpy(vals, sp->floatdata, nvals);
+      }
+      break;
+    case CGO_END:
+      PRINTFB(I->G, FB_CGO, FB_Warnings) " CGOConvertLinesToTrilines: CGO_END encountered without CGO_BEGIN but skipped for OpenGLES\n" ENDFB(I->G);      
+      break;
+    case CGO_VERTEX:
+      PRINTFB(I->G, FB_CGO, FB_Warnings) " CGOConvertLinesToTrilines: CGO_VERTEX encountered without CGO_BEGIN but skipped for OpenGLES\n" ENDFB(I->G);      
+      break;
+    case CGO_BEGIN:
+      {
+	float *last_vertex = NULL, *last_color = NULL, *current_color = NULL, *color = NULL ;
+	int nverts = 0, err = 0, end = 0;
+	int mode = CGO_read_int(pc);
+	while(!err && !end && (op = (CGO_MASK & CGO_read_int(pc)))) {
+	  end = (op == CGO_END);
+	  switch (op) {
+	  case CGO_VERTEX:
+	    if (last_vertex){
+	      switch (mode){
+	      case GL_LINES:
+	      case GL_LINE_STRIP:
+		{
+		  float cc[3] = { 1, 1, 1 };
+		  float alpha = cgo->alpha;
+                  CGOTrilines_GetCurrentColor(current_color, colorv, last_color, cc);
+		  trilinesBufferAddVertices(buffer, pc, last_vertex, current_color, alpha);
+		  line_counter++;
+		  last_vertex = pc;
+		}
+		if (mode==GL_LINES){
+		  last_vertex = NULL;
+		  last_color = NULL;
+		}
+	      }
+	    } else {
+	      last_vertex = pc;
+	      current_color = color;
+	    }
+	    nverts++;
+	  case CGO_LINE:
+	    if (op == CGO_LINE){
+              auto line = reinterpret_cast<cgo::draw::line *>(pc);
+              float cc[3] = { 1, 1, 1 };
+              float alpha = cgo->alpha;
+              CGOTrilines_GetCurrentColor(current_color, colorv, last_color, cc);
+              trilinesBufferAddVertices(buffer, line->vertex1, line->vertex2, current_color, alpha);
+              line_counter++;
+            }
+	  case CGO_SPLITLINE:
+	    if (op == CGO_SPLITLINE){
+              auto splitline = reinterpret_cast<cgo::draw::splitline *>(pc);
+              float cc[3] = { 1, 1, 1 };
+              float alpha = cgo->alpha;
+              float mid[3];
+              float color2[] = { CONVERT_COLOR_VALUE(splitline->color2[0]),
+                                 CONVERT_COLOR_VALUE(splitline->color2[1]),
+                                 CONVERT_COLOR_VALUE(splitline->color2[2]) };
+              add3f(splitline->vertex1, splitline->vertex2, mid);
+              mult3f(mid, .5f, mid);
+              CGOTrilines_GetCurrentColor(current_color, colorv, last_color, cc);
+              trilinesBufferAddVertices(buffer, splitline->vertex1, mid, current_color, alpha);
+              trilinesBufferAddVertices(buffer, mid, splitline->vertex2, color2, alpha);
+              line_counter+=2;
+            }
+	  case CGO_END:
+	    if (op == CGO_END){
+	      switch (mode){
+	      case GL_LINES:
+	      case GL_LINE_STRIP:
+		break;
+	      }
+	    }
+	  case CGO_COLOR:
+	    if (op == CGO_COLOR){
+	      last_color = current_color;
+	      current_color = pc;
+	      color = pc;
+	    }
+	  default:
+	    sz = CGO_sz[op];
+	    pc += sz;
+
+	    break;
+	  }
+	  if (end){
+	    break;
+	  }
+	}
+	//tot_nverts += nverts;
+	save_pc = pc;
+      }
+      break;
+    case CGO_ALPHA:
+      cgo->alpha = *pc;
+      break;
+    case CGO_COLOR:
+      colorv = pc;
+    default:
+      break;
+    }
+    pc = save_pc;
+    pc += CGO_sz[op];
+  }
+
+  cgo->use_shader = I->use_shader;
+  if (cgo->use_shader){
+    cgo->cgo_shader_ub_color = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_color);
+    cgo->cgo_shader_ub_normal = SettingGetGlobal_i(cgo->G, cSetting_cgo_shader_ub_normal);
+  }
+
+  if (nLines){
+    int err = 0;
+    glGenBuffers(1, &glbuff);
+    glBindBuffer(GL_ARRAY_BUFFER, glbuff);
+    glBufferData(GL_ARRAY_BUFFER, line_counter * 6 * 8 * sizeof(float), buffer_start, GL_STATIC_DRAW);
+    free(buffer_start);
+    CHECK_GL_ERROR_OK("ERROR: CGOConvertLinesToTriangleStrips() glBindBuffer returns err=%d\n");
+    if (addshaders)
+      CGOEnable(cgo, GL_TRILINES_SHADER);
+
+    pc = CGO_add(cgo, CGO_DRAW_TRILINES_HEADER);
+    if (!pc) {
+      glDeleteBuffers(1, &glbuff);
+      return NULL;
+    }
+    CGO_write_int(pc, CGO_DRAW_TRILINES);
+    CGO_write_int(pc, line_counter * 6);
+    CGO_write_int(pc, glbuff);
+    cgo->has_draw_buffers = true;
+    if (addshaders)
+        CGODisable(cgo, GL_TRILINES_SHADER);
+    CGOStop(cgo);
+    return (cgo);
+  } else {
+    return NULL;
+  }
+}
+
+/*
+ * copies data for a particular attribute operation into the array used to load the VBO.
+ * this takes into account whether it is interleaved or not.
+ * 
+ * isInterleaved    : whether the VBO is interleaved
+ * nvert            : which vertex in the VBO
+ * attribOp         : the attribute op
+ * vertexDataSize   : total vertex data size in VBO (for interleaved)
+ * dataPtrs         : all data pointers for attributes (for interleaved, they are all the pointer to the one array)
+ * attrOffset       : offsets of the attributes (for interleaved)
+ * pcarg            : pc pointer to CGO operation data
+ * pick_data        : pointer to pick data for current vertex (writes to if pick data)
+ * has_pick_colorBS : keeps track of which pick attributes have been set
+ *
+ */
+static
+void copyAttributeForOp(bool isInterleaved, int &nvert, AttribOp *attribOp, int vertexDataSize, vector<void*> &dataPtrs,
+                        vector<int> &attrOffset, const float *pcarg, float *pick_data, int &has_pick_colorBS, int pstride){
+  auto attrDesc = attribOp->desc;
+  int ord = attrDesc->order;
+  int copyord = -1;
+  void *dataPtr = dataPtrs[ord];
+  unsigned char *pc = ((unsigned char *)pcarg) + attribOp->offset;
+  if (isInterleaved){
+    dataPtr = (unsigned char*) dataPtr + nvert * vertexDataSize + attrOffset[ord];
+    if (attribOp->copyAttribDesc){
+      copyord = attribOp->copyAttribDesc->order;
+      pc = ((unsigned char*) dataPtrs[ord]) + nvert * vertexDataSize + attrOffset[copyord];
+    }
+  } else {
+    int sz = gl_sizeof(attrDesc->type_size) * attrDesc->type_dim;
+    dataPtr = (unsigned char*) dataPtr + nvert * sz;
+    if (attribOp->copyAttribDesc){
+      copyord = attribOp->copyAttribDesc->order;
+      int copysz = gl_sizeof(attribOp->copyAttribDesc->type_size) * attribOp->copyAttribDesc->type_dim;
+      pc = (unsigned char*) dataPtr + nvert * copysz;
+    }
+  }
+  switch (attribOp->conv_type){
+  case NO_COPY:
+    break;
+  case FLOAT_TO_FLOAT:
+    *((float *) dataPtr) = *((float *)pc);
+    break;
+  case FLOAT2_TO_FLOAT2:
+    *((float *) dataPtr) = *((float *)pc);
+    *((float *) dataPtr + 1) = *((float *)pc + 1);
+    break;
+  case FLOAT3_TO_FLOAT3:
+    copy3f((float*)pc, (float*)dataPtr);
+    break;
+  case FLOAT4_TO_FLOAT4:
+    *((float *) dataPtr) = *((float *)pc);
+    *((float *) dataPtr + 1) = *((float *)pc + 1);
+    *((float *) dataPtr + 2) = *((float *)pc + 2);
+    *((float *) dataPtr + 3) = *((float *)pc + 3);
+    break;
+  case FLOAT3_TO_UB3:
+    {
+      auto dataPtrUB = (unsigned char *)dataPtr;
+      float *pcf = (float*)pc;
+      dataPtrUB[0] = CLIP_COLOR_VALUE(pcf[0]);
+      dataPtrUB[1] = CLIP_COLOR_VALUE(pcf[1]);
+      dataPtrUB[2] = CLIP_COLOR_VALUE(pcf[2]);
+    }
+    break;
+  case FLOAT1_TO_UB_4TH:
+    {
+      auto dataPtrUB = (unsigned char *)dataPtr;
+      float *pcf = (float*)pc;
+      dataPtrUB[3] = CLIP_COLOR_VALUE(pcf[0]);
+    }
+    break;
+  case UB3_TO_UB3:
+    {
+      auto dataPtrUB = (unsigned char *)dataPtr;
+      auto pcUB = (unsigned char *)pc;
+      dataPtrUB[0] = pcUB[0];
+      dataPtrUB[1] = pcUB[1];
+      dataPtrUB[2] = pcUB[2];
+      break;
+    }
+  case UINT_INT_TO_PICK_DATA:
+    {
+      float *pcf = (float*)pc;
+      unsigned int index = CGO_get_uint(pcf);
+      int bond = CGO_get_int(pcf+1);
+      CGO_put_uint(ord * 2 + pick_data, index);
+      CGO_put_int(ord * 2 + pick_data + 1, bond);
+      has_pick_colorBS |= (1 << ord) ;
+    }
+    break;
+  case FLOAT4_TO_UB4:
+    {
+      auto dataPtrUB = (unsigned char *)dataPtr;
+      float *pcf = (float*)pc;
+      dataPtrUB[0] = CLIP_COLOR_VALUE(pcf[0]);
+      dataPtrUB[1] = CLIP_COLOR_VALUE(pcf[1]);
+      dataPtrUB[2] = CLIP_COLOR_VALUE(pcf[2]);
+      dataPtrUB[3] = CLIP_COLOR_VALUE(pcf[3]);
+    }
+    break;
+  case CYL_CAP_TO_CAP:
+    {
+      unsigned char *dataPtrUB = (unsigned char *)dataPtr;
+      dataPtrUB[0] = *pc;
+    }
+    break;
+  case CYL_CAPS_ARE_ROUND:
+    {
+      unsigned char *dataPtrUB = (unsigned char *)dataPtr;
+      dataPtrUB[0] = cCylShaderBothCapsRound | cCylShaderInterpColor;
+    }
+    break;
+  case CYL_CAPS_ARE_FLAT:
+    {
+      unsigned char *dataPtrUB = (unsigned char *)dataPtr;
+      dataPtrUB[0] = cCylShaderBothCapsFlat | cCylShaderInterpColor;
+    }
+    break;
+  case CYL_CAPS_ARE_CUSTOM:
+    {
+      unsigned char *dataPtrUB = (unsigned char *)dataPtr;
+      float *pcf = (float*)pc;
+      int pci[] = { (int)pcf[0], (int)pcf[1] };
+      dataPtrUB[0] = (((pci[0]) == 1) ? cCylShaderCap1Flat : (((pci[0]) == 2) ? cCylShaderCap1Round : cCylCapNone)) |
+                     (((pci[1]) == 1) ? cCylShaderCap2Flat : (((pci[1]) == 2) ? cCylShaderCap2Round : cCylCapNone)) | 
+                     cCylShaderInterpColor;
+    }
+    break;
+  case UB1_TO_INTERP:
+    {
+      bool interp = (pc[0] & cgo::draw::splitline::interpolation);
+      unsigned char *dataPtrUB = (unsigned char *)dataPtr;
+      dataPtrUB[0] = interp ? 1 : 0;
+    }
+    break;
+  case UB1_INTERP_TO_CAP:
+    {
+      bool interp = (pc[0] & cgo::draw::splitline::interpolation);
+      unsigned char *dataPtrUB = (unsigned char *)dataPtr;
+      dataPtrUB[0] = (cCylShaderBothCapsRound | (interp ? cCylShaderInterpColor : 0));
+    }
+    break;
+  case FLOAT1_TO_INTERP:
+    {
+      float interp = *((float*)pc);
+      unsigned char *dataPtrUB = (unsigned char *)dataPtr;
+      dataPtrUB[0] = (interp > .5f) ? 1 : 0;
+    }
+    break;
+  case FLOAT1_INTERP_TO_CAP:
+    {
+      float interp = *((float*)pc);
+      unsigned char *dataPtrUB = (unsigned char *)dataPtr;
+      dataPtrUB[0] = (cCylShaderBothCapsRound | ((interp > .5f) ? cCylShaderInterpColor : 0));
+    }
+    break;
+  case UB4_TO_UB4:
+    {
+      auto dataPtrUB = (unsigned char *)dataPtr;
+      auto pcUB = (unsigned char *)pc;
+      dataPtrUB[0] = pcUB[0];
+      dataPtrUB[1] = pcUB[1];
+      dataPtrUB[2] = pcUB[2];
+      dataPtrUB[3] = pcUB[3];
+      break;
+    }
+  case PICK_DATA_TO_PICK_DATA:
+    {
+      float *pcf;
+      if (copyord < 0){
+        pcf = (float*)pc;
+      } else {
+        pcf = (copyord * 2 + pick_data);
+        if (nvert){
+          pcf -= pstride;
+        }
+      }
+      unsigned int index = CGO_get_uint(pcf);
+      int bond = CGO_get_int(pcf+1);
+      CGO_put_uint(ord * 2 + pick_data, index);
+      CGO_put_int(ord * 2 + pick_data + 1, bond);
+      has_pick_colorBS |= (1 << ord) ;
+      break;
+    }
+  }
+}
+
+/*
+ * copies data for a particular attribute into the array used to load the VBO.
+ * this takes into account whether it is interleaved or not, and if an attribute
+ * has repeat values
+ * 
+ * isInterleaved  : whether the VBO is interleaved
+ * nvert          : which vertex in the VBO
+ * attribDesc     : the attribute description
+ * vertexDataSize : total vertex data size in VBO (for interleaved)
+ * dataPtrs       : all data pointers for attributes (for interleaved, they are all the pointer to the one array)
+ * attrOffset     : offsets of the attributes (for interleaved)
+ *
+ */
+static
+void copyAttributeForVertex(bool isInterleaved, int &nvert, AttribDesc &attribDesc,
+                            const int vertexDataSize, vector<void*> &dataPtrs, vector<int> &attrOffset){
+  int ord = attribDesc.order;
+  void *dataPtr = dataPtrs[ord];
+  unsigned char *pc = NULL;
+  int attrSize = gl_sizeof(attribDesc.type_size) * attribDesc.type_dim;
+  if (isInterleaved){
+    dataPtr = (unsigned char*) dataPtr + nvert * vertexDataSize + attrOffset[ord];
+    pc = (unsigned char*) dataPtr - vertexDataSize;
+  } else {
+    dataPtr = (unsigned char*) dataPtr + nvert * attrSize;
+    pc = (unsigned char*) dataPtr - attrSize;
+  }
+  if (attribDesc.repeat_value && attribDesc.repeat_value_length){
+    int pos = (nvert % attribDesc.repeat_value_length);
+    pc = attribDesc.repeat_value + pos * attrSize;
+    memcpy(dataPtr, pc, attrSize);
+  } else {
+    memcpy(dataPtr, pc, attrSize);
+  }
+}
+/*
+ * check all attributes (pick and non-pick) to see if they are specified in the CGO (I)
+ * also checks to see if any picking is specified and sets has_picking argument
+ * if any of the attributes are not specified and if a default_value is set (in the 
+ * AttribDesc) then the associated vertex_attribute CGO operation is inserted into the
+ * cgo that is passed in.
+ *
+ * I:           primitive CGO that is processed
+ * attrData:    definition of attributes
+ * pickData:    definition of pick attributes
+ * cgo:         new cgo that could have vertex_attribute CGO operations added
+ * has_picking: if there are any operations in the CGO (I) that specifies different values for picking.
+ *              if has_picking is set, then a VBO for picking is generated in CGOConvertToShader()
+ *
+ */
+static
+void CheckAttributesForUsage(const CGO *I, AttribDataDesc &attrData, AttribDataDesc &pickData, CGO *cgo, bool &has_picking)
+{
+  size_t attrIdx = 0;
+
+  // need to check attributes:
+  //  - remove any that are not needed
+  //  - add glVertexAttrib for those that are removed
+  std::map<int, int> opToAttrUsed; // bitmask for each op to which attributes are set
+  for (auto &attrDesc : attrData){
+    auto attrOps = &attrDesc.attrOps;
+    attrDesc.order = attrIdx++;
+    for (auto attrOpIt = attrOps->begin(); attrOpIt!=attrOps->end(); ++attrOpIt){
+      auto attrOp = &(*attrOpIt);
+      if (opToAttrUsed.find(attrOp->op) == opToAttrUsed.end())
+        opToAttrUsed[attrOp->op] = 1 << attrDesc.order;
+      else
+        opToAttrUsed[attrOp->op] |= 1 << attrDesc.order;
+    }
+  }
+  // add picking ops (1 << attrIdx) i.e., any pick op is the last bit
+  int pidx = 0;
+  for (auto pickDataIt = pickData.begin(); pickDataIt!=pickData.end(); ++pickDataIt){
+    auto pickDesc = &(*pickDataIt);
+    auto pickOps = &pickDesc->attrOps;
+    pickDesc->order = pidx++;
+    for (auto pickOpIt = pickOps->begin(); pickOpIt!=pickOps->end(); ++pickOpIt){
+      auto pickOp = &(*pickOpIt);
+      pickOp->desc = pickDesc;
+      if (opToAttrUsed.find(pickOp->op) == opToAttrUsed.end())
+        opToAttrUsed[pickOp->op] = 1 << attrIdx;
+      else
+        opToAttrUsed[pickOp->op] |= 1 << attrIdx;
+    }
+  }
+  size_t totAttrIdx = (1 << (attrIdx+1)) - 1;
+  size_t allAttrIdxUsed = 0;
+  for (auto it = I->begin(); !it.is_stop(); ++it) {
+    auto pc = it.data();
+    int op = it.op_code();
+    if (opToAttrUsed.find(op) != opToAttrUsed.end()){
+      int attrUsed = opToAttrUsed[op];
+      if (attrUsed & (1 << attrIdx)){ // if picking, need to check values, and take them out if cPickableNoPick
+        switch (op){
+        case cgo::draw::shadercylinder2ndcolor::op_code:
+          if (reinterpret_cast<const cgo::draw::shadercylinder2ndcolor *>(pc)->pick_color_bond == cPickableNoPick)
+            attrUsed ^= (1 << attrIdx);
+          break;
+        case cgo::draw::splitline::op_code:
+          if (reinterpret_cast<const cgo::draw::splitline *>(pc)->bond == cPickableNoPick)
+            attrUsed ^= (1 << attrIdx);
+        }
+      }
+      allAttrIdxUsed |= attrUsed;
+      if (allAttrIdxUsed == totAttrIdx)
+        break;
+    }
+  }
+  has_picking = allAttrIdxUsed & (1 << attrIdx);  // has_picking if the last bit is set
+
+  if (allAttrIdxUsed != totAttrIdx){
+    // go through any attributes that aren't used:
+    //   - add associated vertex_attribute type (if default_value is set)
+    //   - remove attribute from attrData description so that it isn't included in VBO
+    AttribDataDesc attrDataNew;
+    for (auto idx = 0; idx < attrIdx; ++idx){
+      if (!attrData[idx].repeat_value && !(allAttrIdxUsed & (1 << idx))) {
+        // attribute not used, need to create glVertexAttrib
+        if (attrData[idx].default_value){
+          // need to add glVertexAttrib CGO OP
+          int attr_lookup_idx = I->G->ShaderMgr->GetAttributeUID(attrData[idx].attr_name);
+          switch (attrData[idx].type_size){
+          case GL_FLOAT:
+            switch (attrData[idx].type_dim){
+            case 1:
+              cgo->add<cgo::draw::vertex_attribute_1f>(attr_lookup_idx, *(float*)attrData[idx].default_value);
+              break;
+            case 3:
+              cgo->add<cgo::draw::vertex_attribute_3f>(attr_lookup_idx, attrData[idx].default_value);
+              break;
+            default:
+              std::cerr << "\tNOT IMPLEMENTED: attrData[idx].type_size=" << attrData[idx].type_size << " attrData[idx].type_dim=" << attrData[idx].type_dim << endl;
+            }
+            break;
+          case GL_UNSIGNED_BYTE:
+            switch (attrData[idx].type_dim){
+            case 1:
+              {
+                float val;
+                unsigned char valuc = *attrData[idx].default_value;
+                if (attrData[idx].data_norm){
+                  val = CLAMPVALUE(valuc / 255.f, 0.f, 1.f);
+                } else {
+                  val = (float)valuc;
+                }
+                cgo->add<cgo::draw::vertex_attribute_1f>(attr_lookup_idx, val);
+              }
+              break;
+            case 4:
+              cgo->add<cgo::draw::vertex_attribute_4ub>(attr_lookup_idx, attrData[idx].default_value);
+              break;
+            default:
+              std::cerr << "\tNOT IMPLEMENTED: attrData[idx].type_size=" << attrData[idx].type_size << " attrData[idx].type_dim=" << attrData[idx].type_dim << endl;
+            }
+          }
+        }
+      } else {
+        attrDataNew.push_back(attrData[idx]);
+      }
+    }
+    attrData.swap(attrDataNew);  // only keep attributes that are used
+  }
+}
+
+/*
+ * Populates two structures and sets vertsperpickinfo
+ * opToCntPer           : CGO op to how many vertices are generated for each op.
+ * opToOrderedAttribOps : CGO op to an ordered map of AttribOps that define how we operate on
+ *                        the attribute arrays for each CGO op.
+ * attrData             : definition of attributes
+ * pickData             : definition of pick attributes
+ * vertsperpickinfo     : number of vertices per pick (only used when 
+ * 
+ */
+static
+void PopulateOpsIntoStructuresForConversion(std::map<int,int> &opToCntPer,
+                                            std::map< int, std::map<int, AttribOp*> > &opToOrderedAttribOps, 
+                                            AttribDataDesc &attrData, AttribDataDesc &pickData,
+                                            int &vertsperpickinfo, const bool has_picking){
+  size_t attrIdx = 0;
+  for (auto &attrDesc : attrData){
+    auto attrOps = &attrDesc.attrOps;
+    attrDesc.order = attrIdx++;
+    for (auto attrOpIt = attrOps->begin(); attrOpIt!=attrOps->end(); ++attrOpIt){
+      auto attrOp = &(*attrOpIt);
+      attrOp->desc = &attrDesc;
+      if (attrOp->copyFromAttr >= 0){
+        attrOp->copyAttribDesc = &attrData[attrOp->copyFromAttr];
+      }
+      if (attrOp->incr_vertices > 0){
+        if (!vertsperpickinfo){
+          vertsperpickinfo = attrOp->incr_vertices;
+        } else {
+          if (attrOp->incr_vertices != vertsperpickinfo){
+            std::cerr << "WARNING: attrOp->incr_vertices set to multiple values, vertsperpickinfo=" << vertsperpickinfo << " attrOp->incr_vertices=" << attrOp->incr_vertices << " : picking might get confused" << std::endl;
+          }
+        }
+        if (opToCntPer.find(attrOp->op) == opToCntPer.end())
+          opToCntPer[attrOp->op] = attrOp->incr_vertices;
+        else
+          opToCntPer[attrOp->op] += attrOp->incr_vertices;
+      }
+      if (opToOrderedAttribOps.find(attrOp->op) == opToOrderedAttribOps.end())
+        opToOrderedAttribOps[attrOp->op] = std::map<int, AttribOp*>({});
+      opToOrderedAttribOps[attrOp->op][attrOp->order] = attrOp;
+    }
+  }
+  if (has_picking){
+    for (auto pickDataIt = pickData.begin(); pickDataIt!=pickData.end(); ++pickDataIt){
+      auto pickDesc = &(*pickDataIt);
+      auto pickOps = &pickDesc->attrOps;
+      for (auto pickOpIt = pickOps->begin(); pickOpIt!=pickOps->end(); ++pickOpIt){
+        auto pickOp = &(*pickOpIt);
+        if (pickOp->copyFromAttr >= 0){
+          pickOp->copyAttribDesc = &pickData[pickOp->copyFromAttr];
+        }
+        if (opToOrderedAttribOps.find(pickOp->op) == opToOrderedAttribOps.end())
+          opToOrderedAttribOps[pickOp->op] = std::map<int, AttribOp*>({});
+        opToOrderedAttribOps[pickOp->op][pickOp->order] = pickOp;
+      }
+    }
+  }
+}
+
+/*
+ * converts a "primitive" CGO into a CGO that renders a custom operation
+ *
+ * I:                   primitive CGO that is processed
+ * attrData:            definition of attributes that are accumulated and put into the VBO
+ * pickData:            definition of pick attributes that accumulate pick data and put into the interleaved picking VBO
+ * mode:                which openGL mode to use for rendering (e.g., GL_POINTS, GL_TRIANGLES, GL_LINE_STRIPS, etc.)
+ * layout:              SEPARATE, SEQUENTIAL, or INTERLEAVED : how the VBO is layed out in memory (default: INTERLEAVED)
+ * check_attr_for_data: if true, this function checks whether all attributes are used, and if any are not specified,
+ *                      and default values are defined in AttribDesc, then glVertexAttrib CGO ops are created on the
+ *                      returned CGO (default: true)
+ * idx_array:           if specified, this array is used to specify indices for each fragment in an Indexed Buffer
+ *                      and glDrawElements is used to render (instead of glDrawArrays)
+ * nvertsperfrag:       in conjunction with idx_array, how many vertices for each set of indices (default: 0)
+ *                      both idx_array and nvertsperfrag are used to specify vertices and geometry for each fragment,
+ *                      such as the box for cylinders
+ * nfragspergroup:      Currently, this represents the number of fragments that are inside of a group.  For example,
+ *                      crosses as cylinders (CGOConvertCrossesToCylinderShader) have 36 indices per fragment (nvertsperfrag=36)
+ *                      and 3 fragments per group (nfragspergroup=3) (i.e., one for each line).
+ *                      note: idx_array, nvertsperfrag and nfragspergroup should probably be moved to AttrOp in
+ *                            the future to support different types of fragments.
+ *
+ * returns a CGO that consists of vertex_attrib_* (e.g., glVertexAttrib) and a custom CGO operation that calls
+ * either glDrawArrays or glDrawElements. It also supports picking if specified in the pickData.
+ *
+ */
+CGO *CGOConvertToShader(const CGO *I, AttribDataDesc &attrData, AttribDataDesc &pickData, int mode, 
+                        const VertexBuffer::buffer_layout layout, bool check_attr_for_data,
+                        int *idx_array, int nvertsperfrag, int nfragspergroup){
+  CGO *cgo;
+  int ok = true;
+  bool isInterleaved = (layout == VertexBuffer::INTERLEAVED);
+  bool has_picking = true;
+  std::map<string, AttribDesc*> attrToDesc;
+
+  cgo = CGONew(I->G);
+  cgo->use_shader = true;
+
+  if (check_attr_for_data){
+    CheckAttributesForUsage(I, attrData, pickData, cgo, has_picking);
+  } else {
+    // if attributes aren't checked, still need to set pick order and desc pointer
+    int pidx = 0;
+    for (auto &pickDesc : pickData){
+      pickDesc.order = pidx++;
+      for (auto &pickOp : pickDesc.attrOps){
+        pickOp.desc = &pickDesc;
+      }
+    }
+  }
+  std::map<int,int> opToCntPer;
+  std::map< int, std::map<int, AttribOp*> > opToOrderedAttribOps ;
+
+  int vertsperpickinfo = 0;
+  PopulateOpsIntoStructuresForConversion(opToCntPer, opToOrderedAttribOps, attrData,
+                                         pickData, vertsperpickinfo, has_picking);
+
+
+  // Populate these variables used for accumulating and setting VBO data arrays
+  int vertexDataSize = 0;
+  vector<int> attrSizes;
+  vector<int> attrOffset; // for interleaved
+  int curoffset = 0;      // for interleaved
+  size_t attrIdx = 0;
+  for (auto &attrDesc : attrData){
+    attrDesc.order = attrIdx++;
+    int attrSize = gl_sizeof(attrDesc.type_size) * attrDesc.type_dim;
+    attrSizes.push_back(attrSize);
+    vertexDataSize += attrSize;
+
+    if (isInterleaved){
+      attrOffset.push_back(curoffset);
+      curoffset += attrSize;
+    } else {
+      attrOffset.push_back(0);  // no offset when not interleaved
+    }
+    attrToDesc[attrDesc.attr_name] = &attrDesc;
+  }
+
+  // populate funcData.attrib
+  for (auto &attrDesc : attrData)
+    for (auto &attrop : attrDesc.attrOps)
+      for (auto &funcData : attrop.funcDataConversions){
+        if (attrToDesc.find(funcData.attribName) != attrToDesc.end()){
+          funcData.attrib = attrToDesc[funcData.attribName];
+        }
+      }
+
+  // Since some cards require word-aligned strides (e.g., ATI)
+  // we need to make sure it is word-aligned.  If it isn't, and you
+  // want to save memory, maybe SEQUENTIAL is a better option
+  if (vertexDataSize % 4){
+    vertexDataSize += 4 - (vertexDataSize % 4);
+  }
+
+  int ntotalverts = CGOCountNumberOfOperationsOfTypeN(I, opToCntPer);
+
+  // PYMOL-2668
+  if (ntotalverts == 0) {
+    CGOStop(cgo);
+    return cgo;
+  }
+
+  size_t pickvbohash = 0;
+  int pickDataSize = pickData.size();
+  int pstride = 2 * pickDataSize;
+  // Generate VBOs: both for vertex data (vbo) and picking color data (pickvbo) if necessary
+  // - pickvbo is interleaved so that for multiple channels, pick data for each vertex
+  //   is contiguous
+  VertexBuffer *vbo = I->G->ShaderMgr->newGPUBuffer<VertexBuffer>(layout);
+  VertexBuffer *pickvbo = NULL;
+  if (pickDataSize){
+    pickvbo = I->G->ShaderMgr->newGPUBuffer<VertexBuffer>(VertexBuffer::SEQUENTIAL, GL_DYNAMIC_DRAW);
+    pickvbohash = pickvbo->get_hash_id();
+  }
+
+  // adding SPECIAL OPERATIONS (for now) before adding custom OP
+  // - for now, this is the only operation that needs to be passed to the new CGO
+  for (auto it = I->begin(); !it.is_stop(); ++it) {
+    auto pc = it.data();
+    int op = it.op_code();
+    switch (op){
+    case CGO_SPECIAL:
+      cgo->add_to_cgo(op, pc);
+      break;
+    }
+  }
+
+  // defines how many passes we have, not sure if npickcolattr is actually ever not 32bits with shaders,
+  // but we support two-pass picking
+  int npickcolattr = SceneHas32BitColor(I->G) ? 1 : 2;
+  /* for picking, we need to mask the attributes and bind the buffer in the the picking VBO */
+  int pl = 0;
+  int npickattr = pickData.size();
+  for (auto &pickDesc : pickData){
+    cgo->add<cgo::draw::mask_attribute_if_picking>(I->G->ShaderMgr->GetAttributeUID(pickDesc.attr_name), vbo->get_hash_id());
+    if (has_picking){
+      cgo->add<cgo::draw::bind_vbo_for_picking>(pickvbohash, pl++, npickattr);
+    } else {
+      /* if no picking, should render black */
+      static unsigned char zerocolor[] { 0,0,0,0 };
+      cgo->add<cgo::draw::vertex_attribute_4ub_if_picking>(I->G->ShaderMgr->GetAttributeUID(pickDesc.attr_name), zerocolor);
+    }
+  }
+  size_t iboid = 0;
+  int num_total_indexes = 0;
+  if (nvertsperfrag){
+    GL_C_INT_TYPE *vertexIndices; 
+    int nfrags = nfragspergroup * ntotalverts/vertsperpickinfo;
+    int nvertsperindivfrag = vertsperpickinfo/nfragspergroup;
+    num_total_indexes = nfrags * nvertsperfrag;
+    vertexIndices = Calloc(GL_C_INT_TYPE, num_total_indexes);
+    int idxpl=0;
+    // using vertsperpickinfo as verts per frag
+    for (int cnt = 0, vpl = 0; cnt < nfrags; ++cnt){
+      for (int idx_array_pl = 0; idx_array_pl < nvertsperfrag; ++idx_array_pl){
+        vertexIndices[idxpl] = idx_array[idx_array_pl] + vpl;
+        idxpl++;
+      }
+      vpl+=nvertsperindivfrag;
+    }
+    IndexBuffer * ibo = I->G->ShaderMgr->newGPUBuffer<IndexBuffer>();
+    ok &= ibo->bufferData({
+        BufferDesc( GL_C_INT_ENUM, sizeof(GL_C_INT_TYPE) * num_total_indexes, vertexIndices )
+          });
+    FreeP(vertexIndices);
+    iboid = ibo->get_hash_id();
+  }
+
+  // pick_data is interleaved if more than one attribute
+  float * pick_data = cgo->add<cgo::draw::custom>(mode, ntotalverts, vbo->get_hash_id(), pickvbohash, vertsperpickinfo, pickDataSize, iboid, num_total_indexes);
+  void *allData = malloc(ntotalverts * vertexDataSize);
+  vector<void*> dataPtrs;
+  vector<int> repeat_attr_idx;
+  int allAttrBS = 0;
+
+  // Initialize first entry in array(s) with default values and populate dataPtrs
+  if (isInterleaved){
+    int pl = 0;
+    auto attrDataIt = attrData.begin();
+    auto attrOffsetIt = attrOffset.begin();
+    for (; attrDataIt!=attrData.end() && attrOffsetIt!=attrOffset.end(); ++attrDataIt, ++attrOffsetIt){
+      auto attrDesc = &(*attrDataIt);
+      if (attrDesc->repeat_value){
+        repeat_attr_idx.push_back(pl);
+      } else {
+        allAttrBS |= (1 << attrDesc->order);
+      }
+      auto attrOffset = *attrOffsetIt;
+      unsigned char *first_value = NULL;
+      first_value = (attrDesc->default_value ? attrDesc->default_value : 
+                     (attrDesc->repeat_value ? attrDesc->repeat_value : NULL));
+      if (first_value){
+        int attrSize = gl_sizeof(attrDesc->type_size) * attrDesc->type_dim;
+        memcpy(((unsigned char*)allData)+attrOffset, first_value, attrSize);
+      }
+      dataPtrs.push_back((void*)allData);
+      ++pl;
+    }
+  } else {
+    void *curAllDataPtr = (void*)allData;
+    int pl = 0;
+    for (auto &attrDesc : attrData){
+      if (attrDesc.repeat_value){
+        repeat_attr_idx.push_back(pl);
+      } else {
+        allAttrBS |= (1 << attrDesc.order);
+      }
+      dataPtrs.push_back(curAllDataPtr);
+      unsigned char *first_value = NULL;
+      first_value = (attrDesc.default_value ? attrDesc.default_value : 
+                     (attrDesc.repeat_value ? attrDesc.repeat_value : NULL));
+      if (first_value){
+        memcpy((unsigned char*)curAllDataPtr, first_value, attrSizes[pl]);
+      }
+      curAllDataPtr = ((unsigned char*)curAllDataPtr) + ntotalverts * attrSizes[pl];
+      ++pl;
+    }
+  }
+
+  int nvert = 0;
+  int attrBS = 0;
+  int allPickAttrBS = (1 << pickData.size()) - 1;
+  int has_pick_colorBS = allPickAttrBS;
+  for (int pi = 0; pi<pickDataSize; ++pi){
+    CGO_put_uint(2*pi + pick_data, 0);
+    CGO_put_int(2*pi + pick_data+1, cPickableNoPick);
+  }
+  bool cont = true; // need to break while statement as well if past all vertices
+
+  // This is the loop that goes through the CGO and accumulates all of the data
+  // for both the rendering and picking VBOs.
+  // - For each OP, go through the list of Attribute OPs
+  // - Each Attribute OP:
+  //    - copies attribute data from the OP
+  //    - can generate vertices (incr_vertices)
+  // - Attributes are kept track of (attrBS) and when vertices are generated,
+  //   the attributes that have not been newly written for the current vertex
+  //   are copied from the previous one.
+  for (auto it = I->begin(); cont && !it.is_stop(); ++it) {
+    auto pc = it.data();
+    int op = it.op_code();
+    if (opToOrderedAttribOps.find(op) != opToOrderedAttribOps.end()){
+      std::map<int, AttribOp*> *attribOpsInOrder = &opToOrderedAttribOps[op];
+      for (auto attribOpIt : *attribOpsInOrder){
+        AttribOp *attribOp = attribOpIt.second;
+        int ord = attribOp->desc->order;
+	cont = nvert < ntotalverts;
+	if (!cont)
+	  break;
+        copyAttributeForOp(isInterleaved, nvert, attribOp, vertexDataSize, dataPtrs, attrOffset, pc, pick_data, has_pick_colorBS, pstride);
+        if (ord >= 0)  // picking is negative, has_pick_colorBS is used instead
+          attrBS |= (1 << ord);
+        else
+          cout << "   ord=%d\n" << ord << endl;
+        if (attribOp->incr_vertices){
+          if (has_pick_colorBS!=allPickAttrBS){
+            // copy pick colors that haven't been set from previous vertex
+            for (int pi = 0; pi<pickDataSize; ++pi){
+              if (has_pick_colorBS ^ (1 << pi)){
+                CGO_put_uint(pick_data, CGO_get_uint(pick_data-pstride));
+                CGO_put_int(pick_data + 1, CGO_get_int(pick_data-pstride+1));
+              }
+              pick_data += 2;
+            }
+          } else {
+            pick_data += pstride;
+          }
+          has_pick_colorBS = 0;
+          if (!nvert && attrBS!=allAttrBS){
+            // for the first vertex, all attributes should be set
+            for (auto idx = 0; idx < attrData.size(); ++idx){
+              if (!(attrBS & (1 << idx))) {
+                if (!attrData[idx].default_value){
+                  std::cerr << "WARNING: attribute #" << idx <<
+                    " (" << attrData[idx].attr_name << ") not set for first"
+                    " vertex and does not have default value" << std::endl;
+                }
+              }
+            }
+          }
+          if (nvert && attrBS!=allAttrBS){
+            // for each vertex that hasn't been written for the current vertex, copy it from the previous vertex
+            for (auto idx = 0; idx < attrData.size(); ++idx){
+              if (!(attrBS & (1 << idx))) {
+                copyAttributeForVertex(isInterleaved, nvert, attrData[idx], vertexDataSize, dataPtrs, attrOffset);
+              }
+            }
+          }
+          attrBS = 0;
+
+          // creating new vertices, all attribute data should be copied into new vertex.
+          for (int nxt = 0; nxt < attribOp->incr_vertices; ++nxt){
+            /* for now, always copy values from previous */
+            ++nvert;
+            if (nvert < ntotalverts){
+              {
+                // last should not need to copy into next, since we call copyAttributeForVertex (above)
+                // for all attributes that haven't been set
+                // - note: it might be faster (especially for interleaved) to copy into the next
+                //         vertex, then the above copyAttributeForVertex() would not be needed
+                if (isInterleaved){
+                  void *dest = ((unsigned char*)allData)+vertexDataSize*nvert;
+                  memcpy(dest, ((unsigned char*)dest) - vertexDataSize, vertexDataSize);
+                } else {
+                  auto dataPtrIt = dataPtrs.begin();
+                  auto attrDataIt = attrData.begin();
+                  for (; attrDataIt!=attrData.end() && dataPtrIt!=dataPtrs.end(); ++attrDataIt, ++dataPtrIt){
+                    auto attrDesc = &(*attrDataIt);
+                    auto dataPtr = *dataPtrIt;
+                    int attrSize = gl_sizeof(attrDesc->type_size) * attrDesc->type_dim;
+                    void *dest = ((unsigned char*)dataPtr)+attrSize*nvert;
+                    memcpy((unsigned char*)dest, ((unsigned char*)dest) - attrSize, attrSize);
+                  }
+                }
+              }
+              // always copy repeat attributes
+              if (!repeat_attr_idx.empty()){
+                for (auto ridx = repeat_attr_idx.begin(); ridx != repeat_attr_idx.end(); ++ridx){
+                  copyAttributeForVertex(isInterleaved, nvert, attrData[*ridx], vertexDataSize, dataPtrs, attrOffset);
+                }
+              }
+            }
+            if (!attribOp->funcDataConversions.empty()){
+              // for all attributes, call the funcDataConversion() if defined 
+              int nvert_m_1 = nvert - 1;
+              for (auto funcData : attribOp->funcDataConversions){
+                auto funcAttrib = funcData.attrib;
+                auto order = funcAttrib->order;
+                if (isInterleaved){
+                  unsigned char *dest = ((unsigned char*)allData)+vertexDataSize*nvert_m_1 + attrOffset[order];
+                  funcData.funcDataConversion(dest, pc, funcData.funcDataGlobalArg, nxt);
+                } else {
+                  auto dataPtr = dataPtrs[order];
+                  void *dest = ((unsigned char*)dataPtr)+attrSizes[order]*nvert_m_1;
+                  funcData.funcDataConversion(dest, pc, funcData.funcDataGlobalArg, nxt);
+                }
+              }
+            }
+
+          }
+        }
+      }
+    }
+  }
+
+  /* Generate Pick Buffers with all pick attributes (if necessary) */
+  if (pickvbo){
+    BufferDataDesc pickBufferData;
+    for (int i=0; i < npickcolattr; i++){
+      for (auto &pickDesc : pickData){
+	int pickSize = gl_sizeof(pickDesc.type_size) * pickDesc.type_dim;
+        pickBufferData.push_back(BufferDesc(pickDesc.attr_name, pickDesc.type_size,
+                                            pickDesc.type_dim, pickSize * nvert, NULL, pickDesc.data_norm));
+      }
+    }
+    pickvbo->bufferData(std::move(pickBufferData));
+  }
+
+  /* Generate VBO Buffers with all pick attributes based on the VertexBuffer type SEPARATE/SEQUENTIAL/INTERLEAVED*/
+  BufferDataDesc bufferData;
+  switch (layout){
+  case VertexBuffer::SEPARATE:
+  case VertexBuffer::SEQUENTIAL:
+    {
+      auto attrDataIt = attrData.begin();
+      auto dataPtrIt = dataPtrs.begin();
+      auto attrSizeIt = attrSizes.begin();
+        for (; attrDataIt!=attrData.end() && 
+               dataPtrIt!=dataPtrs.end() && 
+               attrSizeIt!=attrSizes.end(); ++attrDataIt, ++dataPtrIt, ++attrSizeIt){
+        auto attrDesc = &(*attrDataIt);
+        auto dataPtr = *dataPtrIt;
+        auto attrSize = *attrSizeIt;
+        bufferData.push_back(BufferDesc(attrDesc->attr_name, attrDesc->type_size, 
+                                        attrDesc->type_dim, nvert * attrSize, dataPtr, attrDesc->data_norm));
+      }
+        vbo->bufferData(std::move(bufferData));
+    break;
+    }
+    break;
+  case VertexBuffer::INTERLEAVED:
+    {
+      auto attrDataIt = attrData.begin();
+      auto attrOffsetIt = attrOffset.begin();
+      for (; attrDataIt!=attrData.end() && attrOffsetIt!=attrOffset.end(); ++attrDataIt, ++attrOffsetIt){
+        auto attrDesc = &(*attrDataIt);
+        auto offset = *attrOffsetIt;
+        bufferData.push_back(BufferDesc(attrDesc->attr_name, attrDesc->type_size,
+                                        attrDesc->type_dim, offset, attrDesc->data_norm));
+      }
+      vbo->bufferData(std::move(bufferData), (const void *)allData,
+                      (size_t)(nvert*vertexDataSize), (size_t)vertexDataSize);
+    break;
+    }
+  }
+  free(allData);
+
+  CGOStop(cgo);
+  return cgo;
+}
+
+// CGOCheckSplitLineInterpolationIsSame: 
+//   - returns true if always the same
+//   - returns false if not always the same
+bool CGOCheckSplitLineInterpolationIsSame(const CGO *I, bool &interp_value){
+  float *pc = I->op;
+  bool interp_value_first = false;
+  bool interp_value_is_set = false;
+
+  for (auto it = I->begin(); !it.is_stop(); ++it) {
+    switch (it.op_code()) {
+    case cgo::draw::splitline::op_code:
+      interp_value = (it.cast<cgo::draw::splitline>()->flags & cgo::draw::splitline::interpolation);
+      break;
+    case CGO_INTERPOLATED:
+      interp_value = (*pc > .5f);
+      break;
+    default:
+      continue;
+    }
+    if (!interp_value_is_set){
+      interp_value_first = interp_value;
+      interp_value_is_set = true;
+    } else if (interp_value != interp_value_first){
+      return false;
+    }
+  }
+  return true;
+}
+
+// CGOCheckShaderCylinderCapInfoIsSame: 
+//   - returns true if always the same
+//   - returns false if not always the same
+static
+bool CGOCheckShaderCylinderCapInfoIsSame(const CGO *I, unsigned char &cap_value){
+  unsigned char cap_value_first = 0;
+  bool cap_value_first_is_set = false;
+
+  for (auto it = I->begin(); !it.is_stop(); ++it) {
+    switch (it.op_code()) {
+    case cgo::draw::shadercylinder::op_code:
+      cap_value = it.cast<cgo::draw::shadercylinder>()->cap;
+      break;
+    case cgo::draw::shadercylinder2ndcolor::op_code:
+      cap_value = it.cast<cgo::draw::shadercylinder2ndcolor>()->cap;
+      break;
+    case cgo::draw::sausage::op_code:
+      cap_value = cCylShaderBothCapsRound | cCylShaderInterpColor;
+      break;
+    case cgo::draw::cylinder::op_code:
+      cap_value = cCylShaderBothCapsFlat | cCylShaderInterpColor;
+      break;
+    case cgo::draw::custom_cylinder::op_code:
+      {
+        auto cc = it.cast<cgo::draw::custom_cylinder>();
+        int cap1 = (int) cc->cap1;
+        int cap2 = (int) cc->cap2;
+        cap_value = ((cap1 == 1) ? cCylShaderCap1Flat : (cap1 == 2) ? cCylShaderCap1Round : cCylCapNone) |
+                    ((cap2 == 1) ? cCylShaderCap2Flat : (cap2 == 2) ? cCylShaderCap2Round : cCylCapNone) |
+                    cCylShaderInterpColor;
+      }
+      break;
+    case cgo::draw::custom_cylinder_alpha::op_code:
+      {
+        auto cc = it.cast<cgo::draw::custom_cylinder_alpha>();
+        int cap1 = (int) cc->cap1;
+        int cap2 = (int) cc->cap2;
+        cap_value = ((cap1 == 1) ? cCylShaderCap1Flat : (cap1 == 2) ? cCylShaderCap1Round : cCylCapNone) |
+                    ((cap2 == 1) ? cCylShaderCap2Flat : (cap2 == 2) ? cCylShaderCap2Round : cCylCapNone) |
+                    cCylShaderInterpColor;
+      }
+      break;
+    default:
+      continue;
+    }
+
+    if (!cap_value_first_is_set) {
+      cap_value_first = cap_value;
+      cap_value_first_is_set = true;
+    } else if (cap_value != cap_value_first) {
+      return false;
+    }
+  }
+
+  return true;
+}
+
+CGO *CGOConvertToTrilinesShader(const CGO *I, CGO *addTo, bool add_color){
+  PyMOLGlobals *G = I->G;
+
+  AttribDataOp vertexOps =
+    { { CGO_LINE,       1, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::line, vertex1), 0 },
+      { CGO_SPLITLINE,  2, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::splitline, vertex1), 0 } };
+  AttribDataOp vertexOtherOps =
+    { { CGO_LINE,       2, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::line, vertex2), 6 },
+      { CGO_SPLITLINE,  5, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::splitline, vertex2), 6 } };
+  AttribDataOp colorOps =
+    { { CGO_COLOR,      0, FLOAT3_TO_UB3,         0 },
+      { CGO_ALPHA,      0, FLOAT1_TO_UB_4TH,      0 },
+      { CGO_SPLITLINE,  6, UB3_TO_UB3,            offsetof(cgo::draw::splitline, color2) } };
+  AttribDataOp color2Ops =
+    { { CGO_COLOR,      1, FLOAT3_TO_UB3,         0 },
+      { CGO_ALPHA,      1, FLOAT1_TO_UB_4TH,      0 },
+      { CGO_SPLITLINE,  3, UB3_TO_UB3,            offsetof(cgo::draw::splitline, color2) } };
+  AttribDataOp extraPickColorOps =
+    { { CGO_PICK_COLOR, 1, UINT_INT_TO_PICK_DATA, 0, 0 },
+      { CGO_SPLITLINE,  7, UINT_INT_TO_PICK_DATA, offsetof(cgo::draw::splitline, index), 0 } };
+  AttribDataOp extraPickColor2Ops =
+    { { CGO_PICK_COLOR, 2, UINT_INT_TO_PICK_DATA, 0, 0 },
+      { CGO_SPLITLINE,  4, UINT_INT_TO_PICK_DATA, offsetof(cgo::draw::splitline, index), 0 } };
+  AttribDataDesc pickDesc =
+    { { "a_Color", GL_UNSIGNED_BYTE, 4, GL_TRUE, extraPickColorOps },
+      { "a_Color2", GL_UNSIGNED_BYTE, 4, GL_TRUE, extraPickColor2Ops }};
+  AttribDataDesc attrDesc =
+    { { "a_Vertex", GL_FLOAT, 3, GL_FALSE, vertexOps },
+      { "a_OtherVertex", GL_FLOAT, 3, GL_FALSE, vertexOtherOps },
+      { "a_Color", GL_UNSIGNED_BYTE, 4, GL_TRUE, colorOps },
+      { "a_Color2", GL_UNSIGNED_BYTE, 4, GL_TRUE, color2Ops },
+      { "a_UV", GL_UNSIGNED_BYTE, 1, GL_FALSE } };
+
+  if (add_color){
+    static unsigned char default_color[] = { 255, 255, 255, 255 }; // to write in alpha if CGO doesn't have it
+    attrDesc[2].default_value = default_color;
+    attrDesc[3].default_value = default_color;
+  }
+  AttribDesc *uvdesc = &attrDesc[attrDesc.size()-1];
+  uvdesc->repeat_value_length = 6;
+  static unsigned char uv_bits[] = { 1, 3, 0, 3, 2, 1 };
+  uvdesc->repeat_value = uv_bits;
+  
+  bool interp_same, interp_value;
+  if ((interp_same = CGOCheckSplitLineInterpolationIsSame(I, interp_value))){
+    addTo->add<cgo::draw::vertex_attribute_1f>(G->ShaderMgr->GetAttributeUID("a_interpolate"), interp_value ? 1.f : 0.f);
+  } else {
+    AttribDataOp interpOps =
+      { { CGO_SPLITLINE, 1, UB1_TO_INTERP, offsetof(cgo::draw::splitline, flags), 0 } };
+    // need to add a_interpolate attribute
+    attrDesc.push_back({ "a_interpolate", GL_UNSIGNED_BYTE, 1, GL_FALSE, interpOps } );
+  }
+  if (!add_color){
+    attrDesc.erase(attrDesc.begin()+2); // a_Color
+    attrDesc.erase(attrDesc.begin()+2); // a_Color2
+  }
+
+  return CGOConvertToShader(I, attrDesc, pickDesc, GL_TRIANGLES, VertexBuffer::INTERLEAVED);
+}
+
+CGO *CGOConvertToLinesShader(const CGO *I, CGO *addTo, bool add_color){
+  /* Lines that pass in two vertices per line */
+  PyMOLGlobals *G = I->G;
+  AttribDataOp vertexOps =
+    { { CGO_LINE,       1, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::line, vertex1), 1 },
+      { CGO_SPLITLINE,  2, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::splitline, vertex1), 1 },
+      { CGO_LINE,       2, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::line, vertex2), 1 },
+      { CGO_SPLITLINE,  5, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::splitline, vertex2), 1 } };
+  AttribDataOp colorOps =
+    { { CGO_COLOR,      0, FLOAT3_TO_UB3,         0 },
+      { CGO_ALPHA,      0, FLOAT1_TO_UB_4TH,      0 },
+      { CGO_SPLITLINE,  3, UB3_TO_UB3,            offsetof(cgo::draw::splitline, color2) } };
+  AttribDataOp extraPickColorOps =
+    { { CGO_PICK_COLOR, 1, UINT_INT_TO_PICK_DATA, 0, 0 },
+      { CGO_SPLITLINE,  4, UINT_INT_TO_PICK_DATA, offsetof(cgo::draw::splitline, index), 0 } };
+  
+  AttribDataDesc pickDesc =
+    { { "a_Color", GL_UNSIGNED_BYTE, 4, GL_TRUE, extraPickColorOps } };
+  AttribDataDesc attrDesc =
+    { { "a_Vertex", GL_FLOAT, 3, GL_FALSE, vertexOps },
+      { "a_Color", GL_UNSIGNED_BYTE, 4, GL_TRUE, colorOps } };
+  if (add_color){
+    static unsigned char default_color[] = { 255, 255, 255, 255 }; // to write in alpha if CGO doesn't have it
+    attrDesc[1].default_value = default_color;
+  }
+  bool interp_same, interp_value;
+  if ((interp_same = CGOCheckSplitLineInterpolationIsSame(I, interp_value))){
+    addTo->add<cgo::draw::vertex_attribute_1f>(G->ShaderMgr->GetAttributeUID("a_interpolate"), interp_value ? 1.f : 0.f);
+  } else {
+    AttribDataOp interpOps =
+      { { CGO_SPLITLINE, 1, UB1_TO_INTERP, offsetof(cgo::draw::splitline, flags), 0 } };
+    // need to add a_interpolate attribute
+    attrDesc.push_back({ "a_interpolate", GL_UNSIGNED_BYTE, 1, GL_FALSE, interpOps } );
+  }
+#ifndef PURE_OPENGL_ES_2
+  {
+    attrDesc.push_back({ "a_line_position", GL_UNSIGNED_BYTE, 1, GL_FALSE } );
+    AttribDesc *lpdesc = &attrDesc[attrDesc.size()-1];
+    lpdesc->repeat_value_length = 2;
+    static unsigned char flip_bits[] = { 0, 1 };
+    lpdesc->repeat_value = flip_bits;
+  }
+#endif
+  if (!add_color){
+    attrDesc.erase(attrDesc.begin()+1); // a_Color
+  }
+
+  return CGOConvertToShader(I, attrDesc, pickDesc, GL_LINES, VertexBuffer::INTERLEAVED);
+}
+
+CGO *CGOConvertLinesToCylinderShader(const CGO *I, CGO *addTo, bool add_color){
+  /* Lines that pass in two vertices per line */
+  PyMOLGlobals *G = I->G;
+
+  AttribDataOp vertex1Ops =
+    { { CGO_LINE,       1, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::line, vertex1), 0 },
+      { CGO_SPLITLINE,  2, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::splitline, vertex1), 0 } };
+  AttribDataOp vertex2Ops =
+    { { CGO_LINE,       2, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::line, vertex2), 8 },
+      { CGO_SPLITLINE,  5, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::splitline, vertex2), 8 } };
+  static AttribDataOp colorOps =
+    { { CGO_COLOR,      0, FLOAT3_TO_UB3,         0 },
+      { CGO_ALPHA,      0, FLOAT1_TO_UB_4TH,      0 },
+      { CGO_SPLITLINE,  6, UB3_TO_UB3,            offsetof(cgo::draw::splitline, color2) } };
+  static AttribDataOp color2Ops =
+    { { CGO_COLOR,      1, FLOAT3_TO_UB3,         0 },
+      { CGO_ALPHA,      1, FLOAT1_TO_UB_4TH,      0 },
+      { CGO_SPLITLINE,  3, UB3_TO_UB3,            offsetof(cgo::draw::splitline, color2) } };
+
+  AttribDataDesc attrDesc = { { "attr_vertex1", GL_FLOAT, 3, GL_FALSE, vertex1Ops },
+                              { "attr_vertex2", GL_FLOAT, 3, GL_FALSE, vertex2Ops },
+                              { "a_Color",  GL_UNSIGNED_BYTE, 4, GL_TRUE, colorOps },
+                              { "a_Color2", GL_UNSIGNED_BYTE, 4, GL_TRUE, color2Ops },
+                              { "attr_radius", GL_FLOAT, 1, GL_FALSE } };
+  AttribDesc *fdesc;
+  static unsigned char cyl_flags[] = { 0, 4, 6, 2, 1, 5, 7, 3 }; // right(4)/up(2)/out(1)
+
+  attrDesc.push_back( { "attr_flags", GL_UNSIGNED_BYTE, 1, GL_FALSE } ) ;
+  fdesc = &attrDesc[attrDesc.size()-1];
+  fdesc->repeat_value = cyl_flags;
+  fdesc->repeat_value_length = 8;
+
+  if (add_color){
+    static unsigned char default_color[] = { 255, 255, 255, 255 }; // to write in alpha if CGO doesn't have it
+    fdesc = &attrDesc[2];
+    fdesc->default_value = default_color;
+    fdesc = &attrDesc[3];
+    fdesc->default_value = default_color;
+  }
+
+  float default_radius = 1.f;
+  attrDesc[4].default_value = (unsigned char*)&default_radius;
+
+  int box_indices[36] = { // box indices 
+    0, 2, 1, 2, 0, 3, 1, 6, 5, 6, 1, 2, 0, 1, 5, 5, 4, 0, 
+    0, 7, 3, 7, 0, 4, 3, 6, 2, 6, 3, 7, 4, 5, 6, 6, 7, 4 };
+  int *box_indices_ptr = NULL;
+  box_indices_ptr = box_indices;
+
+  bool interp_same, interp_value = false;
+  if ((interp_same = CGOCheckSplitLineInterpolationIsSame(I, interp_value))){
+    addTo->add<cgo::draw::vertex_attribute_1f>(G->ShaderMgr->GetAttributeUID("a_cap"), (cCylShaderBothCapsRound | (interp_value ? cCylShaderInterpColor : 0)));
+  } else {
+    AttribDataOp interpOps =
+      { { CGO_SPLITLINE, 1, UB1_INTERP_TO_CAP, offsetof(cgo::draw::splitline, flags), 0 } };
+    // need to add a_cap attribute
+    attrDesc.push_back({ "a_cap", GL_UNSIGNED_BYTE, 1, GL_FALSE, interpOps } );
+  }
+
+  if (!add_color){
+    attrDesc.erase(attrDesc.begin()+2); // attr_colors
+    attrDesc.erase(attrDesc.begin()+2); // attr_colors2
+  }
+
+  AttribDataOp extraPickColorOps = { { CGO_PICK_COLOR, 1, UINT_INT_TO_PICK_DATA, 0, 0 },
+                                     { CGO_SPLITLINE,  7, UINT_INT_TO_PICK_DATA, offsetof(cgo::draw::splitline, index), 0 } };
+  AttribDataOp extraPickColor2Ops = { { CGO_PICK_COLOR, 2, UINT_INT_TO_PICK_DATA, 0, 0 },
+                                      { CGO_SPLITLINE,  4, UINT_INT_TO_PICK_DATA, offsetof(cgo::draw::splitline, index), 0 } };
+  AttribDataDesc pickDesc = { { "a_Color",  GL_UNSIGNED_BYTE, 4, GL_TRUE, extraPickColorOps },
+                              { "a_Color2", GL_UNSIGNED_BYTE, 4, GL_TRUE, extraPickColor2Ops }};
+  return CGOConvertToShader(I, attrDesc, pickDesc, GL_TRIANGLES, VertexBuffer::INTERLEAVED, true, box_indices_ptr, 36);
+}
+
+struct CrossSizeData {
+  float cross_size;
+  bool forward;
+  CrossSizeData(float _cross_size, bool _forward) : cross_size(_cross_size), forward(_forward){ }
+};
+
+static void CrossVertexConversion(void *varData, const float * pc, void *crossData, int idx){
+  CrossSizeData *csd = (CrossSizeData*)crossData;
+  int idxpl = idx / 8; // X Y or Z
+  float *varDataF = ((float*)varData);
+  varDataF[idxpl] += (csd->forward ? csd->cross_size : -csd->cross_size);
+}
+
+CGO *CGOConvertCrossesToCylinderShader(const CGO *I, CGO *addTo, float cross_size_arg){
+  /* Lines that pass in two vertices per line */
+  PyMOLGlobals *G = I->G;
+  AttribDataOp vertex1Ops =
+    { { CGO_VERTEX_CROSS,       1, FLOAT3_TO_FLOAT3,      0, 0 } };
+  AttribDataOp vertex2Ops =
+    { { CGO_VERTEX_CROSS,       2, FLOAT3_TO_FLOAT3,      0, 3 * 8, 0 } };
+
+  static AttribDataOp colorOps =
+    { { CGO_COLOR,      0, FLOAT3_TO_UB3,         0 },
+      { CGO_ALPHA,      0, FLOAT1_TO_UB_4TH,      0 } };
+  static AttribDataOp color2Ops =
+    { { CGO_COLOR,      1, FLOAT3_TO_UB3,         0 },
+      { CGO_ALPHA,      1, FLOAT1_TO_UB_4TH,      0 } };
+
+  CrossSizeData crossData[] = { { cross_size_arg, false }, { cross_size_arg, true } };
+  AttribDataDesc attrDesc = { { "attr_vertex1", GL_FLOAT, 3, GL_FALSE, vertex1Ops },
+                              { "attr_vertex2", GL_FLOAT, 3, GL_FALSE, vertex2Ops },
+                              { "a_Color",  GL_UNSIGNED_BYTE, 4, GL_TRUE, colorOps },
+                              { "a_Color2", GL_UNSIGNED_BYTE, 4, GL_TRUE, color2Ops },
+                              { "attr_radius", GL_FLOAT, 1, GL_FALSE } };
+  attrDesc.reserve(10);
+  attrDesc[1].attrOps[0].funcDataConversions.push_back( { CrossVertexConversion, &crossData[0], "attr_vertex1" } );
+  attrDesc[1].attrOps[0].funcDataConversions.push_back( { CrossVertexConversion, &crossData[1], "attr_vertex2" } );
+
+  AttribDesc *fdesc;
+  static unsigned char cyl_flags[] = { 0, 4, 6, 2, 1, 5, 7, 3 }; // right(4)/up(2)/out(1)
+
+  attrDesc.push_back( { "attr_flags", GL_UNSIGNED_BYTE, 1, GL_FALSE } ) ;
+  fdesc = &attrDesc[attrDesc.size()-1];
+  fdesc->repeat_value = cyl_flags;
+  fdesc->repeat_value_length = 8;
+
+  unsigned char default_color[] = { 255, 255, 255, 255 }; // to write in alpha if CGO doesn't have it
+  fdesc = &attrDesc[2];
+  fdesc->default_value = default_color;
+  fdesc = &attrDesc[3];
+  fdesc->default_value = default_color;
+  float default_radius = 1.f;
+  attrDesc[4].default_value = (unsigned char*)&default_radius;
+
+  int box_indices[36] = { // box indices 
+    0, 2, 1, 2, 0, 3, 1, 6, 5, 6, 1, 2, 0, 1, 5, 5, 4, 0, 
+    0, 7, 3, 7, 0, 4, 3, 6, 2, 6, 3, 7, 4, 5, 6, 6, 7, 4 };
+  int *box_indices_ptr = NULL;
+  box_indices_ptr = box_indices;
+
+  addTo->add<cgo::draw::vertex_attribute_1f>(G->ShaderMgr->GetAttributeUID("a_cap"), cCylShaderBothCapsRound);
+
+  AttribDataOp extraPickColorOps = { { CGO_PICK_COLOR, 1, UINT_INT_TO_PICK_DATA, 0, 0 } };
+  AttribDataOp extraPickColor2Ops = { { CGO_PICK_COLOR, 2, UINT_INT_TO_PICK_DATA, 0, 0 } };
+  AttribDataDesc pickDesc = { { "a_Color",  GL_UNSIGNED_BYTE, 4, GL_TRUE, extraPickColorOps },
+                              { "a_Color2", GL_UNSIGNED_BYTE, 4, GL_TRUE, extraPickColor2Ops }};
+  return CGOConvertToShader(I, attrDesc, pickDesc, GL_TRIANGLES, VertexBuffer::INTERLEAVED, true, box_indices_ptr, 36, 3);
+}
+
+struct CrossSizeDataLines {
+  float cross_size;
+  CrossSizeDataLines(float _cross_size) : cross_size(_cross_size){ }
+};
+
+static void CrossVertexConversionLines(void *varData, const float * pc, void *crossData, int idx){
+  CrossSizeDataLines *csd = (CrossSizeDataLines*)crossData;
+  int idxpl = idx / 2; // X Y or Z
+  bool forward = idx % 2;
+  float *varDataF = ((float*)varData);
+  varDataF[idxpl] += (forward ? csd->cross_size : -csd->cross_size);
+}
+
+CGO *CGOConvertCrossesToLinesShader(const CGO *I, CGO *addTo, float cross_size_arg){
+  /* Lines that pass in two vertices per line */
+  PyMOLGlobals *G = I->G;
+  AttribDataOp vertexOps =
+    { { CGO_VERTEX_CROSS,       1, FLOAT3_TO_FLOAT3,      0, 6 } };  // 6 vertices for a cross
+  AttribDataOp colorOps =
+    { { CGO_COLOR,      0, FLOAT3_TO_UB3,         0 },
+      { CGO_ALPHA,      0, FLOAT1_TO_UB_4TH,      0 } };
+  AttribDataOp extraPickColorOps =
+    { { CGO_PICK_COLOR, 1, UINT_INT_TO_PICK_DATA, 0, 0 } };
+
+  AttribDataDesc pickDesc =
+    { { "a_Color", GL_UNSIGNED_BYTE, 4, GL_TRUE, extraPickColorOps } };
+  AttribDataDesc attrDesc =
+    { { "a_Vertex", GL_FLOAT, 3, GL_FALSE, vertexOps },
+      { "a_Color", GL_UNSIGNED_BYTE, 4, GL_TRUE, colorOps } };
+  unsigned char default_color[] = { 255, 255, 255, 255 }; // to write in alpha if CGO doesn't have it
+  attrDesc[1].default_value = default_color;
+
+  CrossSizeDataLines crossData = { cross_size_arg };
+  attrDesc[0].attrOps[0].funcDataConversions.push_back( { CrossVertexConversionLines, &crossData, "a_Vertex" } );
+
+  bool interp_same, interp_value = false;
+  if ((interp_same = CGOCheckSplitLineInterpolationIsSame(I, interp_value))){
+    addTo->add<cgo::draw::vertex_attribute_1f>(G->ShaderMgr->GetAttributeUID("a_interpolate"), interp_value ? 1.f : 0.f);
+  } else {
+    AttribDataOp interpOps =
+      { { CGO_SPLITLINE, 1, UB1_TO_INTERP, offsetof(cgo::draw::splitline, flags), 0 } };
+    // need to add a_interpolate attribute
+    attrDesc.push_back({ "a_interpolate", GL_UNSIGNED_BYTE, 1, GL_FALSE, interpOps } );
+  }
+#ifndef PURE_OPENGL_ES_2
+  {
+    attrDesc.push_back({ "a_line_position", GL_UNSIGNED_BYTE, 1, GL_FALSE } );
+    AttribDesc *lpdesc = &attrDesc[attrDesc.size()-1];
+    lpdesc->repeat_value_length = 2;
+    static unsigned char flip_bits[] = { 0, 1 };
+    lpdesc->repeat_value = flip_bits;
+  }
+#endif
+  return CGOConvertToShader(I, attrDesc, pickDesc, GL_LINES, VertexBuffer::INTERLEAVED);
+}
+
+static void CrossVertexConversionTrilines(void *varData, const float * pc, void *crossData, int idx){
+  CrossSizeData *csd = (CrossSizeData*)crossData;
+  int idxpl = idx / 6; // X Y or Z
+  float *varDataF = ((float*)varData);
+  varDataF[idxpl] += (csd->forward ? csd->cross_size : -csd->cross_size);
+}
+
+CGO *CGOConvertCrossesToTrilinesShader(const CGO *I, CGO *addTo, float cross_size_arg){
+  PyMOLGlobals *G = I->G;
+
+  AttribDataOp vertexOps =
+    { { CGO_VERTEX_CROSS,       1, FLOAT3_TO_FLOAT3,      0, 0 } };
+  AttribDataOp vertexOtherOps =
+    { { CGO_VERTEX_CROSS,       2, FLOAT3_TO_FLOAT3,      0, 6 * 3 } };
+  AttribDataOp colorOps =
+    { { CGO_COLOR,      0, FLOAT3_TO_UB3,         0 },
+      { CGO_ALPHA,      0, FLOAT1_TO_UB_4TH,      0 } };
+  AttribDataOp color2Ops =
+    { { CGO_COLOR,      1, FLOAT3_TO_UB3,         0 },
+      { CGO_ALPHA,      1, FLOAT1_TO_UB_4TH,      0 } };
+  AttribDataOp extraPickColorOps =
+    { { CGO_PICK_COLOR, 1, UINT_INT_TO_PICK_DATA, 0, 0 } };
+  AttribDataOp extraPickColor2Ops =
+    { { CGO_PICK_COLOR, 2, UINT_INT_TO_PICK_DATA, 0, 0 } };
+  AttribDataDesc pickDesc =
+    { { "a_Color", GL_UNSIGNED_BYTE, 4, GL_TRUE, extraPickColorOps },
+      { "a_Color2", GL_UNSIGNED_BYTE, 4, GL_TRUE, extraPickColor2Ops } };
+  AttribDataDesc attrDesc =
+    { { "a_Vertex", GL_FLOAT, 3, GL_FALSE, vertexOps },
+      { "a_OtherVertex", GL_FLOAT, 3, GL_FALSE, vertexOtherOps },
+      { "a_Color", GL_UNSIGNED_BYTE, 4, GL_TRUE, colorOps },
+      { "a_Color2", GL_UNSIGNED_BYTE, 4, GL_TRUE, color2Ops },
+      { "a_UV", GL_UNSIGNED_BYTE, 1, GL_FALSE } };
+
+  CrossSizeData crossData[] = { { cross_size_arg, false }, { cross_size_arg, true } };
+
+  attrDesc[1].attrOps[0].funcDataConversions.push_back( { CrossVertexConversionTrilines, &crossData[0], "a_Vertex" } );
+  attrDesc[1].attrOps[0].funcDataConversions.push_back( { CrossVertexConversionTrilines, &crossData[1], "a_OtherVertex" } );
+
+  unsigned char default_color[] = { 255, 255, 255, 255 }; // to write in alpha if CGO doesn't have it
+  attrDesc[2].default_value = default_color;
+  attrDesc[3].default_value = default_color;
+  
+  AttribDesc *uvdesc = &attrDesc[attrDesc.size()-1];
+  uvdesc->repeat_value_length = 6;
+  static unsigned char uv_bits[] = { 1, 3, 0, 3, 2, 1 };
+  uvdesc->repeat_value = uv_bits;
+  
+  addTo->add<cgo::draw::vertex_attribute_1f>(G->ShaderMgr->GetAttributeUID("a_interpolate"), 0.f);
+
+  return CGOConvertToShader(I, attrDesc, pickDesc, GL_TRIANGLES, VertexBuffer::INTERLEAVED);
+}
+
+cgo::draw::shadercylinder2ndcolor::shadercylinder2ndcolor(CGO *I, const float *_origin, 
+                                                          const float *_axis, const float _tube_size,
+                                                          int _cap, const float *_color2, Pickable *pickcolor2,
+                                                          const float _alpha) :
+  tube_size(_tube_size), alpha(_alpha) {
+  copy3f(_origin, origin);
+  copy3f(_axis, axis);
+  cap = _cap;
+  copy3f(_color2, color2);
+  if (pickcolor2){
+    I->current_pick_color_index = pick_color_index = pickcolor2->index;
+    I->current_pick_color_bond = pick_color_bond = pickcolor2->bond;
+  } else {
+    pick_color_index = I->current_pick_color_index;
+    pick_color_bond = I->current_pick_color_bond;
+  }
+};
+
+static void SetVertexFromOriginAxisForCylinder(void *varData, const float * pc, void *np, int idx){
+  float *varDataF = ((float*)varData);
+  add3f(pc, pc + 3, varDataF); // adding origin and axis for both shadercylinder and shadercylinder2ndcolor
+}
+
+/*
+ * converts all cylinders in the input CGO to a CGO custom operation, which includes picking information (if it exists)
+ * 
+ * I     - input CGO (includes cylinders)
+ * addTo - CGO that vertex_attribute operations are added to (if needed), in this case for caps if values for all
+ *         cylinders are the same
+ *
+ */
+CGO *CGOConvertShaderCylindersToCylinderShader(const CGO *I, CGO *addTo){
+  /* Lines that pass in two vertices per line */
+  PyMOLGlobals *G = I->G;
+
+  // TODO: NEED TO ADD: CGO_CUSTOM_CYLINDER and CGO_CYLINDER
+  AttribDataOp vertex1Ops =
+    { { CGO_SHADER_CYLINDER,                 1, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::shadercylinder, origin), 0 },
+      { CGO_SHADER_CYLINDER_WITH_2ND_COLOR,  1, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::shadercylinder2ndcolor, origin), 0 },
+      { CGO_SAUSAGE,                         1, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::sausage, vertex1), 0 },
+      { CGO_CYLINDER,                        1, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::cylinder, vertex1), 0 },
+      { CGO_CUSTOM_CYLINDER,                 1, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::custom_cylinder, vertex1), 0 },
+      { CGO_CUSTOM_CYLINDER_ALPHA,           1, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::custom_cylinder_alpha, vertex1), 0 } };
+  AttribDataOp vertex2Ops =
+    { { CGO_SHADER_CYLINDER,                 5, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::shadercylinder, axis), 8 },
+      { CGO_SHADER_CYLINDER_WITH_2ND_COLOR,  6, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::shadercylinder2ndcolor, axis), 8 },
+      { CGO_SAUSAGE,                         6, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::sausage, vertex2), 8 },
+      { CGO_CYLINDER,                        6, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::cylinder, vertex2), 8 },
+      { CGO_CUSTOM_CYLINDER,                 6, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::custom_cylinder, vertex2), 8 },
+      { CGO_CUSTOM_CYLINDER_ALPHA,           6, FLOAT3_TO_FLOAT3,      offsetof(cgo::draw::custom_cylinder_alpha, vertex2), 8 } };
+  static AttribDataOp colorOps =
+    { { CGO_COLOR,                           0, FLOAT3_TO_UB3,         0 },
+      { CGO_ALPHA,                           0, FLOAT1_TO_UB_4TH,      0 },
+      { CGO_SAUSAGE,                         4, FLOAT3_TO_UB3,         offsetof(cgo::draw::sausage, color1) },
+      { CGO_CYLINDER,                        4, FLOAT3_TO_UB3,         offsetof(cgo::draw::cylinder, color1) },
+      { CGO_CUSTOM_CYLINDER,                 4, FLOAT3_TO_UB3,         offsetof(cgo::draw::custom_cylinder, color1) },
+      { CGO_CUSTOM_CYLINDER_ALPHA,           4, FLOAT4_TO_UB4,         offsetof(cgo::draw::custom_cylinder_alpha, color1) } };
+  static AttribDataOp color2Ops =
+    { { CGO_COLOR,                           1, FLOAT3_TO_UB3,         0 },
+      { CGO_ALPHA,                           1, FLOAT1_TO_UB_4TH,      0 },
+      { CGO_SHADER_CYLINDER_WITH_2ND_COLOR,  2, FLOAT3_TO_UB3,         offsetof(cgo::draw::shadercylinder2ndcolor, color2) },
+      { CGO_SAUSAGE,                         5, FLOAT3_TO_UB3,         offsetof(cgo::draw::sausage, color2) },
+      { CGO_CYLINDER,                        5, FLOAT3_TO_UB3,         offsetof(cgo::draw::cylinder, color2) },
+      { CGO_CUSTOM_CYLINDER,                 5, FLOAT3_TO_UB3,         offsetof(cgo::draw::custom_cylinder, color2) },
+      { CGO_CUSTOM_CYLINDER_ALPHA,           5, FLOAT4_TO_UB4,         offsetof(cgo::draw::custom_cylinder_alpha, color2) } };
+  AttribDataOp radiusOps =
+    { { CGO_SHADER_CYLINDER,                 2, FLOAT_TO_FLOAT,        offsetof(cgo::draw::shadercylinder, tube_size), 0 },
+      { CGO_SHADER_CYLINDER_WITH_2ND_COLOR,  3, FLOAT_TO_FLOAT,        offsetof(cgo::draw::shadercylinder2ndcolor, tube_size), 0 },
+      { CGO_SAUSAGE,                         3, FLOAT_TO_FLOAT,        offsetof(cgo::draw::sausage, radius), 0 },
+      { CGO_CYLINDER,                        3, FLOAT_TO_FLOAT,        offsetof(cgo::draw::cylinder, radius), 0 },
+      { CGO_CUSTOM_CYLINDER,                 3, FLOAT_TO_FLOAT,        offsetof(cgo::draw::custom_cylinder, radius), 0 },
+      { CGO_CUSTOM_CYLINDER_ALPHA,           3, FLOAT_TO_FLOAT,        offsetof(cgo::draw::custom_cylinder_alpha, radius), 0 } };
+
+  AttribDataDesc attrDesc = { { "attr_vertex1", GL_FLOAT,         3, GL_FALSE, vertex1Ops },
+                              { "attr_vertex2", GL_FLOAT,         3, GL_FALSE, vertex2Ops },
+                              { "a_Color",  GL_UNSIGNED_BYTE, 4, GL_TRUE,  colorOps },
+                              { "a_Color2", GL_UNSIGNED_BYTE, 4, GL_TRUE,  color2Ops },
+                              { "attr_radius",  GL_FLOAT,         1, GL_FALSE, radiusOps } };
+  AttribDesc *fdesc;
+  static unsigned char cyl_flags[] = { 0, 4, 6, 2, 1, 5, 7, 3 }; // right(4)/up(2)/out(1)
+
+  attrDesc[1].attrOps[0].funcDataConversions.push_back( { SetVertexFromOriginAxisForCylinder, NULL, "attr_vertex2" } );
+  attrDesc[1].attrOps[1].funcDataConversions.push_back( { SetVertexFromOriginAxisForCylinder, NULL, "attr_vertex2" } );
+
+  attrDesc.push_back( { "attr_flags", GL_UNSIGNED_BYTE, 1, GL_FALSE } ) ;
+  fdesc = &attrDesc[attrDesc.size()-1];
+  fdesc->repeat_value = cyl_flags;
+  fdesc->repeat_value_length = 8;
+
+  unsigned char default_color[] = { 255, 255, 255, 255 }; // to write in alpha if CGO doesn't have it
+  fdesc = &attrDesc[2];
+  fdesc->default_value = default_color;
+  fdesc = &attrDesc[3];
+  fdesc->default_value = default_color;
+  float default_radius = 1.f;
+  attrDesc[4].default_value = (unsigned char*)&default_radius;
+
+  int box_indices[36] = { // box indices 
+    0, 2, 1, 2, 0, 3, 1, 6, 5, 6, 1, 2, 0, 1, 5, 5, 4, 0, 
+    0, 7, 3, 7, 0, 4, 3, 6, 2, 6, 3, 7, 4, 5, 6, 6, 7, 4 };
+  int *box_indices_ptr = NULL;
+  box_indices_ptr = box_indices;
+
+  bool interp_same;
+  unsigned char cap_value = 0;
+  if ((interp_same = CGOCheckShaderCylinderCapInfoIsSame(I, cap_value))){
+    addTo->add<cgo::draw::vertex_attribute_1f>(G->ShaderMgr->GetAttributeUID("a_cap"), cap_value );
+  } else {
+    AttribDataOp interpOps =
+      { { CGO_SHADER_CYLINDER,                3, CYL_CAP_TO_CAP,      offsetof(cgo::draw::shadercylinder, cap), 0 },
+        { CGO_SHADER_CYLINDER_WITH_2ND_COLOR, 4, CYL_CAP_TO_CAP,      offsetof(cgo::draw::shadercylinder2ndcolor, cap), 0 },
+        { CGO_SAUSAGE,                        2, CYL_CAPS_ARE_ROUND,  0, 0 },
+        { CGO_CYLINDER,                       2, CYL_CAPS_ARE_FLAT,   0, 0 },
+        { CGO_CUSTOM_CYLINDER,                2, CYL_CAPS_ARE_CUSTOM, offsetof(cgo::draw::custom_cylinder, cap1), 0 },
+        { CGO_CUSTOM_CYLINDER_ALPHA,          2, CYL_CAPS_ARE_CUSTOM, offsetof(cgo::draw::custom_cylinder_alpha, cap1), 0 },
+      };
+    attrDesc.push_back({ "a_cap", GL_UNSIGNED_BYTE, 1, GL_FALSE, interpOps } );
+  }
+
+  AttribDataOp extraPickColorOps = { { CGO_PICK_COLOR, 1, UINT_INT_TO_PICK_DATA, 0, 0 },
+                                     { CGO_SHADER_CYLINDER_WITH_2ND_COLOR,  8, UINT_INT_TO_PICK_DATA, offsetof(cgo::draw::shadercylinder2ndcolor, pick_color_index), 0 } };
+  AttribDataOp extraPickColor2Ops = { { CGO_PICK_COLOR, 2, UINT_INT_TO_PICK_DATA, 0, 0 },
+                                      { CGO_SHADER_CYLINDER_WITH_2ND_COLOR,  5, UINT_INT_TO_PICK_DATA, offsetof(cgo::draw::shadercylinder2ndcolor, pick_color_index), 0 } };
+  AttribDataDesc pickDesc = { { "a_Color",  GL_UNSIGNED_BYTE, 4, GL_TRUE, extraPickColorOps },
+                              { "a_Color2", GL_UNSIGNED_BYTE, 4, GL_TRUE, extraPickColor2Ops }};
+  return CGOConvertToShader(I, attrDesc, pickDesc, GL_TRIANGLES, VertexBuffer::INTERLEAVED, true, box_indices_ptr, 36);
+}
diff -upNr pymol-open-source-2.3.0.orig/layer1/CGO.h pymol-open-source-2.3.0/layer1/CGO.h
--- pymol-open-source-2.3.0.orig/layer1/CGO.h	2020-03-10 19:31:10.416701058 +0100
+++ pymol-open-source-2.3.0/layer1/CGO.h	2020-03-10 19:31:52.873555720 +0100
@@ -270,6 +270,7 @@ inline uchar CLIP_NORMAL_VALUE(float cv)
 #define CGO_TEX_COORD_ARRAY      0x20
 
 extern int CGO_sz[];
+size_t CGO_sz_size();
 
 // CGOs are floating point arrays so we need to work with sizes in terms of floats
 template <typename T>
@@ -585,7 +586,7 @@ namespace cgo {
       static const int op_code = CGO_SHADER_CYLINDER_WITH_2ND_COLOR;
       shadercylinder2ndcolor(CGO *I, const float *_origin, const float *_axis, const float _radius,
                              int _cap, const float *_color2, Pickable *pickcolor2 = NULL,
-                             const float alpha = 1.0f);
+                             const float alpha = -1.f);
       float origin[3], axis[3], tube_size;
       int cap;
       float color2[3];
diff -upNr pymol-open-source-2.3.0.orig/layer1/CGO.h.orig pymol-open-source-2.3.0/layer1/CGO.h.orig
--- pymol-open-source-2.3.0.orig/layer1/CGO.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ pymol-open-source-2.3.0/layer1/CGO.h.orig	2020-03-10 19:31:34.103008714 +0100
@@ -0,0 +1,1087 @@
+
+/* 
+A* -------------------------------------------------------------------
+B* This file contains source code for the PyMOL computer program
+C* copyright by Schrodinger, LLC
+D* -------------------------------------------------------------------
+E* It is unlawful to modify or remove this copyright notice.
+F* -------------------------------------------------------------------
+G* Please see the accompanying LICENSE file for further information. 
+H* -------------------------------------------------------------------
+I* Additional authors of this source file include:
+-* 
+-* 
+-*
+Z* -------------------------------------------------------------------
+*/
+#ifndef _H_CGO
+#define _H_CGO
+
+#include"Base.h"
+#include"Ray.h"
+#include"Setting.h"
+#include"os_gl.h"
+#include"Rep.h"
+#include"ObjectGadgetRamp.h"
+#include <vector>
+#include <unordered_map>
+#include <typeinfo>
+#include <type_traits>
+#include <memory>
+#include "GenericBuffer.h"
+#include <set>
+
+/* Compiled Graphics Library for simple graphics objects
+   in floating point three-space, with the goal of achieving
+   quick and easy rendering in multiple environments without the
+   headaches of OpenGL arrays.
+
+*/
+
+#define CGO_read_int(p) (*((int*)((p)++)))
+#define CGO_get_int(p) (*((int*)(p)))
+#define CGO_get_uint(p) (uint)(*((uint*)(p)))
+#define CGO_write_int(p,i) ((*((int*)(p++)))=(i))
+#define CGO_write_uint(p,i) ((*((uint*)(p++)))=(i))
+#define CGO_put_int(p,i) ((*((int*)(p)))=(i))
+#define CGO_put_uint(p,i) ((*((uint*)(p)))=(i))
+
+inline uchar CLIP_COLOR_VALUE(float cv){ return ((cv>1.f) ? 255 :  (cv < 0.f) ? 0 : pymol_roundf(cv * 255) ); }
+inline float CONVERT_COLOR_VALUE(unsigned char cv) { return ((cv>255) ? 1.f :  (cv < 0) ? 0.f : (cv / 255.f) ); }
+
+// normal values are mapped between { -1, 1 } to { 0, 255 }, 
+// the values are mapped: { -1/128, -.5/192, 0./255, .5/63, 1./127 }
+inline uchar CLIP_NORMAL_VALUE(float cv){ return ((cv>1.f) ? 127 :
+                                                  (cv < -1.f) ? 128 : 
+                                                  pymol_roundf(((cv + 1.f)/2.f) * 255) - 128 ); }
+
+/* Supported functions:
+ * stop
+ * null
+ * begin
+     GL_POINTS,
+     GL_LINES, GL_LINE_LOOP, GL_LINE_STRIP,
+     GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN
+ * end
+ * vertex
+ * normal
+ * color
+ * sphere   * currently for ray-tracing only
+ * triangle * currently for ray-tracing only
+ * cylinder * currently for ray-tracing only
+ * linewidth
+ * primwidth * ray-tracing
+ */
+
+/* instructions and data segment sizes */
+
+#define CGO_STOP                 0x00
+#define CGO_STOP_SZ              0
+#define CGO_NULL                 0x01
+#define CGO_NULL_SZ              0
+#define CGO_BEGIN                0x02
+#define CGO_BEGIN_SZ             1
+#define CGO_END                  0x03
+#define CGO_END_SZ               0
+#define CGO_VERTEX               0x04
+#define CGO_VERTEX_SZ            3
+#define CGO_NORMAL               0x05
+#define CGO_NORMAL_SZ            3
+#define CGO_COLOR                0x06
+#define CGO_COLOR_SZ             3
+#define CGO_SPHERE               0x07
+#define CGO_SPHERE_SZ            4
+#define CGO_TRIANGLE             0x08
+#define CGO_TRIANGLE_SZ          27
+#define CGO_CYLINDER             0x09
+#define CGO_CYLINDER_SZ          13
+// CGO_LINEWIDTH, CGO_WIDTHSCALE, CGO_DOTWIDTH work only on ray tracing
+#define CGO_LINEWIDTH            0x0A
+#define CGO_LINEWIDTH_SZ         1
+#define CGO_WIDTHSCALE           0x0B
+#define CGO_WIDTHSCALE_SZ        1
+
+#define CGO_ENABLE               0x0C
+#define CGO_ENABLE_SZ            1
+#define CGO_DISABLE              0x0D
+#define CGO_DISABLE_SZ           1
+#define CGO_SAUSAGE              0x0E
+#define CGO_SAUSAGE_SZ           13
+#define CGO_CUSTOM_CYLINDER      0x0F
+#define CGO_CUSTOM_CYLINDER_SZ   15
+
+#define CGO_DOTWIDTH             0x10
+#define CGO_DOTWIDTH_SZ          1
+
+#define CGO_ALPHA_TRIANGLE       0x11
+#define CGO_ALPHA_TRIANGLE_SZ    35
+#define CGO_ELLIPSOID            0x12
+#define CGO_ELLIPSOID_SZ         13
+#define CGO_FONT                 0x13
+#define CGO_FONT_SZ              3      /*  size, face, style */
+#define CGO_FONT_SCALE           0x14
+#define CGO_FONT_SCALE_SZ        2
+#define CGO_FONT_VERTEX          0x15
+#define CGO_FONT_VERTEX_SZ       3      /*  principle axes (zeros -> use camera x y z */
+
+// CGO_FONT_AXES not used
+#define CGO_FONT_AXES            0x16
+#define CGO_FONT_AXES_SZ         9      /*  principle axes (zeros -> use camera x y z */
+
+#define CGO_CHAR                 0x17
+#define CGO_CHAR_SZ              1
+#define CGO_INDENT               0x18
+#define CGO_INDENT_SZ            2
+#define CGO_ALPHA                0x19
+#define CGO_ALPHA_SZ             1
+#define CGO_QUADRIC              0x1A
+#define CGO_QUADRIC_SZ           14
+#define CGO_CONE                 0x1B
+#define CGO_CONE_SZ              16
+#define CGO_RESET_NORMAL         0x1E
+#define CGO_RESET_NORMAL_SZ      1
+#define CGO_PICK_COLOR           0x1F
+#define CGO_PICK_COLOR_SZ        2
+
+
+/* CGO_DRAW_ARRAYS : operation that calls glDrawArrays with all arrays in memory
+   (i.e., stored in the CGO array). There can be up to 4 arrays (vertex, normal, color,
+   and pick color array, where each are stored using GL_FLOAT array (except for the pick
+   color array, which is GL_UNSIGNED_BYTE, because the 2nd 2/3rds of the array is used to
+   store atom/bond picking information. Also, the color array is stored using 4 floats,
+   since glColorPointer() requires having 4 as an argument for OpenGLES.
+   - mode : GL Mode that is used
+   - arrays : which arrays that are used (bitmask on CGO_<type>_ARRAY, where <type>
+              can be VERTEX, NORMAL, COLOR, or PICK_COLOR)
+   - narrays : number of arrays specified in arrays
+   - nverts : number of total vertices specified in arrays
+   - each GL_FLOAT array specified in order
+*/
+#define CGO_DRAW_ARRAYS          0x1C
+/* CGO_DRAW_BUFFERS_INDEXED : operation that uses glDrawArrays with VBOs.  It also
+   has a dynamic length since it holds the picking information (atom/bond) for each vertex,
+   as well as space for picking to use when drawing colors (since colors are dynamically generated
+   for each atom/bond value).
+   - mode : GL Mode that is used
+   - arrays : which arrays that are used (bitmask on CGO_<type>_ARRAY, where <type>
+              can be VERTEX, NORMAL, COLOR, or PICK_COLOR)
+   - narrays : number of arrays specified in arrays
+   - nverts : number of total vertices specified in arrays
+   - bufs[5] : each VBO id in order (if used, VERTEX, NORMAL, COLOR, PICK_COLOR), plus the
+      vertex index array that specifies all vertices.
+ */
+#define CGO_DRAW_BUFFERS_INDEXED         0x21
+
+/* CGO_BOUNDING_BOX : operation that allows the extent to be expanded.  Since the geometry
+   data is not kept in the CGO object for VBO objects (only on the card), this object allows
+   the bounding box of the object to be saved in the CGO.  This is used in the CGOGetExtent(),
+   typically when the view is being automatically set, but can be used for other things.
+ */
+#define CGO_BOUNDING_BOX         0x22
+#define CGO_BOUNDING_BOX_SZ      6
+
+#define CGO_DRAW_BUFFERS_NOT_INDEXED         0x23
+
+#define CGO_SPECIAL            0x24
+#define CGO_SPECIAL_SZ         1
+
+#define CGO_DRAW_CYLINDER_BUFFERS       0x25
+
+#define CGO_SHADER_CYLINDER             0x26
+#define CGO_SHADER_CYLINDER_SZ          8
+
+#define CGO_SHADER_CYLINDER_WITH_2ND_COLOR      0x27
+#define CGO_SHADER_CYLINDER_WITH_2ND_COLOR_SZ    13
+
+#define CGO_DRAW_SPHERE_BUFFERS      0x28
+
+#define CGO_ACCESSIBILITY      0x29
+#define CGO_ACCESSIBILITY_SZ    1
+
+#define CGO_DRAW_TEXTURE      0x2A
+#define CGO_DRAW_TEXTURE_SZ    13
+
+#define CGO_DRAW_TEXTURES      0x2B
+
+#define CGO_DRAW_SCREEN_TEXTURES_AND_POLYGONS      0x2C
+
+#define CGO_TEX_COORD                0x2D
+#define CGO_TEX_COORD_SZ             2
+
+
+#define CGO_DRAW_LABEL      0x2E
+#define CGO_DRAW_LABEL_SZ    20
+
+#define CGO_DRAW_LABELS      0x2F
+
+#define CGO_DRAW_CONNECTOR       0x30
+#define CGO_DRAW_CONNECTOR_SZ    25
+
+#define CGO_DRAW_CONNECTORS      0x31
+
+#define CGO_DRAW_TRILINES        0x32
+#define CGO_DRAW_TRILINES_SZ     2
+#define CGO_DRAW_TRILINES_HEADER 3
+
+#define CGO_UNIFORM3F            0x33
+#define CGO_UNIFORM3F_SZ         4
+#define CGO_UNIFORM3F_HEADER     4
+
+#define CGO_SPECIAL_WITH_ARG    0x34
+#define CGO_SPECIAL_WITH_ARG_SZ    2
+
+#define CGO_LINE                0x35
+#define CGO_LINE_SZ                6
+#define CGO_SPLITLINE           0x36
+#define CGO_SPLITLINE_SZ           9
+
+#define CGO_DRAW_CUSTOM         0x37
+
+#define CGO_VERTEX_ATTRIB_3F    0x38
+#define CGO_VERTEX_ATTRIB_4UB   0x39
+#define CGO_VERTEX_ATTRIB_1F    0x3A
+
+#define CGO_MASK_ATTRIBUTE_IF_PICKING   0x3B
+#define CGO_BIND_VBO_FOR_PICKING        0x3C
+
+#define CGO_VERTEX_BEGIN_LINE_STRIP     0x3D
+#define CGO_VERTEX_BEGIN_LINE_STRIP_SZ     3
+
+#define CGO_INTERPOLATED     0x3E
+#define CGO_INTERPOLATED_SZ     1
+
+#define CGO_VERTEX_CROSS     0x3F
+#define CGO_VERTEX_CROSS_SZ     3
+
+#define CGO_VERTEX_ATTRIB_4UB_IF_PICKING   0x40
+
+#define CGO_CUSTOM_CYLINDER_ALPHA      0x41
+
+#define CGO_MASK                0x7F
+
+
+#define CGO_LIGHTING             0x0B50
+
+#define CGO_VERTEX_ARRAY         0x01
+#define CGO_NORMAL_ARRAY         0x02
+#define CGO_COLOR_ARRAY          0x04
+#define CGO_PICK_COLOR_ARRAY     0x08
+#define CGO_ACCESSIBILITY_ARRAY  0x10
+#define CGO_TEX_COORD_ARRAY      0x20
+
+extern int CGO_sz[];
+
+// CGOs are floating point arrays so we need to work with sizes in terms of floats
+template <typename T>
+static size_t fsizeof() { return sizeof(T) / sizeof(float); }
+
+class CGO;
+
+// These are only the optimized operations
+namespace cgo {
+  namespace draw {
+    struct op_with_data {
+      float * floatdata { nullptr };
+      void set_data(float * data) { floatdata = data; };
+      float * get_data() { return floatdata; };
+      const float * get_data() const { return floatdata; };
+      virtual int get_data_length() const = 0;
+      virtual ~op_with_data() {}
+    };
+
+    struct op_with_draw_buffers {
+    };
+
+    struct arrays : op_with_data {
+      static const int op_code = CGO_DRAW_ARRAYS;
+      arrays(int _mode, short _arrays, int _nverts) :
+      mode(_mode), arraybits(_arrays), narrays(0), nverts(_nverts) {
+        short bit;
+        for (bit = 0; bit < 4; bit++){
+          if ((1 << bit) & arraybits){
+            narrays+=3;
+          }
+        }
+        if (arraybits & CGO_ACCESSIBILITY_ARRAY) narrays++;
+        if (arraybits & CGO_COLOR_ARRAY) narrays++;
+      };
+      int mode;
+      int arraybits;
+      int narrays;
+      int nverts;
+      int get_data_length() const { return narrays * nverts; };
+    };
+
+    struct buffers_indexed : op_with_data, op_with_draw_buffers {
+      static const int op_code = CGO_DRAW_BUFFERS_INDEXED;
+      buffers_indexed(int _mode, short _arrays, int _nindices,
+                      int _nverts, size_t _vboid, size_t _iboid, int _n_data, size_t _pickvboid = 0) :
+        mode(_mode), arraybits(_arrays), narrays(0), nindices(_nindices),
+        nverts(_nverts), vboid(_vboid), iboid(_iboid)
+        , pickvboid(_pickvboid)
+        , pickcolorsset(0)
+        , n_data(_n_data)
+      {
+        short bit;
+        for (bit = 0; bit < 4; bit++){
+          if ((1 << bit) & arraybits){
+            narrays++;
+          }
+        }
+        if (arraybits & CGO_ACCESSIBILITY_ARRAY) narrays++;
+        if (arraybits & CGO_COLOR_ARRAY) narrays++;
+      }
+      int mode;
+      int arraybits;
+      int narrays;
+      int nindices;
+      int nverts;
+      size_t vboid;
+      size_t iboid;
+      size_t pickvboid;
+      int pickcolorsset;
+      int n_data;
+      int get_data_length() const { return nverts * 3 + n_data; };
+    };
+
+    struct sphere_buffers : op_with_data, op_with_draw_buffers {
+      static const int op_code = CGO_DRAW_SPHERE_BUFFERS;
+      sphere_buffers(int _num_spheres, int _ub_flags,
+                     size_t _vboid, size_t _pickvboid) :
+        num_spheres(_num_spheres), ub_flags(_ub_flags),
+        vboid(_vboid), pickvboid(_pickvboid), pickcolorsset(0) {}
+      int num_spheres;
+      int ub_flags;
+      size_t vboid;
+      size_t pickvboid;
+      int pickcolorsset;
+      int get_data_length() const { return num_spheres * 2; };
+    };
+
+    struct cylinder_buffers : op_with_data, op_with_draw_buffers {
+      static const int op_code = CGO_DRAW_CYLINDER_BUFFERS;
+      cylinder_buffers(int _num_cyl, int _alpha, size_t _vboid,
+                       size_t _iboid, size_t _pickvboid) :
+        num_cyl(_num_cyl), alpha(_alpha), vboid(_vboid),
+        iboid(_iboid), pickvboid(_pickvboid), pickcolorsset(0) {
+      }
+      int num_cyl;
+      int alpha;
+      size_t vboid;
+      size_t iboid;
+      size_t pickvboid;
+      int pickcolorsset;
+      int get_data_length() const { return num_cyl * 2 * 2; };
+    };
+
+    struct textures : op_with_data, op_with_draw_buffers {
+      static const int op_code = CGO_DRAW_TEXTURES;
+      textures(int _ntextures, size_t _vboid) : ntextures(_ntextures), vboid(_vboid) { }
+      int ntextures;
+      size_t vboid;
+      int get_data_length() const { return ntextures * 18; };
+    };
+
+    struct screen_textures : op_with_draw_buffers {
+      static const int op_code = CGO_DRAW_SCREEN_TEXTURES_AND_POLYGONS;
+      screen_textures(int _nverts, size_t _vboid) : nverts(_nverts),
+                                                        vboid(_vboid) {};
+      int nverts;
+      size_t vboid;
+    };
+
+    struct buffers_not_indexed : op_with_data, op_with_draw_buffers {
+      static const int op_code = CGO_DRAW_BUFFERS_NOT_INDEXED;
+      buffers_not_indexed(int _mode, int _arrays, int _nverts,
+                          size_t _vboid, size_t _pickvboid = 0) :
+        mode(_mode), arraybits(_arrays), narrays(0), nverts(_nverts),
+        vboid(_vboid), pickvboid(_pickvboid), pickcolorsset(0) {
+        for (short bit = 0; bit < 4; bit++){
+          if ((1 << bit) & arraybits){
+            narrays++;
+          }
+        }
+        if (arraybits & CGO_ACCESSIBILITY_ARRAY) narrays++;
+        if (arraybits & CGO_COLOR_ARRAY) narrays++;
+      };
+      int mode;
+      int arraybits;
+      int narrays;
+      int nverts;
+      size_t vboid;
+      size_t pickvboid;
+      int pickcolorsset;
+      int get_data_length() const { return nverts * 3; };
+    };
+
+    struct label {
+      static const int op_code = CGO_DRAW_LABEL;
+      label(const vec3& _world_pos, const vec3& _screen_world_offset, const vec3& _screen_min,
+            const vec3& _screen_max, const vec4& _text_extent, float _relative_mode,
+            const vec3& _target_pos) :
+        world_pos(_world_pos), screen_world_offset(_screen_world_offset), screen_min(_screen_min),
+        screen_max(_screen_max), text_extent(_text_extent), relative_mode(_relative_mode),
+        target_pos(_target_pos) {}
+      vec3 world_pos;
+      vec3 screen_world_offset;
+      vec3 screen_min;
+      vec3 screen_max;
+      vec4 text_extent;
+      float relative_mode;
+      vec3 target_pos;
+    };
+
+    struct labels : op_with_data, op_with_draw_buffers {
+      static const int op_code = CGO_DRAW_LABELS;
+      labels(int _ntextures, size_t _vboid, size_t _pickvboid) :
+        vboid(_vboid)
+        , pickvboid(_pickvboid)
+        , ntextures(_ntextures)
+        , pickcolorsset(0)
+      {}
+      size_t vboid;
+      size_t pickvboid;
+      int ntextures;
+      int pickcolorsset;
+      int get_data_length() const { return ntextures * 18; };
+    };
+
+    struct connectors : op_with_draw_buffers {
+      static const int op_code = CGO_DRAW_CONNECTORS;
+      connectors(int _nconnectors, size_t _vboid) :
+        nconnectors(_nconnectors), vboid(_vboid) {};
+      int nconnectors;
+      size_t vboid;
+    };
+
+    struct line {
+      static const int op_code = CGO_LINE;
+      line(float *v1, float *v2) {
+        copy3f(v1, vertex1);
+        copy3f(v2, vertex2);
+      };
+      float vertex1[3], vertex2[3];
+    };
+    struct splitline {
+      static const int op_code = CGO_SPLITLINE;
+
+      static const unsigned char interpolation = 0x01; // ramp/interpolation
+      static const unsigned char no_split_for_pick = 0x02;
+      static const unsigned char equal_colors = 0x04;
+      splitline(const float *v1, const float *v2, const float *color2arg, 
+                unsigned int index_2nd, int bond_2nd,
+                bool isRamped, bool same_pick, bool eq_colors) :
+      index(index_2nd), bond(bond_2nd) {
+          copy3f(v1, vertex1);
+          copy3f(v2, vertex2);
+          color2[0] = CLIP_COLOR_VALUE(color2arg[0]);
+          color2[1] = CLIP_COLOR_VALUE(color2arg[1]);
+          color2[2] = CLIP_COLOR_VALUE(color2arg[2]);
+          flags = (isRamped ? cgo::draw::splitline::interpolation : 0x00) |
+            (same_pick ? cgo::draw::splitline::no_split_for_pick : 0x00) |
+            (eq_colors ? cgo::draw::splitline::equal_colors : 0x00);
+      };
+      float vertex1[3], vertex2[3];
+      unsigned char color2[3];
+      unsigned char flags; // interpolation | no_split_for_pick | equal_colors
+      unsigned int index;
+      int bond;
+    };
+
+    struct mask_attribute_if_picking : op_with_draw_buffers {
+      static const int op_code = CGO_MASK_ATTRIBUTE_IF_PICKING;
+      mask_attribute_if_picking(int _attr_lookup_idx, size_t _vboid) {
+        attr_lookup_idx = _attr_lookup_idx;
+        vboid = _vboid;
+      };
+      int attr_lookup_idx;
+      size_t vboid;
+    };
+
+    struct bind_vbo_for_picking : op_with_draw_buffers {
+      static const int op_code = CGO_BIND_VBO_FOR_PICKING;
+      bind_vbo_for_picking(size_t _vboid, int _which_attr_idx, int _npickattrs) {
+        vboid = _vboid;
+        which_attr_idx = _which_attr_idx;
+        npickattrs = _npickattrs;
+      };
+      size_t vboid;
+      int which_attr_idx;
+      int npickattrs;
+    };
+
+    struct custom : op_with_data, op_with_draw_buffers {
+      static const int op_code = CGO_DRAW_CUSTOM;
+      custom(int _mode, int _nverts, size_t _vboid, size_t _pickvboid,
+          int _vertsperpickinfo = 1, int _npickbufs = 1, size_t _iboid = 0,
+          int _nindices = 0)
+          : mode(_mode), nverts(_nverts), vboid(_vboid), pickvboid(_pickvboid),
+            pickcolorsset(0), iboid(_iboid), nindices(_nindices),
+            npickbufs(_npickbufs), vertsperpickinfo(_vertsperpickinfo){};
+      int mode;
+      int nverts;
+      size_t vboid;
+      size_t pickvboid;
+      int pickcolorsset;
+      size_t iboid;
+      int nindices;
+      int npickbufs;
+      int vertsperpickinfo;
+      int get_data_length() const { return npickbufs*nverts*2/vertsperpickinfo; };
+    };
+
+    struct vertex_attribute_3f {
+      static const int op_code = CGO_VERTEX_ATTRIB_3F;
+      vertex_attribute_3f(int _attr_lookup_idx, void *v) {
+        attr_lookup_idx = _attr_lookup_idx;
+        copy3f((float*)v, values);
+      };
+      int attr_lookup_idx;
+      float values[3];
+    };
+
+    struct vertex_attribute_4ub {
+      static const int op_code = CGO_VERTEX_ATTRIB_4UB;
+      vertex_attribute_4ub(int _attr_lookup_idx, void *_ubdata) {
+        attr_lookup_idx = _attr_lookup_idx;
+        memcpy(ubdata, _ubdata, 4);
+      };
+      int attr_lookup_idx;
+      unsigned char ubdata[4];
+    };
+
+    struct vertex_attribute_4ub_if_picking {
+      static const int op_code = CGO_VERTEX_ATTRIB_4UB_IF_PICKING;
+      vertex_attribute_4ub_if_picking(int _attr_lookup_idx, void *_ubdata) {
+        attr_lookup_idx = _attr_lookup_idx;
+        memcpy(ubdata, _ubdata, 4);
+      };
+      int attr_lookup_idx;
+      unsigned char ubdata[4];
+    };
+
+    struct vertex_attribute_1f {
+      static const int op_code = CGO_VERTEX_ATTRIB_1F;
+      vertex_attribute_1f(int _attr_lookup_idx, float v) {
+        attr_lookup_idx = _attr_lookup_idx;
+        value = v;
+      };
+      int attr_lookup_idx;
+      float value;
+    };
+
+    struct shadercylinder {
+      static const int op_code = CGO_SHADER_CYLINDER;
+    shadercylinder(const float *_origin, const float *_axis, const float _tube_size, int _cap) :
+      tube_size(_tube_size), cap(_cap) {
+          copy3f(_origin, origin);
+          copy3f(_axis, axis);
+      };
+      float origin[3], axis[3], tube_size;
+      int cap;
+    };
+
+    struct shadercylinder2ndcolor {
+      static const int op_code = CGO_SHADER_CYLINDER_WITH_2ND_COLOR;
+      shadercylinder2ndcolor(CGO *I, const float *_origin, const float *_axis, const float _radius,
+                             int _cap, const float *_color2, Pickable *pickcolor2 = NULL,
+                             const float alpha = -1.f);
+      float origin[3], axis[3], tube_size;
+      int cap;
+      float color2[3];
+      unsigned int pick_color_index;
+      int pick_color_bond;
+      float alpha;
+    };
+
+    struct sausage {
+      static const int op_code = CGO_SAUSAGE;
+      sausage(const float *_vertex1, const float *_vertex2, const float _radius, const float *_color1, const float *_color2) :
+      radius(_radius) {
+          copy3f(_vertex1, vertex1);
+          copy3f(_vertex2, vertex2);
+          copy3f(_color1, color1);
+          copy3f(_color2, color2);
+      };
+      float vertex1[3], vertex2[3], radius, color1[3], color2[3];
+    };
+
+    struct cylinder {
+      static const int op_code = CGO_CYLINDER;
+      cylinder(const float *_vertex1, const float *_vertex2, const float _radius, const float *_color1, const float *_color2) :
+      radius(_radius) {
+          copy3f(_vertex1, vertex1);
+          copy3f(_vertex2, vertex2);
+          copy3f(_color1, color1);
+          copy3f(_color2, color2);
+      };
+      float vertex1[3], vertex2[3], radius, color1[3], color2[3];
+    };
+
+    struct custom_cylinder {
+      static const int op_code = CGO_CUSTOM_CYLINDER;
+    custom_cylinder(const float *_vertex1, const float *_vertex2, const float _radius, const float *_color1, const float *_color2, const float _cap1, const float _cap2) :
+      radius(_radius), cap1(_cap1), cap2(_cap2) {
+          copy3f(_vertex1, vertex1);
+          copy3f(_vertex2, vertex2);
+          copy3f(_color1, color1);
+          copy3f(_color2, color2);
+      };
+      float vertex1[3], vertex2[3], radius, color1[3], color2[3];
+      float cap1, cap2;
+    };
+
+    struct custom_cylinder_alpha {
+      static const int op_code = CGO_CUSTOM_CYLINDER_ALPHA;
+      custom_cylinder_alpha(const float *_vertex1, const float *_vertex2, const float _radius, const float *_color1, const float *_color2,
+                            const float _alpha1, const float _alpha2,
+                            const float _cap1, const float _cap2) :
+      radius(_radius), cap1(_cap1), cap2(_cap2) {
+          copy3f(_vertex1, vertex1);
+          copy3f(_vertex2, vertex2);
+          copy3f(_color1, color1);
+          copy3f(_color2, color2);
+          color1[3] = _alpha1;
+          color2[3] = _alpha2;
+      };
+      float vertex1[3], vertex2[3], radius, color1[4], color2[4];
+      float cap1, cap2;
+    };
+  };
+};
+
+class CGO {
+public:
+  PyMOLGlobals *G { nullptr };
+  float *op { nullptr };
+  int c { 0 };
+  int z_flag { 0 };
+  float z_min { 0 }, z_max { 0 };
+  float z_vector[3];
+  float alpha { 1.f };
+  int *i_start { 0 }, i_size { 0 };
+  unsigned int current_pick_color_index { 0 };
+  int current_pick_color_bond { cPickableNoPick };
+  float current_accessibility { 1.f };
+  float normal[3], color[3], texture[2];
+  uchar pickColor[4];
+  bool has_begin_end { false };
+  bool has_draw_buffers { false }, has_draw_cylinder_buffers { false }, has_draw_sphere_buffers { false };
+  bool use_shader { false }, cgo_shader_ub_color { false }, cgo_shader_ub_normal { false };
+  bool debug { false };
+  bool no_pick { false };
+  short render_alpha { 0 };  // 1 : render CGOSetZVector/CGORenderGLAlpha only
+                       // 2 : render both CGOSetZVector/CGORenderGLAlpha and rest of object
+                       // calcDepth=1 by default
+  short sphere_quality { 0 }; // quality of spheres when simplified or rendered in immediate mode
+  bool interpolated { false };
+  /***********************************************************************
+   * CGO iterator
+   *
+   * for (auto it = cgo->begin(); !it.is_stop(); ++it) {
+   *   auto pc = it.data();
+   *   int op = it.op_code();
+   *   ...
+   * }
+   ***********************************************************************/
+
+  class const_iterator {
+    protected:
+      const float * m_pc;
+      const float * m_stop;
+    public:
+      int op_code() const {
+        return CGO_MASK & *reinterpret_cast<const int*>(m_pc);
+      }
+      operator int() const { return op_code(); }
+
+      const float * data() const { return m_pc + 1; }
+
+      template <typename T>
+      const T * cast() const { return reinterpret_cast<const T *>(m_pc + 1); }
+
+      const_iterator(const CGO * cgo) {
+        m_pc = cgo->op;
+        m_stop = cgo->op + cgo->c;
+      }
+
+      const_iterator& operator++() {
+        m_pc += CGO_sz[op_code()] + 1;
+        return *this;
+      }
+
+      bool is_stop() const {
+        return m_pc == m_stop || op_code() == CGO_STOP;
+      }
+  };
+
+  class iterator : public const_iterator {
+    public:
+      iterator(CGO * cgo) : const_iterator(cgo) {}
+      float * data() { return const_cast<float*>(m_pc + 1); }
+  };
+
+  const_iterator begin() const { return this; }
+  iterator begin() { return this; }
+
+  /***********************************************************************
+   * This is the add function, the signature may look weird but it's
+   * common c++11 perfect forwarding. This function passes the constructor
+   * arguments into the function. Meaning it is used like:
+   * cgo.add<cgo::draw::arrays>(mode, arrays, nverts);
+   ***********************************************************************/
+  template <typename T, typename... TArgs> float * add(TArgs&&... args) {
+    int size = fsizeof<T>() + 1;
+    float * at = add_to_buffer(size);
+    // write the op code
+    CGO_write_int(at, T::op_code);
+    // call the type constructor in place forwarding the args to the constructor
+    T * sp = new (at) T(std::forward<TArgs>(args)...);
+
+    if (std::is_base_of<cgo::draw::op_with_draw_buffers, T>::value) {
+      has_draw_buffers = true;
+    }
+
+    if (std::is_base_of<cgo::draw::op_with_data, T>::value) {
+      auto ptr = reinterpret_cast<cgo::draw::op_with_data *>(sp);
+      // set the buffer data flag
+      // create the floating point data for this type
+      auto data_len = ptr->get_data_length();
+      if (data_len) {
+        ptr->set_data(allocate_in_data_heap(data_len));
+        return ptr->get_data();
+      }
+    }
+
+    // this op does not have dynamic data, but since the caller knows
+    // then we return the allocated pointer, so that the caller can determine
+    // whether this was successful or not.
+    return at;
+  }
+
+  // Appends the source CGO onto this CGO
+  int append(const CGO * source, bool stopAtEnd);
+  void move_append(CGO * source);
+  void free_append(CGO * &source);
+
+  // Allocates in our CGO data pool
+  float * allocate_in_data_heap(size_t size) {
+    std::unique_ptr<float[]> uni(new float[size]);
+    float * ptr = uni.get();
+    _data_heap.emplace_back(std::move(uni));
+    return ptr;
+  }
+
+  // templated by the op type
+  template <typename T> void copy_op_from(const float * pc) {
+    // copy the op
+    const size_t op_size = fsizeof<T>() + 1; // + 1 is the op
+    float * at = add_to_buffer(op_size);
+    memcpy(at, (pc - 1), op_size * 4);
+
+    if (std::is_base_of<cgo::draw::op_with_draw_buffers, T>::value) {
+      has_draw_buffers = true;
+    }
+
+    if (std::is_base_of<cgo::draw::op_with_data, T>::value) {
+      // copy the float data
+      float * vals { nullptr };
+      auto ptr = reinterpret_cast<const cgo::draw::op_with_data*>(pc);
+      int data_len = ptr->get_data_length();
+      if (data_len) {
+        vals = allocate_in_data_heap(data_len);
+        memcpy(vals, ptr->get_data(), data_len * 4);
+      }
+      auto spop = reinterpret_cast<cgo::draw::op_with_data *>(at + 1);
+      spop->set_data( vals );
+    }
+  }
+
+  // Our CGO_add, allocates size bytes at end of cgo buffer
+  float * add_to_buffer(int size) {
+    float * at { nullptr };
+    VLACheck(op, float, size + c);
+    if (!op)
+      return nullptr;
+    at = op + c;
+    c += size;
+    return at;
+  }
+
+  /***********************************************************************
+   * This function adds to the end of this CGO the cgo op that exists in
+   * the float. This function will also increment the pointer passed to it
+   * by the size of the operation.
+   ***********************************************************************/
+  void add_to_cgo(int, const float*);
+
+  // Pretty prints a table with the layout of this CGO
+  void print_table() const;
+
+private:
+  std::vector<std::unique_ptr<float[]>> _data_heap;
+};
+
+int CGORendererInit(PyMOLGlobals * G);
+void CGORendererFree(PyMOLGlobals * G);
+CGO *CGONew(PyMOLGlobals * G, int size=0);
+#define CGONewSized CGONew
+int CGOGetExtent(CGO * I, float *mn, float *mx);
+int CGOHasNormals(CGO * I);
+
+void CGOFree(CGO * &I, bool withVBOs=true);
+#define CGOFreeWithoutVBOs(I) CGOFree(I, false)
+
+CGO *CGODrawText(CGO * I, int est, float *camera);
+
+CGO *CGOSimplify(const CGO * I, int est, short sphere_quality = -1, bool stick_round_nub = true);
+CGO *CGOSimplifyNoCompress(const CGO * I, int est, short sphere_quality = -1, bool stick_round_nub = true);
+
+// -1 - no lines, 0 - some no interpolation, 1 - all interpolation, 2 - all no interpolation
+bool CGOCombineBeginEnd(CGO ** I, bool do_not_split_lines = false);
+CGO *CGOCombineBeginEnd(const CGO * I, int est, bool do_not_split_lines = false);
+
+void CGOFreeVBOs(CGO *I);
+void CGOFreeStruct(CGO * I, bool freevbos = true);
+
+CGO *CGOOptimizeToVBOIndexed(CGO * I, int est=0, const float *color=NULL, bool addshaders=true, bool embedTransparencyInfo=false);
+#define CGOOptimizeToVBOIndexedWithColorEmbedTransparentInfo(I, est, color, addshaders) CGOOptimizeToVBOIndexed(I, est, color, addshaders, true)
+#define CGOOptimizeToVBOIndexedWithColor CGOOptimizeToVBOIndexed
+#define CGOOptimizeToVBOIndexedNoShader(I, est) CGOOptimizeToVBOIndexed(I, est, NULL, false)
+
+bool CGOOptimizeToVBONotIndexed(CGO ** I);
+CGO *CGOOptimizeToVBONotIndexed(const CGO * I, int est, bool addshaders=true, float **returnedData=NULL);
+
+#define CGOOptimizeToVBONotIndexedWithReturnedData CGOOptimizeToVBONotIndexed
+#define CGOOptimizeToVBONotIndexedNoShader(I, est) CGOOptimizeToVBONotIndexed(I, est, false)
+
+
+CGO *CGOOptimizeSpheresToVBONonIndexed(const CGO * I, int est=0, bool addshaders=false, CGO *leftOverCGO=NULL);
+#define CGOOptimizeSpheresToVBONonIndexedNoShader(I, est) CGOOptimizeSpheresToVBONonIndexed(I, est, false, NULL)
+
+int CGOCheckComplex(CGO * I);
+int CGOPreloadFonts(CGO * I);
+
+int CGOCheckForText(CGO * I);
+
+int CGOFromFloatArray(CGO * I, const float *src, int len);
+
+int CGOBegin(CGO * I, int mode);
+int CGOEnd(CGO * I);
+
+int CGOSphere(CGO * I, const float *v1, float r);
+int CGOEllipsoid(CGO * I, const float *v1, float r, const float *n1, const float *n2, const float *n3);
+int CGOQuadric(CGO * I, const float *v1, float r, const float *p); /* NOT WORKING YET */
+int CGOVertex(CGO * I, float v1, float v2, float v3);
+int CGOVertexv(CGO * I, const float *v);
+int CGOVertexCrossv(CGO * I, const float *v);
+int CGOVertexBeginLineStripv(CGO * I, const float *v);
+int CGOInterpolated(CGO * I, const bool interp);
+int CGOAlpha(CGO * I, float alpha);
+int CGOColor(CGO * I, float v1, float v2, float v3);
+int CGOColorv(CGO * I, const float *v);
+int CGOTexCoord2f(CGO * I, float v1, float v2);
+int CGONormal(CGO * I, float v1, float v2, float v3);
+int CGONormalv(CGO * I, const float *v);
+int CGOResetNormal(CGO * I, int mode);
+int CGOLinewidth(CGO * I, float v);
+int CGOSpecial(CGO * I, int v);
+// all pre-processor definitions for CGOSpecial ops
+enum {
+  LINEWIDTH_DYNAMIC_WITH_SCALE = 1,
+  LINEWIDTH_DYNAMIC_MESH,
+  POINTSIZE_DYNAMIC_DOT_WIDTH,
+  LINEWIDTH_DYNAMIC_WITH_SCALE_RIBBON,
+  LINEWIDTH_DYNAMIC_WITH_SCALE_DASH,
+  CYLINDERWIDTH_DYNAMIC_MESH,
+  LINEWIDTH_WITH_SCALE,
+  DOTSIZE_WITH_SPHERESCALE,
+  MESH_WIDTH_FOR_SURFACES,
+  CYLINDER_WIDTH_FOR_DISTANCES,
+  CYLINDER_WIDTH_FOR_RIBBONS,
+  DOT_WIDTH_FOR_DOTS,
+  DOT_WIDTH_FOR_DOT_SPHERES,
+  CYLINDER_WIDTH_FOR_NONBONDED,
+  CYLINDER_WIDTH_FOR_REPWIRE,
+  CYLINDER_WIDTH_FOR_REPWIRE_VARWIDTH,
+  ENABLE_BACK_FACES_IF_NOT_TWO_SIDED,
+  DISABLE_BACK_FACES_IF_NOT_TWO_SIDED,
+  SET_SURFACE_UNIFORMS,
+  SET_ALIGNMENT_UNIFORMS_ATTRIBS,
+  LINEWIDTH_FOR_LINES,
+  SET_LABEL_SCALE_UNIFORMS
+};
+
+int CGOSpecialWithArg(CGO * I, int v, float arg);
+#define SPHERE_MODE_OPS 1
+#define LINE_LIGHTING  2
+
+int CGODotwidth(CGO * I, float v);
+int CGOChar(CGO * I, char c);
+int CGOFontVertex(CGO * I, float x, float y, float z);
+int CGOFontVertexv(CGO * I, const float *v);
+int CGOFontScale(CGO * I, float v1, float v2);
+int CGOIndent(CGO * I, char c, float dir);
+int CGOWrite(CGO * I, const char *str);
+int CGOWriteLeft(CGO * I, const char *str);
+int CGOWriteIndent(CGO * I, const char *str, float indent);
+
+#define CGODrawArrays(this, ...) (this)->add<cgo::draw::arrays>(__VA_ARGS__)
+#define CGOCustomCylinderv(this, ...) (this)->add<cgo::draw::custom_cylinder>(__VA_ARGS__)
+#define CGOShaderCylinder(this, ...) (this)->add<cgo::draw::shadercylinder>(__VA_ARGS__)
+#define CGOCylinderv(this, ...) (this)->add<cgo::draw::cylinder>(__VA_ARGS__)
+
+int CGOBoundingBox(CGO *I, const float *min, const float *max);
+int CGOAccessibility(CGO * I, const float a);
+
+int CGODrawTexture(CGO *I, int texture_id, float *worldPos, float *screenMin, float *screenMax, float *textExtent);
+int CGODrawLabel(CGO *I, int texture_id, float *targetPos, float *worldPos, float *screenWorldOffset, float *screenMin, float *screenMax, float *textExtent, short relativeMode);
+int CGODrawConnector(CGO *I, float *targetPt3d, float *labelCenterPt3d, float text_width, float text_height, float *screenOffset, float *screenWorldOffset, float *connectorColor, short relativeMode, int draw_bkgrd, float bkgrd_transp, float *bkgrd_color, float rel_ext_length, float connectorWidth);
+CGO *CGOOptimizeLabels(CGO * I, int est, bool addshaders=false);
+CGO *CGOOptimizeTextures(CGO * I, int est);
+CGO *CGOExpandDrawTextures(const CGO * I, int est);
+CGO *CGOOptimizeConnectors(CGO * I, int est);
+
+/*void CGOFontScale(CGO *I,float v);
+  void CGOFont(CGO *I,float size,int face,int style);*/
+
+void CGORoundNub(CGO * I,
+    const float *v1,    // cap center
+    const float *p0,    // normal along axis
+    const float *p1,    // x coord in cap space
+    const float *p2,    // y coord in cap space
+    int direction,      // 1 or -1
+    int nEdge,          // "quality"
+    float size);
+
+int CGOEnable(CGO * I, int mode);
+int CGODisable(CGO * I, int mode);
+
+int CGOStop(CGO * I);
+
+int CGOConev(CGO * I, const float *p1, const float *p2, float r1, float r2, const float *c1, const float *c2,
+              float cap1, float cap2);
+
+int CGOAlphaTriangle(CGO * I,
+		     const float *v1, const float *v2, const float *v3,
+		     const float *n1, const float *n2, const float *n3,
+		     const float *c1, const float *c2, const float *c3,
+		     float a1, float a2, float a3, int reverse);
+void CGOSetZVector(CGO * I, float z0, float z1, float z2);
+struct GadgetSet;
+void CGORenderGLPicking(CGO * I, RenderInfo *info,
+                        PickContext * context, CSetting * set1, CSetting * set2, Rep *rep=NULL);
+void CGORenderGL(CGO * I, const float *color, CSetting * set1, CSetting * set2,
+                 RenderInfo * info, Rep *rep);
+void CGORenderGLAlpha(CGO * I, RenderInfo * info, bool calcDepth);
+int CGORenderRay(CGO * I, CRay * ray, RenderInfo * info, const float *color, ObjectGadgetRamp *ramp, CSetting * set1, CSetting * set2);
+void CGOReset(CGO * I);
+
+void CGOSetUseShader(CGO *I, int use_shader);
+
+PyObject *CGOAsPyList(CGO * I);
+CGO *CGONewFromPyList(PyMOLGlobals * G, PyObject * list, int version, bool shouldCombine=true);
+void SetCGOPickColor(float *colorVals, int nverts, int pl, unsigned int index, int bond);
+int CGOPickColor(CGO * I, unsigned int index, int bond);
+
+float *CGOGetNextDrawBufferedIndex(float *cgo_op, int optype=CGO_DRAW_BUFFERS_INDEXED);
+#define CGOGetNextDrawBufferedNotIndex(cgo_op) CGOGetNextDrawBufferedIndex(cgo_op, CGO_DRAW_BUFFERS_NOT_INDEXED)
+
+float *CGOGetNextOp(float *cgo_op, int optype);
+
+int CGOAppend(CGO *dest, const CGO *source, bool stopAtEnd=true);
+inline int CGOAppendNoStop(CGO *dest, const CGO *source) {
+  return CGOAppend(dest, source, false);
+}
+
+int CGOCountNumberOfOperationsOfTypeDEBUG(const CGO *I, int optype);
+int CGOCountNumberOfOperationsOfType(const CGO *I, int op);
+int CGOCountNumberOfOperationsOfTypeN(const CGO *I, const std::set<int> &optype, bool debug=false);
+int CGOCountNumberOfOperationsOfTypeN(const CGO *I, const std::map<int, int> &optype);
+bool CGOHasOperations(const CGO *I);
+bool CGOHasOperationsOfType(const CGO *I, int optype);
+bool CGOHasOperationsOfTypeN(const CGO *I, const std::set<int> &optype);
+bool CGOHasCylinderOperations(const CGO *I);
+bool CGOHasSphereOperations(const CGO *I);
+bool CGOFilterOutCylinderOperationsInto(const CGO *I, CGO *cgo);
+
+bool CGOCheckWhetherToFree(PyMOLGlobals * G, CGO *I);
+
+CGO *CGOConvertLinesToShaderCylinders(const CGO * I, int est);
+CGO *CGOSplitUpLinesForPicking(const CGO * I);
+CGO *CGOConvertLinesToTrilines(const CGO * I, bool addshaders=true);
+CGO *CGOConvertToLabelShader(const CGO *I, CGO * addTo);
+
+int CGOChangeShadersTo(CGO *I, int frommode, int tomode);
+void CGOCountNumVerticesDEBUG(const CGO *I);
+CGO *CGOOptimizeScreenTexturesAndPolygons(CGO * I, int est);
+CGO *CGOColorByRamp(PyMOLGlobals * G, CGO *I, ObjectGadgetRamp *ramp, int state, CSetting * set1);
+
+#define CGOLineAsTriangleStrips(CGO, minx, miny, maxx, maxy) \
+	CGOBegin(CGO, GL_TRIANGLE_STRIP);         \
+	CGOVertex(CGO, minx, miny, 0.f);         \
+	CGOVertex(CGO, minx, maxy+1, 0.f);         \
+	CGOVertex(CGO, minx+1, miny, 0.f);         \
+	CGOVertex(CGO, minx+1, maxy+1, 0.f);         \
+	CGOEnd(CGO);         \
+	CGOBegin(CGO, GL_TRIANGLE_STRIP);         \
+	CGOVertex(CGO, minx, maxy, 0.f);         \
+	CGOVertex(CGO, minx, maxy+1, 0.f);         \
+	CGOVertex(CGO, maxx, maxy, 0.f);         \
+	CGOVertex(CGO, maxx, maxy+1, 0.f);         \
+	CGOEnd(CGO);         \
+	CGOBegin(CGO, GL_TRIANGLE_STRIP);         \
+	CGOVertex(CGO, maxx, miny, 0.f);         \
+	CGOVertex(CGO, maxx, maxy+1, 0.f);         \
+	CGOVertex(CGO, maxx+1, miny, 0.f);         \
+	CGOVertex(CGO, maxx+1, maxy+1, 0.f);         \
+	CGOEnd(CGO);         \
+	CGOBegin(CGO, GL_TRIANGLE_STRIP);         \
+	CGOVertex(CGO, minx, miny, 0.f);         \
+	CGOVertex(CGO, minx, miny+1, 0.f);         \
+	CGOVertex(CGO, maxx, miny, 0.f);         \
+	CGOVertex(CGO, maxx, miny+1, 0.f);         \
+	CGOEnd(CGO);
+
+int CGOHasTransparency(const CGO *I, bool checkTransp=true, bool checkOpaque=false);
+#define CGOHasOpaque(I) CGOHasTransparency(I, false, true)
+
+CGO *CGOConvertTrianglesToAlpha(const CGO * I);
+CGO *CGOGenerateNormalsForTriangles(const CGO * I);
+
+bool CGOHasAnyTriangleVerticesWithoutNormals(CGO *I, bool checkTriangles=true);
+#define CGOHasAnyLineVerticesWithoutNormals(I) CGOHasAnyTriangleVerticesWithoutNormals(I, false)
+
+CGO *CGOTurnLightingOnLinesOff(CGO * I);
+
+// returns offset of floats in CGO array
+int CGOUniform3f(CGO *I, int uniform_id, const float *value);
+
+void SetUCColorFromIndex_32bit(uchar *color, unsigned int idx);
+void SetUCColorFromIndex_16bit(uchar *color, unsigned int idx);
+
+void SetUCColorToZero_32bit(uchar *color);
+void SetUCColorToZero_16bit(uchar *color);
+
+CGO *CGOConvertSpheresToPoints(CGO *I);
+
+#ifdef _PYMOL_ARB_SHADERS
+void CGORenderSpheresARB(RenderInfo *info, CGO *I, float *fog_info);
+#endif
+
+CGO *CGOConvertToShader(const CGO *I, AttribDataDesc &attrData, AttribDataDesc &pickData, int mode, const VertexBuffer::buffer_layout layout=VertexBuffer::INTERLEAVED, bool check_attr_for_data=true, int *idx_array=NULL, int nindicesperfrag=0, int nfragspergroup = 1);
+
+bool CGOCheckSplitLineInterpolationIsSame(const CGO *I, bool &interp_value);
+
+CGO *CGOConvertToTrilinesShader(const CGO *I, CGO *addTo, bool add_color=true);
+CGO *CGOConvertToLinesShader(const CGO *I, CGO *addTo, bool add_color=true);
+
+CGO *CGOConvertLinesToCylinderShader(const CGO *I, CGO *addTo, bool add_color = true);
+CGO *CGOConvertCrossesToCylinderShader(const CGO *I, CGO *addTo, float cross_size);
+CGO *CGOConvertCrossesToLinesShader(const CGO *I, CGO *addTo, float cross_size);
+CGO *CGOConvertCrossesToTrilinesShader(const CGO *I, CGO *addTo, float cross_size);
+CGO *CGOConvertShaderCylindersToCylinderShader(const CGO *I, CGO *addTo);
+
+bool AssignNewPickColor(CGO *cgo, unsigned int &i, std::vector<Picking>* pick, PickContext * context, unsigned char *color, unsigned int index, int bond);
+
+#endif
diff -upNr pymol-open-source-2.3.0.orig/layer1/FontType.cpp pymol-open-source-2.3.0/layer1/FontType.cpp
--- pymol-open-source-2.3.0.orig/layer1/FontType.cpp	2020-03-10 19:31:10.428701911 +0100
+++ pymol-open-source-2.3.0/layer1/FontType.cpp	2020-03-10 19:31:34.103008714 +0100
@@ -75,9 +75,6 @@ typedef struct {
   CTypeFace *TypeFace;
 } CFontType;
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static const char *_FontTypeRenderOpenGL(RenderInfo * info,
                                    CFontType * I, const char *st,
                                    float size, int flat, float *rpos, short needSize, short relativeMode, short shouldRender SHADERCGOARG)
diff -upNr pymol-open-source-2.3.0.orig/layer1/PConv.cpp pymol-open-source-2.3.0/layer1/PConv.cpp
--- pymol-open-source-2.3.0.orig/layer1/PConv.cpp	2020-03-10 19:31:10.428701911 +0100
+++ pymol-open-source-2.3.0/layer1/PConv.cpp	2020-03-10 19:32:00.270692982 +0100
@@ -264,6 +264,11 @@ int PConvPyStrToStr(PyObject * obj, char
   int ok = true;
   if(!obj) {
     ok = false;
+#if PY_MAJOR_VERSION >= 3
+  } else if(PyBytes_Check(obj)) {
+    auto strval = PyBytes_AsSomeString(obj);
+    UtilNCopy(ptr, strval.c_str(), size);
+#endif
   } else if(!PyString_Check(obj)) {
     ok = false;
     if(size)
diff -upNr pymol-open-source-2.3.0.orig/layer1/Ray.cpp pymol-open-source-2.3.0/layer1/Ray.cpp
--- pymol-open-source-2.3.0.orig/layer1/Ray.cpp	2020-03-10 19:31:10.428701911 +0100
+++ pymol-open-source-2.3.0/layer1/Ray.cpp	2020-03-10 19:31:34.107009200 +0100
@@ -43,11 +43,7 @@ Z* -------------------------------------
 
 #define SettingGetfv SettingGetGlobal_3fv
 
-#ifdef _PYMOL_INLINE
-#undef _PYMOL_INLINE
-#include"Basis.cpp"
-#define _PYMOL_INLINE
-#endif
+#include"Basis.h"
 
 #ifndef RAY_SMALL
 #define RAY_SMALL 0.00001
@@ -218,9 +214,6 @@ int RayGetNPrimitives(CRay * I)
 
 /*========================================================================*/
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static void RayGetSphereNormal(CRay * I, RayInfo * r)
 {
 
@@ -235,9 +228,6 @@ static void RayGetSphereNormal(CRay * I,
   normalize3f(r->surfnormal);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static void RayGetSphereNormalPerspective(CRay * I, RayInfo * r)
 {
 
@@ -463,9 +453,6 @@ static void fill_gradient(CRay * I, int
 }
 
 /*========================================================================*/
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static void RayReflectAndTexture(CRay * I, RayInfo * r, int perspective)
 {
   if(r->prim->wobble)
@@ -6898,7 +6885,6 @@ int CRay::cylinder3fv(const float *v1, c
 
   p->type = cPrimCylinder;
   p->r1 = r;
-  p->trans = I->Trans;
   p->cap1 = cCylCapFlat;
   p->cap2 = cCylCapFlat;
   p->wobble = I->Wobble;
@@ -6939,7 +6925,8 @@ int CRay::cylinder3fv(const float *v1, c
   (*vv++) = (*c2++);
   (*vv++) = (*c2++);
 
-  p->trans = 1.0 - alpha1;
+  // FIXME: alpha1 is not used
+  p->trans = 1.0 - alpha2;
   {
     float *v;
     vv = p->ic;
@@ -6994,7 +6981,6 @@ int CRay::customCylinder3fv(const float
 
   p->type = cPrimCylinder;
   p->r1 = r;
-  p->trans = I->Trans;
   p->cap1 = cap1;
   p->cap2 = cap2;
   p->wobble = I->Wobble;
@@ -7036,7 +7022,8 @@ int CRay::customCylinder3fv(const float
   (*vv++) = (*c2++);
   vv = p->ic;
 
-  p->trans = 1.0f - alpha1;
+  // FIXME: alpha1 is not used
+  p->trans = 1.0f - alpha2;
 
   {
     float *v;
diff -upNr pymol-open-source-2.3.0.orig/layer1/Scene.cpp pymol-open-source-2.3.0/layer1/Scene.cpp
--- pymol-open-source-2.3.0.orig/layer1/Scene.cpp	2020-03-10 19:31:10.428701911 +0100
+++ pymol-open-source-2.3.0/layer1/Scene.cpp	2020-03-10 19:31:34.111009686 +0100
@@ -2117,6 +2117,9 @@ int SceneMakeMovieImage(PyMOLGlobals * G
   PRINTFB(G, FB_Scene, FB_Blather)
     " Scene: Making movie image.\n" ENDFB(G);
 
+  // PYMOL-3209 objects inside hidden groups become visible
+  ExecutiveUpdateSceneMembers(G);
+
   mode = SceneValidateImageMode(G, mode, width || height);
 
   I->DirtyFlag = false;
diff -upNr pymol-open-source-2.3.0.orig/layer1/SceneRay.cpp pymol-open-source-2.3.0/layer1/SceneRay.cpp
--- pymol-open-source-2.3.0.orig/layer1/SceneRay.cpp	2020-03-10 19:31:10.432702196 +0100
+++ pymol-open-source-2.3.0/layer1/SceneRay.cpp	2020-03-10 19:31:34.115010172 +0100
@@ -14,6 +14,7 @@
 static double accumTiming = 0.0;
 
 /* EXPERIMENTAL VOLUME RAYTRACING DATA */
+static std::shared_ptr<pymol::Image> rayVolumeImage;
 extern float *rayDepthPixels;
 extern int rayVolume, rayWidth, rayHeight;
 
@@ -363,6 +364,12 @@ bool SceneRay(PyMOLGlobals * G,
           I->DirtyFlag = false;
           I->CopyType = true;
           I->CopyForced = true;
+
+          if (SettingGet<bool>(G, cSetting_ray_volume) && !I->Image->empty()) {
+            rayVolumeImage = I->Image;
+          } else {
+            rayVolumeImage = nullptr;
+          }
         }
         break;
 
@@ -773,9 +780,10 @@ void SceneRenderRayVolume(PyMOLGlobals *
 #endif
   glDepthMask(GL_FALSE);
 #ifndef PURE_OPENGL_ES_2
-  if (PIsGlutThread() && I->Image && !I->Image->empty()){
+  if (PIsGlutThread() && rayVolumeImage) {
     if (rayWidth == I->Width && rayHeight == I->Height){
-      glDrawPixels(I->Image->getWidth(), I->Image->getHeight(), GL_RGBA, GL_UNSIGNED_BYTE, I->Image->bits());
+      glDrawPixels(rayVolumeImage->getWidth(), rayVolumeImage->getHeight(),
+          GL_RGBA, GL_UNSIGNED_BYTE, rayVolumeImage->bits());
     } else {
       SceneDrawImageOverlay(G, 1, NULL);
     }
diff -upNr pymol-open-source-2.3.0.orig/layer2/CoordSet.cpp pymol-open-source-2.3.0/layer2/CoordSet.cpp
--- pymol-open-source-2.3.0.orig/layer2/CoordSet.cpp	2020-03-10 19:31:10.436702480 +0100
+++ pymol-open-source-2.3.0/layer2/CoordSet.cpp	2020-03-10 19:31:34.115010172 +0100
@@ -851,12 +851,12 @@ bool CoordSetInsureOrthogonal(PyMOLGloba
 }
 
 /*========================================================================*/
-static char RotateU(const double *matrix, float *anisou)
 /* Rotates the ANISOU vector
  *
  * matrix: flat 4x4, but only rotation (upper left 3x3) is considered
  * anisou: has 6 elements (of symmetric 3x3) and will be rotated in-place
  */
+bool RotateU(const double *matrix, float *anisou)
 {
   int i, j, k;
   float Re[3][3];
diff -upNr pymol-open-source-2.3.0.orig/layer2/CoordSet.h pymol-open-source-2.3.0/layer2/CoordSet.h
--- pymol-open-source-2.3.0.orig/layer2/CoordSet.h	2020-03-10 19:31:10.436702480 +0100
+++ pymol-open-source-2.3.0/layer2/CoordSet.h	2020-03-10 19:31:34.115010172 +0100
@@ -221,4 +221,7 @@ template <typename V> void SettingSet(in
   SettingSet(cs->State.G, &cs->Setting, index, value);
 }
 
+// Rotates the ANISOU vector
+bool RotateU(const double *matrix, float *anisou);
+
 #endif
diff -upNr pymol-open-source-2.3.0.orig/layer2/HydrogenAdder.cpp pymol-open-source-2.3.0/layer2/HydrogenAdder.cpp
--- pymol-open-source-2.3.0.orig/layer2/HydrogenAdder.cpp	2020-03-10 19:31:10.436702480 +0100
+++ pymol-open-source-2.3.0/layer2/HydrogenAdder.cpp	2020-03-10 19:31:45.528496749 +0100
@@ -304,8 +304,8 @@ int ObjectMoleculeAddSeleHydrogensRefact
     if (nimplicit <= 0)
       continue;
 
-    VLACheck(I->AtomInfo, AtomInfoType, I->NAtom + nimplicit - 1);
-    VLACheck(I->Bond,     BondType,     I->NBond + nimplicit - 1);
+    I->AtomInfo.reserve(I->NAtom + nimplicit);
+    I->Bond.reserve(I->NBond + nimplicit);
 
     for (int i = 0; i < nimplicit; ++i) {
       // bond
diff -upNr pymol-open-source-2.3.0.orig/layer2/ObjectGadgetRamp.cpp pymol-open-source-2.3.0/layer2/ObjectGadgetRamp.cpp
--- pymol-open-source-2.3.0.orig/layer2/ObjectGadgetRamp.cpp	2020-03-10 19:31:10.440702765 +0100
+++ pymol-open-source-2.3.0/layer2/ObjectGadgetRamp.cpp	2020-03-10 19:31:34.119010659 +0100
@@ -51,9 +51,6 @@ void ObjectGadgetRampFree(ObjectGadgetRa
   OOFreeP(I);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static void ObjectGadgetRampCalculate(ObjectGadgetRamp * I, float v, float *result)
 {
   const float _1 = 1.0F;
@@ -219,9 +216,6 @@ static int _ObjectGadgetRampInterpolate(
   return (ok);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int _ObjectGadgetRampBlend(ObjectGadgetRamp * I, float *color,
                                   const float *table, int mode)
 {
diff -upNr pymol-open-source-2.3.0.orig/layer2/ObjectMesh.cpp pymol-open-source-2.3.0/layer2/ObjectMesh.cpp
--- pymol-open-source-2.3.0.orig/layer2/ObjectMesh.cpp	2020-03-10 19:31:10.440702765 +0100
+++ pymol-open-source-2.3.0/layer2/ObjectMesh.cpp	2020-03-10 19:31:34.119010659 +0100
@@ -782,7 +782,7 @@ static short ObjectMeshStateRenderShader
     RenderInfo *info, short mesh_as_cylinders, float mesh_width)
 {
   PyMOLGlobals *G = I->Obj.G;
-  CShaderPrg *shaderPrg;
+  CShaderPrg *shaderPrg  = nullptr;
 
   if (!mesh_as_cylinders) {
     shaderPrg = G->ShaderMgr->Enable_DefaultShader(info->pass);
@@ -795,6 +795,10 @@ static short ObjectMeshStateRenderShader
 
   CGORenderGL(ms->shaderCGO, NULL, NULL, NULL, info, NULL);
 
+  if (shaderPrg) {
+    shaderPrg->Disable();
+  }
+
   if (ms->shaderUnitCellCGO){
     shaderPrg = G->ShaderMgr->Enable_DefaultShader(info->pass);
     shaderPrg->SetLightingEnabled(0);
diff -upNr pymol-open-source-2.3.0.orig/layer2/Sculpt.cpp pymol-open-source-2.3.0/layer2/Sculpt.cpp
--- pymol-open-source-2.3.0.orig/layer2/Sculpt.cpp	2020-03-10 19:31:10.448703334 +0100
+++ pymol-open-source-2.3.0/layer2/Sculpt.cpp	2020-03-10 19:31:34.119010659 +0100
@@ -70,9 +70,6 @@ Z* -------------------------------------
 (((((a)^((a)>>5)))&0x00FF)|\
  (((    ((b)<<5)))&0xFF00))
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static float ShakerDoDist(float target, float *v0, float *v1, float *d0to1, float *d1to0,
                           float wt)
 {
@@ -104,9 +101,6 @@ static float ShakerDoDist(float target,
   return result;
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static float ShakerDoTors(int type, float *v0, float *v1, float *v2, float *v3,
                           float *p0, float *p1, float *p2, float *p3, float tole,
                           float wt)
@@ -193,9 +187,6 @@ static float ShakerDoTors(int type, floa
 
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static float ShakerDoDistLimit(float target, float *v0, float *v1, float *d0to1,
                                float *d1to0, float wt)
 {
@@ -217,9 +208,6 @@ static float ShakerDoDistLimit(float tar
   }
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static float ShakerDoDistMinim(float target, float *v0, float *v1, float *d0to1,
                                float *d1to0, float wt)
 {
@@ -1417,9 +1405,6 @@ void SculptMeasureObject(CSculpt * I, Ob
 
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int SculptCheckBump(float *v1, float *v2, float *diff, float *dist, float cutoff)
 {
   float d2;
@@ -1440,9 +1425,6 @@ static int SculptCheckBump(float *v1, fl
   return (false);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int SculptCGOBump(float *v1, float *v2,
                          float vdw1, float vdw2,
                          float cutoff,
@@ -1552,9 +1534,6 @@ static int SculptCGOBump(float *v1, floa
   }
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int SculptDoBump(float target, float actual, float *d,
                         float *d0to1, float *d1to0, float wt, float *strain)
 {
@@ -1579,9 +1558,6 @@ static int SculptDoBump(float target, fl
   return 0;
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int SculptCheckAvoid(float *v1, float *v2, float *diff,
                             float *dist, float avoid, float range)
 {
@@ -1607,9 +1583,6 @@ static int SculptCheckAvoid(float *v1, f
   return (false);
 }
 
-#ifdef _PYMOL_INLINE
-__inline__
-#endif
 static int SculptDoAvoid(float avoid, float range, float actual, float *d,
                          float *d0to1, float *d1to0, float wt, float *strain)
 {
diff -upNr pymol-open-source-2.3.0.orig/layer3/Executive.cpp pymol-open-source-2.3.0/layer3/Executive.cpp
--- pymol-open-source-2.3.0.orig/layer3/Executive.cpp	2020-03-10 19:31:10.448703334 +0100
+++ pymol-open-source-2.3.0/layer3/Executive.cpp	2020-03-10 19:31:34.127011631 +0100
@@ -1580,7 +1580,7 @@ static void ExecutiveInvalidateSceneMemb
   I->ValidSceneMembers = false;
 }
 
-static void ExecutiveUpdateSceneMembers(PyMOLGlobals * G)
+void ExecutiveUpdateSceneMembers(PyMOLGlobals * G)
 {
   CExecutive *I = G->Executive;
   ExecutiveUpdateGroups(G, false);
diff -upNr pymol-open-source-2.3.0.orig/layer3/Executive.h pymol-open-source-2.3.0/layer3/Executive.h
--- pymol-open-source-2.3.0.orig/layer3/Executive.h	2020-03-10 19:31:10.448703334 +0100
+++ pymol-open-source-2.3.0/layer3/Executive.h	2020-03-10 19:31:34.127011631 +0100
@@ -167,6 +167,7 @@ int ExecutiveScrollTo(PyMOLGlobals * G,
 
 void ExecutiveInvalidateGroups(PyMOLGlobals * G, int force);
 void ExecutiveUpdateGroups(PyMOLGlobals * G, int force);
+void ExecutiveUpdateSceneMembers(PyMOLGlobals*);
 
 int *ExecutiveGetG3d(PyMOLGlobals * G);
 int ExecutiveOrder(PyMOLGlobals * G, const char *s1, int sort, int location);
diff -upNr pymol-open-source-2.3.0.orig/layer3/MaeExportHelpers.cpp pymol-open-source-2.3.0/layer3/MaeExportHelpers.cpp
--- pymol-open-source-2.3.0.orig/layer3/MaeExportHelpers.cpp	2020-03-10 19:31:10.452703618 +0100
+++ pymol-open-source-2.3.0/layer3/MaeExportHelpers.cpp	2020-03-10 19:31:34.131012117 +0100
@@ -197,3 +197,39 @@ std::string MaeExportGetSubGroupId(PyMOL
 
   return subgroupid;
 }
+
+/*
+ * Get parsable string representation, with quotes and escaped
+ * quotes/backslashes if needed.
+ */
+std::string MaeExportStrRepr(const char * text)
+{
+  if (text[0] /* not empty string */) {
+    bool needquotes = false;
+
+    // check accepted ascii characters
+    for (const char * p = text; *p; ++p) {
+      if (*p < '$' || *p > 'z' || *p == '\\') {
+        needquotes = true;
+        break;
+      }
+    }
+
+    if (!needquotes) {
+      return text;
+    }
+  }
+
+  std::string quoted_text;
+  quoted_text.reserve(strlen(text) + 2);
+  quoted_text += '"';
+
+  for (const char * p = text; *p; ++p) {
+    if (*p == '"' || *p == '\\')
+      quoted_text += '\\';
+    quoted_text += *p;
+  }
+
+  quoted_text += '"';
+  return quoted_text;
+}
diff -upNr pymol-open-source-2.3.0.orig/layer3/MaeExportHelpers.h pymol-open-source-2.3.0/layer3/MaeExportHelpers.h
--- pymol-open-source-2.3.0.orig/layer3/MaeExportHelpers.h	2020-03-10 19:31:10.452703618 +0100
+++ pymol-open-source-2.3.0/layer3/MaeExportHelpers.h	2020-03-10 19:31:34.131012117 +0100
@@ -31,4 +31,6 @@ std::string MaeExportGetLabelUserText(Py
 std::string MaeExportGetSubGroupId(PyMOLGlobals * G,
     const CObject * obj);
 
+std::string MaeExportStrRepr(const char * text);
+
 // vi:sw=2:expandtab
diff -upNr pymol-open-source-2.3.0.orig/layer3/MoleculeExporter.cpp pymol-open-source-2.3.0/layer3/MoleculeExporter.cpp
--- pymol-open-source-2.3.0.orig/layer3/MoleculeExporter.cpp	2020-03-10 19:31:10.452703618 +0100
+++ pymol-open-source-2.3.0/layer3/MoleculeExporter.cpp	2020-03-10 19:31:34.131012117 +0100
@@ -1063,6 +1063,55 @@ struct MoleculeExporterMAE : public Mole
   int m_n_atoms_offset;
   int m_n_arom_bonds;
   std::map<int, const AtomInfoType *> m_atoms;
+  bool m_has_anisou;
+
+#ifdef _PYMOL_MAE_PROP_EXPORT
+#endif
+
+  /* Check if current object has any ANISOU data
+   */
+  bool currentObjectHasAnisou() const {
+    for (auto i = 0; i < m_iter.obj->NAtom; ++i) {
+      if (m_iter.obj->AtomInfo[i].has_anisou()) {
+        return true;
+      }
+    }
+
+    return false;
+  }
+
+  /* Write a single string value to the output buffer
+   */
+  void writeMaeValue(const char * s) {
+    auto s_quoted = MaeExportStrRepr(s);
+    m_offset += VLAprintf(m_buffer, m_offset, "%s\n", s_quoted.c_str());
+  }
+
+  /* Write the given keys to the output buffer.
+   * Add type prefix and make key unique if necessary.
+   */
+  void writeMaeKeys(const std::vector<std::string> &keys) {
+    std::set<std::string> unique_keys;
+
+    for (auto key : keys) {
+      // check for "<type>_" prefix or add one
+      if (key.size() < 2 || key[1] != '_' || !strchr("irsb", key[0])) {
+        key = "s_pymol_" + key;
+      }
+
+      auto key_size = key.size();
+
+      // make key unique (append numbers)
+      for (unsigned i = 1; unique_keys.count(key); ++i) {
+        key.resize(key_size);
+        key += std::to_string(i);
+      }
+
+      unique_keys.insert(key);
+
+      writeMaeValue(key.c_str());
+    }
+  }
 
   // quasi constructor
   void init(PyMOLGlobals * G_) override {
@@ -1089,43 +1138,91 @@ struct MoleculeExporterMAE : public Mole
 
     m_offset += VLAprintf(m_buffer, m_offset,
         "\nf_m_ct {\n"
-        "s_m_subgroupid\n"
-        "s_m_title\n"
+        );
+
+    std::vector<std::string> keys {
+      "s_m_title",
+    };
+
+    if (!groupid.empty()) {
+      keys.emplace_back("s_m_subgroupid");
+    }
+
+#ifdef _PYMOL_MAE_PROP_EXPORT
+#endif
+
+    writeMaeKeys(keys);
+
+    m_offset += VLAprintf(m_buffer, m_offset,
         ":::\n"
-        "\"%s\"\n"
-        "\"%s\"\n",
-        groupid.c_str(),
-        getTitleOrName());
+        );
+
+    // title may contain spaces or quotes
+    writeMaeValue(getTitleOrName());
+
+    if (!groupid.empty()) {
+      m_offset += VLAprintf(m_buffer, m_offset, "\"%s\"\n", groupid.c_str());
+    }
+
+#ifdef _PYMOL_MAE_PROP_EXPORT
+#endif
 
     // defer until number of atoms known
     m_n_atoms_offset = m_offset;
 
+    keys = {
+      "i_m_mmod_type",
+      "r_m_x_coord",
+      "r_m_y_coord",
+      "r_m_z_coord",
+      "i_m_residue_number",
+      "s_m_insertion_code",
+      "s_m_chain_name",
+      "s_m_pdb_residue_name",
+      "s_m_pdb_atom_name",
+      "i_m_atomic_number",
+      "i_m_formal_charge",
+      "s_m_color_rgb",
+      "i_m_secondary_structure",
+      "r_m_pdb_occupancy",
+      "i_pdb_PDB_serial",
+
+      "r_m_pdb_tfactor",
+      "r_m_charge1",
+
+      "i_m_visibility",
+      "i_m_representation",
+      "i_m_ribbon_style",
+      "i_m_ribbon_color",
+      "s_m_ribbon_color_rgb",
+      "s_m_label_format",
+      "i_m_label_color",
+      "s_m_label_user_text",
+    };
+
+    // ANISOU
+    if ((m_has_anisou = currentObjectHasAnisou())) {
+      keys.insert(keys.end(), {
+        "i_pdb_anisou_u11",
+        "i_pdb_anisou_u22",
+        "i_pdb_anisou_u33",
+        "i_pdb_anisou_u12",
+        "i_pdb_anisou_u13",
+        "i_pdb_anisou_u23",
+      });
+    }
+
     m_offset += VLAprintf(m_buffer, m_offset,
         "m_atom[X]            {\n" // place holder
         "# First column is atom index #\n"
-        "i_m_mmod_type\n"
-        "r_m_x_coord\n"
-        "r_m_y_coord\n"
-        "r_m_z_coord\n"
-        "i_m_residue_number\n"
-        "s_m_insertion_code\n"
-        "s_m_chain_name\n"
-        "s_m_pdb_residue_name\n"
-        "s_m_pdb_atom_name\n"
-        "i_m_atomic_number\n"
-        "i_m_formal_charge\n"
-        "s_m_color_rgb\n"
-        "i_m_secondary_structure\n"
-        "r_m_pdb_occupancy\n"
-        "i_pdb_PDB_serial\n"
-        "i_m_visibility\n"
-        "i_m_representation\n"
-        "i_m_ribbon_style\n"
-        "i_m_ribbon_color\n"
-        "s_m_ribbon_color_rgb\n"
-        "s_m_label_format\n"
-        "i_m_label_color\n"
-        "s_m_label_user_text\n"
+        );
+
+#ifdef _PYMOL_MAE_PROP_EXPORT
+#endif
+
+    writeMaeKeys(keys);
+
+    m_offset += VLAprintf(m_buffer, m_offset,
         ":::\n");
 
     m_n_atoms = 0;
@@ -1152,16 +1249,25 @@ struct MoleculeExporterMAE : public Mole
     if (ai->name)
       AtomInfoGetAlignedPDBAtomName(G, ai, resn, name);
 
+    // 4-letter padding for atom name
+    for (auto i = strlen(name); i < 4; ++i) {
+      name[i] = ' ';
+    }
+    name[4] = '\0';
+
+    // 1-letter padding for chain
+    const char* chain = ai->chain ? LexStr(G, ai->chain) : " ";
+
     m_offset += VLAprintf(m_buffer, m_offset,
-        "%d %d %.3f %.3f %.3f %d %s %s \"%-4s\" \"%-4s\" %d %d %02X%02X%02X %d %.2f %d\n",
+        "%d %d %.3f %.3f %.3f %d %s %s \"%-4s\" %s %d %d %02X%02X%02X %d %.2f %d\n",
         getTmpID(),
         getMacroModelAtomType(ai),
         m_coord[0], m_coord[1], m_coord[2],
         ai->resv,
         inscode,
-        ai->chain ? LexStr(G, ai->chain) : "\" \"",
+        MaeExportStrRepr(chain).c_str(),
         resn,
-        name,
+        MaeExportStrRepr(name).c_str(),
         ai->protons,
         ai->formalCharge,
         int(rgb[0] * 255),
@@ -1171,6 +1277,11 @@ struct MoleculeExporterMAE : public Mole
         ai->q,
         ai->id);
 
+    m_offset += VLAprintf(m_buffer, m_offset,
+        "%.2f %.2f ",
+        ai->b,
+        ai->partialCharge);
+
     char ribbon_color_rgb[7] = "<>";
     MaeExportGetRibbonColor(G, m_iter, ribbon_color_rgb);
     std::string label_user_text = MaeExportGetLabelUserText(G, ai);
@@ -1185,6 +1296,28 @@ struct MoleculeExporterMAE : public Mole
         label_user_text.empty() ? "" : "%UT",
         label_user_text.c_str());
 
+    // ANISOU
+    if (m_has_anisou) {
+      if (ai->has_anisou()) {
+        float anisou[6];
+        std::copy_n(ai->get_anisou(), 6, anisou);
+
+        if (m_mat_full.ptr) {
+          RotateU(m_mat_full.ptr, anisou);
+        }
+
+        m_offset += VLAprintf(m_buffer, m_offset,
+            "%.0f %.0f %.0f %.0f %.0f %.0f\n",
+            anisou[0] * 1e4, anisou[1] * 1e4, anisou[2] * 1e4,
+            anisou[3] * 1e4, anisou[4] * 1e4, anisou[5] * 1e4);
+      } else {
+        m_offset += VLAprintf(m_buffer, m_offset, "<> <> <> <> <> <>\n");
+      }
+    }
+
+#ifdef _PYMOL_MAE_PROP_EXPORT
+#endif
+
     m_atoms[getTmpID()] = ai;
 
     ++m_n_atoms;
diff -upNr pymol-open-source-2.3.0.orig/layer3/Selector.cpp pymol-open-source-2.3.0/layer3/Selector.cpp
--- pymol-open-source-2.3.0.orig/layer3/Selector.cpp	2020-03-10 19:31:10.452703618 +0100
+++ pymol-open-source-2.3.0/layer3/Selector.cpp	2020-03-10 19:31:34.139013090 +0100
@@ -14,6 +14,8 @@ I* Additional authors of this source fil
 Z* -------------------------------------------------------------------
 */
 
+#include <algorithm>
+#include <string>
 #include <vector>
 
 #include"os_python.h"
@@ -65,37 +67,6 @@ Z* -------------------------------------
 /* special selections, unknown to executive */
 #define cColorectionFormat "_!c_%s_%d"
 
-#if 0
-// A lot of PyMOL's utility code used to select with lower case atomic
-// identifiers, making the code dependent on "ignore_case=1". The default
-// for this setting was changed to "0 (off)", which required to fix all
-// affected scripts (e.g. mutagenesis wizard, PYMOL-2487).
-// This is a debug/helper function to identify use of lower case
-// identifiers in selection expressions. Remove before the next official
-// release.
-void WARN_IF_LOWERCASE(PyMOLGlobals * G, const char * label, const char * text) {
-  if (!*text)
-    return;
-  for (const char * p = text; *p; ++p)
-    if (isupper(*p))
-      return;
-  PRINTFB(G, FB_Selector, FB_Warnings)
-    "SELECTOR-LOWER-WARNING: %s '%s'\n", label, text
-    ENDFB(G);
-}
-#else
-#define WARN_IF_LOWERCASE(G, a, b)
-#endif
-
-// Count how often `c` occurs in `s`
-static int strchrcount(const char *s, char c) {
-  int i = 0;
-  while(*s)
-    if(*(s++) == c)
-      i++;
-  return i;
-}
-
 static WordKeyValue rep_names[] = {
   {"spheres", cRepSphereBit},
   {"sticks", cRepCylBit},
@@ -129,8 +100,11 @@ typedef struct {
   int level, imp_op_level;
   int type;                     /* 0 = value 1 = operation 2 = pre-operation */
   unsigned int code;
-  SelectorWordType text;
+  std::string m_text;
   int *sele;
+
+  /// read-only access to text
+  const char* text() const { return m_text.c_str(); }
 } EvalElem;
 
 typedef struct {
@@ -155,8 +129,8 @@ static int SelectorSelect2(PyMOLGlobals
 static int SelectorLogic1(PyMOLGlobals * G, EvalElem * base, int state);
 static int SelectorLogic2(PyMOLGlobals * G, EvalElem * base);
 static int SelectorOperator22(PyMOLGlobals * G, EvalElem * base, int state);
-static int *SelectorEvaluate(PyMOLGlobals * G, SelectorWordType * word, int state, int quiet);
-static SelectorWordType *SelectorParse(PyMOLGlobals * G, const char *s);
+static int *SelectorEvaluate(PyMOLGlobals* G, std::vector<std::string>& word, int state, int quiet);
+static std::vector<std::string> SelectorParse(PyMOLGlobals * G, const char *s);
 static void SelectorPurgeMembers(PyMOLGlobals * G, int sele);
 static int SelectorEmbedSelection(PyMOLGlobals * G, int *atom, const char *name,
                                   ObjectMolecule * obj, int no_dummies, int exec_manage);
@@ -670,6 +644,8 @@ static WordKeyValue Keyword[] = {
   {"sidechain", SELE_SC_z},
   {"sc.", SELE_SC_z},
 
+  {"p.", SELE_PROP},
+
   {"x", SELE_XVLx},
   {"y", SELE_YVLx},
   {"z", SELE_ZVLx},
@@ -7919,27 +7895,13 @@ int SelectorUpdateTableImpl(PyMOLGlobals
 /*========================================================================*/
 static int *SelectorSelect(PyMOLGlobals * G, const char *sele, int state, int domain, int quiet)
 {
-  SelectorWordType *parsed;
   int *result = NULL;
   PRINTFD(G, FB_Selector)
     "SelectorSelect-DEBUG: sele = \"%s\"\n", sele ENDFD;
   SelectorUpdateTable(G, state, domain);
-  parsed = SelectorParse(G, sele);
-  if(parsed) {
-    if(Feedback(G, FB_Selector, FB_Debugging)) {
-      SelectorWordType *a;
-      fprintf(stderr, "SelectorSelect-DEBUG: parsed tokens:\n");
-      a = parsed;
-      while(1) {
-        if(!a[0][0])
-          break;
-        fprintf(stderr, "  \"%s\"\n", (a[0]));
-        a++;
-      }
-      fprintf(stderr, "SelectorSelect-DEBUG: end of tokens.\n");
-    }
+  auto parsed = SelectorParse(G, sele);
+  if (!parsed.empty()) {
     result = SelectorEvaluate(G, parsed, state, quiet);
-    VLAFreeP(parsed);
   }
   return (result);
 }
@@ -7979,7 +7941,7 @@ static int SelectorModulate1(PyMOLGlobal
   switch (base[1].code) {
   case SELE_ARD_:
   case SELE_EXP_:
-    if(!sscanf(base[2].text, "%f", &dist))
+    if(!sscanf(base[2].text(), "%f", &dist))
       ok = ErrMessage(G, "Selector", "Invalid distance.");
     if(ok) {
       for(d = 0; d < I->NCSet; d++) {
@@ -8048,7 +8010,7 @@ static int SelectorModulate1(PyMOLGlobal
     break;
 
   case SELE_EXT_:
-    if(sscanf(base[2].text, "%d", &nbond) != 1)
+    if(sscanf(base[2].text(), "%d", &nbond) != 1)
       ok = ErrMessage(G, "Selector", "Invalid bond count.");
     if(ok) {
       ObjectMolecule *lastObj = NULL;
@@ -8084,7 +8046,7 @@ static int SelectorModulate1(PyMOLGlobal
     break;
 
   case SELE_GAP_:
-    if(!sscanf(base[2].text, "%f", &dist))
+    if(!sscanf(base[2].text(), "%f", &dist))
       ok = ErrMessage(G, "Selector", "Invalid distance.");
     if(ok) {
       for(a = 0; a < I->NAtom; a++) {
@@ -8434,7 +8396,6 @@ static int SelectorSelect1(PyMOLGlobals
   int flag;
   int ok = true;
   int index, state;
-  char *np;
   int rep_mask;
   const char *wildcard = SettingGetGlobal_s(G, cSetting_wildcard);
 
@@ -8448,13 +8409,13 @@ static int SelectorSelect1(PyMOLGlobals
   ErrChkPtr(G, base->sele);
   switch (base->code) {
   case SELE_PEPs:
-    if(base[1].text[0]) {
+    if(base[1].text()[0]) {
       AtomInfoType *last_ai0 = NULL, *ai0;
       for(a = cNDummyAtoms; a < I_NAtom; a++) {
         ai0 = i_obj[i_table[a].model]->AtomInfo + i_table[a].atom;
         if(!AtomInfoSameResidueP(G, ai0, last_ai0)) {   /* new starting residue */
           int match_found = false;
-          char *ch = base[1].text;      /* sequence argument */
+          const char *ch = base[1].text();      /* sequence argument */
           AtomInfoType *ai1, *last_ai1 = NULL;
           for(b = a; b < I_NAtom; b++) {
             ai1 = i_obj[i_table[b].model]->AtomInfo + i_table[b].atom;
@@ -8473,7 +8434,7 @@ static int SelectorSelect1(PyMOLGlobals
             }
           }
           if(match_found) {
-            char *ch = base[1].text;    /* sequence argument */
+            const char *ch = base[1].text();    /* sequence argument */
             AtomInfoType *ai1, *last_ai1 = NULL, *ai2;
             for(b = a; b < I_NAtom; b++) {
               ai1 = i_obj[i_table[b].model]->AtomInfo + i_table[b].atom;
@@ -8508,7 +8469,7 @@ static int SelectorSelect1(PyMOLGlobals
 
       WordMatchOptionsConfigInteger(&options);
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8529,7 +8490,7 @@ static int SelectorSelect1(PyMOLGlobals
 
       WordMatchOptionsConfigInteger(&options);
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8554,7 +8515,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8572,7 +8533,6 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_NAMs:
-    WARN_IF_LOWERCASE(G, "name", base[1].text);
     {
       CWordMatchOptions options;
       const char *atom_name_wildcard = SettingGetGlobal_s(G, cSetting_atom_name_wildcard);
@@ -8582,7 +8542,7 @@ static int SelectorSelect1(PyMOLGlobals
 
       WordMatchOptionsConfigAlphaList(&options, atom_name_wildcard[0], ignore_case);
 
-      matcher = WordMatcherNew(G, base[1].text, &options, false);
+      matcher = WordMatcherNew(G, base[1].text(), &options, false);
 
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
@@ -8604,9 +8564,9 @@ static int SelectorSelect1(PyMOLGlobals
             options.wildcard = atom_name_wildcard[0];
             if(matcher)
               WordMatcherFree(matcher);
-            matcher = WordMatcherNew(G, base[1].text, &options, false);
+            matcher = WordMatcherNew(G, base[1].text(), &options, false);
             if(!matcher)
-              WordPrimeCommaMatch(G, base[1].text);
+              WordPrimeCommaMatch(G, &base[1].m_text[0] /* replace '+' with ',' */);
           }
           last_obj = obj;
         }
@@ -8617,7 +8577,7 @@ static int SelectorSelect1(PyMOLGlobals
             WordMatcherMatchAlpha(matcher,
                                   name);
         else
-          hit_flag = (WordMatchCommaExact(G, base[1].text,
+          hit_flag = (WordMatchCommaExact(G, base[1].text(),
                                           name,
                                           ignore_case) < 0);
 
@@ -8639,7 +8599,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
 	AtomInfoType * ai;
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
@@ -8660,7 +8620,6 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_ELEs:
-    WARN_IF_LOWERCASE(G, "element", base[1].text);
     {
       CWordMatchOptions options;
 
@@ -8669,7 +8628,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8694,7 +8653,7 @@ static int SelectorSelect1(PyMOLGlobals
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 #ifndef NO_MMLIBS
@@ -8716,9 +8675,9 @@ static int SelectorSelect1(PyMOLGlobals
     break;
   case SELE_REPs:
     rep_mask = 0;
-    WordPrimeCommaMatch(G, base[1].text);
+    WordPrimeCommaMatch(G, &base[1].m_text[0] /* replace '+' with ',' */);
     for(a = 0; rep_names[a].word[0]; a++) {
-      if(WordMatchComma(G, base[1].text, rep_names[a].word, ignore_case) < 0)
+      if(WordMatchComma(G, base[1].text(), rep_names[a].word, ignore_case) < 0)
         rep_mask |= rep_names[a].value;
     }
     for(SelectorAtomIterator iter(I); iter.next();) {
@@ -8731,7 +8690,7 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_COLs:
-    col_idx = ColorGetIndex(G, base[1].text);
+    col_idx = ColorGetIndex(G, base[1].text());
     for(a = cNDummyAtoms; a < I_NAtom; a++) {
       base[0].sele[a] = false;
       if(i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].color == col_idx) {
@@ -8744,7 +8703,7 @@ static int SelectorSelect1(PyMOLGlobals
   case SELE_RCLs:
     // setting index
     index = (base->code == SELE_CCLs) ? cSetting_cartoon_color : cSetting_ribbon_color;
-    col_idx = ColorGetIndex(G, base[1].text);
+    col_idx = ColorGetIndex(G, base[1].text());
     for(a = cNDummyAtoms; a < I_NAtom; a++) {
       base[0].sele[a] = false;
       {
@@ -8789,7 +8748,7 @@ static int SelectorSelect1(PyMOLGlobals
           printf("coding error: missing case\n");
       }
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8808,7 +8767,6 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_SSTs:
-    WARN_IF_LOWERCASE(G, "ss", base[1].text);
     {
       CWordMatchOptions options;
 
@@ -8817,7 +8775,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8835,11 +8793,16 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_STAs:
-    sscanf(base[1].text, "%d", &state);
+    sscanf(base[1].text(), "%d", &state);
     state = state - 1;
     obj = NULL;
 
-    {
+    if (state < 0 && state != cSelectorUpdateTableCurrentState) {
+      PRINTFB(G, FB_Selector, FB_Errors)
+        " Selector-Error: state %d unsupported (must be -1 (current) or >=1)\n",
+        state + 1 ENDFB(G);
+      ok = false;
+    } else {
       auto state_arg = state;
       for(a = cNDummyAtoms; a < I_NAtom; a++) {
         base[0].sele[a] = false;
@@ -8869,7 +8832,6 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_ALTs:
-    WARN_IF_LOWERCASE(G, "alt", base[1].text);
     {
       CWordMatchOptions options;
 
@@ -8878,7 +8840,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8895,7 +8857,7 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_FLGs:
-    sscanf(base[1].text, "%d", &flag);
+    sscanf(base[1].text(), "%d", &flag);
     flag = (1 << flag);
     for(a = cNDummyAtoms; a < I_NAtom; a++) {
       if(i_obj[i_table[a].model]->AtomInfo[i_table[a].atom].flags & flag) {
@@ -8911,7 +8873,7 @@ static int SelectorSelect1(PyMOLGlobals
 
       WordMatchOptionsConfigInteger(&options);
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8938,7 +8900,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8956,7 +8918,6 @@ static int SelectorSelect1(PyMOLGlobals
     }
     break;
   case SELE_RSNs:
-    WARN_IF_LOWERCASE(G, "resn", base[1].text);
     {
       CWordMatchOptions options;
 
@@ -8965,7 +8926,7 @@ static int SelectorSelect1(PyMOLGlobals
       table_a = i_table + cNDummyAtoms;
       base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, true))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, true))) {
         table_a = i_table + cNDummyAtoms;
         base_0_sele_a = &base[0].sele[cNDummyAtoms];
 
@@ -8983,7 +8944,8 @@ static int SelectorSelect1(PyMOLGlobals
     break;
   case SELE_SELs:
     {
-      char *word = base[1].text;
+      const char *word = base[1].text();
+      WordType activeselename = "";
       int enabled_only = false;
       CWordMatchOptions options;
 
@@ -9052,7 +9014,16 @@ static int SelectorSelect1(PyMOLGlobals
           ExecutiveFreeGroupList(G, group_list_id);
         }
 
-      } else if((!enabled_only) || ExecutiveGetActiveSeleName(G, word, false, false)) {
+      } else if((!enabled_only) || ExecutiveGetActiveSeleName(G, activeselename, false, false)) {
+        if (activeselename[0]) {
+          // TODO not sure if this is intentional. If the active selection is
+          // "foo", then the expression "??bar" will evaluate to "foo". I assume
+          // the intention was to evaluate to the empty selection if "bar" is
+          // not active, and to "bar" in case it's active.
+          // Used with cmd.select(..., merge=2)
+          base[1].m_text = activeselename;
+          word = base[1].text();
+        }
         sele = SelectGetNameOffset(G, word, 1, ignore_case);
         if(sele >= 0) {
           MemberType *I_Member = I->Member;
@@ -9086,7 +9057,7 @@ static int SelectorSelect1(PyMOLGlobals
                 c++;
             }
             ExecutiveFreeGroupList(G, group_list_id);
-          } else if(base[1].text[0] == '?') {   /* undefined ?sele allowed */
+          } else if(base[1].m_text[0] == '?') {   /* undefined ?sele allowed */
             for(a = cNDummyAtoms; a < I_NAtom; a++)
               base[0].sele[a] = false;
           } else {
@@ -9105,12 +9076,14 @@ static int SelectorSelect1(PyMOLGlobals
     /* first, trim off and record the atom index if one exists */
 
     index = -1;
-    if((np = strstr(base[1].text, "`"))) {
-      *np = 0;
+    auto pos = base[1].m_text.find('`');
+    if (pos != std::string::npos) {
+      const char* np = base[1].text() + pos;
       if(sscanf(np + 1, "%d", &index) != 1)
         index = -1;
       else
         index--;
+      base[1].m_text.resize(pos);
     }
     model = 0;
 
@@ -9118,7 +9091,7 @@ static int SelectorSelect1(PyMOLGlobals
       CWordMatchOptions options;
       WordMatchOptionsConfigAlpha(&options, wildcard[0], ignore_case);
 
-      if((matcher = WordMatcherNew(G, base[1].text, &options, false))) {
+      if((matcher = WordMatcherNew(G, base[1].text(), &options, false))) {
 
         int obj_matches = false;
 
@@ -9147,7 +9120,7 @@ static int SelectorSelect1(PyMOLGlobals
         WordMatcherFree(matcher);
       } else {
 
-        obj = (ObjectMolecule *) ExecutiveFindObjectByName(G, base[1].text);
+        obj = (ObjectMolecule *) ExecutiveFindObjectByName(G, base[1].text());
         if(obj) {
           for(a = cNDummyModels; a < I->NModel; a++)
             if(i_obj[a] == obj) {
@@ -9156,7 +9129,7 @@ static int SelectorSelect1(PyMOLGlobals
             }
         }
         if(!model)
-          if(sscanf(base[1].text, "%i", &model) == 1) {
+          if(sscanf(base[1].text(), "%i", &model) == 1) {
             if(model <= 0)
               model = 0;
             else if(model > I->NModel)
@@ -9188,7 +9161,7 @@ static int SelectorSelect1(PyMOLGlobals
           }
         } else {
           PRINTFB(G, FB_Selector, FB_Errors)
-            " Selector-Error: invalid model \"%s\".\n", base[1].text ENDFB(G);
+            " Selector-Error: invalid model \"%s\".\n", base[1].text() ENDFB(G);
           ok = false;
         }
       }
@@ -9221,12 +9194,12 @@ static int SelectorSelect2(PyMOLGlobals
   case SELE_XVLx:
   case SELE_YVLx:
   case SELE_ZVLx:
-    oper = WordKey(G, AtOper, base[1].text, 4, ignore_case, &exact);
+    oper = WordKey(G, AtOper, base[1].text(), 4, ignore_case, &exact);
     switch (oper) {
     case SCMP_GTHN:
     case SCMP_LTHN:
     case SCMP_EQAL:
-      if(sscanf(base[2].text, "%f", &comp1) != 1)
+      if(sscanf(base[2].text(), "%f", &comp1) != 1)
         ok = ErrMessage(G, "Selector", "Invalid Number");
       break;
     default:
@@ -9278,7 +9251,7 @@ static int SelectorSelect2(PyMOLGlobals
   case SELE_FCHx:
   case SELE_BVLx:
   case SELE_QVLx:
-    oper = WordKey(G, AtOper, base[1].text, 4, ignore_case, &exact);
+    oper = WordKey(G, AtOper, base[1].text(), 4, ignore_case, &exact);
     if(!oper)
       ok = ErrMessage(G, "Selector", "Invalid Operator.");
     if(ok) {
@@ -9286,7 +9259,7 @@ static int SelectorSelect2(PyMOLGlobals
       case SCMP_GTHN:
       case SCMP_LTHN:
       case SCMP_EQAL:
-        if(sscanf(base[2].text, "%f", &comp1) != 1)
+        if(sscanf(base[2].text(), "%f", &comp1) != 1)
           ok = ErrMessage(G, "Selector", "Invalid Number");
         break;
       }
@@ -9450,6 +9423,13 @@ static int SelectorSelect2(PyMOLGlobals
 /*========================================================================*/
 static int SelectorSelect3(PyMOLGlobals * G, EvalElem * base, int state)
 {
+  switch (base->code) {
+  case SELE_PROP:
+    ErrMessage(G, "Selector", "properties (p.) not supported in Open-Source PyMOL");
+    return false;
+  }
+  return true;
+ok_except1:
   return false;
 }
 
@@ -10244,7 +10224,7 @@ int SelectorOperator22(PyMOLGlobals * G,
   case SELE_WIT_:
   case SELE_BEY_:
   case SELE_NTO_:
-    if(!sscanf(base[2].text, "%f", &dist))
+    if(!sscanf(base[2].text(), "%f", &dist))
       ok = ErrMessage(G, "Selector", "Invalid distance.");
     if(ok) {
       if(dist < 0.0)
@@ -10337,16 +10317,32 @@ int SelectorOperator22(PyMOLGlobals * G,
   return (1);
 }
 
-static void remove_quotes(char *st)
+/**
+ * Removes matching quotes from a string, at string start as well as after word
+ * list separators ("+" and ","). Does not consider backslash escaping.
+ *
+ * Examples (not sure if all of these are intentional):
+ * @verbatim
+   "foo bar" -> foo bar
+   'foo bar' -> foo bar
+   "foo"+'bar' -> foo+bar
+   "foo bar\" -> foo bar\       # backslash has no escape function
+   "foo" "bar" -> foo "bar"     # second pair of quotes not after separator
+   foo''+''bar -> foo''+bar     # first pair of quotes not after separator
+   "foo"bar" -> foobar"         # third quote unmatched
+   foo'+'bar -> foo'+'bar       # no matching quotes after separator
+   @endverbatim
+ */
+static void remove_quotes(std::string& str)
 {
   /* nasty */
 
-  SelectorWordType store;
+  char *st = &str[0];
   char *p, *q;
   char *quote_start = NULL;
   char active_quote = 0;
   p = st;
-  q = store;
+  q = st;
 
   while(*p) {
     if(((*p) == 34) || ((*p) == 39)) {
@@ -10358,8 +10354,8 @@ static void remove_quotes(char *st)
         q--;
         quote_start = NULL;
         p++;
+        continue;
       } else if(quote_start) {
-        *(q++) = *(p++);
       } else {
         if(p == st) {           /* at start => real quote */
           quote_start = q;
@@ -10368,38 +10364,35 @@ static void remove_quotes(char *st)
           quote_start = q;
           active_quote = *p;
         }
-        *(q++) = *(p++);
       }
-    } else {
-      /* UNWORKABLE -- hopelly getting rid of this kludge will not cause major grief 
-         if((*p=='+')&&(!quote_start))
-         if(!((*(p+1)==0)||(*(p+1)==',')||(*(p+1)=='+')))
-         *p=',';
-       */
-      *(q++) = *(p++);
     }
+    if (q < p) {
+      *q = *p;
+    }
+    ++q;
+    ++p;
+  }
+  if (q < p) {
+    str.resize(q - st);
   }
-  *(q++) = 0;
-  strcpy(st, store);
-
 }
 
 #define STACK_PUSH_VALUE(value) { \
   depth++; \
-  VLACheck(Stack, EvalElem, depth); \
-  e = Stack + depth; \
+  VecCheck(Stack, depth); \
+  e = Stack.data() + depth; \
   e->level = (level << 4) + 1; \
   e->imp_op_level = (imp_op_level << 4) + 1; \
   imp_op_level = level; \
   e->type = STYP_VALU; \
-  strcpy(e->text, value); \
-  remove_quotes(e->text); \
+  e->m_text = value; \
+  remove_quotes(e->m_text); \
 }
 
 #define STACK_PUSH_OPERATION(ocode) { \
   depth++; \
-  VLACheck(Stack, EvalElem, depth); \
-  e = Stack + depth; \
+  VecCheck(Stack, depth); \
+  e = Stack.data() + depth; \
   e->code = ocode; \
   e->level = (level << 4) + ((e->code & 0xF0) >> 4); \
   e->imp_op_level = (imp_op_level << 4) + 1; \
@@ -10408,7 +10401,9 @@ static void remove_quotes(char *st)
 }
 
 /*========================================================================*/
-int *SelectorEvaluate(PyMOLGlobals * G, SelectorWordType * word, int state, int quiet)
+int* SelectorEvaluate(PyMOLGlobals* G,
+    std::vector<std::string>& word,
+    int state, int quiet)
 {
   int level = 0, imp_op_level = 0;
   int depth = 0;
@@ -10418,27 +10413,20 @@ int *SelectorEvaluate(PyMOLGlobals * G,
   int valueFlag = 0;            /* are we expecting? */
   int *result = NULL;
   int opFlag, maxLevel;
-  char *q;
   int totDepth = 0;
   int exact = 0;
 
   int ignore_case = SettingGetGlobal_b(G, cSetting_ignore_case);
   /* CFGs can efficiently be parsed by stacks; use a clean stack w/space
-   * for 100 elements */
-  EvalElem *Stack = NULL, *e;
-  SelectorWordType tmpKW;
-  Stack = VLAlloc(EvalElem, 100);
-  CHECKOK(ok, Stack);
-  if (!ok)
-    return NULL;
-  UtilZeroMem(Stack, sizeof(EvalElem)); /* blank first entry */
+   * for 10 (was: 100) elements */
+  EvalElem *e;
+  auto Stack = std::vector<EvalElem>(10);
 
   /* converts all keywords into code, adds them into a operation list */
-  while(ok && word[c][0]) {
+  while(ok && c < word.size()) {
     if(word[c][0] == '#') {
       if((!valueFlag) && (!level)) {
-        word[c][0] = 0;         /* terminate selection if we encounter a comment */
-        word[c + 1][0] = 0;
+        word.resize(c);         /* terminate selection if we encounter a comment */
         break;
       }
     }
@@ -10472,28 +10460,34 @@ int *SelectorEvaluate(PyMOLGlobals * G,
         valueFlag--;
       } else if(valueFlag < 0) {        /* operation parameter i.e. around X<-- */
         depth++;
-        VLACheck(Stack, EvalElem, depth);
-        e = Stack + depth;
+        VecCheck(Stack, depth);
+        e = Stack.data() + depth;
         e->level = (level << 4) + 1;
         e->imp_op_level = (imp_op_level << 4) + 1;
         imp_op_level = level;
         e->type = STYP_PVAL;
-        strcpy(e->text, word[c]);
+        e->m_text = word[c];
         valueFlag++;
       } else {                  /* possible keyword... */
-        code = WordKey(G, Keyword, word[c], 4, ignore_case, &exact);
+        code = WordKey(G, Keyword, word[c].c_str(), 4, ignore_case, &exact);
         if(!code) {
-          b = strlen(word[c]) - 1;
+          b = word[c].size() - 1;
           if((b > 2) && (word[c][b] == ';')) {
             /* kludge to accomodate unnec. ';' usage */
-            word[c][b] = 0;
-            code = WordKey(G, Keyword, word[c], 4, ignore_case, &exact);
+            word[c].resize(b);
+            code = WordKey(G, Keyword, word[c].c_str(), 4, ignore_case, &exact);
+          } else if(!word[c].compare(0, 2, "p.")) {
+            // kludge to parse p.propertyname without space after p.
+            code = SELE_PROP;
+            exact = 1;
+            word[c].erase(0, 2);
+            c--;
           }
         }
         PRINTFD(G, FB_Selector)
           " Selector: code %x\n", code ENDFD;
         if((code > 0) && (!exact))
-          if(SelectorIndexByName(G, word[c]) >= 0)
+          if(SelectorIndexByName(G, word[c].c_str()) >= 0)
             code = 0;           /* favor selections over partial keyword matches */
         if(code) {
           /* this is a known operation */
@@ -10525,9 +10519,8 @@ int *SelectorEvaluate(PyMOLGlobals * G,
             break;
           }
         } else {
-          strcpy(tmpKW, word[c]);
-
-          if((a = strchrcount(tmpKW, '/'))) { /* handle slash notation */
+          if((a = std::count(word[c].begin(), word[c].end(),
+                  '/'))) { /* handle slash notation */
             if(a > 5) {
               ok = ErrMessage(G, "Selector", "too many slashes in macro");
               break;
@@ -10540,7 +10533,8 @@ int *SelectorEvaluate(PyMOLGlobals * G,
             int codes[] = {0, 0, 0}; // null-terminated
             char * values[2];
 
-            q = tmpKW;
+            std::string tmpKW = word[c];
+            char* q = &tmpKW[0];
 
             // if macro starts with "/" then read from left, otherwise
             // read from right
@@ -10599,7 +10593,7 @@ int *SelectorEvaluate(PyMOLGlobals * G,
             if(!b)
               STACK_PUSH_OPERATION(SELE_ALLz);
 
-          } else if(strstr(tmpKW, "`")) { /* handle <object`index> syntax */
+          } else if(word[c].find('`') != std::string::npos) { /* handle <object`index> syntax */
             STACK_PUSH_OPERATION(SELE_MODs);
             valueFlag = 1;
             c--;
@@ -10623,11 +10617,6 @@ int *SelectorEvaluate(PyMOLGlobals * G,
     opFlag = true;
     maxLevel = -1;
     for(a = 1; a <= totDepth; a++) {
-      PRINTFD(G, FB_Selector)
-        " Selector initial stack %d-%p lv: %x co: %d type: %x sele %p\n",
-        a, (void *) (Stack + a), Stack[a].level, Stack[a].code,
-        Stack[a].type, (void *) Stack[a].sele ENDFD;
-
       if(Stack[a].level > maxLevel)
         maxLevel = Stack[a].level;
     }
@@ -10644,12 +10633,6 @@ int *SelectorEvaluate(PyMOLGlobals * G,
         depth = 1;
         opFlag = true;
         while(ok && opFlag) {   /* loop through all entries looking for ops at the current level */
-          PRINTFD(G, FB_Selector)
-            " Selector: lvl: %d de:%d-%p slv:%d co: %x typ %x sele %p td: %d\n",
-            level, depth, (void *) (Stack + depth), Stack[depth].level,
-            Stack[depth].code,
-            Stack[depth].type, (void *) Stack[depth].sele, totDepth ENDFD;
-
           opFlag = false;
 
           if(Stack[depth].level >= level) {
@@ -10687,7 +10670,7 @@ int *SelectorEvaluate(PyMOLGlobals * G,
                   /* two adjacent lists at zeroth priority level
                      for the scope (lowest nibble of level is
                      zero) is an implicit OR action */
-                  VLACheck(Stack, EvalElem, totDepth);
+                  VecCheck(Stack, totDepth + 1);
                   for(a = totDepth; a >= depth; a--)
                     Stack[a + 1] = Stack[a];
                   totDepth++;
@@ -10695,7 +10678,7 @@ int *SelectorEvaluate(PyMOLGlobals * G,
                   Stack[depth].code = SELE_IOR2;
                   Stack[depth].level = Stack[depth].imp_op_level;
                   Stack[depth].sele = NULL;
-                  Stack[depth].text[0] = 0;
+                  Stack[depth].m_text.clear();
                   if(level < Stack[depth].level)
                     level = Stack[depth].level;
                   opFlag = true;
@@ -10812,24 +10795,14 @@ int *SelectorEvaluate(PyMOLGlobals * G,
       if(Stack[a].type == STYP_LIST)
         FreeP(Stack[a].sele);
     }
-    depth = 0;
-    {
-      OrthoLineType line;
-      for(a = 0; a <= c; a++) {
-        q = line;
-        if(a && word[a][0])
-          q = UtilConcat(q, " ");
-        q = UtilConcat(q, word[a]);
-	  PRINTFB(G, FB_Selector, FB_Errors)
-	    "%s", line ENDFB(G);
-      }
-      q = line;
-      q = UtilConcat(q, "<--");
-	PRINTFB(G, FB_Selector, FB_Errors)
-	  "%s\n", line ENDFB(G);
+    for (a = 0; a <= c && a < word.size(); a++) {
+      const char* space = (a && word[a][0]) ? " " : "";
+      PRINTFB(G, FB_Selector, FB_Errors)
+        "%s%s", space, word[a].c_str() ENDFB(G);
     }
+    PRINTFB(G, FB_Selector, FB_Errors)
+      "<--\n" ENDFB(G);
   }
-  VLAFreeP(Stack);
   if(!ok) {
     FreeP(result);
     result = NULL;
@@ -10839,38 +10812,36 @@ int *SelectorEvaluate(PyMOLGlobals * G,
 
 
 /*========================================================================*/
-SelectorWordType *SelectorParse(PyMOLGlobals * G, const char *s)
+/**
+ * Break a selection down into tokens and return them in a vector.
+ * E.g. "(name CA+CB)" -> {"(", "name", "CA+CB", ")"}.
+ * @param s selection expression to parse
+ * @return tokens
+ */
+std::vector<std::string> SelectorParse(PyMOLGlobals * G, const char *s)
 {
-
-  /* break a selection down into its constituent strings and
-     return them in a SelectorWordType VLA, null string terminated */
-
-  SelectorWordType *r = NULL;
-  int c = 0;
   int w_flag = false;
   int quote_flag = false;
   char quote_char = '"';
   const char *p = s;
-  char *q = NULL, *q_base = NULL;
-  r = VLAlloc(SelectorWordType, 100);
+  std::string* q = nullptr;
+  std::vector<std::string> r;
   while(*p) {
     if(w_flag) {                /* currently in a word, thus q is a valid pointer */
       if(quote_flag) {
         if(*p != quote_char) {
-          *q++ = *p;
+          *q += *p;
         } else {
           quote_flag = false;
-          *q++ = *p;
+          *q += *p;
         }
       } else
         switch (*p) {
         case ' ':
-          *q = 0;
           w_flag = false;
           break;
         case ';':              /* special word terminator */
-          *q++ = *p;
-          *q = 0;
+          *q += *p;
           w_flag = false;
           break;
         case '!':              /* single words */
@@ -10882,31 +10853,18 @@ SelectorWordType *SelectorParse(PyMOLGlo
         case '<':
         case '=':
         case '%':
-          *q = 0;               /* terminate current word */
-          c++;
-          VLACheck(r, SelectorWordType, c);     /* add new word */
-          q = r[c - 1];
-          *q++ = *p;
-          *q = 0;               /* terminate current word */
+          r.emplace_back(1, *p); /* add new word */
+          q = &r.back();
           w_flag = false;
           break;
         case '"':
           quote_flag = true;
-          *q++ = *p;
+          *q += *p;
           break;
         default:
-          *q++ = *p;
+          *q += *p;
           break;
         }
-      if(w_flag) {
-        if((q - q_base) >= sizeof(SelectorWordType)) {
-          q_base[sizeof(SelectorWordType) - 1] = 0;
-          w_flag = false;
-          PRINTFB(G, FB_Selector, FB_Errors)
-            "Selector-Error: Word too long. Truncated:\nSelector-Error: %s...\n", q_base
-            ENDFB(G);
-        }
-      }
     } else {                    /*outside a word -- q is undefined */
 
       switch (*p) {
@@ -10919,11 +10877,8 @@ SelectorWordType *SelectorParse(PyMOLGlo
       case '<':
       case '=':
       case '%':
-        c++;
-        VLACheck(r, SelectorWordType, c);
-        q = r[c - 1];
-        *q++ = (*p);
-        *q = 0;
+        r.emplace_back(1, *p); /* add new word */
+        q = &r.back();
         break;
       case ' ':
         break;
@@ -10931,36 +10886,22 @@ SelectorWordType *SelectorParse(PyMOLGlo
         quote_flag = true;
         quote_char = *p;
         w_flag = true;
-        c++;
-        VLACheck(r, SelectorWordType, c);
-        q = r[c - 1];
-        q_base = q;
-        *q++ = *p;
+        r.emplace_back(1, *p); /* add new word */
+        q = &r.back();
         break;
       default:
         w_flag = true;
-        c++;
-        VLACheck(r, SelectorWordType, c);
-        q = r[c - 1];
-        q_base = q;
-        *q++ = *p;
+        r.emplace_back(1, *p); /* add new word */
+        q = &r.back();
         break;
       }
     }
     p++;
   }
-  /* end current word */
-  if(w_flag)
-    *q = 0;
-
-  /* null strings terminate the list */
-  q = r[c];
-  *q = 0;
+
   if(Feedback(G, FB_Selector, FB_Debugging)) {
-    c = 0;
-    while(r[c][0]) {
-      fprintf(stderr, "word: %s\n", r[c]);
-      c++;
+    for (auto& word : r) {
+      fprintf(stderr, "word: %s\n", word.c_str());
     }
   }
   return (r);
diff -upNr pymol-open-source-2.3.0.orig/layer5/PyMOL.cpp pymol-open-source-2.3.0/layer5/PyMOL.cpp
--- pymol-open-source-2.3.0.orig/layer5/PyMOL.cpp	2020-03-10 19:31:10.452703618 +0100
+++ pymol-open-source-2.3.0/layer5/PyMOL.cpp	2020-03-10 19:31:34.139013090 +0100
@@ -230,13 +230,7 @@ typedef struct _CPyMOL {
 
 /* convenience functions -- inline */
 
-#ifdef _PYMOL_INLINE
-#define CC_INLINE __inline__
-#else
-#define CC_INLINE
-#endif
-
-CC_INLINE static PyMOLstatus get_status_ok(int ok)
+inline PyMOLstatus get_status_ok(int ok)
 {
   if(ok)
     return PyMOLstatus_SUCCESS;
@@ -244,14 +238,14 @@ CC_INLINE static PyMOLstatus get_status_
     return PyMOLstatus_FAILURE;
 }
 
-CC_INLINE static PyMOLreturn_status return_status_ok(int ok)
+inline PyMOLreturn_status return_status_ok(int ok)
 {
   PyMOLreturn_status result;
   result.status = get_status_ok(ok);
   return result;
 }
 
-CC_INLINE static PyMOLreturn_status return_status(int status)
+inline PyMOLreturn_status return_status(int status)
 {
   PyMOLreturn_status result;
   result.status = status;
diff -upNr pymol-open-source-2.3.0.orig/modules/pmg_qt/mimic_tk.py pymol-open-source-2.3.0/modules/pmg_qt/mimic_tk.py
--- pymol-open-source-2.3.0.orig/modules/pmg_qt/mimic_tk.py	2020-03-10 19:31:10.472705041 +0100
+++ pymol-open-source-2.3.0/modules/pmg_qt/mimic_tk.py	2020-03-10 19:31:34.143013577 +0100
@@ -127,17 +127,23 @@ class _qtFileDialog:
                 options.get('initialdir', ''))
 
 
+qtMessageBox = _qtMessageBox()
+qtFileDialog = _qtFileDialog()
+
+# for all Python versions - allows plugin manager to import this with Python 3
+# without importing "tkinter"
+sys.modules['tkMessageBox'] = qtMessageBox
+sys.modules['tkFileDialog'] = qtFileDialog
+
 if sys.version_info[0] < 3:
-    sys.modules['tkMessageBox'] = _qtMessageBox()
-    sys.modules['tkFileDialog'] = _qtFileDialog()
     sys.modules['tkSimpleDialog'] = _qtSimpleDialog()
 else:
     # injecting 'X.Y' into sys.modules without assigning the attribute
     # (import X;X.Y = ...) doesn't work. Use a meta_path solution instead.
 
     mapping = {
-        'tkinter.messagebox': _qtMessageBox(),
-        'tkinter.filedialog': _qtFileDialog(),
+        'tkinter.messagebox': qtMessageBox,
+        'tkinter.filedialog': qtFileDialog,
     }
 
     class MimicTkImporter:
diff -upNr pymol-open-source-2.3.0.orig/modules/pmg_qt/pymol_qt_gui.py pymol-open-source-2.3.0/modules/pmg_qt/pymol_qt_gui.py
--- pymol-open-source-2.3.0.orig/modules/pmg_qt/pymol_qt_gui.py	2020-03-10 19:31:10.472705041 +0100
+++ pymol-open-source-2.3.0/modules/pmg_qt/pymol_qt_gui.py	2020-03-10 19:31:34.143013577 +0100
@@ -848,7 +848,7 @@ PyMOL> color ye<TAB>    (will autocomple
         msg = [
             'The PyMOL Molecular Graphics System\n',
             'Version %s' % (self.cmd.get_version()[0]),
-            'Copyright (C) Schrodinger LLC.',
+            u'Copyright (C) Schr\xF6dinger LLC.',
             'All rights reserved.\n',
             'License information:',
         ]
@@ -1081,6 +1081,15 @@ class PyMOLApplication(QtWidgets.QApplic
         if ev.type() != QtCore.QEvent.FileOpen:
             return False
 
+        # When double clicking a file in Finder, open it in a new instance
+        if not pymol.invocation.options.reuse_helper and pymol.cmd.get_names():
+            window.new_window([ev.file()])
+            return True
+
+        # pymol -I -U
+        if pymol.invocation.options.auto_reinitialize:
+            pymol.cmd.reinitialize()
+
         # PyMOL Show
         if ev.file().endswith('.psw'):
             pymol.cmd.set('presentation')
@@ -1142,6 +1151,12 @@ def execapp():
             for v in ['QT_SCALE_FACTOR', 'QT_SCREEN_SCALE_FACTORS']):
         QtCore.QCoreApplication.setAttribute(Qt.AA_EnableHighDpiScaling)
 
+    # native dialogs broken on macOS 10.15 (attribute new in Qt 5.7)
+    import platform
+    if pymol.IS_MACOS and platform.mac_ver()[0] >= '10.15' and hasattr(
+            Qt, 'AA_DontUseNativeDialogs'):
+        QtCore.QCoreApplication.setAttribute(Qt.AA_DontUseNativeDialogs)
+
     # fix Windows taskbar icon
     if pymol.IS_WINDOWS:
         import ctypes
diff -upNr pymol-open-source-2.3.0.orig/modules/pymol/importing.py pymol-open-source-2.3.0/modules/pymol/importing.py
--- pymol-open-source-2.3.0.orig/modules/pymol/importing.py	2020-03-10 19:31:10.480705610 +0100
+++ pymol-open-source-2.3.0/modules/pymol/importing.py	2020-03-10 19:31:34.143013577 +0100
@@ -708,11 +708,6 @@ SEE ALSO
             if multiplex==None:
                 multiplex=-2
 
-            filename = unquote(filename)
-
-            # analyze filename
-            noext, ext, format_guessed, zipped = filename_to_format(filename)
-
             # file format
             try:
                 # user specified the type as an int
@@ -720,6 +715,22 @@ SEE ALSO
                 format = loadable._reverse_lookup(format)
             except ValueError:
                 format = str(format)
+                ftype = getattr(_loadable, format, -1)
+
+            if ftype in _self._load2str.values():
+                assert format.endswith('str')
+                colorprinting.warning(
+                    ' cmd.load(format="{}") is deprecated, use cmd.load_raw(format="{}")'
+                    .format(format, format[:-3]))
+                return _self.load_raw(filename, format[:-3], object, state,
+                        finish, discrete, quiet, multiplex, zoom)
+
+            filename = unquote(filename)
+
+            # analyze filename
+            noext, ext, format_guessed, zipped = filename_to_format(filename)
+
+            if ftype == -1:
                 if not format:
                     format = format_guessed
                 elif format.startswith('plugin'):
@@ -730,8 +741,7 @@ SEE ALSO
                     format = 'model' # legacy
                 ftype = getattr(_loadable, format, -1)
 
-            if ftype not in _self._load2str.values():
-                filename = _self.exp_path(filename)
+            filename = _self.exp_path(filename)
 
             # object name
             object = str(object).strip()
@@ -875,24 +885,38 @@ NOTES
         return _self.load_raw(''.join(list[1]), list[0], name, state,
                 finish, discrete, quiet, multiplex, zoom)
 
-    def load_raw(content,  format='', object='', state=0, finish=1,
+    def load_raw(content, format, object='', state=0, finish=1,
                  discrete=-1, quiet=1, multiplex=None, zoom=-1,_self=cmd):
+        '''
+DESCRIPTION
+
+    API-only function for loading data from memory.
+
+EXAMPLE
+
+    contents = open('example.mmtf', 'rb').read()
+    cmd.load_raw(contents, 'mmtf')
+        '''
+
         r = DEFAULT_ERROR
         if multiplex==None:
             multiplex=-2
         ftype = getattr(loadable, format, None)
+        if not isinstance(content, bytes):
+            content = content.encode('utf-8')
+
         if True:
             _raw_dict = cmd._load2str
             if ftype in _raw_dict:
                 try:
                     _self.lock(_self)
-                    r = _cmd.load(_self._COb,str(object),str(content),int(state)-1,
+                    r = _cmd.load(_self._COb,str(object),content,int(state)-1,
                                   _raw_dict[ftype],int(finish),int(discrete),
                                   int(quiet),int(multiplex),int(zoom))
                 finally:
                     _self.unlock(r,_self)
             else:
-                raise pymol.CmdException("unknown raw format '%s'", format)
+                raise pymol.CmdException("unknown raw format '{}'".format(format))
         if _self._raising(r,_self): raise pymol.CmdException
         return r
         
@@ -1260,10 +1284,10 @@ PYMOL API
             r = _self.read_pdbstr(contents, name, state,
                     finish, discrete, quiet, zoom, multiplex)
         elif contents and bioType in ('cif', 'cc'):
-            r = _self.load(contents, name, state, loadable.cifstr,
+            r = _self.load_raw(contents, 'cif', name, state,
                     finish, discrete, quiet, multiplex, zoom)
         elif contents and bioType in ('mmtf',):
-            r = _self.load(contents, name, state, loadable.mmtfstr,
+            r = _self.load_raw(contents, 'mmtf', name, state,
                     finish, discrete, quiet, multiplex, zoom)
 
         if not _self.is_error(r):
diff -upNr pymol-open-source-2.3.0.orig/modules/pymol/plugins/__init__.py pymol-open-source-2.3.0/modules/pymol/plugins/__init__.py
--- pymol-open-source-2.3.0.orig/modules/pymol/plugins/__init__.py	2020-03-10 19:31:10.484705894 +0100
+++ pymol-open-source-2.3.0/modules/pymol/plugins/__init__.py	2020-03-10 19:31:34.147014063 +0100
@@ -198,8 +198,9 @@ class PluginInfo(object):
         Parse plugin file for metadata (hash-commented block at beginning of file).
         '''
         metadata = dict()
-        f = open(self.filename, 'rU')
+        f = open(self.filename, 'rb')
         for line in f:
+            line = line.decode('utf-8', errors='replace')
             if line.strip() == '':
                 continue
             if not line.startswith('#'):
@@ -238,7 +239,7 @@ class PluginInfo(object):
             return self.module.__doc__
 
         try:
-            c = compile(''.join(open(self.filename)), 'x', 'exec', dont_inherit=True)
+            c = compile(b''.join(open(self.filename, 'rb')), 'x', 'exec', dont_inherit=True)
             s = c.co_consts[0]
             if cmd.is_string(s):
                 return s
@@ -428,7 +429,10 @@ def initialize(pmgapp=-1):
 
     if os.path.exists(PYMOLPLUGINSRC):
         from pymol import parsing
-        parsing.run_file(PYMOLPLUGINSRC, {'__script__': PYMOLPLUGINSRC}, {})
+        try:
+            parsing.run_file(PYMOLPLUGINSRC, {'__script__': PYMOLPLUGINSRC}, {})
+        except SyntaxError as e:
+            colorprinting.warning(str(e))
 
     autoload = (pmgapp != -2)
     for parent in [startup]:
diff -upNr pymol-open-source-2.3.0.orig/modules/pymol/plugins/installation.py pymol-open-source-2.3.0/modules/pymol/plugins/installation.py
--- pymol-open-source-2.3.0.orig/modules/pymol/plugins/installation.py	2020-03-10 19:31:10.484705894 +0100
+++ pymol-open-source-2.3.0/modules/pymol/plugins/installation.py	2020-03-10 19:31:34.147014063 +0100
@@ -131,6 +131,9 @@ def extract_zipfile(ofile, ext):
     if len(names) == 0:
         raise BadInstallationFile('Missing __init__.py')
     if len(names) > 1:
+        # filter out "tests" directory
+        names = [n for n in names if n[-1] != 'tests']
+    if len(names) > 1:
         raise BadInstallationFile('Archive must contain a single package.')
     check_valid_name(names[0][-1])
 
@@ -320,11 +323,12 @@ def installPluginFromFile(ofile, parent=
         showinfo('Info', 'Installation cancelled', parent=parent)
         return
 
-    except:
+    except Exception as e:
         if pref_get('verbose', False):
             import traceback
             traceback.print_exc()
-        showinfo('Error', 'unable to install plugin "%s"' % name, parent=parent)
+        msg = 'Unable to install plugin "{}".\n{}'.format(name, e)
+        showinfo('Error', msg, parent=parent)
         return
 
     finally:
diff -upNr pymol-open-source-2.3.0.orig/modules/pymol/plugins/legacysupport.py pymol-open-source-2.3.0/modules/pymol/plugins/legacysupport.py
--- pymol-open-source-2.3.0.orig/modules/pymol/plugins/legacysupport.py	2020-03-10 19:31:10.484705894 +0100
+++ pymol-open-source-2.3.0/modules/pymol/plugins/legacysupport.py	2020-03-10 19:31:34.147014063 +0100
@@ -153,9 +153,10 @@ def createlegacypmgapp():
 
 class _tkMessageBox(object):
     def __getattr__(self, name):
-        if sys.version_info[0] == 2:
+        try:
+            # pmg_qt.mimic_tk provides this for all Python versions
             import tkMessageBox as module
-        else:
+        except ImportError:
             import tkinter.messagebox as module
         from . import pref_get
         wrapped = getattr(module, name)
@@ -170,9 +171,10 @@ class _tkMessageBox(object):
 
 class _tkFileDialog(object):
     def __getattr__(self, name):
-        if sys.version_info[0] == 2:
+        try:
+            # pmg_qt.mimic_tk provides this for all Python versions
             import tkFileDialog as module
-        else:
+        except ImportError:
             import tkinter.filedialog as module
         wrapped = getattr(module, name)
         def dialog(parent=None, *args, **kwargs):
diff -upNr pymol-open-source-2.3.0.orig/ov/src/ov_defines.h pymol-open-source-2.3.0/ov/src/ov_defines.h
--- pymol-open-source-2.3.0.orig/ov/src/ov_defines.h	2020-03-10 19:31:10.508707601 +0100
+++ pymol-open-source-2.3.0/ov/src/ov_defines.h	2020-03-10 19:31:34.147014063 +0100
@@ -14,13 +14,8 @@
 
 /* defines */
 
-#ifdef WIN32
-#define OV_INLINE static
+#define OV_INLINE inline
 #define OV_STATIC static
-#else
-#define OV_INLINE __inline__ static
-#define OV_STATIC static
-#endif
 
 #ifndef OV_FALSE
 #define OV_FALSE 0
diff -upNr pymol-open-source-2.3.0.orig/setup.py pymol-open-source-2.3.0/setup.py
--- pymol-open-source-2.3.0.orig/setup.py	2020-03-10 19:31:10.508707601 +0100
+++ pymol-open-source-2.3.0/setup.py	2020-03-10 19:31:34.151014549 +0100
@@ -245,7 +245,6 @@ pymol_src_dirs = [
 def_macros = [
     ("_PYMOL_LIBPNG", None),
     ("_PYMOL_FREETYPE", None),
-    ("_PYMOL_INLINE", None),
 ]
 
 libs = ["png", "freetype"]
